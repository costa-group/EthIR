{"ERC20.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./ERC20Interface.sol\";\r\n\r\ncontract ERC20 is ERC20Interface {\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    // Function to access name of token .\r\n    function name() public view returns (string _name) {\r\n        return name;\r\n    }\r\n    // Function to access symbol of token .\r\n    function symbol() public view returns (string _symbol) {\r\n        return symbol;\r\n    }\r\n    // Function to access decimals of token .\r\n    function decimals() public view returns (uint8 _decimals) {\r\n        return decimals;\r\n    }\r\n    // Function to access total supply of tokens .\r\n    function totalSupply() public view returns (uint256 _totalSupply) {\r\n        return totalSupply;\r\n    }\r\n\r\n    mapping (address =\u003e uint256) balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\r\n\r\n    function balanceOf(address participant) public constant returns (uint256 balance) {\r\n        return balances[participant];\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) {\r\n        require(_to != address(0));\r\n        // documentation says transfer of 0 must be treated as a transfer and fire the transfer event\r\n        require(balances[msg.sender] \u003e= _value \u0026\u0026 _value \u003e 0);\r\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool success) {\r\n        require(_to != address(0));\r\n        require(balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e= _value \u0026\u0026 _value \u003e 0);\r\n        balances[_from] = safeSub(balances[_from], _value);\r\n        balances[_to] = safeAdd(balances[_to], _value);\r\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n \t// To change the approve amount you first have to reduce the addresses\u0027\r\n    //  allowance to zero by calling \u0027approve(_spender, 0)\u0027 if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    function approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool success) {\r\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) onlyPayloadSize(3) public returns (bool success) {\r\n        require(allowed[msg.sender][_spender] == _oldValue);\r\n        allowed[msg.sender][_spender] = _newValue;\r\n        emit Approval(msg.sender, _spender, _newValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // mitigate short address attack\r\n    // thanks to https://github.com/numerai/contract/blob/c182465f82e50ced8dacb3977ec374a892f5fa8c/contracts/Safe.sol#L30-L34.\r\n    // TODO: doublecheck implication of \u003e= compared to ==\r\n    modifier onlyPayloadSize(uint numWords) {\r\n        assert(msg.data.length \u003e= numWords * 32 + 4);\r\n        _;\r\n    }\r\n\r\n    function safeMul(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b \u003c= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c\u003e=a \u0026\u0026 c\u003e=b);\r\n        return c;\r\n    }\r\n}\r\n"},"ERC20Interface.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC20Interface  {\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n    function totalSupply() public constant returns (uint256);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"},"Isonex.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./ERC20.sol\";\r\n\r\ncontract Isonex is ERC20 {\r\n\r\n    // 15M\r\n    uint256 public tokenCap = 15000000 * 10**18;\r\n\r\n    bool public tradeable = false;\r\n\r\n    address public primaryWallet;\r\n    address public secondaryWallet;\r\n\r\n    mapping (address =\u003e bool) public whitelist;\r\n\r\n    // Conversion rate from IX15 to ETH\r\n    struct Price { uint256 numerator; uint256 denominator; }\r\n    Price public currentPrice;\r\n\r\n     // The amount of time that the secondary wallet must wait between price updates\r\n    uint256 public priceUpdateInterval = 1 hours;\r\n\r\n    mapping (uint256 =\u003e Price) public priceHistory;\r\n    uint256 public currentPriceHistoryIndex = 0;\r\n\r\n    // time for each withdrawal is set to the currentPriceHistoryIndex\r\n    struct WithdrawalRequest { uint256 nummberOfTokens; uint256 time; }\r\n    mapping (address =\u003e WithdrawalRequest) withdrawalRequests;\r\n\r\n    mapping(uint8 =\u003e string) restrictionMap;\r\n\r\n    constructor (address newSecondaryWallet, uint256 newPriceNumerator) public {\r\n        require(newSecondaryWallet != address(0), \"newSecondaryWallet != address(0)\");\r\n        require(newPriceNumerator \u003e 0, \"newPriceNumerator \u003e 0\");\r\n        name = \"Isonex\";\r\n        symbol = \"IX15\";\r\n        decimals = 18;\r\n        primaryWallet = msg.sender;\r\n        secondaryWallet = newSecondaryWallet;\r\n        whitelist[primaryWallet] = true;\r\n        whitelist[secondaryWallet] = true;\r\n        currentPrice = Price(newPriceNumerator, 1000);\r\n        currentPriceHistoryIndex = now;\r\n\r\n        restrictionMap[1] = \"Sender is not whitelisted\";\r\n        restrictionMap[2] = \"Receiver is not whitelisted\";\r\n        restrictionMap[3] = \"Trading is not enabled\";\r\n    }\r\n\r\n    // Primary and Secondary wallets may updated the current price. Secondary wallet has time and change size constrainst\r\n    function updatePrice(uint256 newNumerator) external onlyPrimaryAndSecondaryWallets {\r\n        require(newNumerator \u003e 0, \"newNumerator \u003e 0\");\r\n        checkSecondaryWalletRestrictions(newNumerator);\r\n\r\n        currentPrice.numerator = newNumerator;\r\n\r\n        // After the token sale, map time to new Price\r\n        priceHistory[currentPriceHistoryIndex] = currentPrice;\r\n        currentPriceHistoryIndex = now;\r\n        emit PriceUpdated(newNumerator, currentPrice.denominator);\r\n    }\r\n\r\n    // secondaryWallet can only increase price by up to 20% and only every priceUpdateInterval\r\n    function checkSecondaryWalletRestrictions (uint256 newNumerator) view private\r\n      onlySecondaryWallet priceUpdateIntervalElapsed ifNewNumeratorGreater(newNumerator) {\r\n        uint256 percentageDiff = safeSub(safeMul(newNumerator, 100) / currentPrice.numerator, 100);\r\n        require(percentageDiff \u003c= 20, \"percentageDiff \u003c= 20\");\r\n    }\r\n\r\n    function updatePriceDenominator(uint256 newDenominator) external onlyPrimaryWallet {\r\n        require(newDenominator \u003e 0, \"newDenominator \u003e 0\");\r\n        currentPrice.denominator = newDenominator;\r\n        // map time to new Price\r\n        priceHistory[currentPriceHistoryIndex] = currentPrice;\r\n        currentPriceHistoryIndex = now;\r\n        emit PriceUpdated(currentPrice.numerator, newDenominator);\r\n    }\r\n\r\n    function processDeposit(address participant, uint numberOfTokens) external onlyPrimaryWallet {\r\n        require(participant != address(0), \"participant != address(0)\");\r\n        whitelist[participant] = true;\r\n        allocateTokens(participant, numberOfTokens);\r\n        emit Whitelisted(participant);\r\n        emit DepositProcessed(participant, numberOfTokens);\r\n    }\r\n\r\n    // When Ether is sent directly to the contract\r\n    function() public payable {\r\n    }\r\n\r\n    function allocateTokens(address participant, uint256 numberOfTokens) private {\r\n\r\n        // check that token cap is not exceeded\r\n        require(safeAdd(totalSupply, numberOfTokens) \u003c= tokenCap, \"Exceeds token cap\");\r\n\r\n        // increase token supply, assign tokens to participant\r\n        totalSupply = safeAdd(totalSupply, numberOfTokens);\r\n        balances[participant] = safeAdd(balances[participant], numberOfTokens);\r\n\r\n        emit Transfer(address(0), participant, numberOfTokens);\r\n    }\r\n\r\n    function verifyParticipant(address participant) external onlyPrimaryAndSecondaryWallets {\r\n        whitelist[participant] = true;\r\n        emit Whitelisted(participant);\r\n    }\r\n\r\n    function removeFromWhitelist(address participant) external onlyPrimaryAndSecondaryWallets {\r\n        whitelist[participant] = false;\r\n        emit RemovedFromWhitelist(participant);\r\n    }\r\n\r\n    function requestWithdrawal(uint256 amountOfTokensToWithdraw) external isTradeable onlyWhitelist {\r\n        require(amountOfTokensToWithdraw \u003e 0, \"Amount must be greater than 0\");\r\n        address participant = msg.sender;\r\n        require(balanceOf(participant) \u003e= amountOfTokensToWithdraw, \"Not enough balance\");\r\n        require(withdrawalRequests[participant].nummberOfTokens == 0, \"Outstanding withdrawal request must be processed\");\r\n        balances[participant] = safeSub(balanceOf(participant), amountOfTokensToWithdraw);\r\n        withdrawalRequests[participant] = WithdrawalRequest({nummberOfTokens: amountOfTokensToWithdraw, time: currentPriceHistoryIndex});\r\n        emit WithdrawalRequested(participant, amountOfTokensToWithdraw);\r\n    }\r\n\r\n    function withdraw() external {\r\n        address participant = msg.sender;\r\n        uint256 nummberOfTokens = withdrawalRequests[participant].nummberOfTokens;\r\n        require(nummberOfTokens \u003e 0, \"Missing withdrawal request\");\r\n        uint256 requestTime = withdrawalRequests[participant].time;\r\n        Price storage price = priceHistory[requestTime];\r\n        require(price.numerator \u003e 0, \u0027Please wait for the next price update\u0027);\r\n        uint256 etherAmount = safeMul(nummberOfTokens, price.denominator) / price.numerator;\r\n        require(address(this).balance \u003e= etherAmount, \"Not enough Ether in the smart contract.\");\r\n\r\n        withdrawalRequests[participant].nummberOfTokens = 0;\r\n        // Move the Isonex tokens to the primary wallet\r\n        balances[primaryWallet] = safeAdd(balances[primaryWallet], nummberOfTokens);\r\n        // Send ether from the contract wallet to the participant\r\n        participant.transfer(etherAmount);\r\n        emit Withdrew(participant, etherAmount, nummberOfTokens);\r\n    }\r\n\r\n    function checkWithdrawValue(uint256 amountTokensToWithdraw) public constant returns (uint256 etherValue) {\r\n        require(amountTokensToWithdraw \u003e 0, \"Amount must be greater than 0\");\r\n        require(balanceOf(msg.sender) \u003e= amountTokensToWithdraw, \"Not enough balance\");\r\n        uint256 withdrawValue = safeMul(amountTokensToWithdraw, currentPrice.denominator) / currentPrice.numerator;\r\n        require(address(this).balance \u003e= withdrawValue, \"Not enough balance in contract\");\r\n        return withdrawValue;\r\n    }\r\n\r\n    // allow the primaryWallet or secondaryWallet to add Ether to the contract\r\n    function addLiquidity() external onlyPrimaryAndSecondaryWallets payable {\r\n        require(msg.value \u003e 0, \"Amount must be greater than 0\");\r\n        emit LiquidityAdded(msg.value);\r\n    }\r\n\r\n    // allow the primaryWallet or secondaryWallet to remove Ether from contract\r\n    function removeLiquidity(uint256 amount) external onlyPrimaryAndSecondaryWallets {\r\n        require(amount \u003c= address(this).balance, \"amount \u003c= address(this).balance\");\r\n        primaryWallet.transfer(amount);\r\n        emit LiquidityRemoved(amount);\r\n    }\r\n\r\n    function changePrimaryWallet(address newPrimaryWallet) external onlyPrimaryWallet {\r\n        require(newPrimaryWallet != address(0), \"newPrimaryWallet != address(0)\");\r\n        primaryWallet = newPrimaryWallet;\r\n    }\r\n\r\n    function changeSecondaryWallet(address newSecondaryWallet) external onlyPrimaryWallet {\r\n        require(newSecondaryWallet != address(0), \"newSecondaryWallet != address(0)\");\r\n        secondaryWallet = newSecondaryWallet;\r\n    }\r\n\r\n    function changePriceUpdateInterval(uint256 newPriceUpdateInterval) external onlyPrimaryWallet {\r\n        priceUpdateInterval = newPriceUpdateInterval;\r\n    }\r\n\r\n    function enableTrading() external onlyPrimaryWallet {\r\n        tradeable = true;\r\n    }\r\n\r\n    function claimTokens(address _token) external onlyPrimaryWallet {\r\n        require(_token != address(0), \"_token != address(0)\");\r\n        ERC20Interface token = ERC20Interface(_token);\r\n        uint256 balance = token.balanceOf(this);\r\n        token.transfer(primaryWallet, balance);\r\n    }\r\n\r\n    // override transfer and transferFrom to add is tradeable modifier\r\n    function transfer(address _to, uint256 _value) public notRestricted(msg.sender, _to, _value) returns (bool success) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public notRestricted(_from, _to, _value) returns (bool success) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function pendingWithdrawalAmount() external constant returns (uint256) {\r\n        return withdrawalRequests[msg.sender].nummberOfTokens;\r\n    }\r\n\r\n    function pendingWithdrawalRateNumerator() external constant returns (uint256) {\r\n        return priceHistory[withdrawalRequests[msg.sender].time].numerator;\r\n    }\r\n\r\n    function isInWhitelist(address participant) external constant onlyPrimaryWallet returns (bool) {\r\n        return whitelist[participant];\r\n    }\r\n\r\n    function amIWhitelisted() external constant returns (bool) {\r\n        return whitelist[msg.sender];\r\n    }\r\n\r\n    // returns a restriction code,\r\n    // where 0 success\r\n    function detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\r\n        if (whitelist[from] == false) {\r\n            return 1;\r\n        }\r\n        if (whitelist[to] == false) {\r\n            return 2;\r\n        }\r\n        if (!(tradeable || msg.sender == primaryWallet)) {\r\n            return 3;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function messageForTransferRestriction (uint8 restrictionCode) public view returns (string){\r\n        if (bytes(restrictionMap[restrictionCode]).length == 0 ){\r\n            return \"Invalid restriction code\";\r\n        }\r\n\r\n        return restrictionMap[restrictionCode];\r\n    }\r\n\r\n    // Events\r\n\r\n    event PriceUpdated(uint256 numerator, uint256 denominator);\r\n    event DepositProcessed(address indexed participant, uint256 numberOfTokens);\r\n    event Whitelisted(address indexed participant);\r\n    event RemovedFromWhitelist(address indexed participant);\r\n    event WithdrawalRequested(address indexed participant, uint256 numberOfTokens);\r\n    event Withdrew(address indexed participant, uint256 etherAmount, uint256 numberOfTokens);\r\n    event LiquidityAdded(uint256 ethAmount);\r\n    event LiquidityRemoved(uint256 ethAmount);\r\n    event UserDeposited(address indexed participant, address indexed beneficiary, uint256 ethValue, uint256 numberOfTokens);\r\n\r\n    // Modifiers\r\n\r\n    modifier onlyWhitelist {\r\n        require(whitelist[msg.sender], \"Not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPrimaryWallet {\r\n        require(msg.sender == primaryWallet, \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySecondaryWallet {\r\n        if (msg.sender == secondaryWallet)\r\n\t\t_;\r\n    }\r\n\r\n    modifier onlyPrimaryAndSecondaryWallets {\r\n        require(msg.sender == secondaryWallet || msg.sender == primaryWallet, \"Unauthorized\");\r\n        _;\r\n    }\r\n\r\n    modifier priceUpdateIntervalElapsed {\r\n        require(safeSub(now, priceUpdateInterval) \u003e= currentPriceHistoryIndex, \"Price update interval\");\r\n        _;\r\n    }\r\n\r\n    modifier ifNewNumeratorGreater (uint256 newNumerator) {\r\n        if (newNumerator \u003e currentPrice.numerator)\r\n        _;\r\n    }\r\n\r\n    modifier isTradeable { // exempt primaryWallet to allow dev allocations\r\n        require(tradeable || msg.sender == primaryWallet, \"Trading is currently disabled\");\r\n        _;\r\n    }\r\n\r\n    modifier notRestricted (address from, address to, uint256 value) {\r\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\r\n        require(restrictionCode == 0, messageForTransferRestriction(restrictionCode));\r\n        _;\r\n    }\r\n}"}}