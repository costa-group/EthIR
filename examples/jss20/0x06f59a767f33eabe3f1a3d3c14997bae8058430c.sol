{"Deprecatable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\nimport \"./Ownable.sol\";\n\nabstract contract Deprecateble is Ownable {\n  bool internal _deprecated;\n\n  modifier onlyNotDeprecated() {\n    require(!_deprecated, \"Deprecateble: contract is deprecated\");\n    _;\n  }\n\n  function deprecate() public onlyOwner {\n    _deprecated = true;\n    emit Deprecate(msg.sender);\n  }\n\n  event Deprecate(address indexed account);\n}\n"},"Details.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\nabstract contract Detailable {\n  function name() public pure returns (string memory) {\n    return \"Neutrino\";\n  }\n\n  function symbol() public pure returns (string memory) {\n    return \"USDN\";\n  }\n\n  function decimals() public pure returns (uint8) {\n    return 18;\n  }\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ninterface ERC20 {\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"Ownable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\nabstract contract Ownable {\n  address private _owner;\n  address private _admin;\n\n  constructor () {\n    _owner = msg.sender;\n    _admin = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(_owner == msg.sender || _admin == msg.sender, \"Ownable: caller is not the owner or admin\");\n    _;\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _owner = newOwner;\n  }\n}\n"},"Staking.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\ninterface Staking {\n  function deposit(address account, uint256 amount) external returns (bool);\n\n  function stake(uint256 reward) external returns (bool);\n\n  function withdraw(address account) external returns (bool);\n\n  event Reward(uint256 id, uint amount);\n}"},"StandartToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\nimport \"./Staking.sol\";\nimport \"./ERC20.sol\";\nimport \"./Ownable.sol\";\nimport \"./Deprecatable.sol\";\n\nabstract contract StandartToken is Staking, ERC20, Ownable, Deprecateble {\n  struct Snapshots {\n    uint256[] ids;\n    uint256[] values;\n  }\n\n  uint256 internal _totalSupply;\n  uint256 internal _currentDeposits;\n  uint256 internal _currentSnapshotId;\n  mapping(address =\u003e uint256) internal _balances;\n  mapping(address =\u003e mapping(address =\u003e uint256)) internal _allowances;\n  mapping(uint256 =\u003e uint256) internal _rewards;\n  mapping(uint256 =\u003e uint256) internal _totalSupplies;\n  mapping(address =\u003e uint256) internal _lastRewardSnapshot;\n  mapping(address =\u003e Snapshots) internal _accountBalanceSnapshots;\n\n  function deposit(address account, uint256 amount) external onlyOwner onlyNotDeprecated override virtual returns (bool)  {\n    require(amount \u003e 0, \"amount should be \u003e 0\");\n    require(account != address(0), \"deposit to the zero address\");\n\n    uint256 lastSnapshotId;\n    Snapshots storage snapshots = _accountBalanceSnapshots[account];\n    uint256 snapshotLength = snapshots.ids.length;\n    if (snapshotLength != 0) {\n      lastSnapshotId = snapshots.ids[snapshotLength - 1];\n    }\n\n    uint256 temp = _balances[account] + amount;\n    require(temp \u003e= amount, \"addition overflow for new balance\");\n    _balances[account] = temp;\n\n    if (lastSnapshotId == _currentSnapshotId + 2) {\n      temp = snapshots.values[snapshotLength - 1] + amount;\n      require(temp \u003e= amount, \"addition overflow for amount\");\n      snapshots.values[snapshotLength - 1] = temp;\n    } else {\n      snapshots.ids.push(_currentSnapshotId + 2);\n      snapshots.values.push(temp);\n    }\n    _currentDeposits += amount;\n\n    emit Transfer(address(0), account, amount);\n    return true;\n  }\n\n  function stake(uint256 reward) external onlyOwner onlyNotDeprecated override virtual returns (bool) {\n    require(reward \u003e 0, \"reward should be \u003e 0\");\n\n    uint256 oldTotalSupply = _totalSupply;\n    uint256 oldIndex = _currentSnapshotId;\n    uint256 oldDeposits = _currentDeposits;\n\n    require(oldIndex + 1 \u003e= oldIndex, \"addition overflow for currentIndex\");\n    _currentSnapshotId = oldIndex + 1;\n    _rewards[oldIndex + 1] = reward;\n    _totalSupplies[oldIndex + 1] = oldTotalSupply;\n\n    if (oldTotalSupply == 0) {\n      require(oldTotalSupply + oldDeposits \u003e= oldTotalSupply, \"addition overflow for totalSupply\");\n      _totalSupply = oldTotalSupply + oldDeposits;\n    } else {\n      require(oldTotalSupply + oldDeposits + reward \u003e= oldTotalSupply, \"addition overflow for totalSupply\");\n      _totalSupply = oldTotalSupply + oldDeposits + reward;\n    }\n\n    _currentDeposits = 0;\n    emit Reward(oldIndex, reward);\n    return true;\n  }\n\n  function withdraw(address account) external onlyOwner onlyNotDeprecated override virtual returns (bool) {\n    uint256 balanceTotal = balanceOf(account);\n\n    require(balanceTotal \u003e 0, \"balance should be \u003e 0\");\n    uint256 temp = _totalSupply;\n    if (balanceTotal \u003e temp) {\n      _totalSupply = 0;\n      uint256 oldDeposits = _currentDeposits;\n      require(balanceTotal - temp \u003c= oldDeposits, \"balanceTotal - oldTotalSupply \u003e oldDeposits\");\n      _currentDeposits = oldDeposits - (balanceTotal - temp);\n    } else {\n      _totalSupply = temp - balanceTotal;\n    }\n\n    Snapshots storage snapshots = _accountBalanceSnapshots[account];\n    uint256 lastIndex = snapshots.ids.length;\n    uint256 oldIndex = _currentSnapshotId;\n    uint256 length = snapshots.ids.length;\n    while (lastIndex \u003e 0 \u0026\u0026 snapshots.ids[lastIndex - 1] \u003e oldIndex) {\n      lastIndex--;\n    }\n\n    temp = lastIndex + 3;\n    for (; lastIndex \u003c temp; lastIndex++) {\n      if (lastIndex \u003e= length) {\n        snapshots.ids.push(lastIndex);\n        snapshots.values.push(0);\n      } else {\n        snapshots.ids[lastIndex] = lastIndex;\n        snapshots.values[lastIndex] = 0;\n      }\n    }\n    _lastRewardSnapshot[account] = oldIndex;\n    _balances[account] = 0;\n\n    emit Transfer(account, address(0), balanceTotal);\n    return true;\n  }\n\n  // ERC20\n  function totalSupply() external view override virtual returns (uint256) {\n    return _totalSupply + _currentDeposits;\n  }\n\n  function balanceOf(address account) public view override virtual returns (uint256) {\n    uint256 currentSnapshotId = _lastRewardSnapshot[account] + 1;\n    uint256 lastSnapshotId = _currentSnapshotId;\n    Snapshots storage balancesSnapshots = _accountBalanceSnapshots[account];\n\n    uint256 balance = _balances[account];\n    uint256 balancesLength = balancesSnapshots.ids.length;\n\n    uint256 balanceIndex;\n    uint256 low;\n    uint256 high = balancesLength;\n\n    if (balancesLength != 0) {\n      while (low \u003c high) {\n        uint256 mid = (low / 2) + (high / 2) + ((low % 2 + high % 2) / 2);\n        if (balancesSnapshots.ids[mid] \u003e currentSnapshotId) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n\n      if (low \u003e 0 \u0026\u0026 balancesSnapshots.ids[low - 1] == currentSnapshotId) {\n        balanceIndex = low - 1;\n      } else {\n        balanceIndex = low;\n      }\n    }\n\n    uint256 total;\n    for (; currentSnapshotId \u003c= lastSnapshotId; currentSnapshotId++) {\n      while (balanceIndex \u003c balancesLength \u0026\u0026 (balancesLength == 0 ? 0 : balancesSnapshots.ids[balanceIndex]) \u003c currentSnapshotId) {\n        balanceIndex++;\n      }\n\n      if (balanceIndex == balancesLength) {\n        low = balance + total;\n      } else {\n        if (balancesSnapshots.ids[balanceIndex] \u003e currentSnapshotId) {\n          low = total;\n          continue;\n        } else {\n          low = (balanceIndex == balancesLength ? balance : balancesSnapshots.values[balanceIndex]) + total;\n          if (low == 0) {\n            continue;\n          }\n        }\n      }\n\n      high = _totalSupplies[currentSnapshotId];\n      if (high == 0) {\n        continue;\n      }\n\n      low *= _rewards[currentSnapshotId];\n      low /= high;\n      require(low + total \u003e= total, \"addition overflow for total\");\n      total += low;\n    }\n\n    require(balance + total \u003e= balance, \"addition overflow for balanceOf\");\n    return balance + total;\n  }\n\n  function allowance(address owner, address spender) external view override virtual returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function _approve(address owner, address spender, uint256 amount) internal onlyNotDeprecated virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function approve(address spender, uint256 amount) external override virtual returns (bool) {\n    _approve(msg.sender, spender, amount);\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue) external override virtual returns (bool) {\n    uint256 temp = _allowances[msg.sender][spender];\n    require(temp + addedValue \u003e= temp, \"addition overflow\");\n    _approve(msg.sender, spender, temp + addedValue);\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue) external override virtual returns (bool) {\n    uint256 temp = _allowances[msg.sender][spender];\n    require(subtractedValue \u003c= temp, \"ERC20: decreased allowance below zero\");\n    _approve(msg.sender, spender, temp - subtractedValue);\n    return true;\n  }\n\n  function transfer(address recipient, uint256 amount) external override virtual returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function transferFrom(address sender, address recipient, uint256 amount) external override virtual returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 temp = _allowances[sender][msg.sender];\n    require(amount \u003c= temp, \"ERC20: transfer amount exceeds allowance\");\n    _approve(sender, msg.sender, temp - amount);\n    return true;\n  }\n\n  function _transfer(address sender, address recipient, uint256 amount) internal onlyNotDeprecated virtual {\n    require(amount \u003e 0, \"amount should be \u003e 0\");\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    uint256 balance = balanceOf(sender);\n    Snapshots storage snapshots = _accountBalanceSnapshots[sender];\n    uint256 temp = snapshots.ids.length;\n    uint256 length = snapshots.ids.length;\n    uint256 oldSnapshotId = _currentSnapshotId;\n    while (temp \u003e 0 \u0026\u0026 snapshots.ids[temp - 1] \u003e= oldSnapshotId) {\n      snapshots.values[temp - 1] = balance - amount;\n      temp--;\n    }\n\n    temp = 0;\n    if (length != 0) {\n      temp = snapshots.ids[length - 1];\n    }\n    if (temp == oldSnapshotId + 2) {\n      snapshots.values[length - 1] = balance - amount;\n    } else {\n      snapshots.ids.push(oldSnapshotId + 2);\n      snapshots.values.push(balance - amount);\n    }\n    _lastRewardSnapshot[sender] = oldSnapshotId;\n    require(amount \u003c= balance, \"ERC20: transfer amount exceeds balance\");\n    _balances[sender] = balance - amount;\n\n    balance = balanceOf(recipient);\n    snapshots = _accountBalanceSnapshots[recipient];\n    temp = snapshots.ids.length;\n    length = snapshots.ids.length;\n    while (temp \u003e 0 \u0026\u0026 snapshots.ids[temp - 1] \u003e= oldSnapshotId) {\n      snapshots.values[temp - 1] = balance - amount;\n      temp--;\n    }\n\n    _lastRewardSnapshot[recipient] = oldSnapshotId;\n    oldSnapshotId = temp + 3;\n    for (; temp \u003c oldSnapshotId; temp++) {\n      if (temp \u003e= length) {\n        snapshots.ids.push(temp);\n        snapshots.values.push(balance + amount);\n      } else {\n        snapshots.ids[temp] = temp;\n        snapshots.values[temp] = balance + amount;\n      }\n    }\n    require(balance + amount \u003e= amount, \"addition overflow for balance\");\n    _balances[recipient] = balance + amount;\n\n    emit Transfer(sender, recipient, amount);\n  }\n}"},"USDN.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.7.0;\n\nimport \"./StandartToken.sol\";\nimport \"./Details.sol\";\n\ncontract USDN is StandartToken, Detailable {}"}}