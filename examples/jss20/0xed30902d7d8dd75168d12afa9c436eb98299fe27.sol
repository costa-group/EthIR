{"base.sol":{"content":"/// base.sol -- basic ERC20 implementation\r\n\r\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n\r\npragma solidity \u003e=0.4.23;\r\n\r\nimport \"erc20.sol\";\r\nimport \"math.sol\";\r\n\r\ncontract TokenBase is ERC20, DSMath {\r\n    uint256                                            _supply;\r\n    mapping (address =\u003e uint256)                       _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256))  _approvals;\r\n\r\n    constructor(uint supply) public {\r\n        _balances[msg.sender] = supply;\r\n        _supply = supply;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint) {\r\n        return _supply;\r\n    }\r\n    function balanceOf(address src) external view returns (uint) {\r\n        return _balances[src];\r\n    }\r\n    function allowance(address src, address guy) external view returns (uint) {\r\n        return _approvals[src][guy];\r\n    }\r\n\r\n    function transfer(address dst, uint wad) external returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (src != msg.sender) {\r\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); //Revert if funds insufficient. \r\n        }\r\n        _balances[src] = sub(_balances[src], wad);\r\n        _balances[dst] = add(_balances[dst], wad);\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address guy, uint wad) external returns (bool) {\r\n        _approvals[msg.sender][guy] = wad;\r\n\r\n        emit Approval(msg.sender, guy, wad);\r\n\r\n        return true;\r\n    }\r\n\r\n    event Mint(address guy, uint wad);\r\n    event Burn(address guy, uint wad);\r\n\r\n    function mint(uint wad) internal { //Note: _supply constant\r\n        _balances[msg.sender] = add(_balances[msg.sender], wad); \r\n        emit Mint(msg.sender, wad);\r\n    }\r\n\r\n    function burn(uint wad) internal { //Note: _supply constant\r\n        _balances[msg.sender] = sub(_balances[msg.sender], wad); //Revert if funds insufficient.\r\n        emit Burn(msg.sender, wad);\r\n    }\r\n    \r\n}"},"code_v3.14.sol":{"content":"// Copyright (C) 2020 Benjamin M J D Wang\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n\r\npragma solidity ^0.5.0;\r\nimport \"gov_interface_v2.sol\"; //Import governance contract interface.\r\nimport \"proposal_tokens_v3.sol\"; //proposal tokens data structure and transfer functions.\r\ncontract onchain_gov_BMJDW2020 is IOnchain_gov, proposal_tokens, onchain_gov_events{ \r\n\r\n\tERC20 public ERC20Interface;\r\n\r\n\tfunction calculate_price(uint _side, uint _now) public view returns (uint p) { //Function could also be internal if users can calculate price themselves easily. \r\n\t\tuint[4] memory price_data = proposal[pa_proposal_id].next_init_price_data;\r\n\r\n\t\tp = wmul(price_data[_side], wpow(price_data[2], mul(price_data[3], sub(_now, current_tranche_start))/WAD)); //(WAD)\r\n\t\t//p = wmul(_p1, rpow(_e, mul(_f, sub(_now, _start))/ WAD));\r\n\r\n\t\t/**\r\n\t\tp = WAD\r\n\t\tp1 = WAD\r\n\t\te = WAD\r\n\t\tf = int\r\n\t\tnow = int\r\n\t\tstart = int\r\n\t\t*/\r\n\t}\r\n\r\n\t\r\n\tfunction submit_proposal(uint _amount, uint _next_init_tranche_size, uint[4] calldata _next_init_price_data, uint _next_reject_spread_threshold, uint _next_minimum_sell_volume, uint40 _prop_period, uint40 _next_min_prop_period, uint40 _reset_time_period) external {\r\n\t\t \r\n\t\tuint param = wdiv(_amount, mul(_next_min_prop_period, _prop_period)); //_next_min_prop_period is purely an anti-spam prevention to stop spammers submitting proposals with very small amounts. Assume WAD since _next_min_prop_period * _prop_period may result in large number. \r\n\r\n\t\trequire(param \u003e top_param, \"param \u003c top_param\");\r\n\t\trequire(_prop_period \u003e proposal[pa_proposal_id].next_min_prop_period, \"prop_period \u003c minimum\"); //check that voting period is greater than the next_min_prop_period of the last accepted proposal.\r\n\r\n\t\ttop_param = param; //Sets current top param to that of the resently submitted proposal. \r\n\r\n\t\tERC20Interface.transferFrom(msg.sender, address(this), _amount / 100);//Takes proposer\u0027s deposit in dai. This must throw an error and revert if the user does not have enough funds available. \r\n\r\n\t\tERC20Interface.transfer(proposal[top_proposal_id].beneficiary, proposal[top_proposal_id].amount / 100); ////Pays back the deposit to the old top proposer in dai.\r\n\r\n\t\tuint id = ++nonce; //Implicit conversion to uint256\r\n\t\ttop_proposal_id = uint40(id); //set top proposal id and is used as id for recording data.\r\n\r\n\t\t//Store all new proposal data:\r\n\t\tproposal[id].beneficiary = msg.sender;\r\n\t\tproposal[id].amount = _amount;\r\n\t\tproposal[id].next_init_tranche_size = _next_init_tranche_size;\r\n\t\tproposal[id].next_init_price_data = _next_init_price_data;\r\n\t\tproposal[id].next_reject_spread_threshold = _next_reject_spread_threshold;\r\n\t\tproposal[id].next_minimum_sell_volume = _next_minimum_sell_volume;\r\n\t\tproposal[id].prop_period = _prop_period;\r\n\t\tproposal[id].next_min_prop_period = _next_min_prop_period;\r\n\t\tproposal[id].reset_time_period = _reset_time_period;\r\n\r\n\t\temit NewSubmission(uint40(id), msg.sender, _amount, _next_init_tranche_size, _next_init_price_data, _next_reject_spread_threshold, _next_minimum_sell_volume, _prop_period, _next_min_prop_period, _reset_time_period);\r\n\t}\r\n\r\n\r\n\tfunction init_proposal(uint40 _id) external { //\u0027sell\u0027 and \u0027buy\u0027 indicate sell and buy side from the user perspective in the context of governance tokens even though it is in reference to dai.\r\n\t\trequire (running_proposal_id == 0, \"Proposal still running.\"); //Makes sure previous proposal has finished.\r\n\t\t/**\r\n\t\tWhen proposal has ended and was accepted:\r\n\t\tpa_proposal_id = running_proposal_id\r\n\t\trunning_proposal_id = 0\r\n\r\n\t\tWhen proposal has ended and was rejected:\r\n\t\tpa_proposal_id remains the same.\r\n\t\trunning_proposal_id = 0\r\n\r\n\t\tWhen initialised:\r\n\t\trunning_proposal_id = top_proposal_id\r\n\t\ttop_proposal_id = 1;\r\n\t\tproposal status = 1;\r\n\t\t*/\r\n\r\n\t\trequire (_id == top_proposal_id, \"Wrong id.\"); //Require correct proposal to be chosen.\r\n\t\trequire (_id != 0, \"_id != 0\"); //Cannot initialise the genesis proposal.\r\n\t\trunning_proposal_id = _id; //Update running proposal id.\r\n\t\ttop_proposal_id = 0; //Set top proposal to the genesis proposal. This is because some top_proposa_id is necessary in the submission function above for the first submission after each proposal.\r\n\t\tproposal[_id].status = 1; //Set proposal status to \u0027ongoing\u0027.\r\n\t\tuint init_sell_size = proposal[pa_proposal_id].next_init_tranche_size; //Init sell tranche size.\r\n\r\n\t\t proposal[_id].side[1].current_tranche_size = init_sell_size;\r\n\r\n\t\tuint minimum_sell_volume = proposal[pa_proposal_id].next_minimum_sell_volume;\r\n\r\n\t\tuint dai_out = add(wmul(990000000000000000, proposal[_id].amount), minimum_sell_volume);\r\n\r\n\t\tuint net_balance = net_dai_balance;\r\n\r\n\t\tuint init_buy_size;\r\n\r\n\t\t//Make sure that the contract is always running a positive net dai balance:\r\n\r\n\t\tif (dai_out \u003e net_balance){\r\n\t\t\tinit_buy_size = wmul(wdiv(init_sell_size, minimum_sell_volume), sub(dai_out, net_balance));\r\n\t\t}\r\n\t\telse{\r\n\t\t\tinit_buy_size = init_sell_size;\r\n\t\t}\r\n\r\n\t\tproposal[_id].side[0].current_tranche_size = init_buy_size;\r\n\t\tcurrent_tranche_start = uint40(now);\r\n\t\tproposal[_id].proposal_start = uint40(now);\r\n\t\ttop_param = 0; //reset top param.\r\n\r\n\t\temit InitProposal (_id, init_buy_size, init_sell_size);\r\n\t}\r\n\r\n\tfunction reset() external{\r\n\t\trequire (uint40(now) - proposal[pa_proposal_id].proposal_start \u003e proposal[pa_proposal_id].reset_time_period, \"Reset time not elapsed.\"); //Tests amount of time since last proposal passed.\r\n\r\n\t\tuint id = ++nonce;\r\n\t\t//Set proposal data:\r\n\t\tproposal[id].beneficiary = msg.sender;\r\n\t\tproposal[id].next_min_prop_period = proposal[pa_proposal_id].next_min_prop_period;\r\n\t\tproposal[id].next_init_tranche_size = proposal[pa_proposal_id].next_init_tranche_size;\r\n\t\tproposal[id].next_init_price_data = proposal[pa_proposal_id].next_init_price_data;\r\n\t\tproposal[id].next_reject_spread_threshold = proposal[pa_proposal_id].next_reject_spread_threshold;\r\n\t\tuint next_minimum_sell_volume = proposal[pa_proposal_id].next_minimum_sell_volume;\r\n\t\tproposal[id].next_minimum_sell_volume = next_minimum_sell_volume;\r\n\t\tproposal[id].reset_time_period = proposal[pa_proposal_id].reset_time_period;\r\n\r\n\t\trequire (running_proposal_id == 0, \"Proposal still running.\"); //Makes sure previous proposal has finished.\r\n\t\trunning_proposal_id = uint40(id); //Update running proposal id.\r\n\t\ttop_proposal_id = 0; //Set top proposal to the genesis proposal. This is because some top_proposal_id is necessary in the submission function above for the first submission after each proposal.\r\n\t\tproposal[id].status = 4; //Set proposal status to \u0027ongoing reset proposal\u0027.\r\n\t\tproposal[id].side[0].current_tranche_size = next_minimum_sell_volume;\r\n\t\tproposal[id].side[1].current_tranche_size = next_minimum_sell_volume;\r\n\t\t//Set as size of tranche as minimum sell volume.\r\n\r\n\t\tcurrent_tranche_start = uint40(now);\r\n\t\tproposal[id].proposal_start = uint40(now);\r\n\t\ttop_param = 0; //reset top param.\r\n\r\n\t\temit Reset(id);\r\n\r\n\r\n\t}\r\n\r\n\r\n\tfunction all_trades_common(uint _id, uint _side, uint _tranche_size) internal view returns (uint current_tranche_t) {\r\n\t\trequire (_id == running_proposal_id, \"Wrong id.\"); //User can only trade on currently running proposal.\r\n\t\trequire (proposal[_id].side[_side].current_tranche_size == _tranche_size, \"Wrong tranche size.\"); //Make sure the user\u0027s selected tranche size is the current tranche size. Without this they may choose arbitrary tranches and then loose tokens.\r\n\t\trequire (proposal[_id].side[_side].tranche[_tranche_size].price == 0, \"Tranche already closed.\"); //Check tranche is still open.\r\n\t\tcurrent_tranche_t = proposal[_id].side[_side].current_tranche_total;\r\n\t}\r\n\r\n\tfunction buy_sell_common(uint _id, uint _input_amount, uint _side, uint _tranche_size, uint _current_dai_price) internal {\r\n\t\tuint current_tranche_t = all_trades_common(_id, _side, _tranche_size);\r\n\r\n\t\trequire (wmul(add(_input_amount, current_tranche_t), _current_dai_price) \u003c _tranche_size, \"Try closing tranche.\"); //Makes sure users cannot send tokens beyond or even up to the current tranche size since this is for the tranche close function. \r\n\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].balance[msg.sender] = add(proposal[_id].side[_side].tranche[_tranche_size].balance[msg.sender], _input_amount); //Record proposal balance.\r\n\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].recent_trade_time = sub(now, current_tranche_start); //Set time of most recent trade so 2nd to last trade time can be recorded. Offset by current_tranche_start to account for zero initial value.\r\n\r\n\t\tproposal[_id].side[_side].current_tranche_total = add(current_tranche_t, _input_amount); //Update current_tranche_total.\r\n\r\n\t\temit NewTrancheTotal (_side, current_tranche_t + _input_amount);\r\n\t}\r\n\r\n\tfunction buy(uint _id, uint _input_dai_amount, uint _tranche_size) external {\r\n\t\t//Set correct amount of dai \r\n\t\tbuy_sell_common(_id, _input_dai_amount, 0, _tranche_size, WAD); //For buying _dai_amount = _input_dai_amount. Dai price = 1.0.\r\n\r\n\t\tERC20Interface.transferFrom(msg.sender, address(this), _input_dai_amount); //Take dai from user using call to dai contract. User must approve contract address and amount before transaction.\r\n\t}\r\n\r\n\tfunction sell(uint _id, uint _input_token_amount, uint _tranche_size) external {\r\n\t\t//Set correct amount of dai\r\n\r\n\t\tbuy_sell_common(_id, _input_token_amount, 1, _tranche_size, calculate_price(1, now)); //For selling, the current dai amount must be used based on current price.\r\n\r\n\t\tburn(_input_token_amount); //Remove user governance tokens. SafeMath should revert with insufficient funds.\r\n\t}\r\n\r\n\tfunction close_buy_sell_common_1(uint _id, uint _side, uint _tranche_size) internal returns(uint price, uint final_trade_price, uint current_tranche_t) {\r\n\t\tcurrent_tranche_t = all_trades_common(_id, _side, _tranche_size);\r\n\r\n\t\tprice = calculate_price(_side, add(proposal[_id].side[_side].tranche[_tranche_size].recent_trade_time, current_tranche_start)); //(WAD) Sets price for all traders.\r\n\t\tfinal_trade_price = calculate_price(_side, now);\r\n\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].price = price; //(WAD) Sets price for all traders.\r\n\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].final_trade_price = final_trade_price; //(WAD) Sets price for only the final trader.\r\n\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].final_trade_address = msg.sender; //Record address of final trade.\r\n\r\n\t\tproposal[_id].side[_side].current_tranche_total = 0; //Reset current_tranche_total to zero.\r\n\t}\r\n\r\n\r\n\tfunction close_buy_sell_common_2(uint _id, uint _balance_amount, uint _side, uint _tranche_size, uint _input_dai_amount, uint _current_tranche_t_dai, uint _this_tranche_tokens_total) internal {\r\n\t\trequire (add(_input_dai_amount, _current_tranche_t_dai) \u003e= _tranche_size, \"Not enough to close.\"); //Check that the user has provided enough dai or equivalent to close the tranche.\r\n\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].final_trade_amount = _balance_amount; //Record final trade amount.\r\n\t\t\t\r\n\t\tif (proposal[_id].side[(_side+1)%2].tranche[proposal[_id].side[(_side+1)%2].current_tranche_size].price != 0){ //Check whether tranche for other side has closed.\r\n\r\n\t\t\tcurrent_tranche_start = uint40(now); //Reset timer for next tranche.\r\n\r\n\t\t\tproposal[_id].side[_side].total_tokens_traded = add(proposal[_id].side[_side].total_tokens_traded, _this_tranche_tokens_total);\r\n\t\t\tproposal[_id].side[(_side+1)%2].total_tokens_traded = add(proposal[_id].side[(_side+1)%2].total_tokens_traded, lct_tokens_traded); //Sets total tokens traded on each side now that tranches on both sides have closed (using lct_tokens_traded which was recorded when the other side closed.)\r\n\r\n\t\t\tproposal[_id].side[_side].total_dai_traded = add(proposal[_id].side[_side].total_dai_traded, _tranche_size); \r\n\t\t\tproposal[_id].side[(_side+1)%2].total_dai_traded = add(proposal[_id].side[(_side+1)%2].total_dai_traded, proposal[_id].side[(_side+1)%2].current_tranche_size); //Add total dai traded in tranche to total_dai_traded.\r\n\t\t\t//Add total dai traded in tranche to total_dai_traded.\r\n\t\t\tif (proposal[_id].side[1].total_dai_traded \u003e= proposal[pa_proposal_id].next_minimum_sell_volume) { //if sell volume has reached the minimum and reset has not already happened: then reset the tranche sizes on both sides to the same value.\r\n\t\t\t\tuint new_size = mul(_tranche_size, 2);\r\n\t\t\t\tproposal[_id].side[0].current_tranche_size = new_size;\r\n\t\t\t\tproposal[_id].side[1].current_tranche_size = new_size;\r\n\t\t\t\t  //Set both tranche sizes to the same size.\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tproposal[_id].side[_side].current_tranche_size = mul(_tranche_size, 2); \r\n\t\t\t\tproposal[_id].side[(_side+1)%2].current_tranche_size = mul(proposal[_id].side[(_side+1)%2].current_tranche_size, 2); //Double the current tranche sizes.\r\n\t\t\t}\r\n\t\t}\r\n\t\telse{\r\n\t\t\tlct_tokens_traded = _this_tranche_tokens_total; //Records last closed tranche tokens traded total for when both tranches close.\r\n\t\t}\r\n\temit TrancheClose (_side, _tranche_size, _this_tranche_tokens_total); //Users must check when both sides have closed and then calculate total traded themselves by summing the TrancheClose data. \r\n\t}\r\n\r\n\tfunction close_tranche_buy(uint _id, uint _input_dai_amount, uint _tranche_size) external {\r\n\t\t(uint price, uint final_trade_price, uint current_tranche_t) = close_buy_sell_common_1(_id, 0, _tranche_size);\r\n\r\n\t\tuint dai_amount_left = sub(_tranche_size, current_tranche_t); //Calculates new amount of dai for user to give.\r\n\r\n\t\tuint this_tranche_tokens_total = add(wmul(current_tranche_t,price), wmul(dai_amount_left, final_trade_price)); //Update total_tokens_traded\r\n\r\n\t\tclose_buy_sell_common_2(_id, dai_amount_left, 0, _tranche_size, _input_dai_amount, current_tranche_t, this_tranche_tokens_total);\r\n\r\n\t\tERC20Interface.transferFrom(msg.sender, address(this), dai_amount_left); //Take dai from user using call to dai contract. User must approve contract address and amount before transaction.\r\n\r\n\t}\r\n\tfunction close_tranche_sell(uint _id, uint _input_token_amount, uint _tranche_size) external {\r\n\t\t(uint price, uint final_trade_price, uint current_tranche_t) = close_buy_sell_common_1(_id, 1, _tranche_size);\r\n\r\n\t\tuint dai_amount_left = sub(_tranche_size, wmul(current_tranche_t, price)); //Calculates dai_amount_left in tranche which is based on the price the other sellers will pay, not the current price.\r\n\t\tuint token_equiv_left = wdiv(dai_amount_left, final_trade_price); //Calculate amount of tokens to give user based on dai amount left.\r\n\t\tuint equiv_input_dai_amount = wmul(_input_token_amount, final_trade_price); //Equivalent amount of dai at current prices based on the user amount of tokens.\r\n\r\n\t\tuint this_tranche_tokens_total = add(current_tranche_t, token_equiv_left); //Update total_tokens_traded\r\n\r\n\t\tclose_buy_sell_common_2(_id, token_equiv_left, 1, _tranche_size, equiv_input_dai_amount, wmul(current_tranche_t, price), this_tranche_tokens_total);\r\n\r\n\t\tburn(token_equiv_left); //Remove user governance tokens. SafeMath should revert with insufficient funds.\r\n\t}\r\n\r\n\r\n\tfunction accept_prop() external {\r\n\t\tuint id = running_proposal_id;\r\n\t\trequire (proposal[id].side[1].total_dai_traded \u003e= proposal[pa_proposal_id].next_minimum_sell_volume, \"dai sold \u003c minimum\"); //Check that minimum sell volume has been reached.\r\n\r\n\t\t//Collect state data into memory for calculating prices:\r\n\t\tuint current_total_dai_sold = proposal[id].side[0].total_dai_traded;\r\n\t\tuint previous_total_dai_bought = proposal[pa_proposal_id].side[1].total_dai_traded;\r\n\t\tuint current_total_tokens_bought = proposal[id].side[0].total_tokens_traded;\r\n\r\n\t\tuint proposal_amount = proposal[id].amount;\r\n\t\tuint accept_current_p_amount;\r\n\t    uint accept_previous_p_amount;\r\n\r\n\t\t//Calculate where attacker\u0027s capital will be spent for accept case and reject case:\r\n\t\tif (current_total_dai_sold \u003c add(previous_total_dai_bought, proposal_amount)){\r\n\t\t\taccept_current_p_amount = proposal_amount;\r\n\t\t\t//accept_previous_p_amount = 0 by default.\r\n\t\t}\r\n\t\telse{\r\n\t\t\t//accept_current_p_amount = 0 by default.\r\n\t\t\taccept_previous_p_amount = proposal_amount;\r\n\t\t}\r\n\r\n\t\t//Attacker aims to attack at weakest point. The assumed ratio of z_a_p to y_a_p determines where attack is spending capital i.e. where they are attacking. So the attacker will aim to spend the most where the amount of dai is lowest, since this will have the greatest effect on price. Or in other words we want to know the minimum of the minimum prices. \r\n\r\n\t\tuint accept_price = wmul(wdiv(sub(current_total_dai_sold, accept_current_p_amount), current_total_tokens_bought), wdiv(proposal[pa_proposal_id].side[1].total_tokens_traded, add(accept_previous_p_amount, previous_total_dai_bought))); //Minimum non-manipulated price.\r\n\r\n\t\tif (accept_price \u003e WAD){ //If proposal accepted: (change to require later)\r\n\t\t\tproposal[id].status = 2;\r\n\t\t\tERC20Interface.transfer(proposal[id].beneficiary, proposal[id].amount);\r\n\t\t\tpa_proposal_id = running_proposal_id;\r\n\t\t\trunning_proposal_id = 0;\r\n\r\n\t\t\t_supply = sub(add(_supply, proposal[id].side[0].total_tokens_traded), proposal[id].side[1].total_tokens_traded);\r\n\r\n\t\t\tnet_dai_balance = sub(add(net_dai_balance, current_total_dai_sold), add(wmul(990000000000000000, proposal_amount), proposal[id].side[1].total_dai_traded)); //Update net_dai_balance\r\n\t\t}\r\n\r\n\t\temit AcceptAttempt (accept_price, wdiv(current_total_dai_sold, current_total_tokens_bought), wdiv(proposal[id].side[1].total_dai_traded, proposal[id].side[1].total_tokens_traded));\r\n\t}\r\n\r\n\r\n\tfunction reject_prop_spread() external {\r\n\t\tuint id = running_proposal_id;\r\n\t\trequire (proposal[id].status == 1, \"Prop status is incorrect.\"); //Make sure it is not a reset proposal.\r\n\t\tuint recent_buy_price = proposal[id].side[0].tranche[proposal[id].side[0].current_tranche_size].price; //Price of current tranche.\r\n\t\tuint recent_sell_price = proposal[id].side[1].tranche[proposal[id].side[1].current_tranche_size].price;\r\n\r\n\t\tif (recent_buy_price == 0) { //Checks whether current tranche has closed. If not then latest price is calculated.\r\n\t\t\trecent_buy_price = calculate_price(0, now);\r\n\t\t}\r\n\t\tif (recent_sell_price == 0) {\r\n\t\t\trecent_sell_price = calculate_price(1, now);\r\n\t\t}\r\n\r\n\t\tuint spread = wmul(recent_buy_price, recent_sell_price); //Spread based on current tranche using auction prices that have not finished when necessary. You cannot manipulate spread to be larger so naive price is used.\r\n\t\tif (spread \u003e proposal[pa_proposal_id].next_reject_spread_threshold){\r\n\t\t\tproposal[id].status = 3;\r\n\t\t\trunning_proposal_id = 0;\r\n\t\t}\r\n\t\temit RejectSpreadAttempt(spread);\r\n\t}\r\n\r\n\r\n\tfunction reject_prop_time() external {\r\n\t\tuint id = running_proposal_id;\r\n\t\trequire (proposal[id].status == 1, \"Prop status is incorrect.\"); //Make sure it is not a reset proposal.\r\n\t\trequire (now - proposal[id].proposal_start \u003e proposal[id].prop_period, \"Still has time.\");\r\n\t\tproposal[id].status = 3;\r\n\t\trunning_proposal_id = 0;\r\n\r\n\t\temit TimeRejected();\r\n\t}\r\n\r\n\tfunction accept_reset() external {\r\n\t\tuint id = running_proposal_id;\r\n\t\tuint current_total_dai_bought = proposal[id].side[1].total_dai_traded;\r\n\t\tuint current_total_tokens_bought = proposal[id].side[0].total_tokens_traded;\r\n\t\tuint current_total_tokens_sold = proposal[id].side[1].total_tokens_traded;\r\n\t\trequire (current_total_dai_bought \u003e= proposal[pa_proposal_id].next_minimum_sell_volume, \"dai sold \u003c minimum\"); //Check that minimum sell volume has been reached.\r\n\t\trequire (proposal[id].status == 4, \"Not reset proposal.\"); //Check that this is a reset proposal rather than just any standard proposal.\r\n\t\tproposal[id].status = 2; //Proposal accepted\r\n\t\tpa_proposal_id = running_proposal_id;\r\n\t\trunning_proposal_id = 0;\r\n\r\n\t\t_supply = sub(add(_supply, current_total_tokens_bought), current_total_tokens_sold); //Update supply.\r\n\r\n\t\t//Net_dai_balance remains the same since equal dai is traded on both sides and proposal.amount = 0.\r\n\r\n\t\temit ResetAccepted(wdiv(proposal[id].side[0].total_dai_traded, current_total_tokens_bought), wdiv(current_total_dai_bought, current_total_tokens_sold));\r\n\t}\r\n\r\n\r\n\tfunction redeem_refund_common(uint _id, uint _tranche_size, uint _side, uint8 _status) internal returns (uint amount){\r\n\t\trequire (proposal[_id].status == _status, \"incorrect status\");\r\n\t\tamount = proposal[_id].side[_side].tranche[_tranche_size].balance[msg.sender];\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].balance[msg.sender] = 0; //Set balance to zero.\r\n\t}\r\n\r\n\tfunction redeem_common(uint _id, uint _tranche_size, uint _side) internal returns (uint amount) {\r\n\t\trequire (proposal[_id].side[0].tranche[_tranche_size].price != 0 \u0026\u0026 proposal[_id].side[1].tranche[_tranche_size].price != 0, \"Other side never finished.\"); //Make sure that both sides of the tranche finished.\r\n\t\tamount = wmul(redeem_refund_common(_id, _tranche_size, _side, 2), proposal[_id].side[_side].tranche[_tranche_size].price); //Set \u0027amount\u0027 to balance multiplied by price since user just gives the amount of tokens that they are sending in the prop function.\r\n\t}\r\n\r\n\tfunction buy_redeem(uint _id, uint _tranche_size) external {\r\n\r\n\t\tmint(redeem_common(_id, _tranche_size, 0)); //User paid with dai so they get back tokens.\r\n\t}\r\n\r\n\tfunction sell_redeem(uint _id, uint _tranche_size) external {\r\n\r\n\t\tERC20Interface.transfer(msg.sender, redeem_common(_id, _tranche_size, 1)); //User paid with tokens so they get back dai.\r\n\t}\r\n\r\n\tfunction buy_refund_reject(uint _id, uint _tranche_size) external {\r\n\r\n\t\tERC20Interface.transfer(msg.sender, redeem_refund_common(_id, _tranche_size, 0, 3)); //User paid with dai so they get back dai.\r\n\t}\r\n\r\n\tfunction sell_refund_reject(uint _id, uint _tranche_size) external {\r\n\r\n\t\tmint(redeem_refund_common(_id, _tranche_size, 1, 3)); //User paid with tokens so they get back tokens.\r\n\t}\r\n\r\n\tfunction buy_refund_accept(uint _id, uint _tranche_size) external {\r\n\t\trequire (proposal[_id].side[0].tranche[_tranche_size].price == 0 || proposal[_id].side[1].tranche[_tranche_size].price == 0, \"Try redeem\"); //One of tranches is unfinished.\r\n\r\n\t\tERC20Interface.transfer(msg.sender, redeem_refund_common(_id, _tranche_size, 0, 2)); //User paid with dai so they get back dai.\r\n\t}\r\n\r\n\tfunction sell_refund_accept(uint _id, uint _tranche_size) external {\r\n\t\trequire (proposal[_id].side[0].tranche[_tranche_size].price == 0 || proposal[_id].side[1].tranche[_tranche_size].price == 0, \"Try redeem\"); //One of tranches is unfinished.\r\n\r\n\t\tmint(redeem_refund_common(_id, _tranche_size, 1, 2));//User paid with tokens so they get back tokens.\r\n\t}\r\n\r\n\t//Functions for redeeming final trades:\r\n\r\n\tfunction final_redeem_refund_common(uint _id, uint _tranche_size, uint _side, uint8 _status) internal returns (uint amount){\r\n\t\trequire (proposal[_id].status == _status, \"Incorrect status\");\r\n\t\trequire (proposal[_id].side[_side].tranche[_tranche_size].final_trade_address == msg.sender, \"Wasn\u0027t you.\");\r\n\t\tamount = proposal[_id].side[_side].tranche[_tranche_size].final_trade_amount;\r\n\t\tproposal[_id].side[_side].tranche[_tranche_size].final_trade_amount = 0; //Set balance to zero.\r\n\t}\r\n\r\n\tfunction final_redeem_common(uint _id, uint _tranche_size, uint _side) internal returns (uint amount) {\r\n\t\trequire (proposal[_id].side[0].tranche[_tranche_size].price != 0 \u0026\u0026 proposal[_id].side[1].tranche[_tranche_size].price != 0, \"Try refund.\"); //Make sure that both sides of the tranche finished.\r\n\t\tamount = wmul(final_redeem_refund_common(_id, _tranche_size, _side, 2), proposal[_id].side[_side].tranche[_tranche_size].final_trade_price); //Set \u0027amount\u0027 to balance multiplied by price since user just gives the amount of tokens that they are sending in the prop function.\r\n\t}\r\n\r\n\r\n\tfunction final_buy_redeem(uint _id, uint _tranche_size) external {\r\n\r\n\t\tmint(final_redeem_common(_id, _tranche_size, 0)); //User paid with dai so they get back tokens.\r\n\t}\r\n\r\n\tfunction final_sell_redeem(uint _id, uint _tranche_size) external {\r\n\r\n\t\tERC20Interface.transfer(msg.sender, final_redeem_common(_id, _tranche_size, 1)); //User paid with tokens so they get back dai.\r\n\t}\r\n\r\n\tfunction final_buy_refund_reject(uint _id, uint _tranche_size) external {\r\n\r\n\t\tERC20Interface.transfer(msg.sender, final_redeem_refund_common(_id, _tranche_size, 0, 3)); //User paid with dai so they get back dai.\r\n\t}\r\n\r\n\tfunction final_sell_refund_reject(uint _id, uint _tranche_size) external {\r\n\r\n\t\tmint(final_redeem_refund_common(_id, _tranche_size, 1, 3)); //User paid with tokens so they get back tokens.\r\n\t}\r\n\r\n\tconstructor(uint _init_price, ERC20 _ERC20Interface) public { //(WAD) _init_price is defined as dai_amount/token_amount. _supply is defined in the TokenBase constructor.\r\n\t\tERC20Interface = _ERC20Interface; //fakeDai contract. Use checksum version of address.\r\n\r\n\t\t//Genesis proposal which will be used by first proposal. \r\n\t\tproposal[0].status = 2;\r\n\t\tproposal[0].beneficiary = address(this); //Because the submission of first proposal would break the erc20 transfer function if address(0) is used, therefore, we use this address. \r\n\t\tproposal[0].amount = 0; //For first proposal submission, 0/100 will be returned to contract address.\r\n\t\tproposal[0].prop_period = 1;\r\n\t\tproposal[0].next_min_prop_period = 1;\r\n\t\tproposal[0].next_init_tranche_size = wmul(_supply, _init_price)/100;\r\n\t\tproposal[0].next_init_price_data = [wdiv(WAD, wmul(40*WAD, _init_price)), wdiv(_init_price, 2*WAD) , 1003858241594480000, 10**17]; //Price here is defined as [amount received by user after proposal]/[amount given by user before]. \r\n\t\t//Price should double every 30 mins. Buy price starts above sell price at max potential price - vice versa for sell price. p = wmul(_p1, rpow(_e, mul(_f, sub(_now, _start))/ WAD)). e = 2**(1/180). Value of f defines 10 seconds as 1 int.\r\n\t\tproposal[0].next_reject_spread_threshold = 7 * WAD;\r\n\t\tproposal[0].next_minimum_sell_volume = wmul(_supply, _init_price)/100; //(10 ** -6) dai minimum sell volume.\r\n\t\tproposal[0].reset_time_period = 10;\r\n\t\tproposal[0].proposal_start = uint40(now);\r\n\r\n\t\t//Genesis trade values:\r\n\r\n\t\tproposal[0].side[0].total_dai_traded = wmul(_supply, _init_price); //0.001 dai initial market cap. (10 ** -6) dai initial price. \r\n\t\tproposal[0].side[1].total_dai_traded = wmul(_supply, _init_price);\r\n\t\tproposal[0].side[0].total_tokens_traded = _supply;\r\n\t\tproposal[0].side[1].total_tokens_traded = _supply;\r\n\t} //price = total_dai_traded/_supply\r\n}\r\n"},"erc20.sol":{"content":"/// erc20.sol -- API for the ERC20 token standard\r\n\r\n// See \u003chttps://github.com/ethereum/EIPs/issues/20\u003e.\r\n\r\n// This file likely does not meet the threshold of originality\r\n// required for copyright to apply.  As a result, this is free and\r\n// unencumbered software belonging to the public domain.\r\n\r\npragma solidity \u003e0.4.20;\r\n\r\ncontract ERC20Events {\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n}\r\n\r\ncontract ERC20 is ERC20Events {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address guy) external view returns (uint);\r\n    function allowance(address src, address guy) external view returns (uint);\r\n\r\n    function approve(address guy, uint wad) external returns (bool);\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n    function transferFrom(\r\n        address src, address dst, uint wad\r\n    ) public returns (bool);\r\n}"},"gov_interface_v2.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\ncontract onchain_gov_events{\r\n    event NewSubmission (uint40 indexed id, address beneficiary, uint amount,  uint next_init_tranche_size, uint[4] next_init_price_data, uint next_reject_spread_threshold, uint next_minimum_sell_volume, uint40 prop_period, uint40 next_min_prop_period, uint40 reset_time_period);\r\n    event InitProposal (uint40 id, uint init_buy_tranche, uint init_sell_tranche);\r\n    event Reset(uint id);\r\n    \r\n\tevent NewTrancheTotal (uint side, uint current_tranche_t); //Measured in terms of given token.\r\n\tevent TrancheClose (uint side, uint current_tranche_size, uint this_tranche_tokens_total); //Indicates tranche that closed and whether both or just one side have now closed.\r\n\tevent AcceptAttempt (uint accept_price, uint average_buy_dai_price, uint average_sell_dai_price); // \r\n\tevent RejectSpreadAttempt(uint spread);\r\n\tevent TimeRejected();\r\n\r\n\tevent ResetAccepted(uint average_buy_dai_price, uint average_sell_dai_price);\r\n\r\n\r\n}\r\n\r\ninterface IOnchain_gov{\r\n\r\n\tfunction proposal_token_balanceOf(uint40 _id, uint _side, uint _tranche, address _account) external view returns (uint);\r\n\r\n\tfunction proposal_token_allowance(uint40 _id, uint _side, uint _tranche, address _from, address _guy) external view returns (uint);\r\n\r\n\tfunction proposal_token_transfer(uint40 _id, uint _side, uint _tranche, address _to, uint _amount) external returns (bool);\r\n\r\n\tfunction proposal_transfer_from(uint40 _id, uint _side, uint _tranche,address _from, address _to, uint _amount) external returns (bool);\r\n\r\n    function proposal_token_approve(uint40 _id, uint _side, uint _tranche, address _guy, uint _amount) external returns (bool);\r\n\r\n\r\n    function calculate_price(uint _side, uint _now) external view returns (uint p);\r\n\r\n\tfunction submit_proposal(uint _amount, uint _next_init_tranche_size, uint[4] calldata _next_init_price_data, uint _next_reject_spread_threshold, uint _next_minimum_sell_volume, uint40 _prop_period, uint40 _next_min_prop_period, uint40 _reset_time_period) external;\r\n\r\n\tfunction init_proposal(uint40 _id) external;\r\n\r\n\tfunction reset() external;\r\n\r\n\tfunction buy(uint _id, uint _input_dai_amount, uint _tranche_size) external;\r\n\r\n\tfunction sell(uint _id, uint _input_token_amount, uint _tranche_size) external;\r\n\r\n\tfunction close_tranche_buy(uint _id, uint _input_dai_amount, uint _tranche_size) external;\r\n\r\n\tfunction close_tranche_sell(uint _id, uint _input_token_amount, uint _tranche_size) external;  \r\n\r\n\tfunction accept_prop() external;\r\n\r\n\tfunction reject_prop_spread() external;\r\n\r\n\tfunction reject_prop_time() external;\r\n\r\n\tfunction accept_reset() external;\r\n\r\n\tfunction buy_redeem(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction sell_redeem(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction buy_refund_reject(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction sell_refund_reject(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction buy_refund_accept(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction sell_refund_accept(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction final_buy_redeem(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction final_sell_redeem(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction final_buy_refund_reject(uint _id, uint _tranche_size) external;\r\n\r\n\tfunction final_sell_refund_reject(uint _id, uint _tranche_size) external;\r\n}\r\n\r\n//27 functions"},"math.sol":{"content":"/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n\r\npragma solidity \u003e0.4.13;\r\n\r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) \u003e= x, \"ds-math-add-overflow\");\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) \u003c= x, \"ds-math-sub-underflow\");\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It\u0027s O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n\r\n    function wpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : WAD;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = wmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = wmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}"},"proposal_tokens_v3.sol":{"content":"// Copyright (C) 2020 Benjamin M J D Wang\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\r\n\r\npragma solidity ^0.5.0;\r\nimport \"base.sol\";\r\n\r\ncontract proposal_tokens is TokenBase(0) {\r\n\t//Proposal mappings\r\n\tmapping (uint =\u003e Proposal) internal proposal; //proposal id is taken from nonce. \r\n\r\n\tstruct Proposal { //Records all data that is submitted during proposal submission.\r\n\t\taddress beneficiary;\r\n\t\tuint amount; //(WAD)\r\n\t\tuint next_init_tranche_size; //(WAD)\r\n\t\tuint[4] next_init_price_data; //Array of data for next proposal [initial buy price (WAD), initial sell price (WAD), base (WAD), exponent factor (int)] \r\n\t\tuint next_reject_spread_threshold; //(WAD)\r\n\t\tuint next_minimum_sell_volume; //(WAD)\r\n\r\n\t\tuint8 status; //0 = not submitted or not ongoing, 1 = ongoing, 2 = accepted, 3 = rejected, 4 = ongoing reset proposal.\r\n\t\tuint40 prop_period; //(int) How long users have to prop before prop rejected.\r\n\t\tuint40 next_min_prop_period; //(int) Minimum prop period for the next proposal.\r\n\t\tuint40 reset_time_period; //(int) Time period necessary for proposal to be reset. \r\n\t\tuint40 proposal_start; //(int) This is to provide a time limit for the length of proposals.\r\n\t\tmapping (uint =\u003e Side) side; //Each side of proposal\r\n\t}\r\n\tstruct Side { //Current tranche data for this interval.\r\n\t\tuint current_tranche_total; //This is in units of given tokens rather than only dai tokens: dai for buying, proposal token for selling. For selling, total equivalent dai tokens is calculated within the function.\r\n\t\tuint total_dai_traded; //Used for calculating acceptance/rejection thresholds.\r\n\t\tuint total_tokens_traded; //Used for calculating acceptance/rejection thresholds.\r\n\t\tuint current_tranche_size; //(WAD) This is maximum amount or equivalent maximum amount of dai tokens the tranche can be.\r\n\t\tmapping (uint =\u003e Tranche) tranche; //Data for each tranche that must be recorded. Size of tranche will be the uint tranche id.\r\n\t}\r\n\r\n\tstruct Tranche {\r\n\t\tuint price; //(WAD) Final tranche price for each tranche. Price is defined as if the user is selling their respective token types to the proposal so price increases over time to incentivise selling. Buy price is price of dai in proposal tokens where sell price is the price in dai.\r\n\t\tuint final_trade_price;\r\n\t\tuint recent_trade_time;\r\n\t\tuint final_trade_amount;\r\n\t\taddress final_trade_address;\r\n\t\tmapping (address =\u003e uint) balance; //(WAD)\r\n\t\tmapping (address =\u003e mapping (address =\u003e uint256)) approvals;\r\n\t}\r\n \r\n\tuint40 internal nonce; // Nonce for submitted proposals that have a higher param regardless of whether they are chosen or not. Will also be used for chosen proposals.\r\n\tuint40 public top_proposal_id; //Id of current top proposal.\r\n\tuint40 public running_proposal_id; //id of the proposal that has been initialised.\r\n\tuint40 public pa_proposal_id; //Previously accepted proposal id.\r\n\tuint40 current_tranche_start; //(int) \r\n\tuint public top_param; //(WAD)\r\n\tuint internal lct_tokens_traded; //Records the total tokens traded for the tranche on the first side to close. This means that this calculation won\u0027t need to be repeated when both sides close.\r\n\tuint internal net_dai_balance; //The contract\u0027s dai balance as if all redemptions and refunds are collected in full, re-calculated at the end of every accepted proposal.\r\n\r\n\r\n\tfunction proposal_token_balanceOf(uint40 _id, uint _side, uint _tranche, address _account) external view returns (uint) {\r\n        return proposal[_id].side[_side].tranche[_tranche].balance[_account];\r\n    }\r\n\r\n\tfunction proposal_token_allowance(uint40 _id, uint _side, uint _tranche, address _from, address _guy) external view returns (uint) {\r\n\t\treturn proposal[_id].side[_side].tranche[_tranche].approvals[_from][_guy];\r\n\t}\r\n\r\n\tfunction proposal_token_transfer(uint40 _id, uint _side, uint _tranche, address _to, uint _amount) external returns (bool) {\r\n\t\treturn proposal_transfer_from(_id, _side, _tranche, msg.sender, _to, _amount);\r\n\t}\r\n\r\n\tevent ProposalTokenTransfer(address from, address to, uint amount);\r\n\r\n\tfunction proposal_transfer_from(uint40 _id, uint _side, uint _tranche,address _from, address _to, uint _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        if (_from != msg.sender) {\r\n            proposal[_id].side[_side].tranche[_tranche].approvals[_from][msg.sender] = sub(proposal[_id].side[_side].tranche[_tranche].approvals[_from][msg.sender], _amount); //Revert if funds insufficient. \r\n        }\r\n        proposal[_id].side[_side].tranche[_tranche].balance[_from] = sub(proposal[_id].side[_side].tranche[_tranche].balance[_from], _amount);\r\n        proposal[_id].side[_side].tranche[_tranche].balance[_to] = add(proposal[_id].side[_side].tranche[_tranche].balance[_to], _amount);\r\n\r\n        emit ProposalTokenTransfer(_from, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\tevent ProposalTokenApproval(address account, address guy, uint amount);\r\n\r\n    function proposal_token_approve(uint40 _id, uint _side, uint _tranche, address _guy, uint _amount) external returns (bool) {\r\n        proposal[_id].side[_side].tranche[_tranche].approvals[msg.sender][_guy] = _amount;\r\n\r\n        emit ProposalTokenApproval(msg.sender, _guy, _amount);\r\n\r\n        return true;\r\n    }\r\n}"}}