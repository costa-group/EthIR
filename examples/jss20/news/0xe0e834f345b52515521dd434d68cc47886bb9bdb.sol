{"education.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Ownable.sol\";\n\ncontract education is Ownable {\n    struct CertificateDetails {\n        bytes  student_copy;\n        bytes  issuer_copy;\n        uint256 courseID;\n        string  serialNumber;\n        uint256 expiry;\n        bool   invalidated;\n    }\n\n    mapping(address =\u003e bool) private issuers;\n\n    // Array with all certificate ids, used for enumeration\n    uint256[] private _allCertificates;\n\n    // Mapping from certificate id to position in the allCertificates array\n    mapping(uint256 =\u003e uint256) private _allCertificatesIndex;\n\n    // The certificates\n    mapping(uint256 =\u003e CertificateDetails) private _certificates;\n    mapping(bytes32 =\u003e uint) public _certificatesBySerialHash;\n    mapping (uint256 =\u003e address) private _certificateOwners;\n    // Mapping from owner to list of owned certificate IDs\n    mapping(address =\u003e uint256[]) private _ownedCertificates;\n    mapping (uint256 =\u003e address) private _certificateIssuers;\n    mapping (uint256 =\u003e uint256) private _ownedCertificatesIndex;\n    mapping (uint256 =\u003e uint256[]) private _certificatesForCourse;\n\n    uint256 private _latestCourseID;\n\n    event Issue(address issuer, address recipient, uint256 certificateID, uint256 courseID);\n    event CertificateInvalidated(uint256 certificateID);\n    event NewCourseID(address creator,uint256 courseID);\n\n    modifier onlyIssuer {\n        require(issuers[msg.sender],\"only certificate issuers can create certificates\");\n        _;\n    }\n\n\n    function addIssuer(address issuer) external onlyOwner {\n        issuers[issuer] = true;\n    }\n\n    function removeIssuer(address issuer) external onlyOwner {\n        issuers[issuer] = false;\n    }\n\n   /**\n     * @dev Gets the certificate ID at a given index of the certificates list of the requested owner.\n     * @param owner address owning the certificates list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested certificates list\n     * @return uint256 certificate ID at the given index of the certificates list owned by the requested address\n     */\n    function certificateOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index \u003c numberOfCertificatesOwnedBy(owner), \"Certificate owner index out of bounds\");\n        return _ownedCertificates[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of certificates stored by the contract.\n     * @return uint256 representing the total amount of certificates\n     */\n    function numberOfCertificates() public view  returns (uint256) {\n        return _allCertificates.length;\n    }\n\n    /**\n     * @dev Gets the certificate ID at a given index of all the certificates in this contract\n     * Reverts if the index is greater or equal to the total number of certificates.\n     * @param index uint256 representing the index to be accessed of the certificates list\n     * @return uint256 certificate ID at the given index of the certificates list\n     */\n    function certificateByIndex(uint256 index) public view  returns (uint256) {\n        require(index \u003c numberOfCertificates(), \"Certificate index out of bounds\");\n        return _allCertificates[index];\n    }\n\n    /**\n     * @dev Gets the list of certificate IDs of the requested owner.\n     * @param owner address owning the certificates\n     * @return uint256[] List of certificate IDs owned by the requested address\n     */\n    function _certificatesOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedCertificates[owner];\n    }\n\n    /**\n     * @dev Private function to add a certificate to this extension\u0027s ownership-tracking data structures.\n     * @param to address representing the new owner of the given certificate ID\n     * @param certificateID uint256 ID of the certificate to be added to the certificates list of the given address\n     */\n    function _addCertificateToOwnerEnumeration(address to, uint256 certificateID) private {\n        _ownedCertificatesIndex[certificateID] = _ownedCertificates[to].length;\n        _ownedCertificates[to].push(certificateID);\n    }\n\n    /**\n     * @dev Private function to add a certificate to this extension\u0027s certificate tracking data structures.\n     * @param certificateID uint256 ID of the certificate to be added to the certificates list\n     */\n    function _addCertificateToAllCertificatesEnumeration(uint256 certificateID) private {\n        _allCertificatesIndex[certificateID] = _allCertificates.length;\n        _allCertificates.push(certificateID);\n    }\n\n    function getCertificate(uint256 certificateID) internal view  returns (CertificateDetails memory) {\n        require(_exists(certificateID),\"certificate does not exist\");\n        require(!_certificates[certificateID].invalidated,\"certificate not valid\");\n        return _certificates[certificateID];\n    }\n\n    function getStudentCopy(uint256 certificateID) external view returns (bytes memory studentVersion) {\n        return getCertificate(certificateID).student_copy;\n    }\n\n    function getIssuerCopy(uint256 certificateID) external view returns (bytes memory issuerVersion) {\n        return getCertificate(certificateID).issuer_copy;\n    }\n\n    function getSerialNumber(uint256 certificateID) external view returns (string memory serialNumber) {\n        return getCertificate(certificateID).serialNumber;\n    }\n\n    function getCourseID(uint256 certificateID) external view returns (uint256 courseID) {\n        return getCertificate(certificateID).courseID;\n    }\n\n    function getCertificateExpiry(uint256 certificateID) external view returns (bool valid, uint256 expiryDate) {\n        require(_exists(certificateID),\"certificate does not exist\");\n        valid = !_certificates[certificateID].invalidated;\n        expiryDate = _certificates[certificateID].expiry;\n    }\n\n\n    function ownerOf(uint256 certificateID) public view  returns (address) {\n        address owner = _certificateOwners[certificateID];\n        require(owner != address(0), \"Owner query for nonexistent certificate\");\n\n        return owner;\n    }\n\n    function issuerOf(uint256 certificateID) public view  returns (address) {\n        address issuer = _certificateIssuers[certificateID];\n        require(issuer != address(0), \"Issuer query for nonexistent certificate\");\n        return issuer;\n    }\n\n    function numberOfCertificatesOwnedBy(address owner) public view  returns (uint256) {\n        require(owner != address(0), \"Balance query for address zero\");\n        return _ownedCertificates[owner].length;\n    }\n\n    function numberOfCourses() public view returns (uint256) {\n        return _latestCourseID;\n    }\n\n    function numberOfAttendees(uint256 courseID) public view returns (uint256) {\n        return _certificatesForCourse[courseID].length;\n    }\n\n    function certificateForCourse(uint256 courseID, uint256 index) public view returns (uint256) {\n        require(index \u003c numberOfAttendees(courseID),\"invalid certificate index\");\n        return _certificatesForCourse[courseID][index];\n    }\n\n    /**\n     * @dev Returns whether the specified certificate exists.\n     * @param certificateID uint256 ID of the certificate to query the existence of\n     * @return bool whether the certificate exists\n     */\n    function _exists(uint256 certificateID) internal view returns (bool) {\n        address owner = _certificateOwners[certificateID];\n        return owner != address(0);\n    }\n\n\n    function _mint(address to, uint256 certificateID, uint256 courseID) internal {\n        require(to != address(0), \"Certificates cannot be issued to address zero\");\n        require(!_exists(certificateID), \"This certificate is already issued\");\n\n        _certificateOwners[certificateID] = to;\n        _certificateIssuers[certificateID] = msg.sender;\n\n        emit Issue(msg.sender, to, certificateID, courseID);\n    }\n\n\n    function _setCertificateData(\n        uint256 certificateID,\n        string memory serialNumber,\n        bytes memory studentCopy,\n        bytes memory issuerCopy,\n        uint256 courseID,\n        uint256 expiryDate)\n        internal {\n        bytes32 hash = keccak256(bytes(serialNumber));\n        require(_exists(certificateID),\"Certificate ID does not exist\");\n        require(_certificatesBySerialHash[hash] == 0, \"This serial number has already been allocated\");\n        _certificates[certificateID].issuer_copy = issuerCopy;\n        _certificates[certificateID].student_copy = studentCopy;\n        _certificates[certificateID].serialNumber = serialNumber;\n        _certificates[certificateID].expiry = expiryDate;\n        _certificates[certificateID].courseID = courseID;\n        _certificatesBySerialHash[hash] = certificateID;\n        _certificatesForCourse[courseID].push(certificateID);\n    }\n\n    function createCertificate(\n        address recipient,\n        string calldata serialNumber,\n        bytes calldata studentCopy,\n        bytes calldata issuerCopy,\n        uint256 courseID,\n        uint256 expiryDate) external onlyIssuer {\n        uint256 newCert = numberOfCertificates();\n        _addCertificateToAllCertificatesEnumeration(newCert);\n        _addCertificateToOwnerEnumeration(recipient,newCert);\n        _mint(recipient,newCert,courseID);\n        _setCertificateData(newCert,serialNumber,studentCopy,issuerCopy,courseID,expiryDate);\n    }\n\n    function invalidateCertificate(uint256 certificateID) public onlyIssuer {\n        require(_certificateIssuers[certificateID]==msg.sender,\"You did not issue this certificate\");\n        _certificates[certificateID].invalidated = true;\n        emit CertificateInvalidated(certificateID);\n    }\n\n    function Version() external pure returns (uint256) {\n        return 6;\n    }\n\n    function newCourseID() public onlyIssuer {\n        _latestCourseID = _latestCourseID+1;\n        emit NewCourseID(msg.sender,_latestCourseID);\n    }\n\n    \n\n}"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable  {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal  {\n        require(newOwner != address(0), \"Ownable: new owner\u0027s address not valid\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"}}