{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "byzantium",
    "libraries": {},
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "/Users/simon/ws/in3/in3-contracts/contracts/BlockhashRegistry.sol": {
      "keccak256": "0x159b52ca451f045503ca6c10ecbe0b76a0e78212a85e91c5e3c96ddaac315ae7",
      "content": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\n\n/// @title Registry for blockhashes\ncontract BlockhashRegistry {\n\n    /// a new blockhash and its number has been added to the contract\n    event LogBlockhashAdded(uint indexed blockNr, bytes32 indexed bhash);\n\n    /// maps the blocknumber to its blockhash\n    mapping(uint => bytes32) public blockhashMapping;\n\n    /// constructor, calls snapshot-function when contract get deployed as entry point\n    /// @dev cannot be deployed in a genesis block\n    constructor() public {\n        snapshot();\n    }\n\n    /// @notice searches for an already existing snapshot\n    /// @param _startNumber the blocknumber to start searching\n    /// @param _numBlocks the number of blocks to search for\n    /// @return the closes snapshot of found within the given range, 0 else\n    function searchForAvailableBlock(uint _startNumber, uint _numBlocks) external view returns (uint) {\n        uint target = _startNumber + _numBlocks;\n\n        require(target <= block.number || target < _startNumber, \"invalid search\");\n\n        for (uint i = _startNumber; i <= target; i++) {\n            if (blockhashMapping[i] != 0x0) {\n                return i;\n            }\n        }\n    }\n\n    /// @notice starts with a given blocknumber and its header and tries to recreate a (reverse) chain of blocks\n    /// @notice only usable when the given blocknumber is already in the smart contract\n    /// @notice it will be checked whether the provided chain is correct by using the reCalculateBlockheaders function\n    /// @notice if successfull the last blockhash of the header will be added to the smart contract\n    /// @param _blockNumber the block number to start recreation from\n    /// @param _blockheaders array with serialized blockheaders in reverse order (youngest -> oldest) => (e.g. 100, 99, 98)\n    /// @dev reverts when there is not parent block already stored in the contract\n    /// @dev reverts when the chain of headers is incorrect\n    /// @dev function is public due to the usage of a dynamic bytes array (not yet supported for external functions)\n    function recreateBlockheaders(uint _blockNumber, bytes[] memory _blockheaders) public {\n        /// we should never fail this assert, as this would mean that we were able to recreate a invalid blockchain\n        require(_blockNumber > _blockheaders.length, \"too many blockheaders provided\");\n        require(_blockNumber < block.number, \"cannot recreate a not yet existing block\");\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n\n        uint bnr = _blockNumber - _blockheaders.length;\n        require(blockhashMapping[bnr] == 0x0, \"block already stored\");\n\n        bytes32 currentBlockhash = blockhashMapping[_blockNumber];\n        require(currentBlockhash != 0x0, \"parentBlock is not available\");\n\n        /// if the blocknumber we want to store is within the last 256 blocks, we use the evm hash\n        if (bnr > block.number-256) {\n            saveBlockNumber(bnr);\n            return;\n        }\n\n        bytes32 calculatedHash = reCalculateBlockheaders(_blockheaders, currentBlockhash, _blockNumber);\n        require(calculatedHash != 0x0, \"invalid headers\");\n\n        blockhashMapping[bnr] = calculatedHash;\n        emit LogBlockhashAdded(bnr, calculatedHash);\n    }\n\n    /// @notice stores a certain blockhash to the state\n    /// @param _blockNumber the blocknumber to be stored\n    /// @dev reverts if the block can't be found inside the evm\n    function saveBlockNumber(uint _blockNumber) public {\n\n        require(blockhashMapping[_blockNumber] == 0x0, \"block already stored\");\n\n        bytes32 bHash = blockhash(_blockNumber);\n\n        require(bHash != 0x0, \"block not available\");\n\n        blockhashMapping[_blockNumber] = bHash;\n        emit LogBlockhashAdded(_blockNumber, bHash);\n    }\n\n    /// @notice stores the currentBlock-1 in the smart contract\n    function snapshot() public {\n        /// blockhash cannot return the current block, so we use the previous block\n        saveBlockNumber(block.number-1);\n    }\n\n    /// @notice returns the value from rlp encoded data.\n    ///         This function is limited to only value up to 32 bytes length!\n    /// @param _data rlp encoded data\n    /// @param _offset the offset\n    /// @return the value\n    function getRlpUint(bytes memory _data, uint _offset) public pure returns (uint value) {\n        /// get the byte at offset to figure out the length of the value\n        uint8 c = uint8(_data[_offset]);\n\n        /// we will not accept values above 0xa0, since this would mean we either have a list\n        /// or we have a value with a length greater 32 bytes\n        /// for the use cases (getting the blockNumber or difficulty) we can accept these limits.\n        require(c < 0xa1, \"lists or long fields are not supported\");\n        if (c < 0x80)  // single byte-item\n            return uint(c); // value = byte\n\n        // length of the value\n        uint len = c - 0x80;\n        // we skip the first 32 bytes since they contain the legth and add 1 because this byte contains the length of the value.\n        uint dataOffset = _offset + 33;\n\n        /// check the range\n        require(_offset + len <= _data.length, \"invalid offset\");\n\n        /// we are using assembly because we need to get the value of the next `len` bytes\n        /// This is done by copying the bytes in the \"scratch space\" so we can take the first 32 bytes as value afterwards.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            mstore(0x0, 0) // clean memory in the \"scratch space\"\n            mstore(\n                sub (0x20, len), // we move the position so the first bytes from rlp are the last bytes within the 32 bytes\n                mload(\n                    add ( _data, dataOffset ) // load the data from rlp-data\n                )\n            )\n            value:=mload(0x0)\n        }\n        return value;\n    }\n\n    /// @notice returns the blockhash and the parent blockhash from the provided blockheader\n    /// @param _blockheader a serialized (rlp-encoded) blockheader\n    /// @return the parent blockhash and the keccak256 of the provided blockheader (= the corresponding blockhash)\n    function getParentAndBlockhash(bytes memory _blockheader) public pure returns (bytes32 parentHash, bytes32 bhash, uint blockNumber) {\n\n        /// we need the 1st byte of the blockheader to calculate the position of the parentHash\n        uint8 first = uint8(_blockheader[0]);\n\n        /// calculates the offset\n        /// by using the 1st byte (usually f9) and substracting f7 to get the start point of the parentHash information\n        require(first > 0xf7, \"invalid offset\");\n\n        /// we also have to add \"2\" = 1 byte to it to skip the length-information\n        uint offset = first - 0xf7 + 2;\n        require(offset+32 < _blockheader.length, \"invalid length\");\n\n        /// we are using assembly because it's the most efficent way to access the parent blockhash within the rlp-encoded blockheader\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            // we load the provided blockheader\n            // then we add 0x20 (32 bytes) to get to the start of the blockheader\n            // then we add the offset we calculated\n            // and load it to the parentHash variable\n            parentHash :=mload(\n                add(\n                    add(\n                        _blockheader, 0x20\n                    ), offset)\n            )\n        }\n\n        // verify parentHash\n        require(parentHash != 0x0, \"invalid parentHash\");\n        bhash = keccak256(_blockheader);\n\n        // get the blockNumber\n        // we set the offset to the difficulty field which is fixed since all fields between them have a fixed length.\n        offset += 444;\n\n        // we get the first byte for the difficulty field ( which is a field with a dynamic length)\n        // and calculate the length, because the next field is the blockNumber\n        uint8 c = uint8(_blockheader[offset]);\n        require(c < 0xa1, \"lists or long fields are not supported for difficulty\");\n        offset += c < 0x80 ? 1 : (c - 0x80 + 1);\n\n        // we fetch the blockNumber from the calculated offset\n        blockNumber = getRlpUint(_blockheader, offset);\n    }\n\n    /// @notice starts with a given blockhash and its header and tries to recreate a (reverse) chain of blocks\n    /// @notice the array of the blockheaders have to be in reverse order (e.g. [100,99,98,97])\n    /// @param _blockheaders array with serialized blockheaders in reverse order, i.e. from youngest to oldest\n    /// @param _bHash blockhash of the 1st element of the _blockheaders-array\n    /// @param _blockNumber blocknumber of the 1st element of the _blockheaders-array. This is only needed to verify the blockheader\n    /// @return 0x0 if the functions detects a wrong chaining of blocks, blockhash of the last element of the array otherwhise\n    function reCalculateBlockheaders(bytes[] memory _blockheaders, bytes32 _bHash, uint _blockNumber) public view returns (bytes32 bhash) {\n\n        require(_blockheaders.length > 0, \"no blockheaders provided\");\n        require(_bHash != 0x0, \"invalid blockhash provided\");\n        bytes32 currentBlockhash = _bHash;\n        bytes32 calcParent = 0x0;\n        bytes32 calcBlockhash = 0x0;\n        uint calcBlockNumber = 0;\n        uint currentBlockNumber = _blockNumber;\n\n        /// save to use for up to 200 blocks, exponential increase of gas-usage afterwards\n        for (uint i = 0; i < _blockheaders.length; i++) {\n            /// we alway need to verify the blockHash and parentHash\n            /// but in addition we also verify the blockNumber.\n            /// This is just safety-check in case of detected hash collision which makes it almost impossible\n            /// to add an invalid header which might create the correct hash.\n            (calcParent, calcBlockhash, calcBlockNumber) = getParentAndBlockhash(_blockheaders[i]);\n            if (calcBlockhash != currentBlockhash || calcParent == 0x0 || calcBlockNumber != currentBlockNumber) {\n                return 0x0;\n            }\n\n            uint currentBlock = block.number > 256 ? block.number : 256;\n\n            if (currentBlock - 256 < calcBlockNumber) {\n                if (calcBlockhash != blockhash(calcBlockNumber)) {\n                    return 0x0;\n                }\n            }\n            currentBlockhash = calcParent;\n            currentBlockNumber--;\n        }\n\n        return currentBlockhash;\n    }\n}\n"
    },
    "/Users/simon/ws/in3/in3-contracts/contracts/IERC20.sol": {
      "keccak256": "0xb94cda223b95eaa18773de593f3c1db30f26b579729b995a061ad87ce349f3f2",
      "content": "pragma solidity 0.5.10;\n\n// file taken from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value); // solhint-disable-line\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "/Users/simon/ws/in3/in3-contracts/contracts/NodeRegistryData.sol": {
      "keccak256": "0x9ba0477cc04cd01b7ab34713512cdecf50409b5eaa3f04181a37493ef03cc097",
      "content": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryData {\n\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint props, address signer, uint deposit);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a user received its deposit back\n    event LogDepositReturned(address nodeOwner, uint amount);\n\n    struct In3Node {\n        string url;                         /// the url of the node\n\n        uint deposit;                       /// stored deposit\n\n        uint64 registerTime;                /// timestamp when the node was registered\n        uint192 props;                      /// a list of properties-flags representing the capabilities of the node\n\n        uint64 weight;                      ///  the flag for (future) incentivisation\n        address signer;                     /// the signer for requests\n\n        bytes32 proofHash;                  /// keccak(deposit,timeout,registerTime,props,signer,url)\n    }\n\n    /// information of a in3-node owner\n    struct SignerInformation {\n        uint64 lockedTime;                  /// timestamp until the deposit of an in3-node can not be withdrawn after the node was removed\n        address owner;                      /// the owner of the node\n\n        uint stage;                       /// state of the address\n\n        uint depositAmount;                 /// amount of deposit to be locked, used only after a node had been removed\n\n        uint index;                         /// current index-position of the node in the node-array\n    }\n\n    /// information of an url\n    struct UrlInformation {\n        bool used;                          /// flag whether the url is currently used\n        address signer;                     /// address of the owner of the url\n    }\n\n    /// node list of incubed nodes\n    In3Node[] public nodes;\n\n    /// id used for signing in3-requests and in order to prevent cross-chain convicts\n    /// in case a fork happens there is the possibility that a node can be convicted on the other fork,\n    /// because they would use the very same registryId. Nevertheless we cannot change the registryId.\n    /// So in case of a fork a node should chose one of the forks and unregister his nodes on the others.\n    /// In this case it is also recommend to not sign requests until the node get his deposits from the forked contracts\n    bytes32 public registryId;\n\n    /// timeout for all nodes until they can receive their deposit after unregistering\n    uint public timeout;\n\n    /// tokenContract to be used\n    IERC20 public supportedToken;\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n\n    /// Logic-contract that is allowed to call certain functions within the smart contract\n    address public ownerContract;\n\n    /// mapping for information of the owner\n    mapping (address => SignerInformation) public signerIndex;\n\n    /// mapping for the information of the url\n    /// can be used to access the SignerInformation-struct\n    mapping (bytes32 => UrlInformation) public urlIndex;\n\n    /// mapping for convicts: sender => convictHash => block number when the convict-tx had been mined)\n    mapping (address => mapping(bytes32 => uint)) public convictMapping;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyLogicContract {\n        require(ownerContract == msg.sender, \"not the owner\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @dev cannot be deployed in a genesis block\n    constructor() public {\n        // solium-disable-next-line security/no-block-members\n        registryId = keccak256(abi.encodePacked(address(this), blockhash(block.number-1)));\n        timeout = 40 days;\n        ownerContract = msg.sender;\n    }\n\n    /// @notice removes an in3-node from the nodeList\n    /// @param _signer the signer-address of the in3-node\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyLogicContract\n    {\n        SignerInformation memory si = signerIndex[_signer];\n        _removeNodeInternal(si.index);\n\n    }\n\n    /// @notice sets the logic-address / owner of the contract\n    /// @dev used to update the corresponding logic contract\n    /// @dev only callable by the current logic contract\n    /// @param _newLogic the new logic-contract / owner\n    /// @return true if successfull\n    function adminSetLogic(address _newLogic) external onlyLogicContract returns (bool) {\n        require(address(_newLogic) != address(0x0), \"no address provided\");\n        ownerContract = _newLogic;\n        return true;\n    }\n\n    /// @notice sets the deposit of the node\n    /// @dev only callable by the logic contract\n    /// @dev used to delete the deposit after being being convicted\n    /// @param _signer the signer for the node\n    /// @param _newDeposit the new deposit\n    /// @return true if successfull\n    function adminSetNodeDeposit(address _signer, uint _newDeposit) external onlyLogicContract returns (bool) {\n        SignerInformation memory si = signerIndex[_signer];\n        In3Node storage node = nodes[si.index];\n        require(node.signer == _signer, \"not the correct signer of the in3-node\");\n        node.deposit = _newDeposit;\n        return true;\n    }\n\n    /// @notice sets the stage of a certain signer\n    /// @dev only callable by the current logic contract\n    /// @param _signer the signer-account for the stage to be set\n    /// @param _stage the new stage\n    /// @return true if successfull\n    function adminSetStage(address _signer, uint _stage) external onlyLogicContract returns (bool) {\n        SignerInformation storage si = signerIndex[_signer];\n        si.stage = _stage;\n        return true;\n    }\n\n    /// @notice changes the supported token\n    /// @dev only callable by the current logic contract\n    /// @param _newToken the new token-contract\n    /// @return true if successfull\n    function adminSetSupportedToken(IERC20 _newToken) external onlyLogicContract returns (bool) {\n        require(address(_newToken) != address(0x0), \"0x0 is invalid\");\n        supportedToken = _newToken;\n        return true;\n    }\n\n    /// @notice sets a new timeout for all node until they can recive their deposit\n    /// @dev only callable by the current logic contract\n    /// @param _newTimeout the new timeout\n    /// @return true if successfull\n    function adminSetTimeout(uint _newTimeout) external onlyLogicContract returns (bool) {\n        timeout = _newTimeout;\n        return true;\n    }\n\n    /// @notice transfers tokens to an address\n    /// @dev used when returning deposit or rewarding successfull convicts\n    /// @dev only callable by the logic contract\n    /// @param _to the address that shall receive tokens\n    /// @param _amount the amount of tokens to be transfered\n    /// @return true when successfull\n    function adminTransferDeposit(address _to, uint _amount) external onlyLogicContract returns (bool) {\n        require(supportedToken.transfer(_to, _amount), \"ERC20 token transfer failed\");\n        return true;\n    }\n\n    /// @notice writes a value to te convictMapping to be used later for revealConvict in the logic contract\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @param _caller the address for that called convict in the logic-contract\n    function setConvict(bytes32 _hash, address _caller) external onlyLogicContract {\n        convictMapping[_caller][_hash] = block.number;\n    }\n\n    /// @notice registers a new node in the nodeList\n    /// @dev only callable by the logic contract\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the in3-node (in erc20 token)\n    /// @param _stage the stage of the in3-node\n    /// @return true if successfull\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        address _owner,\n        uint _deposit,\n        uint _stage\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // sets the information of the owner\n        SignerInformation storage si = signerIndex[_signer];\n\n        si.index = nodes.length;\n        si.owner = _owner;\n        si.stage = _stage;\n\n        // add new In3Node\n        In3Node memory m;\n        m.url = _url;\n        m.props = _props;\n        m.signer = _signer;\n        m.deposit = _deposit;\n        // solium-disable-next-line security/no-block-members\n        m.registerTime = uint64(block.timestamp); // solhint-disable-line not-rely-on-time\n        m.weight = _weight;\n\n        m.proofHash = _calcProofHashInternal(m);\n        nodes.push(m);\n\n        // sets the information of the url\n        UrlInformation memory ui;\n        ui.used = true;\n        ui.signer = _signer;\n        urlIndex[urlHash] = ui;\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n        return true;\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @return true if successfull\n    function transferOwnership(address _signer, address _newOwner)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation storage si = signerIndex[_signer];\n        emit LogOwnershipChanged(_signer, si.owner, _newOwner);\n\n        si.owner = _newOwner;\n        return true;\n    }\n\n    /// @notice removes a node from the registry\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer of the in3-node\n    /// @return true if successfull\n    function unregisteringNode(address _signer)\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n\n        SignerInformation storage si = signerIndex[_signer];\n        In3Node memory n = nodes[si.index];\n        _unregisterNodeInternal(si, n);\n        return true;\n    }\n\n    /// @notice updates a node by adding the msg.value to the deposit and setting the props or timeout\n    /// @dev reverts when trying to change the url to an already existing one\n    /// @dev only callable by the logic contract\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _deposit the deposit of the in3-node\n    /// @return true if successfull\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n        onlyLogicContract\n        returns (bool)\n    {\n        SignerInformation memory si = signerIndex[_signer];\n\n        In3Node storage node = nodes[si.index];\n\n        bytes32 newURL = keccak256(bytes(_url));\n        bytes32 oldURL = keccak256(bytes(node.url));\n\n        // the url got changed\n        if (newURL != oldURL) {\n\n            // make sure the new url is not already in use\n            require(!urlIndex[newURL].used, \"url is already in use\");\n\n            UrlInformation memory ui;\n            ui.used = true;\n            ui.signer = node.signer;\n            urlIndex[newURL] = ui;\n            node.url = _url;\n\n            // deleting the old entry\n            delete urlIndex[oldURL];\n        }\n\n        if (_deposit != node.deposit) {\n            node.deposit = _deposit;\n        }\n\n        if (_props != node.props) {\n            node.props = _props;\n        }\n\n        if (_weight != node.weight) {\n            node.weight = _weight;\n        }\n\n        node.proofHash = _calcProofHashInternal(node);\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            node.deposit\n        );\n\n        return true;\n    }\n\n    /// @notice returns the In3Node-struct of a certain index\n    /// @param _index the position of the NodeInfo in the node-array\n    /// @return the In3Node for the index provided\n    function getIn3NodeInformation(uint _index) external view returns (In3Node memory) {\n        return nodes[_index];\n    }\n\n    /// @notice returns the SignerInformation of a signer\n    /// @param _signer the signer for the information to get\n    /// @return the SignerInformation for the signer\n    function getSignerInformation(address _signer) external view returns (SignerInformation memory) {\n        return signerIndex[_signer];\n    }\n\n    /// @notice returns the In3Node-struct for a signer\n    /// @param _signer the signer for the information to get\n    /// @return the In3Node-struct for that signer\n    function getNodeInfromationBySigner(address _signer) external view returns (In3Node memory) {\n        return nodes[signerIndex[_signer].index];\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodes.length;\n    }\n\n    /// @notice sets the signerInformation for a signer\n    /// @dev only callable by the logic contract\n    /// @dev gets used for updating the information after returning the deposit\n    /// @dev public-visibility due to passing a struct to the function\n    /// @param _signer the address for the information to be set\n    /// @param _si the new signerInformation\n    /// @return true when successfull\n    function adminSetSignerInfo(address _signer, SignerInformation memory _si) public onlyLogicContract returns (bool) {\n        signerIndex[_signer] = _si;\n        return true;\n    }\n\n    /// @notice calculates the sha3 hash of the most important properties in order to make the proof more efficient\n    /// @param _node the in3 node to calculate the hash from\n    /// @return the hash of the properties of an in3-node\n    function _calcProofHashInternal(In3Node memory _node) internal pure returns (bytes32) {\n\n        return keccak256(\n            abi.encodePacked(\n                _node.deposit,\n                _node.registerTime,\n                _node.props,\n                _node.weight,\n                _node.signer,\n                _node.url\n            )\n        );\n    }\n\n    /// @notice Handles the setting of the unregister values for a node internally\n    /// @param _si information of the signer\n    /// @param _n information of the in3-node\n    function _unregisterNodeInternal(SignerInformation  storage _si, In3Node memory _n) internal {\n\n        // solium-disable-next-line security/no-block-members\n        _si.lockedTime = uint64(block.timestamp + timeout);// solhint-disable-line not-rely-on-time\n        _si.depositAmount = _n.deposit;\n\n        _removeNodeInternal(_si.index);\n    }\n\n    /// @notice removes a node from the node-array\n    /// @param _nodeIndex the nodeIndex to be removed\n    function _removeNodeInternal(uint _nodeIndex) internal {\n\n        require(_nodeIndex < nodes.length, \"invalid node index provided\");\n        // trigger event\n        emit LogNodeRemoved(nodes[_nodeIndex].url, nodes[_nodeIndex].signer);\n        // deleting the old entry\n        delete urlIndex[keccak256(bytes(nodes[_nodeIndex].url))];\n        uint length = nodes.length;\n\n        assert(length > 0);\n\n        // we set the SignerIndex to an invalid index.\n        signerIndex[nodes[_nodeIndex].signer].index = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n        // move the last entry to the removed one.\n        In3Node memory m = nodes[length - 1];\n        nodes[_nodeIndex] = m;\n\n        SignerInformation storage si = signerIndex[m.signer];\n        si.index = _nodeIndex;\n        nodes.length--;\n    }\n}\n"
    },
    "/Users/simon/ws/in3/in3-contracts/contracts/NodeRegistryLogic.sol": {
      "keccak256": "0xe38918240a3191465741b8a75c0ed92b2b936d85c0ee0e823ff601f231358bcb",
      "content": "/***********************************************************\n* This file is part of the Slock.it IoT Layer.             *\n* The Slock.it IoT Layer contains:                         *\n*   - USN (Universal Sharing Network)                      *\n*   - INCUBED (Trustless INcentivized remote Node Network) *\n************************************************************\n* Copyright (C) 2016 - 2018 Slock.it GmbH                  *\n* All Rights Reserved.                                     *\n************************************************************\n* You may use, distribute and modify this code under the   *\n* terms of the license contract you have concluded with    *\n* Slock.it GmbH.                                           *\n* For information about liability, maintenance etc. also   *\n* refer to the contract concluded with Slock.it GmbH.      *\n************************************************************\n* For more information, please refer to https://slock.it   *\n* For questions, please contact info@slock.it              *\n***********************************************************/\n\npragma solidity 0.5.10;\npragma experimental ABIEncoderV2;\n\nimport \"./BlockhashRegistry.sol\";\nimport \"./NodeRegistryData.sol\";\nimport \"./IERC20.sol\";\n\n\n/// @title Registry for IN3-nodes\ncontract NodeRegistryLogic {\n\n    /// node has been registered\n    event LogNodeRegistered(string url, uint192 props, address signer, uint deposit);\n\n    /// a node was convicted\n    event LogNodeConvicted(address signer);\n\n    /// a Node is removed\n    event LogNodeRemoved(string url, address signer);\n\n    /// a node has been updated\n    event LogNodeUpdated(string url, uint192 props, address signer, uint deposit);\n\n    /// the ownership of a node changed\n    event LogOwnershipChanged(address signer, address oldOwner, address newOwner);\n\n    /// a new logic contract got proposed\n    event LogNewPendingContract(address newPendingContract);\n\n    /// deposit has been returned\n    event LogDepositReturned(address signer, address owner, uint deposit, address erc20Token);\n\n    /// Different Stages a node can have\n    enum Stages {\n        NotInUse,                           /// node is not in use, so a new node with the same address can be registered\n        Active,                             /// node is active, so a new node with the same address cannot be registered\n        Convicted,                          /// node is convited, so he is inactive, but cannot be registered anymore\n        DepositNotWithdrawn                 /// node is not in use anymore, but still has some deposit stored within the contract\n    }\n\n    /// add your additional storage here. If you add information before this line you will break in3 nodelist\n    /// blockhash registry address\n    BlockhashRegistry public blockRegistry;\n\n    /// address for the data of the nodeRegistry\n    NodeRegistryData public nodeRegistryData;\n\n    /// timestamp until the unregisterKey is active\n    uint public timestampAdminKeyActive;\n\n    /// admin-key to remove some server, only usable within the 1st year\n    address public adminKey;\n\n    /// timestamp when an update of the logic-contract can be applied\n    uint public updateTimeout;\n\n    /// address of an updated logic contract to be applied\n    address public pendingNewLogic;\n\n    /// capping the max deposit timeout on 1 year\n    uint constant internal YEAR_DEFINITION = 1 days * 365;\n\n    /// limit for ether per node in the 1st year\n    uint public maxDepositFirstYear;\n\n    /// min deposit required for registering a node\n    uint public minDeposit;\n\n    /// version: major minor fork(000) date(yyyy/mm/dd)\n    uint constant public VERSION = 12300020190709;\n\n    modifier onlyAdmin {\n        require(msg.sender == adminKey, \"not the admin\");\n        _;\n    }\n\n    /// @notice constructor\n    /// @param _blockRegistry address of a BlockhashRegistry-contract\n    /// @param _nodeRegistryData address of the nodeRegistryData-contract\n    /// @dev cannot be deployed in a genesis block\n    constructor(BlockhashRegistry _blockRegistry, NodeRegistryData _nodeRegistryData, uint _minDeposit) public {\n\n        require(address(_blockRegistry) != address(0x0), \"no blockRegistry address provided\");\n        blockRegistry = _blockRegistry;\n\n        // solium-disable-next-line security/no-block-members\n        timestampAdminKeyActive = block.timestamp + YEAR_DEFINITION;  // solhint-disable-line not-rely-on-time\n        adminKey = msg.sender;\n        require(address(_nodeRegistryData) != address(0x0), \"no nodeRegistry address provided\");\n        nodeRegistryData = _nodeRegistryData;\n\n        minDeposit = _minDeposit;\n        maxDepositFirstYear = 2000 * minDeposit;\n    }\n\n    /// @notice applies the pending update\n    /// @dev this will remove the current contract as owner of the NodeRegistryData\n    /// @dev only callable after 47 since the new logicContract has been registered\n    function activateNewLogic() external {\n        require(updateTimeout != 0, \"no timeout set\");\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp > updateTimeout, \"timeout not yet over\"); // solhint-disable-line not-rely-on-time\n\n        nodeRegistryData.adminSetLogic(pendingNewLogic);\n    }\n\n    /// @notice removes an in3-server from the registry\n    /// @param _signer the signer-address of the in3-node\n    /// @dev only callable by the adminKey-account\n    /// @dev only callable in the 1st year after deployment\n    function adminRemoveNodeFromRegistry(address _signer)\n        external\n        onlyAdmin\n    {\n        // solium-disable-next-line security/no-block-members\n        require(block.timestamp <= timestampAdminKeyActive, \"only in 1st year\"); // solhint-disable-line not-rely-on-time\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n\n        nodeRegistryData.unregisteringNode(_signer);\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice sets the address for a new (pending) logic\n    ///         the update can only be applied after 47 days,\n    ///         giving all the nodes enough time to unregister their node if they dislike the update\n    /// @dev only callable by the owner of the contract\n    /// @param _newLogic the address of the new logic contract\n    function adminUpdateLogic(address _newLogic) external onlyAdmin {\n        require(_newLogic != address(0x0), \"0x address not supported\");\n\n        // solium-disable-next-line security/no-block-members\n        updateTimeout = block.timestamp + 47 days; // solhint-disable-line not-rely-on-time\n        pendingNewLogic = _newLogic;\n\n        emit LogNewPendingContract(_newLogic);\n    }\n\n    /// @notice commits a blocknumber and a hash\n    /// @notice must be called before revealConvict\n    /// @param _hash keccak256(wrong blockhash, msg.sender, v, r, s); used to prevent frontrunning.\n    /// @dev The v,r,s paramaters are from the signature of the wrong blockhash that the node provided\n    function convict(bytes32 _hash) external {\n        nodeRegistryData.setConvict(_hash, msg.sender);\n    }\n\n    /// @notice register a new node with the sender as owner\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _deposit the deposit in erc20 tokens\n    function registerNode(\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _deposit\n    )\n        external\n    {\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            msg.sender,\n            msg.sender,\n            _deposit,\n            _weight\n        );\n    }\n\n    /// @notice register a new node as a owner using a different signer address\n    /// @dev the supported tokens have to be approved by the owner first\n    /// @param _url the url of the node, has to be unique\n    /// @param _props properties of the node\n    /// @param _signer the signer of the in3-node\n    /// @param _weight how many requests per second the node is able to handle\n    /// @param _depositAmount deposit in erc20 tokens\n    /// @param _v v of the signed message\n    /// @param _r r of the signed message\n    /// @param _s s of the signed message\n    /// @dev will call the registerNodeInteral function\n    /// @dev in order to prove that the owner has controll over the signer-address he has to sign a message\n    /// @dev which is calculated by the hash of the url, properties, weight and the owner\n    /// @dev will revert when a wrong signature has been provided\n    function registerNodeFor(\n        string calldata _url,\n        uint192 _props,\n        address _signer,\n        uint64 _weight,\n        uint _depositAmount,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 tempHash = keccak256(\n            abi.encodePacked(\n                _url,\n                _props,\n                _weight,\n                msg.sender\n            )\n        );\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, tempHash));\n\n        require(_v == 27 || _v == 28, \"invalid signature\");\n\n        address signer = ecrecover(\n            prefixedHash,\n            _v,\n            _r,\n            _s\n        );\n\n        require(_signer == signer, \"not the correct signature of the signer provided\");\n\n        _registerNodeInternal(\n            _url,\n            _props,\n            _signer,\n            msg.sender,\n            _depositAmount,\n            _weight\n        );\n    }\n\n    /// @notice returns the deposit of a former node after the timeout has passed\n    /// @dev only callable by the owner of the former signer\n    /// @param _signer the former signer\n    function returnDeposit(address _signer) external {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.owner == msg.sender, \"not the owner of the node\");\n        require(si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n        // solium-disable-next-line security/no-block-members\n        require(si.lockedTime <= block.timestamp, \"deposit still locked\"); // solhint-disable-line not-rely-on-time\n\n        uint depositAmount = si.depositAmount;\n\n        si.lockedTime = 0;\n        si.owner = address(0x0);\n        si.stage = 0;\n        si.depositAmount = 0;\n        si.index = 0;\n\n        nodeRegistryData.adminSetSignerInfo(_signer, si);\n        nodeRegistryData.adminTransferDeposit(msg.sender, depositAmount);\n\n        emit LogDepositReturned(\n            _signer,\n            msg.sender,\n            depositAmount,\n            address(nodeRegistryData.supportedToken())\n        );\n    }\n\n    /// @notice reveals the wrongly provided blockhash, so that the node-owner will lose its deposit\n    /// @param _signer the address that signed the wrong blockhash\n    /// @param _blockhash the wrongly provided blockhash\n    /// @param _blockNumber number of the wrongly provided blockhash\n    /// @param _v v of the signature\n    /// @param _r r of the signature\n    /// @param _s s of the signature\n    /// @dev reverts if a block with that number cannot be found in either the latest 256 blocks or the blockhash registry\n    /// @dev reverts when tryin to convict someone with a correct blockhash\n    /// @dev reverts when trying to reveal immediately after calling convict\n    /// @dev reverts when the _signer did not sign the block\n    /// @dev reverts when the wrong convict hash (see convict-function) is used\n    function revealConvict(\n        address _signer,\n        bytes32 _blockhash,\n        uint _blockNumber,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        external\n    {\n        require(_v == 27 || _v == 28, \"wrong signature\");\n\n        // solium-disable-next-line security/no-block-members\n        bytes32 evmBlockhash = blockhash(_blockNumber);\n\n        if (evmBlockhash == 0x0) {\n            evmBlockhash = blockRegistry.blockhashMapping(_blockNumber);\n        }\n\n        require(evmBlockhash != 0x0, \"block not found\");\n\n        // if the blockhash is correct you cannot convict the node\n        require(evmBlockhash != _blockhash, \"you try to convict with a correct hash\");\n\n        bytes32 wrongBlockHashIdent = keccak256(\n            abi.encodePacked(\n                _blockhash, msg.sender, _v, _r, _s\n            )\n        );\n\n        uint convictBlockNumber = nodeRegistryData.convictMapping(msg.sender, wrongBlockHashIdent);\n        // as we cannot deploy the contract at block 0, a convicting at block 0 is also impossible\n        // and as 0 is the standard value this also means that the convict hash is also wrong\n        require(convictBlockNumber != 0, \"wrong convict hash\");\n\n        require(block.number > convictBlockNumber + 2, \"revealConvict still locked\");\n        require(\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        _blockhash,\n                        _blockNumber,\n                        nodeRegistryData.registryId()\n                    )\n                ),\n                _v, _r, _s) == _signer,\n            \"the block was not signed by the signer of the node\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active) || si.stage == uint(Stages.DepositNotWithdrawn), \"wrong stage\");\n\n        uint deposit = 0;\n        if (si.stage == uint(Stages.Active)) {\n            NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n            deposit = in3Node.deposit;\n            nodeRegistryData.adminSetNodeDeposit(_signer, 0);\n            nodeRegistryData.adminRemoveNodeFromRegistry(_signer);\n            nodeRegistryData.adminSetStage(_signer, uint(Stages.Convicted));\n            emit LogNodeRemoved(in3Node.url, _signer);\n\n        } else {\n            deposit = si.depositAmount;\n\n            si.stage = uint(Stages.Convicted);\n            si.depositAmount = 0;\n            nodeRegistryData.adminSetSignerInfo(_signer, si);\n        }\n\n        nodeRegistryData.adminTransferDeposit(msg.sender, deposit/2);\n        emit LogNodeConvicted(_signer);\n\n    }\n\n    /// @notice changes the ownership of an in3-node\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _newOwner the new owner\n    /// @dev reverts when trying to change ownership of an inactive node\n    /// @dev reverts when trying to pass ownership to 0x0\n    /// @dev reverts when the sender is not the current owner\n    function transferOwnership(address _signer, address _newOwner)\n        external\n    {\n        require(_newOwner != address(0x0), \"0x0 not allowed\");\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.transferOwnership(_signer, _newOwner);\n\n        emit LogOwnershipChanged(_signer, msg.sender, _newOwner);\n    }\n\n    /// @notice a node owner can unregister a node, removing it from the nodeList\n    /// @notice doing so will also lock his deposit for the timeout of the node\n    /// @param _signer the signer of the in3-node\n    /// @dev reverts when the provided address is not an in3-signer\n    /// @dev reverts when not called by the owner of the node\n    /// @dev reverts when the node is not active\n    function unregisteringNode(address _signer)\n        external\n    {\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory in3Node = nodeRegistryData.getIn3NodeInformation(si.index);\n        require(in3Node.signer == _signer, \"wrong signer\");\n\n        nodeRegistryData.unregisteringNode(_signer);\n\n        nodeRegistryData.adminSetStage(_signer, uint(Stages.DepositNotWithdrawn));\n\n        emit LogNodeRemoved(in3Node.url, _signer);\n\n    }\n\n    /// @notice updates a node by changing its props\n    /// @dev if there is an additional deposit the owner has to approve the tokenTransfer before\n    /// @param _signer the signer-address of the in3-node, used as an identifier\n    /// @param _url the url, will be changed if different from the current one\n    /// @param _props the new properties, will be changed if different from the current onec\n    /// @param _weight the amount of requests per second the node is able to handle\n    /// @param _additionalDeposit the additional deposit in erc20-token\n    /// @dev reverts when the sender is not the owner of the node\n    /// @dev reverts when the signer does not own a node\n    /// @dev reverts when trying to change the url to an already existing one\n    function updateNode(\n        address _signer,\n        string calldata _url,\n        uint192 _props,\n        uint64 _weight,\n        uint _additionalDeposit\n    )\n        external\n    {\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        require(si.stage == uint(Stages.Active), \"wrong stage\");\n        require(si.owner == msg.sender, \"not the owner\");\n\n        NodeRegistryData.In3Node memory node = nodeRegistryData.getNodeInfromationBySigner(_signer);\n        require(node.signer == _signer, \"wrong signer\");\n\n        uint deposit = node.deposit;\n        _checkNodePropertiesInternal(deposit);\n\n        if (_additionalDeposit > 0) {\n            IERC20 supportedToken = nodeRegistryData.supportedToken();\n            require(supportedToken.transferFrom(msg.sender, address(nodeRegistryData), _additionalDeposit), \"ERC20 token transfer failed\");\n            deposit += _additionalDeposit;\n        }\n\n        nodeRegistryData.updateNode(\n            _signer,\n            _url,\n            _props,\n            _weight,\n            deposit\n        );\n\n        emit LogNodeUpdated(\n            node.url,\n            _props,\n            _signer,\n            deposit\n        );\n    }\n\n    /// @notice returns the supported ERC20 token for registering a node\n    /// @return the supported ERC20 token\n    function supportedToken() external view returns (IERC20) {\n        return nodeRegistryData.supportedToken();\n    }\n\n    /// @notice length of the nodelist\n    /// @return the number of total in3-nodes\n    function totalNodes() external view returns (uint) {\n        return nodeRegistryData.totalNodes();\n    }\n\n    /// @notice function to check whether the allowed amount of deposit per server has been reached\n    /// @param _deposit the new amount of deposit a server has\n    /// @dev will fail when the deposit is greater than the maxDepositFirstYear in the 1st year\n    /// @dev will fail when the deposit is less than the minDeposit\n    function _checkNodePropertiesInternal(uint256 _deposit) internal view {\n\n        require(_deposit >= minDeposit, \"not enough deposit\");\n\n        // solium-disable-next-line security/no-block-members\n        if (block.timestamp < timestampAdminKeyActive) { // solhint-disable-line not-rely-on-time\n            require(_deposit < maxDepositFirstYear, \"Limit of 50 ETH reached\");\n        }\n    }\n\n    /// @notice helper function for registering a node\n    /// @param _url the url of the node\n    /// @param _props the properties of the node\n    /// @param _signer the signer of the node\n    /// @param _owner the owner of the node\n    /// @param _deposit the deposit of the node\n    /// @param _weight the weight of the node (# of requests per second he is able to handle)\n    function _registerNodeInternal (\n        string memory _url,\n        uint192 _props,\n        address _signer,\n        address _owner,\n        uint _deposit,\n        uint64 _weight\n    )\n        internal\n    {\n        _checkNodePropertiesInternal(_deposit);\n\n        IERC20 supportedERC20Token = nodeRegistryData.supportedToken();\n\n        require(supportedERC20Token.transferFrom(_owner, address(nodeRegistryData), _deposit), \"ERC20 token transfer failed\");\n\n        NodeRegistryData.SignerInformation memory si = nodeRegistryData.getSignerInformation(_signer);\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        (bool _used,) = nodeRegistryData.urlIndex(urlHash);\n\n        require(!_used, \"url already in use\");\n\n        require(si.stage == uint(Stages.NotInUse), \"signer already in use\");\n\n        nodeRegistryData.registerNodeFor(\n            _url,\n            _props,\n            _signer,\n            _weight,\n            _owner,\n            _deposit,\n            uint(Stages.Active)\n        );\n\n        emit LogNodeRegistered(\n            _url,\n            _props,\n            _signer,\n            _deposit\n        );\n\n    }\n\n}\n"
    }
  }
}}