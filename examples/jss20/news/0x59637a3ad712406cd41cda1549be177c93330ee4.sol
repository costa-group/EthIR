{"Agent_Private.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./Ownable.sol\";\n\ncontract FeeCalcInterface {\n    function getFee() public view returns(uint256);\n    function getCompanyFee() public view returns(uint256);\n    function getNetworkGrowthFee() public view returns(uint256);\n}\n\ncontract ERC20Interface {\n    function transfer(address, uint256) public returns (bool);\n}\n\ncontract DocumentRegistryInterface {\n    function register(address) public;\n    function feeCalc() public view returns(address);\n\n    function companyWallet() public view returns(address);\n    function networkGrowthPoolWallet() public view returns(address);\n    function token() public view returns(address);\n}\n\ncontract Agent is Ownable {\n\n    DocumentRegistryInterface public documentRegistry;\n    string public name;\n\n    address public user;\n\n    event Error(string msg);\n\n    modifier onlyRegisteredUser() {\n        uint256 code = 0;\n        address _sender = msg.sender;\n        if (_sender == user) {\n            _;\n        }\n        else {\n            emit Error(\"User does not registered\");\n        }\n    }\n\n    constructor(address _documentRegistry, address _owner, address _user) public {\n        documentRegistry = DocumentRegistryInterface(_documentRegistry);\n        owner = _owner;\n        user = _user;\n    }\n\n    function setDocumentRegistry(address _documentRegistry) public onlyOwner {\n        documentRegistry = DocumentRegistryInterface(_documentRegistry);\n    }\n\n    function setName(string memory _name) public onlyOwner {\n        name = _name;\n    }\n\n    function setUser(address _user) public onlyOwner {\n        user = _user;\n    }\n\n    function register(address _document) public onlyRegisteredUser {\n        FeeCalcInterface feeCalc = FeeCalcInterface(documentRegistry.feeCalc());\n\n        documentRegistry.register(_document);\n\n        // Transfer fee to company wallet\n        address companyWallet = documentRegistry.companyWallet();\n        assert(companyWallet != address(0));\n        uint256 companyFee = feeCalc.getCompanyFee();\n        assert(ERC20Interface(documentRegistry.token()).transfer(companyWallet, companyFee));\n\n        // Transfer fee to network wallet\n        address networkGrowthPoolWallet = documentRegistry.networkGrowthPoolWallet();\n        assert(networkGrowthPoolWallet != address(0));\n        uint256 networkGrowthFee = feeCalc.getNetworkGrowthFee();\n        assert(ERC20Interface(documentRegistry.token()).transfer(networkGrowthPoolWallet, networkGrowthFee));\n    }\n\n}\n\n"},"BaseDocument.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./Owned.sol\";\n\ncontract BaseDocument is Owned {\n\n    bytes32 public hash;\n    string[] public tags;\n\n    bool public finalized;\n\n    modifier isNotFinalized() {\n        require(!finalized, \"Contract is finalized\");\n        _;\n    }\n\n    constructor(bytes32 _hash) public {\n        hash = _hash;\n    }\n\n    function proxy_init(address _owner, bytes32 _hash) public {\n        require(contractOwner == address(0));\n        contractOwner = _owner;\n        hash = _hash;\n    }\n\n    function setHash(bytes32 _hash) public isNotFinalized onlyContractOwner {\n        hash = _hash;\n    }\n\n    function addTag(string memory _key) public isNotFinalized onlyContractOwner {\n        require(tagsLength() \u003c 32, \"Tags is too many!\");\n        tags.push(_key);\n    }\n\n    function setFinalized() public isNotFinalized onlyContractOwner {\n        finalized = true;\n    }\n\n    function tagsLength() public view returns(uint256) {\n        return tags.length;\n    }\n\n    function documentType() public pure returns(bytes32) {\n        return keccak256(\"basic\");\n    }\n\n}\n\n"},"DocumentRegistry.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./Storage.sol\";\nimport \"./StorageAdapter.sol\";\nimport \"./RolesLibraryAdapter.sol\";\nimport \"./BaseDocument.sol\";\n\ncontract DocumentRegistry is StorageAdapter, RolesLibraryAdapter {\n\n    address public companyWallet;\n    address public networkGrowthPoolWallet;\n    address public feeCalc;\n    address public token;\n\n    StorageInterface.Bytes32AddressMapping documents;\n    StorageInterface.StringAddressSetMapping tags;\n    StorageInterface.AddressBytes32Bytes32Mapping documentsv2;\n\n    event DocumentRegistered(address _document, bytes32 _hash, bytes32 _type);\n    event DocumentRegisteredv2(bytes32 _hash, bytes32 _metahash);\n    event Error(string _message);\n\n    modifier isDocumentFinalized(BaseDocument _document) {\n        if(!_document.finalized()) {\n            emit Error(\"Document is not finalized\");\n            return;\n        }\n        _;\n    }\n\n    constructor(\n        Storage _store,\n        bytes32 _crate,\n        address _companyWallet,\n        address _networkGrowthPoolWallet,\n        address _feeCalc,\n        address _token,\n        address _rolesLibrary\n    ) public StorageAdapter(_store, _crate) RolesLibraryAdapter(_rolesLibrary) {\n        companyWallet = _companyWallet;\n        networkGrowthPoolWallet = _networkGrowthPoolWallet;\n        feeCalc = _feeCalc;\n        token = _token;\n        documents.init(\"RegisteredDocuments\");\n        tags.init(\"ContainsTagDocuments\");\n    }\n\n    function proxy_init(\n        Storage _store,\n        bytes32 _crate,\n        address _companyWallet,\n        address _networkGrowthPoolWallet,\n        address _feeCalc,\n        address _token,\n        address _rolesLibrary\n    ) public {\n        require(address(rolesLibrary) == address(0));\n        store.init(_store, _crate);\n        rolesLibrary = RolesLibraryInterface(_rolesLibrary);\n        companyWallet = _companyWallet;\n        networkGrowthPoolWallet = _networkGrowthPoolWallet;\n        feeCalc = _feeCalc;\n        token = _token;\n        documents.init(\"RegisteredDocuments\");\n        tags.init(\"ContainsTagDocuments\");\n        documentsv2.init(\"RegisteredDocumentsv2\");\n    }\n\n    function setWallets(address _companyWallet, address _networkGrowthPoolWallet) public auth {\n        companyWallet = _companyWallet;\n        networkGrowthPoolWallet = _networkGrowthPoolWallet;\n    }\n\n    function setFeeCalc(address _feeCalc) public auth {\n        feeCalc = _feeCalc;\n    }\n\n    function register(BaseDocument _document) public auth isDocumentFinalized(_document) {\n        require(!exists(_document.hash()), \"Document is already exists!\");\n        store.set(documents, _document.hash(), address(_document));\n        for(uint256 i = 0; i \u003c _document.tagsLength(); ++i) {\n            store.add(tags, _document.tags(i), address(_document));\n        }\n        emit DocumentRegistered(address(_document), _document.hash(), _document.documentType());\n    }\n\n    function getDocument(bytes32 _hash) public view returns(address) {\n        return store.get(documents, _hash);\n    }\n\n    function getDocumentsByTag(string memory _tag) public view returns(address[] memory) {\n        return store.get(tags, _tag);\n    }\n\n    function exists(bytes32 _hash) public view returns(bool) {\n        return store.get(documents, _hash) != address(0);\n    }\n    \n    // Access methods for version 2 (only hash)\n    // Here we don\u0027t deploy contract for document but just store physical(electronic) document hash\n    // and metadata hash which is just JSON with all the data related to registration.\n    \n    function registerv2(bytes32 _hash, bytes32 _metahash) public auth {\n        require(!existsv2(_hash), \"Document already exists!\");\n        store.set(documentsv2, address(0), _hash, _metahash);\n        emit DocumentRegisteredv2(_hash, _metahash);\n    }\n    \n     function existsv2(bytes32 _hash) public view returns(bool) {\n        return store.get(documentsv2, address(0), _hash) != bytes32(0);\n    }\n    \n    function getMetahash(bytes32 _hash) public view returns(bytes32) {\n        return store.get(documentsv2, address(0), _hash);\n    }\n\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.8;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n\n}\n\n\n"},"Owned.sol":{"content":"pragma solidity ^0.5.8;\n\n\n/**\n * @title Owned contract with safe ownership pass.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn\u0027t happen yet.\n */\ncontract Owned {\n    address public contractOwner;\n    address public pendingContractOwner;\n\n    constructor () public {\n        contractOwner = msg.sender;\n    }\n\n    modifier onlyContractOwner() {\n        if (contractOwner == msg.sender || contractOwner == address(0)) {\n            _;\n        }\n    }\n\n    /**\n     * Prepares ownership pass.\n     *\n     * Can only be called by current owner.\n     *\n     * @param _to address of the next owner.\n     *\n     * @return success.\n     */\n    function changeContractOwnership(address _to) public onlyContractOwner returns(bool) {\n        pendingContractOwner = _to;\n        return true;\n    }\n\n    /**\n     * Finalize ownership pass.\n     *\n     * Can only be called by pending owner.\n     *\n     * @return success.\n     */\n    function claimContractOwnership() public returns(bool) {\n        if (pendingContractOwner != msg.sender) {\n            return false;\n        }\n        contractOwner = pendingContractOwner;\n        delete pendingContractOwner;\n        return true;\n    }\n\n    /**\n     * Force ownership pass.\n     *\n     * Can only be called by current owner.\n     *\n     * @param _to address of the next owner.\n     *\n     * @return success.\n     */\n    function forceChangeContractOwnership(address _to) public onlyContractOwner returns(bool) {\n        contractOwner = _to;\n        return true;\n    }\n\n}\n\n"},"RolesLibraryAdapter.sol":{"content":"pragma solidity 0.5.8;\n\n\ncontract RolesLibraryInterface {\n    function canCall(address, address, bytes4) public view returns(bool);\n}\n\ncontract RolesLibraryAdapter {\n    RolesLibraryInterface rolesLibrary;\n\n    event Unauthorized(address user);\n\n    modifier auth() {\n        if (!_isAuthorized(msg.sender, msg.sig)) {\n            emit Unauthorized(msg.sender);\n            return;\n        }\n        _;\n    }\n\n    constructor(address _rolesLibrary) public {\n        rolesLibrary = RolesLibraryInterface(_rolesLibrary);\n    }\n\n    function setRolesLibrary(RolesLibraryInterface _rolesLibrary) auth() public returns(bool) {\n        rolesLibrary = _rolesLibrary;\n        return true;\n    }\n\n    function _isAuthorized(address _src, bytes4 _sig) internal view returns(bool) {\n        if (_src == address(this)) {\n            return true;\n        }\n        if (address(rolesLibrary) == address(0)) {\n            return false;\n        }\n        return rolesLibrary.canCall(_src, address(this), _sig);\n    }\n}\n\n"},"Storage.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./Owned.sol\";\n\n\ncontract Manager {\n    function isAllowed(address _actor, bytes32 _role) view public returns(bool);\n}\n\ncontract Storage is Owned {\n\n    struct Crate {\n        mapping(bytes32 =\u003e uint) uints;\n        mapping(bytes32 =\u003e address) addresses;\n        mapping(bytes32 =\u003e bool) bools;\n        mapping(bytes32 =\u003e int) ints;\n        mapping(bytes32 =\u003e uint8) uint8s;\n        mapping(bytes32 =\u003e bytes32) bytes32s;\n    }\n\n    mapping(bytes32 =\u003e Crate) crates;\n    Manager public manager;\n\n    modifier onlyAllowed(bytes32 _role) {\n        if (!manager.isAllowed(msg.sender, _role)) {\n            revert();\n        }\n        _;\n    }\n\n    function setManager(Manager _manager) onlyContractOwner public returns(bool) {\n        manager = _manager;\n        return true;\n    }\n\n    function setUInt(bytes32 _crate, bytes32 _key, uint _value) onlyAllowed(_crate) public {\n        crates[_crate].uints[_key] = _value;\n    }\n\n    function getUInt(bytes32 _crate, bytes32 _key) view public returns(uint) {\n        return crates[_crate].uints[_key];\n    }\n\n    function setUInt8(bytes32 _crate, bytes32 _key, uint8 _value) onlyAllowed(_crate) public {\n        crates[_crate].uint8s[_key] = _value;\n    }\n\n    function getUInt8(bytes32 _crate, bytes32 _key) view public returns(uint8) {\n        return crates[_crate].uint8s[_key];\n    }\n\n    function setInt(bytes32 _crate, bytes32 _key, int _value) onlyAllowed(_crate) public {\n        crates[_crate].ints[_key] = _value;\n    }\n\n    function getInt(bytes32 _crate, bytes32 _key) view public returns(int) {\n        return crates[_crate].ints[_key];\n    }\n\n    function setAddress(bytes32 _crate, bytes32 _key, address _value) onlyAllowed(_crate) public {\n        crates[_crate].addresses[_key] = _value;\n    }\n\n    function getAddress(bytes32 _crate, bytes32 _key) view public returns(address) {\n        return crates[_crate].addresses[_key];\n    }\n\n    function setBool(bytes32 _crate, bytes32 _key, bool _value) onlyAllowed(_crate) public {\n        crates[_crate].bools[_key] = _value;\n    }\n\n    function getBool(bytes32 _crate, bytes32 _key) view public returns(bool) {\n        return crates[_crate].bools[_key];\n    }\n\n    function setBytes32(bytes32 _crate, bytes32 _key, bytes32 _value) onlyAllowed(_crate) public {\n        crates[_crate].bytes32s[_key] = _value;\n    }\n\n    function getBytes32(bytes32 _crate, bytes32 _key) view public returns(bytes32) {\n        return crates[_crate].bytes32s[_key];\n    }\n\n\n    /// RESTRICTIONS \u0026 DISASTER RECOVERY ///\n\n    function kill() public onlyContractOwner {\n        selfdestruct(msg.sender);\n    }\n\n    // FIXME: Add maintenance mode\n\n\n}\n\n"},"StorageAdapter.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./StorageInterface.sol\";\n\n\ncontract StorageAdapter {\n    using StorageInterface for *;\n\n    StorageInterface.Config store;\n\n    constructor(Storage _store, bytes32 _crate) public {\n        assert(_crate != bytes32(0));\n        store.init(_store, _crate);\n    }\n}"},"StorageInterface.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./Storage.sol\";\n\n/*\ncontract StorageMethods {\n    function setUInt(bytes32, bytes32, uint);\n    function setUInt8(bytes32, bytes32, uint8);\n    function setInt(bytes32, bytes32, int);\n    function setAddress(bytes32, bytes32, address);\n    function setBool(bytes32, bytes32, bool);\n    function setBytes32(bytes32, bytes32, bytes32);\n\n    function getUInt(bytes32, bytes32) returns(uint) ;\n    function getUInt8(bytes32, bytes32) returns(uint8) ;\n    function getInt(bytes32, bytes32) returns(int) ;\n    function getAddress(bytes32, bytes32) returns(address) ;\n    function getBool(bytes32, bytes32) returns(bool) ;\n    function getBytes32(bytes32, bytes32) returns(bytes32) ;\n}\n*/\n\nlibrary StorageInterface {\n\n    // DEFINE STORAGE LINK //\n\n    struct Config {\n        Storage store;\n        bytes32 crate;\n    }\n\n\n    // DEFINE PRIMITIVES //\n\n    struct UInt {\n        bytes32 id;\n    }\n\n    struct UInt8 {\n        bytes32 id;\n    }\n\n    struct Int {\n        bytes32 id;\n    }\n\n    struct Address {\n        bytes32 id;\n    }\n\n    struct Bool {\n        bytes32 id;\n    }\n\n    struct Bytes32 {\n        bytes32 id;\n    }\n\n    struct Mapping {\n        bytes32 id;\n    }\n\n\n    // DEFINE MAPPINGS //\n\n    struct AddressAddressMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressBoolMapping {\n        Mapping innerMapping;\n    }\n\n    struct UintAddressBoolMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressBytes32Mapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUInt8Mapping {\n        bytes32 id;\n    }\n\n    struct AddressUIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUIntUInt8Mapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntUIntBoolMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressBytes4BoolMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressBytes4Bytes32Mapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUIntUIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUIntUIntUIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressAddressUIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressAddressUInt8Mapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressBytes32Bytes32Mapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntAddressMapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntAddressAddressMapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntAddressUIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntBoolMapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntUIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntEnumMapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUIntAddressUInt8Mapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUIntUIntAddressUInt8Mapping {\n        Mapping innerMapping;\n    }\n\n    struct AddressUIntUIntUIntAddressUInt8Mapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntBytes32Mapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntUIntBytes32Mapping {\n        Mapping innerMapping;\n    }\n\n    struct UIntUIntUIntBytes32Mapping {\n        Mapping innerMapping;\n    }\n\n    struct Bytes32UIntMapping {\n        Mapping innerMapping;\n    }\n\n    struct Bytes32AddressMapping {\n        Mapping innerMapping;\n    }\n\n    struct Set {\n        UInt count;\n        Mapping indexes;\n        Mapping values;\n    }\n\n    struct AddressesSet {\n        Set innerSet;\n    }\n\n    struct StringAddressSetMapping {\n        Set innerSet;\n    }\n\n    // Can\u0027t use modifier due to a Solidity bug.\n    function sanityCheck(bytes32 _currentId, bytes32 _newId) internal pure {\n        if (_currentId != 0 || _newId == 0) {\n            revert();\n        }\n    }\n\n    /// INITIATION ///\n\n    function init(Config storage self, Storage _store, bytes32 _crate) internal {\n        self.store = _store;\n        self.crate = _crate;\n    }\n\n\n    /// INIT PRIMITIVES ///\n\n    function init(UInt storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    function init(UInt8 storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    function init(Int storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    function init(Address storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    function init(Bool storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    function init(Bytes32 storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    /// INIT LOW-LEVEL MAPPING ///\n\n    function init(Mapping storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n\n    /// INIT HIGH-LEVEL MAPPINGS ///\n\n    function init(AddressAddressMapping storage self, bytes32 _id) internal {\n        // TODO : TESTING\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressBoolMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UintAddressBoolMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressBytes32Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUInt8Mapping storage self, bytes32 _id) internal {\n        sanityCheck(self.id, _id);\n        self.id = _id;\n    }\n\n    function init(AddressUIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUIntUInt8Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntUIntBoolMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressBytes4BoolMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressBytes4Bytes32Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUIntUIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUIntUIntUIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressAddressUIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressAddressUInt8Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressBytes32Bytes32Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntBytes32Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntAddressMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntAddressAddressMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntAddressUIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntBoolMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntUIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntEnumMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(AddressUIntUIntUIntAddressUInt8Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntUIntBytes32Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(UIntUIntUIntBytes32Mapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(Bytes32UIntMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    function init(Bytes32AddressMapping storage self, bytes32 _id) internal {\n        init(self.innerMapping, _id);\n    }\n\n    /// INIT SETS ///\n\n    function init(Set storage self, bytes32 _id) internal {\n        init(self.count, keccak256(abi.encodePacked(_id, \u0027count\u0027)));\n        init(self.indexes, keccak256(abi.encodePacked(_id, \u0027indexes\u0027)));\n        init(self.values, keccak256(abi.encodePacked(_id, \u0027values\u0027)));\n    }\n\n    function init(AddressesSet storage self, bytes32 _id) internal {\n        init(self.innerSet, _id);\n    }\n\n    function init(StringAddressSetMapping storage self, bytes32 _id) internal {\n        init(self.innerSet, _id);\n    }\n\n    /// SET PRIMITIVES ///\n\n    function set(Config storage self, UInt storage item, uint _value) internal {\n        self.store.setUInt(self.crate, item.id, _value);\n    }\n\n    function set(Config storage self, UInt storage item, bytes32 _key, uint _value) internal {\n        self.store.setUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\n    }\n\n    function set(Config storage self, UInt8 storage item, uint8 _value) internal {\n        self.store.setUInt8(self.crate, item.id, _value);\n    }\n\n    function set(Config storage self, Int storage item, int _value) internal {\n        self.store.setInt(self.crate, item.id, _value);\n    }\n\n    function set(Config storage self, Address storage item, address _value) internal {\n        self.store.setAddress(self.crate, item.id, _value);\n    }\n\n    function set(Config storage self, Bool storage item, bool _value) internal {\n        self.store.setBool(self.crate, item.id, _value);\n    }\n\n    function set(Config storage self, Bytes32 storage item, bytes32 _value) internal {\n        self.store.setBytes32(self.crate, item.id, _value);\n    }\n\n\n    /// SET LOW-LEVEL MAPPINGS ///\n\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _value) internal {\n        self.store.setBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)), _value);\n    }\n\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _value) internal {\n        set(self, item, keccak256(abi.encodePacked(_key, _key2)), _value);\n    }\n\n    function set(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3, bytes32 _value) internal {\n        set(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)), _value);\n    }\n\n\n\n    /// SET HIGH-LEVEL MAPPINGS ///\n\n    function set(Config storage self, AddressAddressMapping storage item, address _key, address _value) internal {\n        // TODO : TESTING\n        set(self, item.innerMapping, addressToBytes32(_key), addressToBytes32(_value));\n    }\n\n    function set(Config storage self, AddressBoolMapping storage item, address _key, bool _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), toBytes32(_value));\n    }\n\n    function set(Config storage self, UintAddressBoolMapping storage item, uint _key, address _key2, bool _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(uint256(_key2)), toBytes32(_value));\n    }\n\n    function set(Config storage self, AddressBytes32Mapping storage item, address _key, bytes32 _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), _value);\n    }\n\n    function set(Config storage self, AddressUIntMapping storage item, address _key, uint _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), bytes32(_value));\n    }\n\n    function set(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2, uint8 _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, UIntUIntBoolMapping storage item, uint _key, uint _key2, bool _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), toBytes32(_value));\n    }\n\n    function set(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2, bool _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2), toBytes32(_value));\n    }\n\n    function set(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2, bytes32 _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2), _value);\n    }\n\n    function set(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2, uint _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2), bytes32(_value));\n    }\n\n    function set(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2,  uint _key3, uint _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2), bytes32(_key3), bytes32(_value));\n    }\n\n    function set(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2, uint _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), addressToBytes32(_key2), bytes32(_value));\n    }\n\n    function set(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2, uint8 _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), addressToBytes32(_key2), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2, bytes32 _value) internal {\n        set(self, item.innerMapping, addressToBytes32(_key), _key2, _value);\n    }\n\n    function set(Config storage self, UIntBytes32Mapping storage item, uint _key, bytes32 _value) internal {\n        set(self, item.innerMapping, bytes32(_key), _value);\n    }\n\n    function set(Config storage self, UIntAddressMapping storage item, uint _key, address _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, UIntBoolMapping storage item, uint _key, bool _value) internal {\n        set(self, item.innerMapping, bytes32(_key), toBytes32(_value));\n    }\n\n    function set(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2, address _value) internal {\n        set(self, item.innerMapping, bytes32(_key), addressToBytes32(_key2), addressToBytes32(_value));\n    }\n\n    function set(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2, uint _value) internal {\n        set(self, item.innerMapping, bytes32(_key), addressToBytes32(_key2), bytes32(_value));\n    }\n\n    function set(Config storage self, UIntUIntMapping storage item, uint _key, uint _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(_value));\n    }\n\n    function set(Config storage self, UIntEnumMapping storage item, uint _key, uint8 _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3, uint8 _value) internal {\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4, uint8 _value) internal {\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2,  uint _key3, uint _key4, address _key5, uint8 _value) internal {\n        set(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)), bytes32(uint256(_value)));\n    }\n\n    function set(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2, bytes32 _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), _value);\n    }\n\n    function set(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2,  uint _key3, bytes32 _value) internal {\n        set(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3), _value);\n    }\n\n    function set(Config storage self, Bytes32UIntMapping storage item, bytes32 _key, uint _value) internal {\n        set(self, item.innerMapping, _key, bytes32(_value));\n    }\n\n    function set(Config storage self, Bytes32AddressMapping storage item, bytes32 _key, address _value) internal {\n        set(self, item.innerMapping, _key, bytes32(uint256(_value)));\n    }\n\n\n    /// OPERATIONS ON SETS ///\n    \n    function add(Config storage self, Set storage item, bytes32 _value) internal {\n        if (includes(self, item, _value)) {\n            return;\n        }\n        uint newCount = count(self, item) + 1;\n        set(self, item.values, bytes32(newCount), _value);\n        set(self, item.indexes, _value, bytes32(newCount));\n        set(self, item.count, newCount);\n    }\n\n    function add(Config storage self, AddressesSet storage item, address _value) internal {\n        add(self, item.innerSet, addressToBytes32(_value));\n    }\n\n    function add(Config storage self, StringAddressSetMapping storage item, string memory _key, address _value) internal {\n        if (includes(self, item, _key, _value)) {\n            return;\n        }\n        uint newCount = count(self, item, _key) + 1;\n        set(self, item.innerSet.values, keccak256(abi.encodePacked(_key, newCount)), addressToBytes32(_value));\n        set(self, item.innerSet.indexes, keccak256(abi.encodePacked(_key)), addressToBytes32(_value), bytes32(newCount));\n        set(self, item.innerSet.count, keccak256(abi.encodePacked(_key)), newCount);\n    }\n\n    function remove(Config storage self, Set storage item, bytes32 _value) internal {\n        if (!includes(self, item, _value)) {\n            return;\n        }\n        uint lastIndex = count(self, item);\n        bytes32 lastValue = get(self, item.values, bytes32(lastIndex));\n        uint index = uint(get(self, item.indexes, _value));\n        if (index \u003c lastIndex) {\n            set(self, item.indexes, lastValue, bytes32(index));\n            set(self, item.values, bytes32(index), lastValue);\n        }\n        set(self, item.indexes, _value, bytes32(0));\n        set(self, item.values, bytes32(lastIndex), bytes32(0));\n        set(self, item.count, lastIndex - 1);\n    }\n\n    function remove(Config storage self, AddressesSet storage item, address _value) internal {\n        remove(self, item.innerSet, addressToBytes32(_value));\n    }\n\n\n    /// GET PRIMITIVES ///\n\n    function get(Config storage self, UInt storage item) internal view returns(uint) {\n        return self.store.getUInt(self.crate, item.id);\n    }\n\n    function get(Config storage self, UInt storage item, bytes32 _key) internal view returns(uint) {\n        return self.store.getUInt(self.crate, keccak256(abi.encodePacked(item.id, _key)));\n    }\n\n    function get(Config storage self, UInt8 storage item) internal view returns(uint8) {\n        return self.store.getUInt8(self.crate, item.id);\n    }\n\n    function get(Config storage self, Int storage item) internal view returns(int) {\n        return self.store.getInt(self.crate, item.id);\n    }\n\n    function get(Config storage self, Address storage item) internal view returns(address) {\n        return self.store.getAddress(self.crate, item.id);\n    }\n\n    function get(Config storage self, Bool storage item) internal view returns(bool) {\n        return self.store.getBool(self.crate, item.id);\n    }\n\n    function get(Config storage self, Bytes32 storage item) internal view returns(bytes32) {\n        return self.store.getBytes32(self.crate, item.id);\n    }\n\n\n    /// GET LOW-LEVEL MAPPINGS ///\n\n    function get(Config storage self, Mapping storage item, bytes32 _key) internal view returns(bytes32) {\n        return self.store.getBytes32(self.crate, keccak256(abi.encodePacked(item.id, _key)));\n    }\n\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2) internal view returns(bytes32) {\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2)));\n    }\n\n    function get(Config storage self, Mapping storage item, bytes32 _key, bytes32 _key2, bytes32 _key3) internal view returns(bytes32) {\n        return get(self, item, keccak256(abi.encodePacked(_key, _key2, _key3)));\n    }\n\n\n    /// GET HIGH-LEVEL MAPPINGS ///\n\n    function get(Config storage self, AddressAddressMapping storage item, address _key) internal view returns(address) {\n        // TODO : TESTING\n        return bytes32ToAddress(get(self, item.innerMapping, addressToBytes32(_key)));\n    }\n\n    function get(Config storage self, AddressBoolMapping storage item, address _key) internal view returns(bool) {\n        return toBool(get(self, item.innerMapping, addressToBytes32(_key)));\n    }\n\n    function get(Config storage self, UintAddressBoolMapping storage item, uint _key, address _key2) internal view returns(bool) {\n        return toBool(get(self, item.innerMapping, bytes32(_key), addressToBytes32(_key2)));\n    }\n\n    function get(Config storage self, AddressBytes32Mapping storage item, address _key) internal view returns(bytes32) {\n        return get(self, item.innerMapping, addressToBytes32(_key));\n    }\n\n    function get(Config storage self, AddressUIntMapping storage item, address _key) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, addressToBytes32(_key)));\n    }\n\n    function get(Config storage self, AddressUIntUInt8Mapping storage item, address _key, uint _key2) internal view returns(uint) {\n        return uint8(uint256(get(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2))));\n    }\n\n    function get(Config storage self, UIntUIntBoolMapping storage item, uint _key, uint _key2) internal view returns(bool) {\n        return toBool(get(self, item.innerMapping, bytes32(_key), bytes32(_key2)));\n    }\n\n    function get(Config storage self, AddressBytes4BoolMapping storage item, address _key, bytes4 _key2) internal view returns(bool) {\n        return toBool(get(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2)));\n    }\n\n    function get(Config storage self, AddressBytes4Bytes32Mapping storage item, address _key, bytes4 _key2) internal view returns(bytes32) {\n        return get(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2));\n    }\n\n    function get(Config storage self, AddressUIntUIntMapping storage item, address _key, uint _key2) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2)));\n    }\n\n    function get(Config storage self, AddressUIntUIntUIntMapping storage item, address _key, uint _key2, uint _key3) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, addressToBytes32(_key), bytes32(_key2), bytes32(_key3)));\n    }\n\n    function get(Config storage self, AddressAddressUIntMapping storage item, address _key, address _key2) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, addressToBytes32(_key), addressToBytes32(_key2)));\n    }\n\n    function get(Config storage self, AddressAddressUInt8Mapping storage item, address _key, address _key2) internal view returns(uint8) {\n        return uint8(uint256(get(self, item.innerMapping, addressToBytes32(_key), addressToBytes32(_key2))));\n    }\n\n    function get(Config storage self, AddressBytes32Bytes32Mapping storage item, address _key, bytes32 _key2) internal view returns(bytes32) {\n        return get(self, item.innerMapping, addressToBytes32(_key), _key2);\n    }\n\n    function get(Config storage self, UIntBytes32Mapping storage item, uint _key) internal view returns(bytes32) {\n        return get(self, item.innerMapping, bytes32(_key));\n    }\n\n    function get(Config storage self, UIntAddressMapping storage item, uint _key) internal view returns(address) {\n        return bytes32ToAddress(get(self, item.innerMapping, bytes32(_key)));\n    }\n\n    function get(Config storage self, UIntBoolMapping storage item, uint _key) internal view returns(bool) {\n        return toBool(get(self, item.innerMapping, bytes32(_key)));\n    }\n\n    function get(Config storage self, UIntAddressAddressMapping storage item, uint _key, address _key2) internal view returns(address) {\n        return bytes32ToAddress(get(self, item.innerMapping, bytes32(_key), addressToBytes32(_key2)));\n    }\n\n    function get(Config storage self, UIntAddressUIntMapping storage item, uint _key, address _key2) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, bytes32(_key), addressToBytes32(_key2)));\n    }\n\n    function get(Config storage self, UIntUIntMapping storage item, uint _key) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, bytes32(_key)));\n    }\n\n    function get(Config storage self, UIntEnumMapping storage item, uint _key) internal view returns(uint8) {\n        return uint8(uint256(get(self, item.innerMapping, bytes32(_key))));\n    }\n\n    function get(Config storage self, AddressUIntAddressUInt8Mapping storage item, address _key, uint _key2, address _key3) internal view returns(uint8) {\n        return uint8(uint256(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3)))));\n    }\n\n    function get(Config storage self, AddressUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, address _key4) internal view returns(uint8) {\n        return uint8(uint256(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4)))));\n    }\n\n    function get(Config storage self, AddressUIntUIntUIntAddressUInt8Mapping storage item, address _key, uint _key2, uint _key3, uint _key4, address _key5) internal view returns(uint8) {\n        return uint8(uint256(get(self, item.innerMapping, keccak256(abi.encodePacked(_key, _key2, _key3, _key4, _key5)))));\n    }\n\n    function get(Config storage self, UIntUIntBytes32Mapping storage item, uint _key, uint _key2) internal view returns(bytes32) {\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2));\n    }\n\n    function get(Config storage self, UIntUIntUIntBytes32Mapping storage item, uint _key, uint _key2, uint _key3) internal view returns(bytes32) {\n        return get(self, item.innerMapping, bytes32(_key), bytes32(_key2), bytes32(_key3));\n    }\n\n    function get(Config storage self, Bytes32UIntMapping storage item, bytes32 _key) internal view returns(uint) {\n        return uint(get(self, item.innerMapping, _key));\n    }\n\n    function get(Config storage self, Bytes32AddressMapping storage item, bytes32 _key) internal view returns(address) {\n        return bytes32ToAddress(get(self, item.innerMapping, _key));\n    }\n\n\n    /// OPERATIONS ON SETS ///\n\n    function includes(Config storage self, Set storage item, bytes32 _value) internal view returns(bool) {\n        return get(self, item.indexes, _value) != 0;\n    }\n\n    function includes(Config storage self, StringAddressSetMapping storage item, string memory _key, address _value) internal view returns(bool) {\n        return get(self, item.innerSet.indexes, keccak256(abi.encodePacked(_key)), addressToBytes32(_value)) != 0;\n    }\n\n    function includes(Config storage self, AddressesSet storage item, address _value) internal view returns(bool) {\n        return includes(self, item.innerSet, addressToBytes32(_value));\n    }\n\n    function count(Config storage self, Set storage item) internal view returns(uint) {\n        return get(self, item.count);\n    }\n\n    function count(Config storage self, AddressesSet storage item) internal view returns(uint) {\n        return count(self, item.innerSet);\n    }\n\n    function count(Config storage self, StringAddressSetMapping storage item, string memory _key) internal view returns(uint) {\n        return get(self, item.innerSet.count, keccak256(abi.encodePacked(_key)));\n    }\n\n    function get(Config storage self, Set storage item) internal view returns(bytes32[] memory) {\n        uint valuesCount = count(self, item);\n        bytes32[] memory result = new bytes32[](valuesCount);\n        for (uint i = 0; i \u003c valuesCount; i++) {\n            result[i] = get(self, item, i);\n        }\n        return result;\n    }\n\n    function get(Config storage self, StringAddressSetMapping storage item, string memory _key) internal view returns(address[] memory) {\n        uint valuesCount = count(self, item, _key);\n        bytes32[] memory result = new bytes32[](valuesCount);\n        for (uint i = 0; i \u003c valuesCount; i++) {\n            result[i] = get(self, item, _key, i);\n        }\n        return toAddresses(result);\n    }\n\n    function get(Config storage self, AddressesSet storage item) internal view returns(address[] memory) {\n        return toAddresses(get(self, item.innerSet));\n    }\n\n    function get(Config storage self, Set storage item, uint _index) internal view returns(bytes32) {\n        return get(self, item.values, bytes32(_index + 1));\n    }\n\n    function get(Config storage self, StringAddressSetMapping storage item, string memory _key, uint _index) internal view returns(bytes32) {\n        return get(self, item.innerSet.values, keccak256(abi.encodePacked(_key, bytes32(_index + 1))));\n    }\n\n    function get(Config storage self, AddressesSet storage item, uint _index) internal view returns(address) {\n        return bytes32ToAddress(get(self, item.innerSet, _index));\n    }\n\n\n    /// HELPERS ///\n\n    function toBool(bytes32 self) pure public returns(bool) {\n        return self != bytes32(0);\n    }\n\n    function toBytes32(bool self) pure public returns(bytes32) {\n        return bytes32(self ? uint256(1) : 0);\n    }\n\n    function toAddresses(bytes32[] memory self) pure public returns(address[] memory) {\n        address[] memory result = new address[](self.length);\n        for (uint i = 0; i \u003c self.length; i++) {\n            result[i] = bytes32ToAddress(self[i]);\n        }\n        return result;\n    }\n    \n    // These helpers introduced after moving to solidity v.0.5 since\n    // types with different size now cannot be casted implicitly\n    function bytes32ToAddress(bytes32 b) pure private returns(address) {\n        return address(uint160(uint256(b)));\n    }\n    \n    function addressToBytes32(address addr) pure private returns(bytes32) {\n        return bytes32(uint256(addr));\n    }\n}\n"}}