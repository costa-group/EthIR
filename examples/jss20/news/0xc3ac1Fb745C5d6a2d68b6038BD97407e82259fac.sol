{{

  "language": "Solidity",

  "sources": {

    "solidity/contracts/KeepRandomBeaconServiceImplV1.sol": {

      "content": "/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"./utils/AddressArrayUtils.sol\";\nimport \"./utils/PercentUtils.sol\";\nimport \"./KeepRegistry.sol\";\nimport \"./IRandomBeacon.sol\";\n\n\ninterface OperatorContract {\n    function entryVerificationFee() external view returns(uint256);\n    function groupCreationFee() external view returns(uint256);\n    function groupProfitFee() external view returns(uint256);\n    function gasPriceCeiling() external view returns(uint256);\n    function sign(\n        uint256 requestId,\n        bytes calldata previousEntry\n    ) external payable;\n    function numberOfGroups() external view returns(uint256);\n    function createGroup(uint256 newEntry, address payable submitter) external payable;\n    function isGroupSelectionPossible() external view returns (bool);\n}\n\n/// @title KeepRandomBeaconServiceImplV1\n/// @notice Initial version of service contract that works under Keep Random\n/// Beacon proxy and allows upgradability. The purpose of the contract is to have\n/// up-to-date logic for threshold random number generation. Updated contracts\n/// must inherit from this contract and have to be initialized under updated version\n/// name.\n/// @dev Warning: you can't set constants directly in the contract and must use\n/// initialize() please see openzeppelin upgradeable contracts approach for more\n/// info.\ncontract KeepRandomBeaconServiceImplV1 is ReentrancyGuard, IRandomBeacon {\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using AddressArrayUtils for address[];\n\n    event RelayEntryRequested(uint256 requestId);\n\n    /// @dev Fraction in % of the estimated cost of DKG that is included\n    /// in relay request fee.\n    uint256 internal _dkgContributionMargin;\n\n    /// @dev Every relay request payment includes DKG contribution that is added to\n    /// the DKG fee pool, once the pool value reaches the required minimum, a new\n    /// relay entry will trigger the creation of a new group. Expressed in wei.\n    uint256 internal _dkgFeePool;\n\n    /// @dev Rewards not paid out to the operators are sent to request subsidy pool to\n    /// subsidize new requests: 1% of the subsidy pool is returned to the requester's\n    /// surplus address. Expressed in wei.\n    uint256 internal _requestSubsidyFeePool;\n\n    /// @dev Each service contract tracks its own requests and these are independent\n    /// from operator contracts which track signing requests instead.\n    uint256 internal _requestCounter;\n\n    /// @dev Previous entry value produced by the beacon.\n    bytes internal _previousEntry;\n\n    /// @dev The cost of executing executeCallback() code of this contract, includes\n    /// everything but the logic of the external contract called.\n    /// The value is used to estimate the cost of executing a callback and is\n    /// used for calculating callback call surplus reimbursement for requestor.\n    ///\n    /// This value has to be updated in case of EVM opcode price change, but since\n    /// upgrading service contract is easy, it is not a worrisome problem.\n    uint256 internal _baseCallbackGas;\n\n    struct Callback {\n        address callbackContract;\n        uint256 callbackFee;\n        uint256 callbackGas;\n        address payable surplusRecipient;\n    }\n\n    mapping(uint256 => Callback) internal _callbacks;\n\n    /// @dev KeepRegistry contract with a list of approved operator contracts and upgraders.\n    address internal _registry;\n\n    address[] internal _operatorContracts;\n\n    /// @dev Mapping to store new implementation versions that inherit from this contract.\n    mapping (string => bool) internal _initialized;\n\n    /// @dev Seed used as the first random beacon value.\n    /// It's a G1 point G * PI =\n    /// G * 31415926535897932384626433832795028841971693993751058209749445923078164062862\n    /// Where G is the generator of G1 abstract cyclic group.\n    bytes constant internal _beaconSeed =\n    hex\"15c30f4b6cf6dbbcbdcc10fe22f54c8170aea44e198139b776d512d8f027319a1b9e8bfaf1383978231ce98e42bafc8129f473fc993cf60ce327f7d223460663\";\n\n    /// @dev Throws if called by any account other than the operator contract\n    /// upgrader authorized for this service contract.\n    modifier onlyOperatorContractUpgrader() {\n        address operatorContractUpgrader = KeepRegistry(_registry).operatorContractUpgraderFor(address(this));\n        require(operatorContractUpgrader == msg.sender, \"Caller is not operator contract upgrader\");\n        _;\n    }\n\n    constructor() public {\n        _initialized[\"KeepRandomBeaconServiceImplV1\"] = true;\n    }\n\n    /// @notice Initialize Keep Random Beacon service contract implementation.\n    /// @param dkgContributionMargin Fraction in % of the estimated cost of DKG that is included in relay\n    /// request fee.\n    /// @param registry KeepRegistry contract linked to this contract.\n    function initialize(\n        uint256 dkgContributionMargin,\n        address registry\n    )\n        public\n    {\n        require(!initialized(), \"Contract is already initialized.\");\n        require(registry != address(0), \"Incorrect registry address\");\n\n        _initialized[\"KeepRandomBeaconServiceImplV1\"] = true;\n        _dkgContributionMargin = dkgContributionMargin;\n        _previousEntry = _beaconSeed;\n        _registry = registry;\n        _baseCallbackGas = 10226;\n    }\n\n    /// @notice Checks if this contract is initialized.\n    function initialized() public view returns (bool) {\n        return _initialized[\"KeepRandomBeaconServiceImplV1\"];\n    }\n\n    /// @notice Adds operator contract\n    /// @param operatorContract Address of the operator contract.\n    function addOperatorContract(address operatorContract) public onlyOperatorContractUpgrader {\n        require(\n            KeepRegistry(_registry).isApprovedOperatorContract(operatorContract),\n            \"Operator contract is not approved\"\n        );\n        _operatorContracts.push(operatorContract);\n    }\n\n    /// @notice Removes operator contract\n    /// @param operatorContract Address of the operator contract.\n    function removeOperatorContract(address operatorContract) public onlyOperatorContractUpgrader {\n        _operatorContracts.removeAddress(operatorContract);\n    }\n\n    /// @notice Add funds to DKG fee pool.\n    function fundDkgFeePool() public payable {\n        _dkgFeePool += msg.value;\n    }\n\n    /// @notice Add funds to request subsidy fee pool.\n    function fundRequestSubsidyFeePool() public payable {\n        _requestSubsidyFeePool += msg.value;\n    }\n\n    /// @notice Selects an operator contract from the available list using modulo\n    /// operation with seed value weighted by the number of active groups on each\n    /// operator contract.\n    /// @param seed Cryptographically generated random value.\n    /// @return Address of operator contract.\n    function selectOperatorContract(uint256 seed) public view returns (address) {\n\n        uint256 totalNumberOfGroups;\n\n        uint256 approvedContractsCounter;\n        address[] memory approvedContracts = new address[](_operatorContracts.length);\n\n        for (uint i = 0; i < _operatorContracts.length; i++) {\n            if (KeepRegistry(_registry).isApprovedOperatorContract(_operatorContracts[i])) {\n                totalNumberOfGroups += OperatorContract(_operatorContracts[i]).numberOfGroups();\n                approvedContracts[approvedContractsCounter] = _operatorContracts[i];\n                approvedContractsCounter++;\n            }\n        }\n\n        require(totalNumberOfGroups > 0, \"Total number of groups must be greater than zero.\");\n\n        uint256 selectedIndex = seed % totalNumberOfGroups;\n\n        uint256 selectedContract;\n        uint256 indexByGroupCount;\n\n        for (uint256 i = 0; i < approvedContractsCounter; i++) {\n            indexByGroupCount += OperatorContract(approvedContracts[i]).numberOfGroups();\n            if (selectedIndex < indexByGroupCount) {\n                return approvedContracts[selectedContract];\n            }\n            selectedContract++;\n        }\n\n        return approvedContracts[selectedContract];\n    }\n\n    /// @notice Creates a request to generate a new relay entry, which will include\n    /// a random number (by signing the previous entry's random number).\n    /// @return An uint256 representing uniquely generated entry Id.\n    function requestRelayEntry() public payable returns (uint256) {\n        return requestRelayEntry(address(0), 0);\n    }\n\n    /// @notice Creates a request to generate a new relay entry (random number).\n    /// @param callbackContract Callback contract address. Callback is called\n    /// once a new relay entry has been generated. Callback contract must\n    /// declare public `__beaconCallback(uint256)` function that is going to be\n    /// executed with the result, once ready.\n    /// @param callbackGas Gas required for the callback (2 million gas max).\n    /// The customer needs to ensure they provide a sufficient callback gas\n    /// to cover the gas fee of executing the callback. Any surplus is returned\n    /// to the customer. If the callback gas amount turns to be not enough to\n    /// execute the callback, callback execution is skipped.\n    /// @return An uint256 representing uniquely generated relay request ID. It\n    /// is also returned as part of the event.\n    function requestRelayEntry(\n        address callbackContract,\n        uint256 callbackGas\n    ) public nonReentrant payable returns (uint256) {\n        require(\n            callbackGas <= 2000000,\n            \"Callback gas exceeds 2000000 gas limit\"\n        );\n\n        require(\n            msg.value >= entryFeeEstimate(callbackGas),\n            \"Payment is less than required minimum.\"\n        );\n\n        (\n            uint256 entryVerificationFee,\n            uint256 dkgContributionFee,\n            uint256 groupProfitFee,\n            uint256 gasPriceCeiling\n        ) = entryFeeBreakdown();\n\n        uint256 callbackFee = msg.value.sub(entryVerificationFee)\n            .sub(dkgContributionFee).sub(groupProfitFee);\n\n        _dkgFeePool += dkgContributionFee;\n\n        OperatorContract operatorContract = OperatorContract(\n            selectOperatorContract(uint256(keccak256(_previousEntry)))\n        );\n\n        uint256 selectedOperatorContractFee = operatorContract.groupProfitFee().add(\n            operatorContract.entryVerificationFee()\n        );\n\n        _requestCounter++;\n        uint256 requestId = _requestCounter;\n\n        operatorContract.sign.value(\n            selectedOperatorContractFee.add(callbackFee)\n        )(requestId, _previousEntry);\n\n        // If selected operator contract is cheaper than expected return the\n        // surplus to the subsidy fee pool.\n        // We do that instead of returning the surplus to the requestor to have\n        // a consistent beacon pricing for customers without fluctuations caused\n        // by different operator contracts being selected.\n        uint256 surplus = entryVerificationFee.add(groupProfitFee).sub(selectedOperatorContractFee);\n        _requestSubsidyFeePool = _requestSubsidyFeePool.add(surplus);\n\n        if (callbackContract != address(0)) {\n            _callbacks[requestId] = Callback(callbackContract, callbackFee, callbackGas, msg.sender);\n        }\n\n        // Send 1% of the request subsidy pool to the requestor.\n        if (_requestSubsidyFeePool >= 100) {\n            uint256 amount = _requestSubsidyFeePool.percent(1);\n            _requestSubsidyFeePool -= amount;\n            (bool success, ) = msg.sender.call.value(amount)(\"\");\n            require(success, \"Failed send subsidy fee\");\n        }\n\n        emit RelayEntryRequested(requestId);\n        return requestId;\n    }\n\n    /// @notice Store valid entry returned by operator contract and call customer\n    /// specified callback if required.\n    /// @param requestId Request id tracked internally by this contract.\n    /// @param entry The generated random number.\n    /// @param submitter Relay entry submitter.\n    function entryCreated(uint256 requestId, bytes memory entry, address payable submitter) public {\n        require(\n            _operatorContracts.contains(msg.sender),\n            \"Only authorized operator contract can call relay entry.\"\n        );\n\n        _previousEntry = entry;\n        uint256 entryAsNumber = uint256(keccak256(entry));\n        emit RelayEntryGenerated(requestId, entryAsNumber);\n\n        createGroupIfApplicable(entryAsNumber, submitter);\n    }\n\n    /// @notice Executes customer specified callback for the relay entry request.\n    /// @param requestId Request id tracked internally by this contract.\n    /// @param entry The generated random number.\n    function executeCallback(uint256 requestId, uint256 entry) public {\n        require(\n            _operatorContracts.contains(msg.sender),\n            \"Only authorized operator contract can call execute callback.\"\n        );\n\n        require(\n            _callbacks[requestId].callbackContract != address(0),\n            \"Callback contract not found\"\n        );\n\n        _callbacks[requestId].callbackContract.call(\n            abi.encodeWithSignature(\"__beaconCallback(uint256)\", entry)\n        );\n\n        delete _callbacks[requestId];\n    }\n\n    /// @notice Triggers the selection process of a new candidate group if the\n    /// DKG fee pool equals or exceeds DKG cost estimate.\n    /// @param entry The generated random number.\n    /// @param submitter Relay entry submitter - operator.\n    function createGroupIfApplicable(uint256 entry, address payable submitter) internal {\n        address latestOperatorContract = _operatorContracts[_operatorContracts.length.sub(1)];\n        uint256 groupCreationFee = OperatorContract(latestOperatorContract).groupCreationFee();\n\n        if (_dkgFeePool >= groupCreationFee && OperatorContract(latestOperatorContract).isGroupSelectionPossible()) {\n            OperatorContract(latestOperatorContract).createGroup.value(groupCreationFee)(entry, submitter);\n            _dkgFeePool = _dkgFeePool.sub(groupCreationFee);\n        }\n    }\n\n    /// @notice Get base callback gas required for relay entry callback.\n    function baseCallbackGas() public view returns(uint256) {\n        return _baseCallbackGas;\n    }\n\n    /// @notice Get the minimum payment in wei for relay entry callback.\n    /// @param _callbackGas Gas required for the callback.\n    function callbackFee(\n        uint256 _callbackGas,\n        uint256 _gasPriceCeiling\n    ) internal view returns(uint256) {\n        // gas for the callback itself plus additional operational costs of\n        // executing the callback\n        uint256 callbackGas = _callbackGas == 0 ? 0 : _callbackGas.add(_baseCallbackGas);\n        // We take the gas price from the price feed to not let malicious\n        // miner-requestors manipulate the gas price when requesting relay entry\n        // and underpricing expensive callbacks.\n        return callbackGas.mul(_gasPriceCeiling);\n    }\n\n    /// @notice Get the entry fee estimate in wei for relay entry request.\n    /// @param callbackGas Gas required for the callback.\n    function entryFeeEstimate(uint256 callbackGas) public view returns(uint256) {\n        require(\n            callbackGas <= 2000000,\n            \"Callback gas exceeds 2000000 gas limit\"\n        );\n\n        (\n            uint256 entryVerificationFee,\n            uint256 dkgContributionFee,\n            uint256 groupProfitFee,\n            uint256 gasPriceCeiling\n        ) = entryFeeBreakdown();\n\n        return entryVerificationFee\n            .add(dkgContributionFee)\n            .add(groupProfitFee)\n            .add(callbackFee(callbackGas, gasPriceCeiling));\n    }\n\n    /// @notice Get the entry fee breakdown in wei for relay entry request.\n    function entryFeeBreakdown() public view returns(\n        uint256 entryVerificationFee,\n        uint256 dkgContributionFee,\n        uint256 groupProfitFee,\n        uint256 gasPriceCeiling\n    ) {\n        // Select the most expensive entry verification from all the operator contracts\n        // and the highest group profit fee from all the operator contracts. We do not\n        // know what is going to be the gas price at the moment of submitting an entry,\n        // thus we can't calculate at this point which contract is the most expensive\n        // based on the entry verification gas and group profit fee. Hence, we need to\n        // select maximum of both those values separately.\n        for (uint i = 0; i < _operatorContracts.length; i++) {\n            OperatorContract operator = OperatorContract(_operatorContracts[i]);\n\n            if (operator.numberOfGroups() > 0) {\n                uint256 operatorBid = operator.entryVerificationFee();\n                if (operatorBid > entryVerificationFee) {\n                    entryVerificationFee = operatorBid;\n                }\n\n                operatorBid = operator.groupProfitFee();\n                if (operatorBid > groupProfitFee) {\n                    groupProfitFee = operatorBid;\n                }\n\n                operatorBid = operator.gasPriceCeiling();\n                if (operatorBid > gasPriceCeiling) {\n                    gasPriceCeiling = operatorBid;\n                }\n            }\n        }\n\n        // Use DKG gas estimate from the latest operator contract since it will be used for the next group creation.\n        address latestOperatorContract = _operatorContracts[_operatorContracts.length.sub(1)];\n        uint256 groupCreationFee = OperatorContract(latestOperatorContract).groupCreationFee();\n\n        return (\n            entryVerificationFee,\n            groupCreationFee.percent(_dkgContributionMargin),\n            groupProfitFee,\n            gasPriceCeiling\n        );\n    }\n\n    /// @notice Returns DKG contribution margin - a fraction in % of the\n    /// estimated cost of DKG that is included in relay request fee.\n    function dkgContributionMargin() public view returns(uint256) {\n        return _dkgContributionMargin;\n    }\n\n    /// @notice Returns the current DKG fee pool value.\n    /// Every relay request payment includes DKG contribution that is added to\n    /// the DKG fee pool, once the pool value reaches the required minimum, a new\n    /// relay entry will trigger the creation of a new group. Expressed in wei.\n    function dkgFeePool() public view returns(uint256) {\n        return _dkgFeePool;\n    }\n\n    /// @notice Returns the current value of request subsidy pool.\n    /// Rewards not paid out to the operators are sent to request subsidy pool to\n    /// subsidize new requests: 1% of the subsidy pool is returned to the requester's\n    /// surplus address. Expressed in wei.\n    function requestSubsidyFeePool() public view returns(uint256) {\n        return _requestSubsidyFeePool;\n    }\n\n    /// @notice Returns callback surplus recipient for the provided request id.\n    function callbackSurplusRecipient(uint256 requestId) public view returns(address payable) {\n        return _callbacks[requestId].surplusRecipient;\n    }\n\n    /// @notice Gets version of the current implementation.\n    function version() public pure returns (string memory) {\n        return \"V1\";\n    }\n}\n"

    },

    "openzeppelin-solidity/contracts/math/SafeMath.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"

    },

    "openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n"

    },

    "solidity/contracts/utils/AddressArrayUtils.sol": {

      "content": "pragma solidity 0.5.17;\n\n\nlibrary AddressArrayUtils {\n\n    function contains(address[] memory self, address _address)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint i = 0; i < self.length; i++) {\n            if (_address == self[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function removeAddress(address[] storage self, address _addressToRemove)\n        internal\n        returns (address[] storage)\n    {\n        for (uint i = 0; i < self.length; i++) {\n            // If address is found in array.\n            if (_addressToRemove == self[i]) {\n                // Delete element at index and shift array.\n                for (uint j = i; j < self.length-1; j++) {\n                    self[j] = self[j+1];\n                }\n                self.length--;\n                i--;\n            }\n        }\n        return self;\n    }\n}\n"

    },

    "solidity/contracts/utils/PercentUtils.sol": {

pragma solidity ^0.5.17;
    },

    "solidity/contracts/KeepRegistry.sol": {

      "content": "pragma solidity 0.5.17;\n\n\n/// @title KeepRegistry\n/// @notice Governance owned registry of approved contracts and roles.\ncontract KeepRegistry {\n    enum ContractStatus {New, Approved, Disabled}\n\n    // Governance role is to enable recovery from key compromise by rekeying\n    // other roles. Also, it can disable operator contract panic buttons\n    // permanently.\n    address public governance;\n\n    // Registry Keeper maintains approved operator contracts. Each operator\n    // contract must be approved before it can be authorized by a staker or\n    // used by a service contract.\n    address public registryKeeper;\n\n    // Each operator contract has a Panic Button which can disable malicious\n    // or malfunctioning contract that have been previously approved by the\n    // Registry Keeper.\n    //\n    // New operator contract added to the registry has a default panic button\n    // value assigned (defaultPanicButton). Panic button for each operator\n    // contract can be later updated by Governance to individual value.\n    //\n    // It is possible to disable panic button for individual contract by\n    // setting the panic button to zero address. In such case, operator contract\n    // can not be disabled and is permanently approved in the registry.\n    mapping(address => address) public panicButtons;\n\n    // Default panic button for each new operator contract added to the\n    // registry. Can be later updated for each contract.\n    address public defaultPanicButton;\n\n    // Each service contract has a Operator Contract Upgrader whose purpose\n    // is to manage operator contracts for that specific service contract.\n    // The Operator Contract Upgrader can add new operator contracts to the\n    // service contract’s operator contract list, and deprecate old ones.\n    mapping(address => address) public operatorContractUpgraders;\n\n    // Operator contract may have a Service Contract Upgrader whose purpose is\n    // to manage service contracts for that specific operator contract.\n    // Service Contract Upgrader can add and remove service contracts\n    // from the list of service contracts approved to work with the operator\n    // contract. List of service contracts is maintained in the operator\n    // contract and is optional - not every operator contract needs to have\n    // a list of service contracts it wants to cooperate with.\n    mapping(address => address) public serviceContractUpgraders;\n\n    // The registry of operator contracts\n    mapping(address => ContractStatus) public operatorContracts;\n\n    event OperatorContractApproved(address operatorContract);\n    event OperatorContractDisabled(address operatorContract);\n\n    event GovernanceUpdated(address governance);\n    event RegistryKeeperUpdated(address registryKeeper);\n    event DefaultPanicButtonUpdated(address defaultPanicButton);\n    event OperatorContractPanicButtonDisabled(address operatorContract);\n    event OperatorContractPanicButtonUpdated(\n        address operatorContract,\n        address panicButton\n    );\n    event OperatorContractUpgraderUpdated(\n        address serviceContract,\n        address upgrader\n    );\n    event ServiceContractUpgraderUpdated(\n        address operatorContract,\n        address keeper\n    );\n\n    modifier onlyGovernance() {\n        require(governance == msg.sender, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyRegistryKeeper() {\n        require(registryKeeper == msg.sender, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyPanicButton(address _operatorContract) {\n        address panicButton = panicButtons[_operatorContract];\n        require(panicButton != address(0), \"Panic button disabled\");\n        require(panicButton == msg.sender, \"Not authorized\");\n        _;\n    }\n\n    modifier onlyForNewContract(address _operatorContract) {\n        require(\n            isNewOperatorContract(_operatorContract),\n            \"Not a new operator contract\"\n        );\n        _;\n    }\n\n    modifier onlyForApprovedContract(address _operatorContract) {\n        require(\n            isApprovedOperatorContract(_operatorContract),\n            \"Not an approved operator contract\"\n        );\n        _;\n    }\n\n    constructor() public {\n        governance = msg.sender;\n        registryKeeper = msg.sender;\n        defaultPanicButton = msg.sender;\n    }\n\n    function setGovernance(address _governance) public onlyGovernance {\n        governance = _governance;\n        emit GovernanceUpdated(governance);\n    }\n\n    function setRegistryKeeper(address _registryKeeper) public onlyGovernance {\n        registryKeeper = _registryKeeper;\n        emit RegistryKeeperUpdated(registryKeeper);\n    }\n\n    function setDefaultPanicButton(address _panicButton) public onlyGovernance {\n        defaultPanicButton = _panicButton;\n        emit DefaultPanicButtonUpdated(defaultPanicButton);\n    }\n\n    function setOperatorContractPanicButton(\n        address _operatorContract,\n        address _panicButton\n    ) public onlyForApprovedContract(_operatorContract) onlyGovernance {\n        require(\n            panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicButtonUpdated(\n            _operatorContract,\n            _panicButton\n        );\n    }\n\n    function disableOperatorContractPanicButton(address _operatorContract)\n        public\n        onlyForApprovedContract(_operatorContract)\n        onlyGovernance\n    {\n        require(\n            panicButtons[_operatorContract] != address(0),\n            \"Panic button already disabled\"\n        );\n\n        panicButtons[_operatorContract] = address(0);\n\n        emit OperatorContractPanicButtonDisabled(_operatorContract);\n    }\n\n    function setOperatorContractUpgrader(\n        address _serviceContract,\n        address _operatorContractUpgrader\n    ) public onlyGovernance {\n        operatorContractUpgraders[_serviceContract] = _operatorContractUpgrader;\n        emit OperatorContractUpgraderUpdated(\n            _serviceContract,\n            _operatorContractUpgrader\n        );\n    }\n\n    function setServiceContractUpgrader(\n        address _operatorContract,\n        address _serviceContractUpgrader\n    ) public onlyGovernance {\n        serviceContractUpgraders[_operatorContract] = _serviceContractUpgrader;\n        emit ServiceContractUpgraderUpdated(\n            _operatorContract,\n            _serviceContractUpgrader\n        );\n    }\n\n    function approveOperatorContract(address operatorContract)\n        public\n        onlyForNewContract(operatorContract)\n        onlyRegistryKeeper\n    {\n        operatorContracts[operatorContract] = ContractStatus.Approved;\n        panicButtons[operatorContract] = defaultPanicButton;\n        emit OperatorContractApproved(operatorContract);\n    }\n\n    function disableOperatorContract(address operatorContract)\n        public\n        onlyForApprovedContract(operatorContract)\n        onlyPanicButton(operatorContract)\n    {\n        operatorContracts[operatorContract] = ContractStatus.Disabled;\n        emit OperatorContractDisabled(operatorContract);\n    }\n\n    function isNewOperatorContract(address operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return operatorContracts[operatorContract] == ContractStatus.New;\n    }\n\n    function isApprovedOperatorContract(address operatorContract)\n        public\n        view\n        returns (bool)\n    {\n        return operatorContracts[operatorContract] == ContractStatus.Approved;\n    }\n\n    function operatorContractUpgraderFor(address _serviceContract)\n        public\n        view\n        returns (address)\n    {\n        return operatorContractUpgraders[_serviceContract];\n    }\n\n    function serviceContractUpgraderFor(address _operatorContract)\n        public\n        view\n        returns (address)\n    {\n        return serviceContractUpgraders[_operatorContract];\n    }\n}\n"

    },

    "solidity/contracts/IRandomBeacon.sol": {

pragma solidity ^0.5.17;
    }

  },

  "settings": {

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "abi"

        ]

      }

    }

  }

}}