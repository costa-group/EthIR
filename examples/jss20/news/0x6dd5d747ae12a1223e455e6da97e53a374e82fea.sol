{"HEX.sol":{"content":"\r\npragma solidity 0.5.13;\r\n\r\ninterface HEX {\r\n   /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n   function stakeStart(uint256 newStakedHearts, uint256 newStakedDays) external;\r\n   function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external;\r\n   function stakeCount(address stakerAddr) external view returns (uint256);\r\n   function stakeLists(address owner, uint256 stakeIndex) external view returns (uint40, uint72, uint72, uint16, uint16, uint16, bool);\r\n   function currentDay() external view returns (uint256);\r\n   function dailyDataRange(uint256 beginDay, uint256 endDay) external view returns (uint256[] memory);\r\n   function globalInfo() external view returns (uint256[13] memory);\r\n\r\n}\r\n"},"HEXPOOL.sol":{"content":"//HEXPOOL.sol\r\n//\r\n//\r\n\r\npragma solidity ^0.5.13;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./IERC20.sol\";\r\nimport \"./HEX.sol\";\r\n\r\n////////////////////////////////////////////////\r\n////////////////////EVENTS/////////////////////\r\n//////////////////////////////////////////////\r\ncontract PoolEvents {\r\n\r\n//when a user enters a pool\r\n    event PoolEntry(\r\n        address indexed user,//msg.sender\r\n        uint indexed heartValue,\r\n        uint indexed entryId,\r\n        uint poolId\r\n    );\r\n    \r\n//when a user exits a pool\r\n    event PoolExit(\r\n        address indexed user,//msg.sender\r\n        uint indexed heartValue,\r\n        uint indexed entryId,\r\n        uint poolId\r\n    );\r\n\r\n//when a pool starts staking\r\n    event PoolStartStake(\r\n        uint heartValue,//always 150m\r\n        uint indexed dayLength,\r\n        uint indexed poolId,\r\n        uint hexStakeId\r\n    );\r\n\r\n//when a pool ends stake\r\n    event PoolEndStake(\r\n        uint heartValue,//always 150m\r\n        uint indexed stakeProfit,\r\n        uint indexed dayLength,\r\n        uint indexed poolId,\r\n        uint hexStakeId\r\n    );\r\n\r\n//when an ended stakes rewards are withdrawn\r\n    event Withdrawal(\r\n        address indexed user,\r\n        uint indexed heartValue\r\n    );\r\n}\r\n\r\ncontract TokenEvents {\r\n\r\n//when a user freezes tokens\r\n    event TokenFreeze(\r\n        address indexed user,\r\n        uint indexed value\r\n    );\r\n\r\n//when a user unfreezes tokens\r\n    event TokenUnfreeze(\r\n        address indexed user,\r\n        uint indexed value\r\n    );\r\n}\r\n\r\n//////////////////////////////////////\r\n//////////POOL TOKEN CONTRACT////////\r\n////////////////////////////////////\r\ncontract POOL is IERC20, TokenEvents{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    bool internal mintBlock;//stops any more tokens ever being minted once _totalSupply reaches _maxSupply - allows for burn rate to take full effect\r\n    uint256 internal _maxSupply = 10000000000000000000;// max supply @ 100B\r\n    uint256 internal _totalSupply;\r\n    string public constant name = \"HEXPOOL\";\r\n    string public constant symbol = \"POOL\";\r\n    uint public constant decimals = 8;\r\n\r\n    //BUDDY SYSTEM\r\n    uint public buddyDiv;\r\n    //FREEZING\r\n    uint public totalFrozen;\r\n    mapping (address =\u003e uint) public tokenFrozenBalances;//balance of POOL frozen mapped by user\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        //1% burn rate\r\n        uint burnt = amount.div(100);\r\n        uint newAmt = amount.sub(burnt);\r\n        _balances[sender] = _balances[sender].sub(newAmt, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(newAmt);\r\n        _burn(sender, burnt);\r\n        emit Transfer(sender, recipient, newAmt);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        uint256 amt = amount;\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        if(!mintBlock){\r\n            if(_totalSupply \u003c _maxSupply){\r\n                if(_totalSupply.add(amt) \u003e _maxSupply){\r\n                    amt = _maxSupply.sub(_totalSupply);\r\n                    _totalSupply = _maxSupply;\r\n                    mintBlock = true;\r\n                }\r\n                else{\r\n                    _totalSupply = _totalSupply.add(amt);\r\n                }\r\n                _balances[account] = _balances[account].add(amt);\r\n                emit Transfer(address(0), account, amt);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller\u0027s allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    //mint POOL to msg.sender\r\n    function mintPool(uint hearts)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint amt = hearts.div(100);\r\n        address minter = msg.sender;\r\n        _mint(minter, amt);//mint POOL - 1% of total heart value before fees @ 10 POOL for 1000 HEX\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    /////////////////PUBLIC FACING - POOL CONTROL//////////\r\n    //////////////////////////////////////////////////////\r\n\r\n    //freeze POOL to contract\r\n    function FreezeTokens(uint amt)\r\n        public\r\n    {\r\n        require(amt \u003e 0, \"zero input\");\r\n        require(tokenBalance() \u003e= amt, \"Error: insufficient balance\");//ensure user has enough funds\r\n        //update balances (allow for 1% burn)\r\n        tokenFrozenBalances[msg.sender] = tokenFrozenBalances[msg.sender].add(amt.sub(amt.div(100)));\r\n        totalFrozen = totalFrozen.add(amt.sub(amt.div(100)));\r\n        _transfer(msg.sender, address(this), amt);//make transfer and burn\r\n        emit TokenFreeze(msg.sender, amt);\r\n    }\r\n\r\n    //unfreeze POOL from contract\r\n    function UnfreezeTokens(uint amt)\r\n        public\r\n    {\r\n        require(amt \u003e 0, \"zero input\");\r\n        require(tokenFrozenBalances[msg.sender] \u003e= amt,\"Error: unsufficient frozen balance\");//ensure user has enough frozen funds\r\n        tokenFrozenBalances[msg.sender] = tokenFrozenBalances[msg.sender].sub(amt);//update balances\r\n        totalFrozen = totalFrozen.sub(amt);\r\n        _transfer(address(this), msg.sender, amt);//make transfer and burn\r\n        emit TokenUnfreeze(msg.sender, amt);\r\n    }\r\n\r\n    ///////////////////////////////\r\n    ////////VIEW ONLY//////////////\r\n    ///////////////////////////////\r\n\r\n    //total POOL frozen in contract\r\n    function totalFrozenTokenBalance()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalFrozen;\r\n    }\r\n\r\n    //pool balance of caller\r\n    function tokenBalance()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balanceOf(msg.sender);\r\n    }\r\n}\r\n\r\ncontract HEXPOOL is POOL, PoolEvents {\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////CONTRACT SETUP///////////////////////\r\n    ////////////////////////////////////////////////////////////////////\r\n    using SafeMath for uint256;\r\n\r\n    HEX hexInterface;\r\n\r\n    //HEXPOOL\r\n    address payable constant hexAddress = 0x2b591e99afE9f32eAA6214f7B7629768c40Eeb39;\r\n\r\n    address payable devAddress;//set in constructor\r\n    address payable constant devAddress2 = 0xD30BC4859A79852157211E6db19dE159673a67E2;\r\n\r\n    uint constant fee = 100; //1%;\r\n    uint constant devFee = 2; // 50% of 1% @ 0.5%;\r\n    uint constant devFee2 = 4; // 25% of 1% @ 0.25%;\r\n    uint constant refFee = 4; // 25% of 1% @ 0.25%; - 100% goes to buddyDiv if no ref, 50% if ref;\r\n\r\n    uint public last_pool_entry_id;// pool entry id\r\n    uint public last_pool_id;// pool id\r\n    uint public last_stake_id;// stake id\r\n\r\n    mapping (address =\u003e UserInfo) public users;\r\n    mapping (uint =\u003e EntryInfo) public entries;\r\n    mapping (uint =\u003e PoolInfo) public pools;\r\n\r\n    mapping (uint =\u003e uint) internal poolUserCount;\r\n    mapping (uint =\u003e uint[]) internal poolEntryIds;\r\n    mapping (address =\u003e uint[]) internal userEntryIds;\r\n\r\n    bool locked;\r\n    bool ready;\r\n\r\n    struct UserInfo {\r\n        uint     totalHeartsEntered;\r\n        address  userAddress;\r\n    }\r\n\r\n    struct EntryInfo {\r\n        uint     heartValue;\r\n        uint     poolId;\r\n        uint     entryId;\r\n        address payable userAddress;\r\n        address payable refferer;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint     poolStakeThreshold;//hearts\r\n        uint     poolStakeDayLength;\r\n        uint     poolValue;//hearts\r\n        uint     poolId;\r\n        uint     poolType;\r\n        mapping  (address =\u003e bool) poolParticipant;\r\n        mapping  (address =\u003e uint) userHeartValue;\r\n        uint     stakeId;\r\n        uint40   hexStakeId;\r\n        bool     isStaking;\r\n        bool     isActive;\r\n        uint256  poolStakeStartTimestamp;\r\n        uint     stakeValue;\r\n        uint     stakeProfit;\r\n        bool     stakeEnded;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == devAddress, \"notOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier canEnter(uint id, uint hearts) {\r\n        require(isPoolActive(id), \"cannot enter, poolId not active\");\r\n        require(id \u003c= last_pool_id, \"Error: poolId out of range\");\r\n        require(hearts \u003e 0, \"Invalid value\");\r\n        _;\r\n    }\r\n\r\n    modifier isReady {\r\n        require(ready, \"cannot enter, pools not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier synchronized {\r\n        require(!locked, \"Sync lock\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() public {\r\n        devAddress = msg.sender;\r\n        hexInterface = HEX(hexAddress);\r\n        initializePools();\r\n    }\r\n\r\n    function() external payable {\r\n        require(false); //refunds any eth accidently sent to contract;\r\n    }\r\n\r\n    function initializePools()\r\n        internal\r\n        onlyOwner\r\n    {\r\n        require(!ready, \"cannot reinitialize\");\r\n        //create one of each pool on deployment\r\n        for(uint i = 0; i \u003c 3; i++){\r\n            newPool(i, 0, address(0));\r\n        }\r\n        ready = true;\r\n    }\r\n\r\n    ///////////////////////////////////////////////////////////////////////\r\n    ////////////////////////////////HEXPOOL CORE//////////////////////////\r\n    ////////////////////////////////////////////////////////////////////\r\n\r\n    //creates a new pool - called on initializePools and when a poolValue reachs its poolStakeThreshold\r\n    function newPool(uint poolType, uint remainderHearts, address payable ref)\r\n       internal\r\n       returns (bool)\r\n    {\r\n        uint threshold;\r\n        uint dayLength;\r\n\r\n        if(poolType == 0){\r\n            threshold = 15000000000000000;//150M BPB @ 10% - 36 DAYS\r\n            dayLength = 36;//~1 month\r\n        }\r\n        else if(poolType == 1){\r\n            threshold = 15000000000000000;//150M BPB @ 10% - 365 DAYS\r\n            dayLength = 365;//1 year\r\n        }\r\n        else if(poolType == 2){\r\n            threshold = 15000000000000000;//150M BPB @ 10% - 3650 DAYS\r\n            dayLength = 3650;//10 years (max rewards)\r\n        }\r\n        else{\r\n            revert(\"invalid poolType\");\r\n        }\r\n        uint id = _next_pool_id();\r\n        PoolInfo storage pool = pools[id];\r\n        pool.poolStakeThreshold = threshold;//hearts\r\n        pool.poolStakeDayLength = dayLength;\r\n        pool.poolValue = remainderHearts;//hearts\r\n        pool.poolId = id;\r\n        pool.poolType = poolType;\r\n        pool.isActive = true;\r\n        if(remainderHearts \u003e 0){//update pool, user and entry data as the new pool now has 1 participant\r\n            poolUserCount[id]++;\r\n            pool.poolParticipant[msg.sender] = true;\r\n            pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].add(remainderHearts);\r\n            //user info\r\n            updateUserData(remainderHearts);\r\n            //entry info\r\n            updateEntryData(remainderHearts, id, ref);\r\n        }\r\n        pools[id] = pool;\r\n        return true;\r\n    }\r\n\r\n    //enters pool - transfers HEX from user to contract - approval needed\r\n    function enterPool(uint hearts, uint poolId, address payable ref)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        PoolInfo storage pool = pools[poolId];\r\n        require(hearts \u003c= pool.poolStakeThreshold, \"amount over threshold - only 1 new pool to be created per tx\");\r\n        require(!pool.isStaking, \"pool is staking\");\r\n        //calc amounts\r\n        uint _fee = hearts.div(fee);\r\n        uint _devFee = _fee.div(devFee);\r\n        uint _devFee2 = _fee.div(devFee2);\r\n        uint _refFee = _fee.div(refFee);\r\n        uint _hearts = hearts.sub(_fee);\r\n        pool.poolValue = pool.poolValue.add(_hearts);//increment pool value with heart value after fees\r\n        if(!pool.poolParticipant[msg.sender]){\r\n            pool.poolParticipant[msg.sender] = true;\r\n            poolUserCount[poolId]++;\r\n        }\r\n         //TOTAL amount of hearts this user has input in THIS pool after fees (EntryInfo for individual pool entries)\r\n        pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].add(_hearts);\r\n        //buddy divs\r\n        if(buddyDiv \u003e 0){\r\n            require(hexInterface.transfer(msg.sender, buddyDiv), \"Transfer failed\");//send hex as buddy div to user\r\n        }\r\n        if(ref == address(0)){//no ref\r\n            //hex refFee to buddyDivs\r\n            buddyDiv = _refFee;\r\n        }\r\n        else{//ref\r\n            //hex refFee to ref\r\n            buddyDiv = _refFee.div(2);\r\n            require(hexInterface.transferFrom(msg.sender, ref, _refFee.div(2)), \"Ref transfer failed\");//send hex to refferer\r\n        }\r\n        //send\r\n        require(hexInterface.transferFrom(msg.sender, address(this), _hearts.add(buddyDiv)), \"Transfer failed\");//send hex from user to contract + buddyDivs to remain in contract\r\n        require(hexInterface.transferFrom(msg.sender, devAddress, _devFee), \"Dev1 transfer failed\");//send hex to dev\r\n        require(hexInterface.transferFrom(msg.sender, devAddress2, _devFee2), \"Dev2 transfer failed\");//send hex to dev2\r\n        //check for pool overflow\r\n        if(pool.poolValue \u003e pool.poolStakeThreshold){\r\n            uint remainderHearts = pool.poolValue.sub(pool.poolStakeThreshold);//get remainder\r\n            //user info\r\n            updateUserData(_hearts.sub(remainderHearts));//remainder to be rolled to next pool\r\n            //entry info\r\n            updateEntryData(_hearts.sub(remainderHearts), pool.poolId, ref);//remainder to be rolled to next pool\r\n            pool.poolValue = pool.poolStakeThreshold;//set as max\r\n             //Back out the remainder value that is spilling into the next pool\r\n            pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].sub(remainderHearts);\r\n            require(startStake(poolId, pool), \"Error: could not start stake\");\r\n            require(newPool(pool.poolType, remainderHearts, ref), \"Error: could not create new pool\");//create new pool with remainder\r\n        }\r\n        else if(pool.poolValue == pool.poolStakeThreshold){\r\n            //user info\r\n            updateUserData(_hearts);\r\n            //entry info\r\n            updateEntryData(_hearts, pool.poolId, ref);\r\n            require(startStake(poolId, pool), \"Error: could not start stake\");\r\n            require(newPool(pool.poolType, 0, ref), \"Error: could not create new pool\");//new pool no remainder\r\n        }\r\n        else{\r\n            //user info\r\n            updateUserData(_hearts);\r\n            //entry info\r\n            updateEntryData(_hearts, pool.poolId, ref);\r\n        }\r\n        //mint bonus POOL tokens relative to HEX amount before fees\r\n        require(mintPool(hearts), \"Error: could not mint tokens\");\r\n        return true;\r\n    }\r\n\r\n    //starts staking poolStakeThreshold to the HEX contract\r\n    function startStake(uint poolId, PoolInfo storage pool)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(pool.poolValue == pool.poolStakeThreshold, \"Stake amount incorrect\");\r\n        uint newStakedHearts = pool.poolStakeThreshold;\r\n        uint newStakedDays = pool.poolStakeDayLength;\r\n        hexInterface.stakeStart(newStakedHearts, newStakedDays);\r\n        uint hexStakeIndex = hexInterface.stakeCount(address(this)).sub(1);//get the most recent stakeIndex\r\n        SStore memory stake = getStakeByIndex(address(this), hexStakeIndex); //get stake from address and stakeindex\r\n        //set pool stake id info\r\n        pool.hexStakeId = stake.stakeId;\r\n        pool.stakeId = last_stake_id;\r\n        pool.poolStakeStartTimestamp = now;\r\n        pool.isActive = false;\r\n        pool.isStaking = true;\r\n        _next_stake_id();\r\n        emit PoolStartStake(\r\n            newStakedHearts,\r\n            newStakedDays,\r\n            poolId,\r\n            stake.stakeId\r\n        );\r\n        return true;\r\n    }\r\n\r\n    //end a pool stake - cannot emergency unstake - needs testing\r\n    function endStake(uint poolId)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(poolId \u003c= last_pool_id, \"Error: poolId out of range\");\r\n        PoolInfo storage pool = pools[poolId];\r\n        require(pool.isStaking, \"Error: pool is not yet staked, or has already ended staking\");\r\n        require(isPoolStakeFinished(poolId), \"Error: cannot early unstake\");\r\n\r\n        uint256 oldBalance = getContractBalance();\r\n        //find the stake index then\r\n        //end stake\r\n        hexInterface.stakeEnd(getStakeIndexById(address(this), pool.hexStakeId), pool.hexStakeId);\r\n        pool.isStaking = false;\r\n        pool.stakeEnded = true;\r\n        //calc stakeValue and stakeProfit\r\n        uint256 stakeValue = getContractBalance().sub(oldBalance);\r\n        pool.stakeValue = stakeValue;\r\n        pool.stakeProfit = stakeValue.sub(pool.poolStakeThreshold);\r\n        emit PoolEndStake(\r\n            pool.stakeProfit,\r\n            pool.poolValue,\r\n            pool.poolStakeDayLength,\r\n            pool.poolId,\r\n            pool.hexStakeId\r\n        );\r\n        return true;\r\n    }\r\n\r\n    //withdraws any staking rewards - or ends a stake if finished but not yet unstaked\r\n    function withdrawPoolRewards(uint poolId)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        PoolInfo storage pool = pools[poolId];\r\n        require(pool.poolValue \u003e 0, \"pool rewards have been drained\");\r\n        require(pools[poolId].userHeartValue[msg.sender] \u003e 0, \"you have no share in this pool\");\r\n        if(!pool.stakeEnded){\r\n            endStake(poolId);\r\n        }\r\n        uint rewards = getWithdrawableRewards(poolId);//calculate pool share\r\n        pool.poolValue = pool.poolValue.sub(pool.userHeartValue[msg.sender]);//reduce pool value\r\n        pool.userHeartValue[msg.sender] = 0;//user has withdrawn rewards from pool\r\n        if(pool.poolValue == 0){\r\n            delete pools[poolId];//delete pool if empty\r\n        }\r\n        require(hexInterface.transfer(msg.sender, rewards), \"Transfer failed\");//transfer users share\r\n        emit Withdrawal(msg.sender, rewards);\r\n        return true;\r\n    }\r\n\r\n    //get any withdrawable staking rewards of caller\r\n    function getWithdrawableRewards(uint poolId)\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        PoolInfo storage pool = pools[poolId];\r\n        require(pool.stakeEnded, \"pool stake has not yet finished\");\r\n        if(pool.userHeartValue[msg.sender] == 0){\r\n            return 0;\r\n        }\r\n        uint stakeWithdrawable = pool.stakeValue.mul(pool.userHeartValue[msg.sender]).div(pool.poolStakeThreshold);//withdrawable rewards\r\n        return stakeWithdrawable;\r\n    }\r\n\r\n    //exits pool of entry by entryId\r\n    function exitPool(uint entryId)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        EntryInfo memory entry = entries[entryId];\r\n        require(msg.sender == entry.userAddress, \"not entry owner, or already exited\");\r\n        PoolInfo storage pool = pools[entry.poolId];\r\n        require(pool.poolParticipant[msg.sender], \"you are not a pool participant\");\r\n        require(!pool.isStaking, \"pool is staking, cannot exit\");\r\n        users[msg.sender].totalHeartsEntered = users[msg.sender].totalHeartsEntered.sub(entry.heartValue);\r\n        pool.poolValue = pool.poolValue.sub(entry.heartValue); //reduce pool value\r\n        pool.userHeartValue[msg.sender] = pool.userHeartValue[msg.sender].sub(entry.heartValue);//reduce users pool share\r\n        //remove user from pool data if 0 pool share\r\n        if(pool.userHeartValue[msg.sender] == 0){\r\n            pool.poolParticipant[msg.sender] = false;\r\n            poolUserCount[entry.poolId]--;\r\n        }\r\n        delete entries[entryId];\r\n        //calc fee amount\r\n        uint _fee = entry.heartValue.div(fee);\r\n        uint _devFee = _fee.div(devFee);\r\n        uint _devFee2 = _fee.div(devFee2);\r\n        uint _refFee = _fee.div(refFee);\r\n        uint _hearts = entry.heartValue.sub(_fee);\r\n        \r\n        if(buddyDiv \u003e 0){\r\n            require(hexInterface.transfer(devAddress, buddyDiv.div(2)), \"Transfer failed\");//send hex as buddy div to dev1 as penalty for user exiting pool\r\n            require(hexInterface.transfer(devAddress2, buddyDiv.div(2)), \"Transfer failed\");//send hex as buddy div to dev2 as penalty for user exiting pool\r\n        }\r\n        if(entry.refferer == address(0)){//no ref\r\n            //set new buddyDivs as hex refFee\r\n            buddyDiv = _refFee;\r\n        }\r\n        else{//ref\r\n            //set new buddyDivs as hex refFee / 2\r\n            buddyDiv = _refFee.div(2);\r\n            require(hexInterface.transfer(entry.refferer, _refFee.div(2)), \"Ref transfer failed\");//send hex to refferer\r\n        }\r\n        //send\r\n        require(hexInterface.transfer(msg.sender, _hearts), \"Transfer failed\");//send hex from contract to user\r\n        require(hexInterface.transfer(devAddress, _devFee), \"Dev1 transfer failed\");//send hex to dev\r\n        require(hexInterface.transfer(devAddress2, _devFee2), \"Dev2 transfer failed\");//send hex to dev2\r\n        //events\r\n        emit PoolExit(\r\n            entry.userAddress,\r\n            entry.heartValue,\r\n            entry.entryId,\r\n            pool.poolId\r\n        );\r\n        return true;\r\n    }\r\n\r\n    //updates user data\r\n    function updateUserData(uint hearts)\r\n        internal\r\n    {\r\n        UserInfo storage user = users[msg.sender];\r\n        user.totalHeartsEntered = user.totalHeartsEntered.add(hearts);//total amount of hearts deposited by this user after fees\r\n        user.userAddress = msg.sender;\r\n    }\r\n\r\n    //updates entry data\r\n    function updateEntryData(uint hearts, uint poolId, address payable ref)\r\n        internal\r\n    {\r\n        uint _entryID = _next_pool_entry_id();\r\n        userEntryIds[msg.sender].push(_entryID);//update userEntryIds\r\n        poolEntryIds[poolId].push(_entryID);//update poolEntryIds\r\n        EntryInfo memory entry;\r\n        entry.heartValue = hearts;//amount of hearts deposited in this entry after fees\r\n        entry.poolId = poolId;//poolId this entry has deposited to\r\n        entry.entryId = _entryID;\r\n        entry.userAddress = msg.sender;\r\n        entry.refferer = ref;\r\n        entries[_entryID] = entry;//update entry data\r\n        emit PoolEntry(\r\n            entry.userAddress,\r\n            entry.heartValue,\r\n            entry.entryId,\r\n            poolId\r\n        );\r\n    }\r\n\r\n    //get next entry id\r\n    function _next_pool_entry_id()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        last_pool_entry_id++;\r\n        return last_pool_entry_id;\r\n    }\r\n\r\n    //get next pool id\r\n    function _next_pool_id()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        last_pool_id++;\r\n        return last_pool_id;\r\n    }\r\n\r\n    //get next stake id\r\n    function _next_stake_id()\r\n        internal\r\n        returns (uint)\r\n    {\r\n        last_stake_id++;\r\n        return last_stake_id;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////////////\r\n    ////////////////////////PUBLIC FACING HEXPOOL////////////////////\r\n    ////////////////////////////////////////////////////////////////\r\n\r\n    //enter any pool that isActive\r\n    function EnterPool(uint _hearts, uint _poolId, address payable _ref)\r\n        public\r\n        canEnter(_poolId, _hearts)\r\n        synchronized\r\n    {\r\n        require(enterPool(_hearts, _poolId, _ref), \"Error: could not enter pool\");\r\n    }\r\n\r\n    //withdraw funds from pool by entryId - pool cannot be already staking\r\n    function ExitPool(uint _entryId)\r\n        public\r\n        synchronized\r\n    {\r\n        require(exitPool(_entryId), \"Error: could not exit pool\");\r\n    }\r\n\r\n    //ends a staked pool\r\n    function EndPoolStake(uint _poolId)\r\n        public\r\n        synchronized\r\n    {\r\n        require(endStake(_poolId), \"Error: could not end stake\");\r\n    }\r\n\r\n    //withdraws HEX staking rewards\r\n    function WithdrawHEX(uint _poolId)\r\n        public\r\n        synchronized\r\n    {\r\n        require(withdrawPoolRewards(_poolId), \"Error: could not withdraw rewards\");\r\n    }\r\n\r\n    //////////////////////////////////////////\r\n    ////////////VIEW ONLY/////////////////////\r\n    //////////////////////////////////////////\r\n\r\n    //only an active pool can be entered or exited\r\n    function isPoolActive(uint poolId)\r\n        public\r\n        view\r\n        isReady\r\n        returns(bool)\r\n    {\r\n        return pools[poolId].isActive;\r\n    }\r\n\r\n    //\r\n    function isPoolStaking(uint poolId)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return pools[poolId].isStaking;\r\n    }\r\n\r\n    //\r\n    function isPoolStakeFinished(uint poolId)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return pools[poolId].poolStakeStartTimestamp.add(pools[poolId].poolStakeDayLength.mul(86400)) \u003c= now;\r\n    }\r\n\r\n    //\r\n    function isPoolStakeEnded(uint poolId)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return pools[poolId].stakeEnded;\r\n    }\r\n\r\n    //general user info\r\n    function getUserInfo(address addr)\r\n        public\r\n        view\r\n        returns(\r\n        uint    totalHeartsEntered,\r\n        uint[] memory _entryIds,\r\n        address userAddress\r\n        )\r\n    {\r\n        return(users[addr].totalHeartsEntered, userEntryIds[addr], users[addr].userAddress);\r\n    }\r\n\r\n    //general entry info\r\n    function getEntryInfo(uint entryId)\r\n        public\r\n        view\r\n        returns(\r\n        uint     heartValue,\r\n        uint     poolId,\r\n        address payable userAddress,\r\n        address payable refferer\r\n        )\r\n    {\r\n        return(entries[entryId].heartValue, entries[entryId].poolId, entries[entryId].userAddress, entries[entryId].refferer);\r\n    }\r\n\r\n    //general pool info\r\n    function getPoolInfo(uint poolId)\r\n        public\r\n        view\r\n        returns(\r\n        uint     poolStakeThreshold,//hearts\r\n        uint     poolStakeDayLength,\r\n        uint     poolValue,//hearts\r\n        uint     poolType,\r\n        bool     isStaking,\r\n        uint256  poolStakeStartTimestamp,\r\n        bool     stakeEnded\r\n        )\r\n    {\r\n        return(\r\n            pools[poolId].poolStakeThreshold,\r\n            pools[poolId].poolStakeDayLength,\r\n            pools[poolId].poolValue,\r\n            pools[poolId].poolType,\r\n            pools[poolId].isStaking,\r\n            pools[poolId].poolStakeStartTimestamp,\r\n            pools[poolId].stakeEnded\r\n            );\r\n    }\r\n\r\n    //returns all entryIds of a pool\r\n    function getPoolEntryIds(uint poolId)\r\n        public\r\n        view\r\n        returns(uint[] memory)\r\n    {\r\n        return poolEntryIds[poolId];\r\n    }\r\n\r\n    //return vital stake params\r\n    function getPoolStakeInfo(uint poolId)\r\n        public\r\n        view\r\n        returns(uint stakeId, uint hexStakeIndex, uint40 hexStakeId)\r\n    {\r\n        return(pools[poolId].stakeId, getStakeIndexById(address(this), pools[poolId].hexStakeId), pools[poolId].hexStakeId);\r\n    }\r\n\r\n    //returns amount of users by address in a pool\r\n    function getPoolUserCount(uint poolId)\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return poolUserCount[poolId];\r\n    }\r\n\r\n    //is address a user of pool\r\n    function isPoolParticipant(uint id, address addr)\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n       return pools[id].poolParticipant[addr];\r\n    }\r\n\r\n    //returns total hearts a user owns in pool\r\n    function getUserHeartValue(uint id, address addr)\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n       return pools[id].userHeartValue[addr];\r\n    }\r\n\r\n    //returns contract HEX balance\r\n    function getContractBalance()\r\n        public\r\n        view\r\n        returns(uint)\r\n    {\r\n        return hexInterface.balanceOf(address(this));\r\n    }\r\n\r\n    ///////////////////////////////////////////////\r\n    ///////////////////HEX UTILS///////////////////\r\n    ///////////////////////////////////////////////\r\n    //credits to kyle bahr @ https://gist.github.com/kbahr/80e61ab761053849f7fdc6226b85a354\r\n\r\n    struct SStore {\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n    }\r\n\r\n    struct DailyDataCache {\r\n        uint256 dayPayoutTotal;\r\n        uint256 dayStakeSharesTotal;\r\n        uint256 dayUnclaimedSatoshisTotal;\r\n    }\r\n    uint256 private constant HEARTS_UINT_SHIFT = 72;\r\n    uint256 private constant HEARTS_MASK = (1 \u003c\u003c HEARTS_UINT_SHIFT) - 1;\r\n    uint256 private constant SATS_UINT_SHIFT = 56;\r\n    uint256 private constant SATS_MASK = (1 \u003c\u003c SATS_UINT_SHIFT) - 1;\r\n\r\n    function decodeDailyData(uint256 encDay)\r\n    private\r\n    pure\r\n    returns (DailyDataCache memory)\r\n    {\r\n        uint256 v = encDay;\r\n        uint256 payout = v \u0026 HEARTS_MASK;\r\n        v = v \u003e\u003e HEARTS_UINT_SHIFT;\r\n        uint256 shares = v \u0026 HEARTS_MASK;\r\n        v = v \u003e\u003e HEARTS_UINT_SHIFT;\r\n        uint256 sats = v \u0026 SATS_MASK;\r\n        return DailyDataCache(payout, shares, sats);\r\n    }\r\n\r\n    function interestForRange(DailyDataCache[] memory dailyData, uint256 myShares)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        uint256 len = dailyData.length;\r\n        uint256 total = 0;\r\n        for(uint256 i = 0; i \u003c len; i++){\r\n            total += interestForDay(dailyData[i], myShares);\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function interestForDay(DailyDataCache memory dayObj, uint256 myShares)\r\n    private\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        return myShares * dayObj.dayPayoutTotal / dayObj.dayStakeSharesTotal;\r\n    }\r\n\r\n    function getDataRange(uint256 b, uint256 e)\r\n    private\r\n    view\r\n    returns (DailyDataCache[] memory)\r\n    {\r\n        uint256[] memory dataRange = hexInterface.dailyDataRange(b, e);\r\n        uint256 len = dataRange.length;\r\n        DailyDataCache[] memory data = new DailyDataCache[](len);\r\n        for(uint256 i = 0; i \u003c len; i++){\r\n            data[i] = decodeDailyData(dataRange[i]);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    function getLastDataDay()\r\n    private\r\n    view\r\n    returns(uint256)\r\n    {\r\n        uint256[13] memory globalInfo = hexInterface.globalInfo();\r\n        uint256 lastDay = globalInfo[4];\r\n        return lastDay;\r\n    }\r\n\r\n    function getInterestByStake(SStore memory s)\r\n    private\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 b = s.lockedDay;\r\n        uint256 e = getLastDataDay(); // ostensibly \"today\"\r\n\r\n        if (b \u003e= e) {\r\n            //not started - error\r\n            return 0;\r\n        } else {\r\n            DailyDataCache[] memory data = getDataRange(b, e);\r\n            return interestForRange(data, s.stakeShares);\r\n        }\r\n    }\r\n\r\n    function getInterestByStakeId(address addr, uint40 stakeId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        SStore memory s = getStakeByStakeId(addr, stakeId);\r\n\r\n        return getInterestByStake(s);\r\n    }\r\n\r\n    function getTotalValueByStakeId(address addr, uint40 stakeId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        SStore memory stake = getStakeByStakeId(addr, stakeId);\r\n\r\n        uint256 interest = getInterestByStake(stake);\r\n        return stake.stakedHearts + interest;\r\n    }\r\n\r\n    function getStakeByIndex(address addr, uint256 idx)\r\n    private\r\n    view\r\n    returns (SStore memory)\r\n    {\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n\r\n        (stakeId,\r\n            stakedHearts,\r\n            stakeShares,\r\n            lockedDay,\r\n            stakedDays,\r\n            unlockedDay,\r\n            isAutoStake) = hexInterface.stakeLists(addr, idx);\r\n\r\n        return SStore(stakeId,\r\n                        stakedHearts,\r\n                        stakeShares,\r\n                        lockedDay,\r\n                        stakedDays,\r\n                        unlockedDay,\r\n                        isAutoStake);\r\n    }\r\n\r\n    function getStakeByStakeId(address addr, uint40 sid)\r\n    private\r\n    view\r\n    returns (SStore memory)\r\n    {\r\n\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n\r\n        uint256 stakeCount = hexInterface.stakeCount(addr);\r\n        for(uint256 i = 0; i \u003c stakeCount; i++){\r\n            (stakeId,\r\n            stakedHearts,\r\n            stakeShares,\r\n            lockedDay,\r\n            stakedDays,\r\n            unlockedDay,\r\n            isAutoStake) = hexInterface.stakeLists(addr, i);\r\n\r\n            if(stakeId == sid){\r\n                return SStore(stakeId,\r\n                                stakedHearts,\r\n                                stakeShares,\r\n                                lockedDay,\r\n                                stakedDays,\r\n                                unlockedDay,\r\n                                isAutoStake);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStakeIndexById(address addr, uint40 sid)\r\n        private\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint40 stakeId;\r\n        uint72 stakedHearts;\r\n        uint72 stakeShares;\r\n        uint16 lockedDay;\r\n        uint16 stakedDays;\r\n        uint16 unlockedDay;\r\n        bool isAutoStake;\r\n\r\n        uint256 stakeCount = hexInterface.stakeCount(addr);\r\n        for(uint256 i = 0; i \u003c stakeCount; i++){\r\n            (stakeId,\r\n            stakedHearts,\r\n            stakeShares,\r\n            lockedDay,\r\n            stakedDays,\r\n            unlockedDay,\r\n            isAutoStake) = hexInterface.stakeLists(addr, i);\r\n\r\n            if(stakeId == sid){\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.13;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\n \r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);//from address(0) for minting\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.13;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n"}}