{"BrightID.sol":{"content":"pragma solidity ^0.6.3;\n\ncontract BrightID {\n    uint256 public id;\n\n    struct Context {\n        bool isActive;\n        mapping(address =\u003e bool) owners;\n        mapping(address =\u003e bool) nodes;\n        mapping(uint256 =\u003e address[]) accounts;\n        mapping(bytes32 =\u003e uint256) cIdToUid;\n        mapping(address =\u003e uint256) ethToUid;\n    }\n\n    mapping(bytes32 =\u003e Context) private contexts;\n\n    string private constant DUPLICATE_ETHEREUM_ADDRESS = \"Duplicate ethereum address\";\n    string private constant DUPLICATE_CONTEXT_ID = \"Duplicate context id\";\n    string private constant ONLY_CONTEXT_OWNER = \"Only context owner\";\n    string private constant UNAUTHORIZED_NODE = \"Unauthorized node\";\n    string private constant CONTEXT_NOT_FOUND = \"Context not found\";\n    string private constant NODE_NOT_FOUND = \"Node not found\";\n    string private constant ALREADY_EXISTS = \"Already exists\";\n    string private constant BAD_SIGNATURE = \"Bad signature\";\n    string private constant NO_CONTEXT_ID = \"No context id\";\n\n    /// Events\n    event ContextAdded(bytes32 indexed context, address indexed owner);\n    event ContextOwnerAdded(bytes32 indexed context, address owner);\n    event ContextOwnerRemoved(bytes32 indexed context, address owner);\n    event NodeAddedToContext(bytes32 indexed context, address nodeAddress);\n    event NodeRemovedFromContext(bytes32 indexed context, address nodeAddress);\n    event AddressLinked(bytes32 context, bytes32 contextId, address ethAddress);\n    event SponsorshipRequested(bytes32 indexed context, bytes32 indexed contextid);\n\n    constructor()\n        public\n    {\n        id = 0;\n    }\n\n    /**\n     * @notice Check whether the context has been added to the smart contract using `addContext`.\n     * @param context The context.\n     * @return has the context been added?\n     */\n    function isContext(bytes32 context)\n        public\n        view\n        returns(bool)\n    {\n        return contexts[context].isActive;\n    }\n\n    /**\n     * @notice Check whether `nodeAddress`\u0027s signature is acceptable for the context.\n     * @param context The context.\n     * @param nodeAddress The node\u0027s address.\n     * @return can `nodeAddress` sign requests for this context?\n     */\n    function isNodeInContext(bytes32 context, address nodeAddress)\n        public\n        view\n        returns(bool)\n    {\n        return contexts[context].nodes[nodeAddress];\n    }\n\n    /**\n     * @dev get uid.\n     * @param context The context.\n     * @param cIds an array of contextIds.\n     */\n    function getUid(bytes32 context, bytes32[] memory cIds)\n        internal\n        returns(uint256)\n    {\n        for(uint256 i=1; i \u003c cIds.length-1; i++) {\n            uint256 uid = contexts[context].cIdToUid[cIds[i]];\n            if (uid != 0) {\n                return uid;\n            }\n        }\n        return ++id;\n    }\n\n    /**\n     * @notice Link `cIds[0]` to `msg.sender` under `context`.\n     * @param context The context.\n     * @param cIds an array of contextIds.\n     * @param v signature\u0027s v.\n     * @param r signature\u0027s r.\n     * @param s signature\u0027s s.\n     */\n    function register(\n        bytes32 context,\n        bytes32[] memory cIds,\n        uint8 v,\n        bytes32 r,\n        bytes32 s)\n        public\n    {\n        require(isContext(context), CONTEXT_NOT_FOUND);\n        require(0 \u003c cIds.length, NO_CONTEXT_ID);\n        require(contexts[context].cIdToUid[cIds[0]] == 0, DUPLICATE_CONTEXT_ID);\n        require(contexts[context].ethToUid[msg.sender] == 0, DUPLICATE_ETHEREUM_ADDRESS);\n\n        bytes32 message = keccak256(abi.encodePacked(context, cIds));\n        address signerAddress = ecrecover(message, v, r, s);\n        require(signerAddress != address(0), BAD_SIGNATURE);\n        require(contexts[context].nodes[signerAddress], UNAUTHORIZED_NODE);\n\n        uint256 uid = getUid(context, cIds);\n\n        contexts[context].ethToUid[msg.sender] = uid;\n\n        for(uint256 i=0; i \u003c cIds.length-1; i++) {\n            contexts[context].cIdToUid[cIds[i]] = uid;\n        }\n\n        // The last member of contexts[context].accounts[uid] is active address of the user\n        contexts[context].accounts[uid].push(msg.sender);\n\n        emit AddressLinked(context, cIds[0], msg.sender);\n    }\n\n    /**\n     * @notice Check that `ethAddress` is the mostly recently used address by a unique human in the context.\n     * Also return any addresses previously used by this unique human.\n     * @param ethAddress an Ethereum address.\n     * @param context the context.\n     * @return is `ethAddress` the most recently used address by a unique human in the `context`.\n     * @return addresses previously used by this unique human.\n     */\n    function isUniqueHuman(\n        address ethAddress,\n        bytes32 context)\n        public\n        view\n        returns(bool, address[] memory)\n    {\n        uint256 uid = contexts[context].ethToUid[ethAddress];\n        if (uid != 0) {\n            uint256 lastIndex = contexts[context].accounts[uid].length - 1;\n            if (contexts[context].accounts[uid][lastIndex] == ethAddress) {\n                return(true, contexts[context].accounts[uid]);\n            }\n        }\n    }\n\n    /**\n     * @notice Submit a request to sponsor `contextid` under `context`.\n     * @param context The context.\n     * @param contextid The contextid.\n     */\n    function sponsor(bytes32 context, bytes32 contextid)\n        public\n        onlyContextOwner(context)\n    {\n        emit SponsorshipRequested(context, contextid);\n    }\n\n    /**\n     * @notice Add a context.\n     * @param context The context.\n     */\n    function addContext(bytes32 context)\n        public\n    {\n        require(contexts[context].isActive != true, ALREADY_EXISTS);\n\n        contexts[context].isActive = true;\n        contexts[context].owners[msg.sender] = true;\n        emit ContextAdded(context, msg.sender);\n    }\n\n    /**\n     * @notice Add a context owner.\n     * @param context The context.\n     * @param owner The address of the context owner to be added.\n     */\n    function addContextOwner(bytes32 context, address owner)\n        public\n        onlyContextOwner(context)\n    {\n        contexts[context].owners[owner] = true;\n        emit ContextOwnerAdded(context, owner);\n    }\n\n    /**\n     * @notice Remove a context owner.\n     * @param context The context.\n     * @param owner The address of the context owner to be removed.\n     */\n    function removeContextOwner(bytes32 context, address owner)\n        public\n        onlyContextOwner(context)\n    {\n        contexts[context].owners[owner] = false;\n        emit ContextOwnerRemoved(context, owner);\n    }\n\n\n    /**\n     * @notice Check that `owner` is a owner of `context`.\n     * @param context The context.\n     * @param owner The new context\u0027s owner.\n     */\n    function isContextOwner(bytes32 context, address owner)\n        public\n        view\n        returns(bool)\n    {\n        return contexts[context].owners[owner];\n    }\n\n    /**\n     * @notice Add `nodeAddress` as a node to the context.\n     * @param context The context.\n     * @param nodeAddress The node\u0027s address.\n     */\n    function addNodeToContext(bytes32 context, address nodeAddress)\n        public\n        onlyContextOwner(context)\n    {\n        require(isContext(context), CONTEXT_NOT_FOUND);\n        require(contexts[context].nodes[nodeAddress] != true, ALREADY_EXISTS);\n\n        contexts[context].nodes[nodeAddress] = true;\n        emit NodeAddedToContext(context, nodeAddress);\n    }\n\n    /**\n     * @notice Remove `nodeAddress` from the context\u0027s nodes.\n     * @param context The context.\n     * @param nodeAddress The node\u0027s address.\n     */\n    function removeNodeFromContext(bytes32 context, address nodeAddress)\n        public\n        onlyContextOwner(context)\n    {\n        require(isContext(context), CONTEXT_NOT_FOUND);\n        require(contexts[context].nodes[nodeAddress] == true, NODE_NOT_FOUND);\n\n        contexts[context].nodes[nodeAddress] = false;\n        emit NodeRemovedFromContext(context, nodeAddress);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner of the context.\n     * @param context The context.\n     */\n    modifier onlyContextOwner(bytes32 context) {\n        require(contexts[context].owners[msg.sender], ONLY_CONTEXT_OWNER);\n        _;\n    }\n}\n"},"Sponsor.sol":{"content":"pragma solidity ^0.6.4;\n\nimport \"./BrightID.sol\";\n\ncontract Sponsor {\n  BrightID public brightID;\n  bytes32 public context;\n\n  constructor(BrightID _brightID, bytes32 _context) public {\n    brightID = _brightID;\n    context = _context;\n  }\n\n  // sponsor any address that sends a transaction to this contract.\n  function sponsor() public payable {\n    brightID.sponsor(context, bytes32(uint(msg.sender)));\n  }\n}\n"}}