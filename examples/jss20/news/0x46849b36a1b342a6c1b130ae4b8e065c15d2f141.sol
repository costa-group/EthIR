{"Address.sol":{"content":"pragma solidity ^0.5.1;\n\n/**\n * Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * Returns true if `account` is a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n\n    /**\n     * Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n}\n"},"IToken.sol":{"content":"pragma solidity ^0.5.1;\n\n/**\n * Interface of the ERC223Token standard as defined in the EIP.\n */\n\ncontract IToken {\n    \n    /**\n     * Returns the balance of the `who` address.\n     */\n    function balanceOf(address who) public view returns (uint);\n        \n    /**\n     * Transfers `value` tokens from `msg.sender` to `to` address\n     * and returns `true` on success.\n     */\n    function transfer(address to, uint value) public returns (bool success);\n        \n    /**\n     * Transfers `value` tokens from `msg.sender` to `to` address with `data` parameter\n     * and returns `true` on success.\n     */\n    function transfer(address to, uint value, bytes memory data) public returns (bool success);\n     \n     /**\n     * Event that is fired on successful transfer.\n     */\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\n"},"Migrations.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.7.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.1;\n\n/**\n * Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"},"Token.sol":{"content":"pragma solidity ^0.5.1;\n\nimport \"./IToken.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./TokenReceiver.sol\";\n\n/**\n * @title Reference implementation of the ERC223 standard token.\n */\ncontract XlpToken is IToken, TokenReceiver {\n    using SafeMath for uint;\n\n    string public constant name = \"Leviar Platform Token\";\n    string public constant symbol = \"XLP\";\n    uint8 public constant decimals = 8;\n    uint public _totalSupply = 20000000 * 100000000; //20,000,000.0000 0000 XLP\n\n    /**\n     * Constructor\n     */\n    constructor() public {\n        balances[msg.sender] = totalSupply();\n    }\n\n    /**\n     * Returns total supply\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    mapping(address =\u003e uint) balances; // List of user balances.\n\n    /**\n     *      Transfer the specified amount of tokens to the specified address.\n     *      Invokes the `tokenFallback` function if the recipient is a contract.\n     *      The token transfer fails if the recipient is a contract\\\n     *      but does not implement the `tokenFallback` function\n     *      or the fallback function to receive funds.\n     *\n     * @param _to    Receiver address.\n     * @param _value Amount of tokens that will be transferred.\n     * @param _data  Transaction metadata.\n     */\n    function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\n        // Standard function transfer similar to ERC20 transfer with no _data .\n        // Added due to backwards compatibility reasons .\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        if (Address.isContract(_to)) {\n            TokenReceiver receiver = TokenReceiver(_to);\n            receiver.tokenFallback(msg.sender, _value, _data);\n        }\n        emit Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /**\n     *      Transfer the specified amount of tokens to the specified address.\n     *      This function works the same with the previous one\n     *      but doesn\u0027t contain `_data` param.\n     *      Added due to backwards compatibility reasons.\n     *\n     * @param _to    Receiver address.\n     * @param _value Amount of tokens that will be transferred.\n     */\n    function transfer(address _to, uint _value) public returns (bool success){\n        bytes memory empty = hex\"00000000\";\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        if (Address.isContract(_to)) {\n            TokenReceiver receiver = TokenReceiver(_to);\n            receiver.tokenFallback(msg.sender, _value, empty);\n        }\n        emit Transfer(msg.sender, _to, _value, empty);\n        return true;\n    }\n\n    /**\n     * Returns balance of the `_owner`.\n     *\n     * @param _owner   The address whose balance will be returned.\n     * @return balance Balance of the `_owner`.\n     */\n    function balanceOf(address _owner) public view returns (uint balance) {\n        return balances[_owner];\n    }\n\n    function tokenFallback(address _from, uint _value, bytes memory _data) public {\n        revert();\n    }\n\n    /**\n     * Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 _amount) public {\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n        _totalSupply = _totalSupply.sub(_amount);\n\n        bytes memory empty = hex\"00000000\";\n        emit Transfer(msg.sender, address(0), _amount, empty);\n    }\n}\n"},"TokenReceiver.sol":{"content":"pragma solidity ^0.5.1;\n\ncontract TokenReceiver {\n/**\n * Standard ERC223 function that will handle incoming token transfers.\n *\n * @param _from  Token sender address.\n * @param _value Amount of tokens.\n * @param _data  Transaction metadata.\n */\n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\n}\n"}}