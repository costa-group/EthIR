{"Whitelist.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2019-05-01\n*/\n\npragma solidity 0.5.6;\n\n/// @author The Calystral Team\n/// @title A subscriber contract\ncontract Whitelist {\n    /// This mapping contains the index and subscriber addresses.\n    mapping (uint =\u003e address) subscriberIndexToAddress;\n\n    /// This mapping contains the addresses and subscriber status.\n    mapping (address =\u003e uint) subscriberAddressToSubscribed;\n\n    /// The current subscriber index.\n    /// Caution: This wiil be likely unequal to the actual subscriber amount.\n    /// This will be used as the index of a new subscriber.\n    /// We start at 1 because 0 will be the indicator that an address is not a subscriber.\n    uint subscriberIndex = 1;\n\n    /// This event will be triggered when a subscription was done.\n    event OnSubscribed(address subscriberAddress);\n\n    /// This event will be triggered when a subscription was revoked.\n    event OnUnsubscribed(address subscriberAddress);\n\n    /// This modifier prevents other smart contracts from subscribing.\n    modifier isNotAContract(){\n        require (msg.sender == tx.origin, \"Contracts are not allowed to interact.\");\n        _;\n    }\n    \n    /// Fall back to the subscribe function if no specific function was called.\n    function() external {\n        subscribe();\n    }\n    \n    /// Gets the subscriber list.\n    function getSubscriberList() external view returns (address[] memory) {\n        uint subscriberListAmount = getSubscriberAmount();\n        \n        address[] memory subscriberList = new address[](subscriberListAmount);\n        uint subscriberListCounter = 0;\n        \n        /// Iterate over all subscriber addresses, to fill the subscriberList.\n        for (uint i = 1; i \u003c subscriberIndex; i++) {\n            address subscriberAddress = subscriberIndexToAddress[i];\n\n            /// Add the addresses which are actual subscribers only.\n            if (isSubscriber(subscriberAddress) == true) {\n                subscriberList[subscriberListCounter] = subscriberAddress;\n                subscriberListCounter++;\n            }\n        }\n\n        return subscriberList;\n    }\n\n    /// Gets the amount of subscriber.\n    function getSubscriberAmount() public view returns (uint) {\n        uint subscriberListAmount = 0;\n\n        /// Iterate over all subscriber addresses, to get the actual subscriber amount.\n        for (uint i = 1; i \u003c subscriberIndex; i++) {\n            address subscriberAddress = subscriberIndexToAddress[i];\n            \n            /// Count the addresses which are actual subscribers only.\n            if (isSubscriber(subscriberAddress) == true) {\n                subscriberListAmount++;\n            }\n        }\n\n        return subscriberListAmount;\n    }\n\n    /// The sender\u0027s address will be added to the subscriber list\n    function subscribe() public isNotAContract {\n        require(isSubscriber(msg.sender) == false, \"You already subscribed.\");\n        \n        // New subscriber\n        subscriberAddressToSubscribed[msg.sender] = subscriberIndex;\n        subscriberIndexToAddress[subscriberIndex] = msg.sender;\n        subscriberIndex++;\n\n        emit OnSubscribed(msg.sender);\n    }\n\n    /// The sender\u0027s subscribtion will be revoked.\n    function unsubscribe() external isNotAContract {\n        require(isSubscriber(msg.sender) == true, \"You have not subscribed yet.\");\n\n        uint index = subscriberAddressToSubscribed[msg.sender];\n        delete subscriberIndexToAddress[index];\n\n        emit OnUnsubscribed(msg.sender);\n    }\n    \n    /// Checks wheter the transaction origin address is in the subscriber list\n    function isSubscriber() external view returns (bool) {\n        return isSubscriber(tx.origin);\n    }\n\n    /// Checks wheter the given address is in the subscriber list\n    function isSubscriber(address subscriberAddress) public view returns (bool) {\n        return subscriberIndexToAddress[subscriberAddressToSubscribed[subscriberAddress]] != address(0);\n    }\n}"},"WhitelistAdvanced.sol":{"content":"pragma solidity 0.5.6;\n\nimport \"./Whitelist.sol\";\n\n/// @author The Calystral Team\n/// @title A subscriber contract\n/// @notice A whitelist, which is maintained to grant extras to the community\ncontract WhitelistAdvanced {\n    /// @dev Maps the subscriber index to an address\n    mapping (uint256 =\u003e address) internal subscriberIndexToAddress;\n    /// @dev Maps the subscriber address to the subscriber index or 0 if not subscriped.\n    mapping (address =\u003e uint256) internal subscriberAddressToSubscribed;\n    /// @dev Maps the subscriber address to the blocknumber of subscription or 0 if not subscriped.\n    mapping (address =\u003e uint256) internal subscriberAddressToBlockNumber;\n\n    /// @dev The legacy whitelist contract.\n    Whitelist internal whitelistContract = Whitelist(0x6198149b79AFE8114dc07b46A01d94a6af304ED9);\n\n    /// @dev Used to point towards the subscriber address. Caution: This will be likely unequal to the actual subscriber count. We start at 1 because 0 will be the indicator that an address is not a subscriber.\n    uint256 internal subscriberIndex = 1;\n\n    /** @dev Emits on successful subscription.\n      * @param _subscriberAddress The address of the subscriber.\n      */\n    event OnSubscribed(address _subscriberAddress);\n    /** @dev Emits on successful unsubscription.\n      * @param _subscriberAddress The address of the unsubscriber.\n      */\n    event OnUnsubscribed(address _subscriberAddress);\n\n    /// @notice This modifier prevents other smart contracts from subscribing.\n    modifier isNotAContract(){\n        require (msg.sender == tx.origin, \"Contracts are not allowed to interact.\");\n        _;\n    }\n    \n    /** @notice Creates the smart contract and initializes the whitelist.\n      * @dev The constructor, which initializes the whitelist by scraping all the subscribers from the legacy contract. Legacy subscribers are initialized by the current block number.\n      */\n    constructor() public {\n        address[] memory subscriberList = whitelistContract.getSubscriberList();\n        for (uint256 i = 0; i \u003c subscriberList.length; i++) {\n            _subscribe(subscriberList[i]);\n        }\n    }\n\n    /** @notice Calls the subscribe function if no specific function was called.\n      * @dev Fallback function forwards to subscribe function.\n      */\n    function() external {\n        subscribe();\n    }\n\n    /** @notice Shows the whole subscriber list.\n      * @dev Returns all current subscribers as an address array.\n      * @return A list of subscriber addresses.\n      */\n    function getSubscriberList() external view returns (address[] memory) {\n        uint256 subscriberListCounter = 0;\n        uint256 subscriberListCount = getSubscriberCount();        \n        address[] memory subscriberList = new address[](subscriberListCount);\n        \n        for (uint256 i = 1; i \u003c subscriberIndex; i++) {\n            address subscriberAddress = subscriberIndexToAddress[i];\n            if (isSubscriber(subscriberAddress) != 0) {\n                subscriberList[subscriberListCounter] = subscriberAddress;\n                subscriberListCounter++;\n            }\n        }\n\n        return subscriberList;\n    }\n\n    /** @notice Shows the count of subscribers.\n      * @dev Returns the subscriber count as an integer.\n      * @return The count of subscribers.\n      */\n    function getSubscriberCount() public view returns (uint256) {\n        uint256 subscriberListCount = 0;\n\n        for (uint256 i = 1; i \u003c subscriberIndex; i++) {\n            address subscriberAddress = subscriberIndexToAddress[i];\n            if (isSubscriber(subscriberAddress) != 0) {\n                subscriberListCount++;\n            }\n        }\n\n        return subscriberListCount;\n    }\n\n    /** @notice Any user can add him or herself to the subscriber list.\n      * @dev Subscribes the message sender to the list. Other contracts are not allowed to subscribe.\n      */\n    function subscribe() public isNotAContract {\n        _subscribe(msg.sender);\n    }\n\n    /** @dev This function is necessary, so it can be used by the constructor. Nobody should be able to add other people to the list.\n      * @param _subscriber The user address, which should be added.\n      */\n    function _subscribe(address _subscriber) internal {\n        require(isSubscriber(_subscriber) == 0, \"You already subscribed.\");\n        \n        subscriberAddressToSubscribed[_subscriber] = subscriberIndex;\n        subscriberAddressToBlockNumber[_subscriber] = block.number;\n        subscriberIndexToAddress[subscriberIndex] = _subscriber;\n        subscriberIndex++;\n\n        emit OnSubscribed(_subscriber);\n    }\n\n    /** @notice Any user can revoke his or her subscription.\n      * @dev Deletes the index entry in the subscriberIndexToAddress mapping for the message sender.\n      */\n    function unsubscribe() external isNotAContract {\n        require(isSubscriber(msg.sender) != 0, \"You have not subscribed yet.\");\n\n        uint256 index = subscriberAddressToSubscribed[msg.sender];\n        delete subscriberIndexToAddress[index];\n\n        emit OnUnsubscribed(msg.sender);\n    }\n    \n    /** @notice Checks wether a user is in the subscriber list.\n      * @dev tx.origin is used instead of msg.sender so other contracts may forward a user request (e.g. limited rewards contract).\n      * @return The blocknumber at which the user has subscribed or 0 if not subscribed at all.\n      */\n    function isSubscriber() external view returns (uint256) {\n        return isSubscriber(tx.origin);\n    }\n\n    /** @notice Checks wheter the given address is in the subscriber list.\n      * @dev This function isn\u0027t external since it\u0027s used by the contract as well.\n      * @param _subscriberAddress The address to check for.\n      * @return The blocknumber at which the user has subscribed or 0 if not subscribed at all.\n      */\n    function isSubscriber(address _subscriberAddress) public view returns (uint256) {\n        if (subscriberIndexToAddress[subscriberAddressToSubscribed[_subscriberAddress]] != address(0)){\n            return subscriberAddressToBlockNumber[_subscriberAddress];\n        } else {\n            return 0;\n        }\n    }\n}"}}