{"OpenOracleData.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\n/**\n * @title The Open Oracle Data Base Contract\n * @author Compound Labs, Inc.\n */\ncontract OpenOracleData {\n    /**\n     * @notice The event emitted when a source writes to its storage\n     */\n    //event Write(address indexed source, \u003cKey\u003e indexed key, string kind, uint64 timestamp, \u003cValue\u003e value);\n\n    /**\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\n     * @param message The payload containing the timestamp, and (key, value) pairs\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n     * @return The keys that were written\n     */\n    //function put(bytes calldata message, bytes calldata signature) external returns (\u003cKey\u003e memory);\n\n    /**\n     * @notice Read a single key with a pre-defined type signature from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The claimed Unix timestamp for the data and the encoded value (defaults to (0, 0x))\n     */\n    //function get(address source, \u003cKey\u003e key) external view returns (uint, \u003cValue\u003e);\n\n    /**\n     * @notice Recovers the source address which signed a message\n     * @dev Comparing to a claimed address would add nothing,\n     *  as the caller could simply perform the recover and claim that address.\n     * @param message The data that was presumably signed\n     * @param signature The fingerprint of the data + private key\n     * @return The source address which signed the message, presumably\n     */\n    function source(bytes memory message, bytes memory signature) public pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = abi.decode(signature, (bytes32, bytes32, uint8));\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(message)));\n        return ecrecover(hash, v, r, s);\n    }\n}\n"},"OpenOraclePriceData.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.10;\n\nimport \"./OpenOracleData.sol\";\n\n/**\n * @title The Open Oracle Price Data Contract\n * @notice Values stored in this contract should represent a USD price with 6 decimals precision\n * @author Compound Labs, Inc.\n */\ncontract OpenOraclePriceData is OpenOracleData {\n    ///@notice The event emitted when a source writes to its storage\n    event Write(address indexed source, string key, uint64 timestamp, uint64 value);\n    ///@notice The event emitted when the timestamp on a price is invalid and it is not written to storage\n    event NotWritten(uint64 priorTimestamp, uint256 messageTimestamp, uint256 blockTimestamp);\n\n    ///@notice The fundamental unit of storage for a reporter source\n    struct Datum {\n        uint64 timestamp;\n        uint64 value;\n    }\n\n    /**\n     * @dev The most recent authenticated data from all sources.\n     *  This is private because dynamic mapping keys preclude auto-generated getters.\n     */\n    mapping(address =\u003e mapping(string =\u003e Datum)) private data;\n\n    /**\n     * @notice Write a bunch of signed datum to the authenticated storage mapping\n     * @param message The payload containing the timestamp, and (key, value) pairs\n     * @param signature The cryptographic signature of the message payload, authorizing the source to write\n     * @return The keys that were written\n     */\n    function put(bytes calldata message, bytes calldata signature) external returns (string memory) {\n        (address source, uint64 timestamp, string memory key, uint64 value) = decodeMessage(message, signature);\n        return putInternal(source, timestamp, key, value);\n    }\n\n    function putInternal(address source, uint64 timestamp, string memory key, uint64 value) internal returns (string memory) {\n        // Only update if newer than stored, according to source\n        Datum storage prior = data[source][key];\n        if (timestamp \u003e prior.timestamp \u0026\u0026 timestamp \u003c block.timestamp + 60 minutes \u0026\u0026 source != address(0)) {\n            data[source][key] = Datum(timestamp, value);\n            emit Write(source, key, timestamp, value);\n        } else {\n            emit NotWritten(prior.timestamp, timestamp, block.timestamp);\n        }\n        return key;\n    }\n\n    function decodeMessage(bytes calldata message, bytes calldata signature) internal pure returns (address, uint64, string memory, uint64) {\n        // Recover the source address\n        address source = source(message, signature);\n\n        // Decode the message and check the kind\n        (string memory kind, uint64 timestamp, string memory key, uint64 value) = abi.decode(message, (string, uint64, string, uint64));\n        require(keccak256(abi.encodePacked(kind)) == keccak256(abi.encodePacked(\"prices\")), \"Kind of data must be \u0027prices\u0027\");\n        return (source, timestamp, key, value);\n    }\n\n    /**\n     * @notice Read a single key from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The claimed Unix timestamp for the data and the price value (defaults to (0, 0))\n     */\n    function get(address source, string calldata key) external view returns (uint64, uint64) {\n        Datum storage datum = data[source][key];\n        return (datum.timestamp, datum.value);\n    }\n\n    /**\n     * @notice Read only the value for a single key from an authenticated source\n     * @param source The verifiable author of the data\n     * @param key The selector for the value to return\n     * @return The price value (defaults to 0)\n     */\n    function getPrice(address source, string calldata key) external view returns (uint64) {\n        return data[source][key].value;\n    }\n}\n"}}