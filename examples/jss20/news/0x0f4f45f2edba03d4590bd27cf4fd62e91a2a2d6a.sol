{"AssetSwap.sol":{"content":"pragma solidity 0.6.3;\n\nimport \"./Book.sol\";\nimport \"./Oracle.sol\";\n\n/**\nMIT License\nCopyright © 2020 Eric G. Falkenstein\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\n OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\ncontract AssetSwap {\n\n    constructor (address priceOracle, int _levRatio)\n        public {\n            administrators[msg.sender] = true;\n            feeAddress = msg.sender;\n            oracle = Oracle(priceOracle);\n            levRatio = _levRatio;\n        }\n\n    Oracle public oracle;\n    int[5][2] public assetReturns; /// these are pushed by the oracle each week\n    int public levRatio;\n    uint public lastOracleSettleTime; /// updates at time of oracle settlement.\n    /// Used a lot so this is written to the contract\n    mapping(address =\u003e address) public books;  /// LP eth address to book contract address\n    mapping(address =\u003e uint) public assetSwapBalance;  /// how ETH is ultimately withdrawn\n    mapping(address =\u003e bool) public administrators;  /// gives user right to key functions\n    address payable public feeAddress;   /// address for oracle fees\n\n    event SubkTracker(\n        address indexed eLP,\n        address indexed eTaker,\n        bytes32 eSubkID,\n        bool eisOpen);\n\n    event BurnHist(\n        address eLP,\n        bytes32 eSubkID,\n        address eBurner,\n        uint eTime);\n\n    event LPNewBook(\n        address indexed eLP,\n        address eLPBook);\n\n    event RatesUpdated(\n        address indexed eLP,\n        uint8 closefee,\n        int16 longFundingRate,\n        int16 shortFundingRate\n        );\n\n    modifier onlyAdmin() {\n        require(administrators[msg.sender], \"admin only\");\n        _;\n    }\n\n    function removeAdmin(address toRemove)\n        external\n        onlyAdmin\n    {\n        require(toRemove != msg.sender, \"You may not remove yourself as an admin.\");\n        administrators[toRemove] = false;\n    }\n\n    /** Grant administrator priviledges to a user\n    * @param newAdmin the address to promote\n    */\n    function addAdmin(address newAdmin)\n        external\n        onlyAdmin\n    {\n        administrators[newAdmin] = true;\n    }\n\n    function adjustMinRM(uint16 _min)\n        external\n    {\n        require(books[msg.sender] != address(0), \"User must have a book\");\n        require(_min \u003e= 1);\n        Book b = Book(books[msg.sender]);\n        b.adjustMinRMBook(_min);\n    }\n\n    /** data are input in basis points as a percent of national\n    * thus 10 is 0.1% of notional, which when applied to the crypto\n    * with 2.5 leverage, generates a 0.25% of RM charge. funding rates\n    * can be negative, which implies the taker receives a payment.\n    * if you change the fees so they can be greater than 2.5% of RM,\n    * say X, you must adjustn the Oracle contract to have a maximum value of\n    * 1 - X, so that player RM can cover every conceivable scenario\n    */\n    function updateFees(uint newClose, int frLong, int frShort)\n        external\n    {\n        require(books[msg.sender] != address(0), \"User must have a book\");\n        /// data are input as basis points of notional, adjusted to bps of RM to simplify calculations\n        /// thus for the spx, the leverage ratio is 1000, and so dividing it by 1e2 gives 10\n        /// Thus for the spx, a long rate of 0.21% per week, applied to the notional,\n        /// is 2.1% per week applied to the RM\n        int longRate = frLong * levRatio / 1e2;\n        int shortRate = frShort * levRatio / 1e2;\n        uint closefee = newClose * uint(levRatio) / 1e2;\n        /// fees are capped to avoid predatory pricing that would potentially besmirch OracleSwap\u0027s reputation\n        require(closefee \u003c= 250);\n        require(longRate \u003c= 250 \u0026\u0026 longRate \u003e= -250);\n        require(shortRate \u003c= 250 \u0026\u0026 shortRate \u003e= -250);\n        Book b = Book(books[msg.sender]);\n        b.updateFeesBook(uint8(closefee), int16(longRate), int16(shortRate));\n        emit RatesUpdated(msg.sender, uint8(closefee), int16(longRate), int16(shortRate));\n    }\n\n    function changeFeeAddress(address payable newAddress)\n        external\n        onlyAdmin\n    {\n        feeAddress = newAddress;\n    }\n    /** this is where money is sent from the Book contract to a player\u0027s account\n    * the player can then withdraw this to their personal address\n    */\n\n    function balanceInput(address recipient)\n            external\n            payable\n    {\n        assetSwapBalance[recipient] += msg.value;\n    }\n\n    /** fees are in basis points of national, as in the case when updating the fees\n    * minimum RM is in Szabo, so 4 would imply a minimum RM of 4 Szabo\n    */\n    function createBook(uint16 _min, uint _closefee, int frLong, int frShort)\n        external\n        payable\n        returns (address newBook)\n    {\n        require(books[msg.sender] == address(0), \"User must not have a preexisting book\");\n        require(msg.value \u003e= uint(_min) * 10 szabo, \"Must prep for book\");\n        require(_min \u003e= 1);\n        int16 longRate = int16(frLong * levRatio / 1e2);\n        int16 shortRate = int16(frShort * levRatio / 1e2);\n        uint8 closefee = uint8(_closefee * uint(levRatio) / 1e2);\n        require(longRate \u003c= 250 \u0026\u0026 longRate \u003e= -250);\n        require(shortRate \u003c= 250 \u0026\u0026 shortRate \u003e= -250);\n        require(closefee \u003c= 250);\n        books[msg.sender] = address(new Book(msg.sender, address(this), _min, closefee, longRate, shortRate));\n        Book b = Book(books[msg.sender]);\n        b.fundLPBook.value(msg.value)();\n        emit LPNewBook(msg.sender, books[msg.sender]);\n        return books[msg.sender];\n    }\n\n    function fundLP(address _lp)\n        external\n        payable\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        b.fundLPBook.value(msg.value)();\n    }\n\n    function fundTaker(address _lp, bytes32 subkID)\n        external\n        payable\n        {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        b.fundTakerBook.value(msg.value)(subkID);\n    }\n\n    function burnTaker(address _lp, bytes32 subkID)\n        external\n        payable\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        uint refund = b.burnTakerBook(subkID, msg.sender, msg.value);\n        emit BurnHist(_lp, subkID, msg.sender, now);\n        assetSwapBalance[msg.sender] += refund;\n    }\n\n    function burnLP()\n        external\n        payable\n    {\n        require(books[msg.sender] != address(0));\n        Book b = Book(books[msg.sender]);\n        uint refund = b.burnLPBook(msg.value);\n        bytes32 abcnull;\n        emit BurnHist(msg.sender, abcnull, msg.sender, now);\n        assetSwapBalance[msg.sender] += refund;\n    }\n\n    function cancel(address _lp, bytes32 subkID, bool closeNow)\n        external\n        payable\n    {\n        require(hourOfDay() != 16, \"Cannot cancel during 4 PM ET hour\");\n        Book b = Book(books[_lp]);\n        uint8 priceDay = oracle.getStartDay();\n        uint8 endDay = 5;\n        if (closeNow)\n            endDay = priceDay;\n        b.cancelBook.value(msg.value)(lastOracleSettleTime, subkID, msg.sender, endDay);\n    }\n\n    function closeBook(address _lp)\n        external\n        payable\n    {\n        require(msg.sender == _lp);\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        b.closeBookBook.value(msg.value)();\n    }\n\n    function redeem(address _lp, bytes32 subkID)\n        external\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        b.redeemBook(subkID, msg.sender);\n        emit SubkTracker(_lp, msg.sender, subkID, false);\n    }\n      /** once started, this process requires a total of at least 4 separate executions.\n      * Each execution is limited to processing 200 subcontracts to avoid gas limits, so if there\n      * are more than 200 accounts in any step they will have to be executed multiple times\n      * eg, 555 new accounts would require 3 executions of that step\n      */\n\n    function settleParts(address _lp)\n        external\n        returns (bool isComplete)\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        uint lastBookSettleTime = b.lastBookSettleTime();\n        require(now \u003e (lastOracleSettleTime + 24 hours));\n        require(lastOracleSettleTime \u003e lastBookSettleTime, \"one settle per week\");\n        uint settleNumb = b.settleNum();\n        if (settleNumb \u003c 1e4) {\n            b.settleExpiring(assetReturns[1]);\n        } else if (settleNumb \u003c 2e4) {\n            b.settleRolling(assetReturns[0][0]);\n        } else if (settleNumb \u003c 3e4) {\n            b.settleNew(assetReturns[0]);\n        } else if (settleNumb == 3e4) {\n            b.settleFinal();\n            isComplete = true;\n        }\n    }\n\n    function settleBatch(address _lp)\n        external\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        uint lastBookSettleTime = b.lastBookSettleTime();\n        require(now \u003e (lastOracleSettleTime + 24 hours));\n        require(lastOracleSettleTime \u003e lastBookSettleTime, \"one settle per week\");\n        /// the 5x1 vector of returns in units of szabo, where 0.6 is a +60% of RM payoff,\n        /// -0.6 is a -60% of RM payoff. The refer to initial price days to settlement day\n        b.settleExpiring(assetReturns[1]);\n        /// this is the settle to settle return\n        b.settleRolling(assetReturns[0][0]);\n        /// this is the return from the last settlement day to the price day\n        /// for regular closes, the price day == 5, so it is a settlement to settlement return\n        b.settleNew(assetReturns[0]);\n        b.settleFinal();\n    }\n\n    function take(address _lp, uint rm, bool isTakerLong)\n        external\n        payable\n        returns (bytes32 newsubkID)\n    {\n        require(rm \u003c 3, \"above max size\"); // This is to make this contract economically trivial\n        /// a real contract would allow positions much greater than 2 szabos\n        rm = rm * 1 szabo;\n        require(msg.value \u003e= 3 * rm / 2, \"Insuffient ETH for your RM\");\n        require(hourOfDay() != 16, \"Cannot take during 4 PM ET hour\");\n\n        uint takerLong;\n        if (isTakerLong)\n            takerLong = 1;\n        else\n            takerLong = 0;\n        /// starting price is taken from the oracle contract based on what the next price day is\n        uint8 priceDay = oracle.getStartDay();\n        Book book = Book(books[_lp]);\n        newsubkID = book.takeBook.value(msg.value)(msg.sender, rm, lastOracleSettleTime, priceDay, takerLong);\n        emit SubkTracker(_lp, msg.sender, newsubkID, true);\n    }\n\n    /** withdraw amounts are in 1/1000 of the unit of denomination\n    * Thus, 1234 is 1.234 Szabo\n    */\n    function withdrawLP(uint amount)\n        external\n    {\n        require(amount \u003e 0);\n        require(books[msg.sender] != address(0));\n        Book b = Book(books[msg.sender]);\n        amount = 1e9 * amount;\n        b.withdrawLPBook(amount, lastOracleSettleTime);\n    }\n\n    function withdrawTaker(uint amount, address _lp, bytes32 subkID)\n        external\n    {\n        require(amount \u003e 0);\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        amount = 1e9 * amount;\n        b.withdrawTakerBook(subkID, amount, lastOracleSettleTime, msg.sender);\n    }\n    /// one can withdraw from one\u0027s assetSwap balance at any time. It can only send the entire amount\n\n    function withdrawFromAssetSwap()\n        external\n    {\n        uint amount = assetSwapBalance[msg.sender];\n        require(amount \u003e 0);\n        assetSwapBalance[msg.sender] = 0;\n        msg.sender.transfer(amount);\n    }\n\n    function inactiveOracle(address _lp)\n        external\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        b.inactiveOracleBook();\n    }\n\n    function inactiveLP(address _lp, bytes32 subkID)\n        external\n    {\n        require(books[_lp] != address(0));\n        Book b = Book(books[_lp]);\n        b.inactiveLPBook(subkID, msg.sender, lastOracleSettleTime);\n    }\n\n    function getBookData(address _lp)\n        external\n        view\n        returns (address book,\n            // balances in wei\n            uint lpMargin,\n            uint totalLpLong,\n            uint totalLpShort,\n            uint lpRM,\n            /// in Szabo\n            uint bookMinimum,\n            /// in basis points as a percent of RM\n            /// to convert to notional, we multiply by the leverage ratio\n            int16 longFundingRate,\n            int16 shortFundingRate,\n            uint8 lpCloseFee,\n            /** 0 is fine, 1 means book cancels at next settlement\n            * 2 means LP burned (which cancels the book at next settlement)\n            * 3 book is inactive, no more settling or new positions\n            */\n            uint8 bookStatus\n            )\n    {\n        book = books[_lp];\n        if (book != address(0)) {\n            Book b = Book(book);\n            lpMargin = b.margin(0);\n            totalLpLong = b.margin(1);\n            totalLpShort = b.margin(2);\n            lpRM = b.margin(3);\n            bookMinimum = b.lpMinTakeRM();\n            longFundingRate = b.fundingRates(1);\n            shortFundingRate = b.fundingRates(0);\n            lpCloseFee = b.bookCloseFee();\n            bookStatus = b.bookStatus();\n        }\n    }\n\n    function getSubkData1(address _lp, bytes32 subkID)\n        external\n        view\n        returns (\n            address taker,\n            /// in wei\n            uint takerMargin,\n            uint reqMargin\n            )\n    {\n        address book = books[_lp];\n        if (book != address(0)) {\n            Book b = Book(book);\n            (taker, takerMargin, reqMargin) = b.getSubkData1Book(subkID);\n        }\n    }\n\n    function getSubkData2(address _lp, bytes32 subkID)\n        external\n        view\n        returns (\n          /** 0 new, 1 active and rolled over, 2 taker cancelled, 3 LP cancelled,\n          * 4 intraweek cancelled, 5 taker burned, 6 taker default/redeemable, 7 inactive/redeemable\n          */\n            uint8 subkStatus,\n          /// for new and expiring subcontracts, either the start or end price that week\n            uint8 priceDay,\n          /** the LP\u0027s closing fee, in basis points as a percent of the RM. The total closing fee\n          * is this plus 2.5% of RM, the oracle\u0027s fee\n          */\n            uint8 closeFee,\n          /// the funding rate paid by the taker, which may be negative\n            int16 fundingRate,\n          /// true for taker is long (and thus LP is short)\n            bool takerSide\n            )\n    {\n        address book = books[_lp];\n        if (book != address(0)) {\n            Book b = Book(book);\n            (subkStatus, priceDay, closeFee, fundingRate, takerSide)\n                = b.getSubkData2Book(subkID);\n        }\n    }\n\n    function getSettleInfo(address _lp)\n        external\n        view\n        returns (\n          /// total number of taker subcontracts, including new, rolled-over, cancelled, and inactive subcontracts\n            uint totalLength,\n          /// taker subcontracts that are expiring at next settlement\n            uint expiringLength,\n          /// taker subcontracts that have not yet settled. Such positions cannot be cancelled. The next week,\n          /// they will be \u0027active\u0027, and cancelable.\n            uint newLength,\n          /// time of last book settlement, in seconds from 1970, Greenwich Mean Time\n            uint lastBookSettleUTC,\n          /// this is used for assessing the progress of a settlement when it is too large to be\n          /// executed in batch.\n            uint settleNumber,\n          /// amount of ETH in the LP book\n            uint bookBalance,\n          /// an LP can close they book en masse, which would push the maturity of the book to 28 days after\n          /// the close is instantiated. Takers should take note. A taker does not pay a cancel fee when\n          /// the LP cancels their book, but they must then wait until the final settlement\n            uint bookMaturityUTC\n            )\n    {\n        address book = books[_lp];\n        if (book != address(0)) {\n            Book b = Book(book);\n            (totalLength, expiringLength, newLength, lastBookSettleUTC, settleNumber,\n                bookBalance, bookMaturityUTC) = b.getSettleInfoBook();\n        }\n    }\n\n    /**\n    * This gives the raw asset returns for all potential start and end dates: 5 different returns\n    * for new positions (price day to settlement day), and 5 for expiring positions (last settlement to price day)\n    * these are posted by the Oracle at the settlemnet price update.\n    * They are in % return * Leverage Ratio times 1 Szabo,\n    * this allows the books to simply apply these numbers to the RM of the various subcontracts to generate the\n    * weekly PNL. They are capped at +/- 0.975e12 (the unit of account in this contract, szabo),\n    * so that the extreme case of a maximum funding rate, the liability\n    * is never greater than 1 Szabo. This effectively caps player liability at their RM\n    */\n    function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\n            public\n        {\n        require(msg.sender == address(oracle));\n        assetReturns[0] = assetRetNew;\n        assetReturns[1] = assetRetExp;\n        lastOracleSettleTime = now;\n    }\n\n    function hourOfDay()\n        public\n        view\n        returns(uint hour1)\n    {\n        uint nowTemp = now;\n    /**\n    * 2020 Summer, 1583668800 = March 8 2020 through 1604232000 = November 1 2020\n    * 2021 Summer, 1615705200 = March 14 2021 through 1636264800 = November 7 2021\n    * 2022 summer, 1647154800 = March 13 2022 through 1667714400 = November 6 2022\n    * summer is Daylight Savings Time in the US, where the hour is GMT - 5 in New York City\n    * winter is Standard Time in the US, where the hour is GMT - 4 in New York City\n    * No takes from 4-5 PM NYC time, so hour == 16 is the exclusion time\n    * hour1 takes the number of seconds in the day at this time (nowTemp % 86400),\n    * and divideds by the number of seconds in an hour 3600\n    */\n        hour1 = (nowTemp % 86400) / 3600 - 5;\n        if ((nowTemp \u003e 1583668800 \u0026\u0026 nowTemp \u003c 1604232000) || (nowTemp \u003e 1615705200 \u0026\u0026 nowTemp \u003c 1636264800) ||\n            (nowTemp \u003e 1647154800 \u0026\u0026 nowTemp \u003c 1667714400))\n            hour1 = hour1 + 1;\n    }\n\n    function subzero(uint _a, uint _b)\n        internal\n        pure\n        returns (uint)\n    {\n        if (_b \u003e= _a) {\n            return 0;\n        }\n        return _a - _b;\n    }\n\n\n}\n"},"Book.sol":{"content":"pragma solidity 0.6.3;\n\nimport \"./AssetSwap.sol\";\n\n/**\nMIT License\nCopyright © 2020 Eric G. Falkenstein\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\n OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\ncontract Book {\n\n    constructor(address user, address admin, uint16 minReqMarg, uint8 closefee,\n        int16 fundRateLong, int16 fundRateShort)\n        public {\n            assetSwap = AssetSwap(admin);\n            lp = user;\n            lpMinTakeRM = minReqMarg;\n            lastBookSettleTime = now;\n            bookCloseFee = closefee;\n            fundingRates[0] = fundRateShort;\n            fundingRates[1] = fundRateLong;\n            bookEndTime = now + 1100 days;\n        }\n\n    address public lp;\n    AssetSwap public assetSwap;\n    /// 0 is actual or total margin, 1 is sum of LP\u0027s short takers\n    /// 2 is sum of LP\u0027s long takers, 3 is the LP\u0027s required margin\n    /// units an in wei, and refer to the RM, not the notional\n    uint[4] public margin;\n    uint public lastBookSettleTime;\n    uint public burnFactor = 1 szabo;\n    uint public settleNum;\n    int public lpSettleDebitAcct;\n    uint public bookEndTime;\n    int16[2] public fundingRates;\n    uint16 public lpMinTakeRM;\n    uint8 public bookStatus;\n    uint8 public bookCloseFee;\n    bytes32[][2] public tempContracts;\n    bytes32[] public takerContracts;\n    mapping(bytes32 =\u003e Subcontract) public subcontracts;\n\n    struct Subcontract {\n        address taker;\n        uint takerMargin;   /// in wei\n        uint requiredMargin;     /// in wei\n        uint16 index;\n        int16 fundingRate;\n        uint8 closeFee;\n        uint8 subkStatus;\n        uint8 priceDay;\n        int8 takerSide; /// 1 if long, -1 if short\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == address(assetSwap));\n        _;\n    }\n\n    function adjustMinRMBook(uint16 _min)\n        external\n        onlyAdmin\n    {\n        lpMinTakeRM = _min;\n    }\n\n    function updateFeesBook(uint8 newClose, int16 longRate, int16 shortRate)\n        external\n        onlyAdmin\n    {\n        fundingRates[0] = shortRate;\n        fundingRates[1] = longRate;\n        bookCloseFee = newClose;\n    }\n\n    function burnTakerBook(bytes32 subkID, address sender, uint msgval)\n        external\n        onlyAdmin\n        returns (uint)\n    {\n        Subcontract storage k = subcontracts[subkID];\n        require(sender == k.taker, \"must by party to his subcontract\");\n        require(settleNum == 0, \"not during settlement process\");\n        require(k.subkStatus \u003c 5, \"can only burn active subcontract\");\n        uint burnFee = k.requiredMargin / 2;\n        require(msgval \u003e= burnFee, \"Insufficient burn fee\");\n        burnFee = subzero(msgval, burnFee);\n        /** The taker\u0027s RM as a percent of the larger of the long or short\n        * side is used to decrement the credits of those at the upcoming settlement\n        * This prevents the burnFactor from going below zero. It is also the likely\n        * side of oracle cheating, as otherwise this implies a greater loss\n        * of future revenue relative to the cheat. Further, it implies the oracle\n        * \u0027left money on the table\u0027 because it did not maximize its position. This assumption,\n        * is not necessary for the incentive effect to work.\n        */\n        if (margin[1] \u003e margin[2]) {\n            burnFactor = subzero(burnFactor, 1 szabo * k.requiredMargin / margin[1]);\n        } else {\n            burnFactor = subzero(burnFactor, 1 szabo * k.requiredMargin / margin[2]);\n        }\n        k.subkStatus = 5;\n        return burnFee;\n    }\n\n    function burnLPBook(uint msgval)\n        external\n        onlyAdmin\n        returns (uint)\n    {\n        require(bookStatus != 2, \"can only burn once\");\n        /// burn fee is 50% of RM\n        uint burnFee = margin[3] / 2;\n        require(msgval \u003e= burnFee, \"Insufficient burn fee\");\n        burnFee = subzero(msgval, burnFee);\n        /** The entire LP RM as a percent of the larger of the long or short\n        * side is used to decrement the credits of those at the upcoming settlement\n        */\n        if (margin[2] \u003e margin[1]) {\n            burnFactor = subzero(burnFactor, 1 szabo * margin[3] / margin[2]);\n        } else {\n            burnFactor = subzero(burnFactor, 1 szabo * margin[3] / margin[1]);\n        }\n        bookStatus = 2;\n        return burnFee;\n    }\n\n    function cancelBook(uint lastOracleSettle, bytes32 subkID, address sender, uint8 _endDay)\n        external\n        payable\n        onlyAdmin\n    {\n        Subcontract storage k = subcontracts[subkID];\n        require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot do during settle period\");\n        require(sender == k.taker || sender == lp, \"Canceller not LP or taker\");\n        /// checks to see if subk already cancelled, as otherwise redundant\n        require(k.subkStatus == 1, \"redundant or too new\");\n        uint feeOracle = 250 * k.requiredMargin / 1e4;\n        /// users sends enough to cover the maximum cancel fee.\n        /// Cancel fee less than the maximum is just sent to the taker\u0027s margin account\n        require(msg.value \u003e= (2 * feeOracle), \"Insufficient cancel fee\");\n        uint feeLP = uint(k.closeFee) * k.requiredMargin / 1e4;\n        if (bookEndTime \u003c (now + 28 days)) {\n            feeLP = 0;\n            feeOracle = 0;\n        }\n        if (sender == k.taker \u0026\u0026 _endDay == 5) {\n            k.subkStatus = 2;  /// regular taker cancel\n        } else if (sender == k.taker) {\n            require(k.requiredMargin \u003c subzero(margin[0], margin[3]), \"Insuff LP RM for immed cancel\");\n            feeLP = feeOracle;  /// close fee is now max close fee, overriding initial close fee\n            k.subkStatus = 4;  /// immediate taker cancel\n            k.priceDay = _endDay;  /// this is the end-day of the subcontract\u0027s last week\n        } else {\n            feeOracle = 2 * feeOracle;\n            feeLP = subzero(msg.value, feeOracle); /// this is really a refund to the LP, not a fee\n            k.subkStatus = 3;  /// LP cancel\n        }\n        balanceSend(feeOracle, assetSwap.feeAddress());\n        tempContracts[1].push(subkID);  /// sets this up to settle as an expiring subcontract\n        margin[0] += feeLP;\n        k.takerMargin += subzero(msg.value, feeLP + feeOracle);\n    }\n\n    function fundLPBook()\n        external\n        onlyAdmin\n        payable\n    {\n        margin[0] += msg.value;\n    }\n\n    function fundTakerBook(bytes32 subkID)\n        external\n        onlyAdmin\n        payable\n    {\n        Subcontract storage k = subcontracts[subkID];\n        require(k.subkStatus \u003c 2);\n        k.takerMargin += msg.value;\n    }\n\n    function closeBookBook()\n        external\n        payable\n        onlyAdmin\n    { /// pays the close fee on the larger side of her book\n        uint feeOracle = 250 * (margin[1] + margin[2] - min(margin[1], margin[2])) / 1e4;\n        require(msg.value \u003e= feeOracle, \"Insufficient cancel fee\");\n        uint feeOverpay = msg.value - feeOracle;\n        balanceSend(feeOracle, assetSwap.feeAddress());\n        if (now \u003e bookEndTime)\n        /// this means the next settlement ends this book\u0027s activity\n            bookStatus = 1;\n        else\n        /// if initial, needs to be run again in 28 days to complete the shut down\n            bookEndTime = now + 28 days;\n        margin[0] += feeOverpay;\n    }\n\n    /**\n    *We only need look at when the last book settlement because\n    * if the LP was at fault, someone could have inactivatedthe LP\n    * and received a reward. Thus, the only scenario where a book\n    * can be active and the LP not inactivated, is when the oracle has been\n    * absent for a week\n    */\n    function inactiveOracleBook()\n        external\n        onlyAdmin\n        {\n        require(now \u003e (lastBookSettleTime + 10 days));\n        bookStatus = 3;\n    }\n\n    /** if the book was not settled, the LP is held accountable\n     * the first counterparty to execute this function will then get a bonus credit of their RM from  *the LP\n     * if the LP\u0027s total margin is zero, they will get whatever is there\n     * after the book is in default all players can redeem their subcontracts\n     * After a book is in default, this cannot be executed\n     */\n    function inactiveLPBook(bytes32 subkID, address sender, uint _lastOracleSettle)\n        external\n        onlyAdmin\n    {\n\n        require(bookStatus != 3);\n        Subcontract storage k = subcontracts[subkID];\n        require(k.taker == sender);\n        require(_lastOracleSettle \u003e lastBookSettleTime);\n        require(subzero(now, _lastOracleSettle) \u003e 48 hours);\n        uint lpDefFee = min(margin[0], margin[3] / 2);\n        margin[0] = subzero(margin[0], lpDefFee);\n        margin[3] = 0;\n        bookStatus = 3;\n        /// annoying, but at least someone good get the negligent LP\u0027s money\n        k.takerMargin += lpDefFee;\n    }\n\n    function redeemBook(bytes32 subkid, address sender)\n        external\n        onlyAdmin\n    {\n        Subcontract storage k = subcontracts[subkid];\n        require(k.subkStatus \u003e 5 || bookStatus == 3);\n        /// redemption can happen if the subcontract has defaulted subkStatus = 6, is inactive subkStatus = 7\n        /// or if the book is inactive (bookStatus == 3)\n        uint tMargin = k.takerMargin;\n        k.takerMargin = 0;\n        uint16 index = k.index;\n        /// iff the taker defaulted on an active book, they are penalized by\n        /// burning RM/2 of their margin\n        bool isDefaulted = (k.subkStatus == 6 \u0026\u0026 bookStatus == 0);\n        uint defPay = k.requiredMargin / 2;\n        uint lpPayment;\n        address tAddress = k.taker;\n        /// this pays the lp for the gas and effort of redeeming for the taker\n        /// The investor should now see their margin in the\n        /// assetSwapBalance, and withdraw from there. It is not meant to generate\n        /// LP profit, just pay them for the inconvenience and gas\n        if (sender == lp) {\n            lpPayment = tMargin - subzero(tMargin, 2e9);\n            tMargin -= lpPayment;\n            margin[0] += lpPayment;\n        }\n        /// this pays the lp for the gas and effort of redeeming for the taker\n        /// it\u0027s just 2 finney. The investor should now see their margin in the\n        /// assetSwapBalance, and withdraw from there\n        /** we have to pop the takerLong/Short lists to free up space\n        * this involves this little trick, moving the last row to the row we are\n        * redeeming and writing it over the redeemed subcontract\n        * then we remove the duplicate.\n        */\n        Subcontract storage lastTaker = subcontracts[takerContracts[takerContracts.length - 1]];\n        lastTaker.index = index;\n        takerContracts[index] = takerContracts[takerContracts.length - 1];\n        takerContracts.pop();\n        delete subcontracts[subkid];\n        // we only take what is there. It goes to the oracle, so if he\u0027s a cheater, you can punish\n        /// him more by withholding this payment as well as the fraudulent PNL. If he\u0027s not a cheater\n        /// then you are just negligent for defaulting and probably were not paying attention, as\n        /// you should have know you couldn\u0027t cure your margin Friday afternoon before close.\n        if (isDefaulted) {\n            tMargin = subzero(tMargin, defPay);\n            balanceSend(defPay, assetSwap.feeAddress());\n        }\n        /// money is sent to AssetSwapContract\n        balanceSend(tMargin, tAddress);\n\n    }\n\n    /** Settle the rolled over taker sukcontracts\n    * @param assetRet the returns for a long contract for a taker for only one\n    * start day, as they are all starting on the prior settlement price\n    */\n    function settleRolling(int assetRet)\n        external\n        onlyAdmin\n    {\n        require(settleNum \u003c 2e4, \"done with rolling settle\");\n        int takerRetTemp;\n        int lpTemp;\n        /// the first settlement function set the settleNum = 1e4, so that is subtracted to\n        /// see where we are in the total number of takers in the LP\u0027s book\n        uint loopCap = min(settleNum - 1e4 + 250, takerContracts.length);\n        for (uint i = (settleNum - 1e4); i \u003c loopCap; i++) {\n            Subcontract storage k = subcontracts[takerContracts[i]];\n            if (k.subkStatus == 1) {\n                takerRetTemp = int(k.takerSide) * assetRet * int(k.requiredMargin) / 1\n                szabo - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\n                lpTemp = lpTemp - takerRetTemp;\n                if (takerRetTemp \u003c 0) {\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\n                } else {\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 szabo;\n                }\n                if (k.takerMargin \u003c k.requiredMargin) {\n                    k.subkStatus = 6;\n                    if (k.takerSide == 1)\n                        margin[2] = subzero(margin[2], k.requiredMargin);\n                    else\n                        margin[1] = subzero(margin[1], k.requiredMargin);\n                }\n            }\n        }\n        settleNum += 250;\n        if ((settleNum - 1e4) \u003e= takerContracts.length)\n            settleNum = 2e4;\n        lpSettleDebitAcct += lpTemp;\n    }\n\n    /// this is the fourth and the final of the settlement functions\n    function settleFinal()\n        external\n        onlyAdmin\n    {\n        require(settleNum == 3e4, \"not done with all the subcontracts\");\n        /// this take absolute value of (long - short) to update the LP\u0027s RM\n        if (margin[2] \u003e margin[1])\n            margin[3] = margin[2] - margin[1];\n        else\n            margin[3] = margin[1] - margin[2];\n        if (lpSettleDebitAcct \u003c 0)\n            margin[0] = subzero(margin[0], uint(-lpSettleDebitAcct));\n        else\n        /// if the lpSettleDebitAcct is positive, we add it, but first apply the burnFactor\n        /// to remove the burner\u0027s pnl in a pro-rata way\n            margin[0] = margin[0] + uint(lpSettleDebitAcct) * burnFactor / 1 szabo;\n        if (bookStatus != 0) {\n            bookStatus = 3;\n            margin[3] = 0;\n        } else if (margin[0] \u003c margin[3]) {\n            // default scenario for LP\n            bookStatus = 3;\n            uint defPay = min(margin[0], margin[3] / 2);\n            margin[0] = subzero(margin[0], defPay);\n            balanceSend(defPay, assetSwap.feeAddress());\n            margin[3] = 0;\n        }\n        // resets for our next book settlement\n        lpSettleDebitAcct = 0;\n        lastBookSettleTime = now;\n        settleNum = 0;\n        delete tempContracts[1];\n        delete tempContracts[0];\n        burnFactor = 1 szabo;\n    }\n\n    /** Create a new Taker long subcontract of the given parameters\n    * @param taker the address of the party on the other side of the contract\n    * @param rM the Szabo amount in the required margin\n    * isTakerLong is +1 if taker is long, 0 if taker is short\n    * @return subkID the id of the newly created subcontract\n    */\n    function takeBook(address taker, uint rM, uint lastOracleSettle, uint8 _priceDay, uint isTakerLong)\n        external\n        payable\n        onlyAdmin\n        returns (bytes32 subkID)\n    {\n        require(bookStatus == 0, \"book no longer taking positions\");\n\n        require((now + 28 days) \u003c bookEndTime, \"book closing soon\");\n        require(rM \u003e= uint(lpMinTakeRM) * 1 szabo, \"must be greater than book min\");\n        require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot do during settle period\");\n        require(takerContracts.length \u003c 4000, \"book is full\");\n        uint availableMargin = subzero(margin[0] / 2 + margin[2 - isTakerLong], margin[1 + isTakerLong]);\n        require(rM \u003c= availableMargin \u0026\u0026 (margin[0] - margin[3]) \u003e rM);\n        require(rM \u003c= availableMargin);\n        margin[1 + isTakerLong] += rM;\n        Subcontract memory order;\n        order.requiredMargin = rM;\n        order.takerMargin = msg.value;\n        order.taker = taker;\n        order.takerSide = int8(2 * isTakerLong - 1);\n        margin[3] += rM;\n        subkID = keccak256(abi.encodePacked(now, takerContracts.length));\n        order.index = uint16(takerContracts.length);\n        order.priceDay = _priceDay;\n        order.fundingRate = fundingRates[isTakerLong];\n        order.closeFee = bookCloseFee;\n        subcontracts[subkID] = order;\n        takerContracts.push(subkID);\n        tempContracts[0].push(subkID);\n        return subkID;\n    }\n\n    /** Withdrawing margin\n    * reverts if during the settle period, oracleSettleTime \u003e book settle time\n    * also must leave total margin greater than the required margin\n    */\n    function withdrawLPBook(uint amount, uint lastOracleSettle)\n        external\n        onlyAdmin\n    {\n        require(margin[0] \u003e= amount, \"Cannot withdraw more than the margin\");\n         // if book is dead LP can take everything left, if not dead, can only take up to RM\n        if (bookStatus != 3) {\n            require(subzero(margin[0], amount) \u003e= margin[3], \"Cannot w/d more than excess margin\");\n            require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot w/d during settle period\");\n        }\n        margin[0] = subzero(margin[0], amount);\n        balanceSend(amount, lp);\n    }\n\n    function withdrawTakerBook(bytes32 subkID, uint amount, uint lastOracleSettle, address sender)\n        external\n        onlyAdmin\n    {\n        require(lastOracleSettle \u003c lastBookSettleTime, \"Cannot w/d during settle period\");\n        Subcontract storage k = subcontracts[subkID];\n        require(k.subkStatus \u003c 6, \"subk dead, must redeem\");\n        require(sender == k.taker, \"Must be taker to call this function\");\n        require(subzero(k.takerMargin, amount) \u003e= k.requiredMargin, \"cannot w/d more than excess margin\");\n        k.takerMargin = subzero(k.takerMargin, amount);\n        balanceSend(amount, k.taker);\n    }\n\n    function getSubkData1Book(bytes32 subkID)\n        external\n        view\n        returns (address takerAddress, uint takerMargin, uint requiredMargin)\n    {   Subcontract memory k = subcontracts[subkID];\n        takerAddress = k.taker;\n        takerMargin = k.takerMargin;\n        requiredMargin = k.requiredMargin;\n    }\n\n    function getSubkData2Book(bytes32 subkID)\n        external\n        view\n        returns (uint8 kStatus, uint8 priceDay, uint8 closeFee, int16 fundingRate, bool takerSide)\n    {   Subcontract memory k = subcontracts[subkID];\n        kStatus = k.subkStatus;\n        priceDay = k.priceDay;\n        closeFee = k.closeFee;\n        fundingRate = k.fundingRate;\n        if (k.takerSide == 1)\n            takerSide = true;\n    }\n\n    function getSettleInfoBook()\n        external\n        view\n        returns (uint totalLength, uint expiringLength, uint newLength, uint lastBookSettleUTC, uint settleNumber,\n            uint bookBalance, uint bookMaturityUTC)\n    {\n        totalLength = takerContracts.length;\n        expiringLength = tempContracts[1].length;\n        newLength = tempContracts[0].length;\n        lastBookSettleUTC = lastBookSettleTime;\n        settleNumber = settleNum;\n        bookMaturityUTC = bookEndTime;\n        bookBalance = address(this).balance;\n    }\n\n    /** Settle the taker long sukcontracts\n    * priceDay Expiring returns use the return from the last settle to the priceDay, which\n    * for regular cancels is just 5, the most recent settlement price\n    * this is the first of 4 settlement functions\n    * */\n    function settleExpiring(int[5] memory assetRetExp)\n        public\n        onlyAdmin\n        {\n        require(bookStatus != 3 \u0026\u0026 settleNum \u003c 1e4, \"done with expiry settle\");\n        int takerRetTemp;\n        int lpTemp;\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\n        for (uint i = settleNum; i \u003c loopCap; i++) {\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 szabo -\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\n            lpTemp -= takerRetTemp;\n            if (takerRetTemp \u003c 0) {\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\n            } else {\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 szabo;\n            }\n            if (k.takerSide == 1)\n                margin[2] = subzero(margin[2], k.requiredMargin);\n            else\n                margin[1] = subzero(margin[1], k.requiredMargin);\n            k.subkStatus = 7;\n        }\n        settleNum += 200;\n        if (settleNum \u003e= tempContracts[1].length)\n            settleNum = 1e4;\n        lpSettleDebitAcct += lpTemp;\n    }\n\n    /// this is the third of the settlement functions\n    function settleNew(int[5] memory assetRets)\n        public\n        onlyAdmin\n    {\n        require(settleNum \u003c 3e4, \"done with new settle\");\n        int takerRetTemp;\n        int lpTemp;\n        /// after running the second settlement function, settleRolling, it is set to 2e4\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\n        for (uint i = (settleNum - 2e4); i \u003c loopCap; i++) {\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\n            /// subkStatus set to \u0027active\u0027 which means it can be cancelled\n            /// it will also be settled in the settleRolling if not cancelled\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\n            k.subkStatus = 1;\n            if (k.priceDay != 5) {\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\n                szabo - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\n                lpTemp = lpTemp - takerRetTemp;\n                if (takerRetTemp \u003c 0) {\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\n                } else {\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 szabo;\n                }\n                if (k.takerMargin \u003c k.requiredMargin) {\n                    k.subkStatus = 6;\n                    if (k.takerSide == 1)\n                        margin[2] = subzero(margin[2], k.requiredMargin);\n                    else\n                        margin[1] = subzero(margin[1], k.requiredMargin);\n                }\n                k.priceDay = 5;\n            }\n        }\n        settleNum += 200;\n        if (settleNum \u003e= tempContracts[0].length)\n            settleNum = 3e4;\n        lpSettleDebitAcct += lpTemp;\n    }\n\n    /// Function to send balances back to the Assetswap contract\n    function balanceSend(uint amount, address recipient)\n        internal\n    {\n        assetSwap.balanceInput.value(amount)(recipient);\n    }\n\n    /** Utility function to find the minimum of two unsigned values\n    * @notice returns the first parameter if they are equal\n    */\n    function min(uint a, uint b)\n        internal\n        pure\n        returns (uint)\n    {\n        if (a \u003c= b)\n            return a;\n        else\n            return b;\n    }\n\n    function subzero(uint _a, uint _b)\n        internal\n        pure\n        returns (uint)\n    {\n        if (_b \u003e= _a)\n            return 0;\n        else\n            return _a - _b;\n    }\n\n\n}\n"},"ManagedAccount.sol":{"content":"pragma solidity 0.6.3;\r\n\r\nimport \"./AssetSwap.sol\";\r\n/**\r\nMIT License\r\nCopyright © 2020 Eric G. Falkenstein\r\n\r\nPermission is hereby granted, free of charge, to any person\r\nobtaining a copy of this software and associated documentation\r\nfiles (the \"Software\"), to deal in the Software without restriction,\r\nincluding without limitation the rights to use, copy, modify, merge,\r\npublish, distribute, sublicense, and/or sell copies of the Software,\r\nand to permit persons to whom the Software is furnished to do so,\r\nsubject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\r\n OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\n\r\ncontract ManagedAccount {\r\n/// fee is in basis points. 100 means 1.0% of assets per year is sent to the manager\r\n\r\n    constructor(address payable _manager, uint _fee) public {\r\n        manager = _manager;\r\n        investor[msg.sender] = true;\r\n        lastUpdateTime = now;\r\n        managerStatus = true;\r\n        mgmtFee = _fee;\r\n    }\r\n\r\n    address payable public manager;\r\n    mapping(address =\u003e bool) public approvedSwaps;\r\n    mapping(address =\u003e bool) public investor;\r\n    mapping(bytes32 =\u003e Takercontract) public takercontracts;\r\n    bytes32[] public ourTakerContracts;\r\n    address[] public ourSwaps;\r\n    uint public lastUpdateTime;\r\n    uint public managerBalance;\r\n    uint public totAUMlag;\r\n    bool public managerStatus;\r\n    uint public mgmtFee;\r\n\r\n    event AddedFunds(uint amount, address payor);\r\n    event RemovedFunds(uint amount, address payee);\r\n\r\n    struct Takercontract {\r\n        address swapAddress;\r\n        address lp;\r\n        uint index;\r\n    }\r\n\r\n    modifier onlyInvestor() {\r\n        require(investor[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyApproved() {\r\n        if (managerStatus)\r\n            require(msg.sender == manager || investor[msg.sender]);\r\n        else\r\n            require(investor[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    receive ()\r\n        external\r\n        payable\r\n    { emit AddedFunds(msg.value, msg.sender);\r\n    }\r\n\r\n    function changeManager(address payable _manager)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        updateFee();\r\n        uint manBal = managerBalance;\r\n        managerBalance = 0;\r\n        emit RemovedFunds(manBal, manager);\r\n        manager.transfer(manBal);\r\n        manager = _manager;\r\n    }\r\n\r\n    function addInvestor(address payable newInvestor)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        investor[newInvestor] = true;\r\n    }\r\n\r\n    function removeInvestor(address payable oldInvestor)\r\n        external\r\n        onlyInvestor\r\n    {\r\n      require(oldInvestor != msg.sender);\r\n      investor[oldInvestor] = false;\r\n    }\r\n\r\n    function disableManager(bool _managerStatus)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        if (managerStatus \u0026\u0026 !_managerStatus)\r\n            generateFee(totAUMlag);\r\n        managerStatus = _managerStatus;\r\n    }\r\n\r\n    function adjFee(uint newFee)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        mgmtFee = newFee;\r\n    }\r\n\r\n    function addSwap(address swap)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        require(approvedSwaps[swap] == false);\r\n        approvedSwaps[swap] = true;\r\n        ourSwaps.push(swap);\r\n    }\r\n    /// must send 10x the minimum RM to fund a new createBook\r\n\r\n    function createBook(uint amount, address swap, uint16 min, uint closefee, int fundingLong, int fundingShort)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        amount = amount * 1 szabo;\r\n        require(amount \u003c= address(this).balance);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.createBook.value(amount)(min, closefee, fundingLong, fundingShort);\r\n    }\r\n\r\n    function fundBookMargin(uint amount, address swap)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        amount = amount * 1 szabo;\r\n        uint totAUM = totAUMlag + amount;\r\n        generateFee(totAUM);\r\n        require(amount \u003c address(this).balance);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.fundLP.value(amount)(address(this));\r\n    }\r\n\r\n    function fundTakerMargin(uint amount, address swap, address lp, bytes32 subkid)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        amount = amount * 1 szabo;\r\n        uint totAUM = totAUMlag + amount;\r\n        generateFee(totAUM);\r\n        require(amount \u003c address(this).balance);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.fundTaker.value(amount)(lp, subkid);\r\n    }\r\n\r\n    function takeFromLP(uint amount, address swap, address lp, uint16 rM, bool takerLong)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        amount = 1 szabo * amount;\r\n        require(amount \u003c address(this).balance);\r\n        uint totAUM = totAUMlag + amount;\r\n        generateFee(totAUM);\r\n        bytes32 subkid = s.take.value(amount)(lp, rM, takerLong);\r\n        Takercontract memory t;\r\n        t.swapAddress = swap;\r\n        t.lp = lp;\r\n        t.index = ourTakerContracts.length;\r\n        takercontracts[subkid] = t;\r\n        ourTakerContracts.push(subkid);\r\n\r\n    }\r\n\r\n    function cancelSubcontract(address swap, address lp, bytes32 id)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        (, , uint rm) = s.getSubkData1(lp, id);\r\n        uint amount = 5 * rm / 100;\r\n        require(amount \u003c address(this).balance);\r\n        s.cancel.value(amount)(lp, id, false);\r\n    }\r\n\r\n    function fund()\r\n        external\r\n        payable\r\n        onlyApproved\r\n    {\r\n        emit AddedFunds(msg.value, msg.sender);\r\n    }\r\n\r\n    function activateEndBook(address swap)\r\n        external\r\n        payable\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.closeBook.value(msg.value)(address(this));\r\n    }\r\n\r\n    function adjMinReqMarg(uint16 amount, address swap)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.adjustMinRM(amount);\r\n    }\r\n\r\n    function setFees(address swap, uint close, int longFR, int shortFR)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.updateFees(close, longFR, shortFR);\r\n    }\r\n\r\n    function investorWithdraw(uint amount)\r\n        external\r\n        onlyInvestor\r\n    {\r\n        require(subzero(address(this).balance, amount) \u003e managerBalance);\r\n        emit RemovedFunds(amount, msg.sender);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    function managerWithdraw()\r\n        external\r\n        onlyManager\r\n    {\r\n        uint manBal = managerBalance;\r\n        managerBalance = 0;\r\n        emit RemovedFunds(manBal, manager);\r\n        msg.sender.transfer(manBal);\r\n    }\r\n\r\n    function withdrawLPToAS(address swap, uint16 amount)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        /// fund in gwei, or 1/1000 of the unit of denomination\r\n        /// adjust to finney when applied for real use (1e15)\r\n        s.withdrawLP(amount);\r\n    }\r\n\r\n    function withdrawTakerToAS(address swap, uint16 amount, address lp, bytes2 subkid)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        /// adjust this to finney for real use\r\n        s.withdrawTaker(amount, lp, subkid);\r\n    }\r\n\r\n    function withdrawFromAS(address swap)\r\n        external\r\n        onlyApproved\r\n    {\r\n        require(approvedSwaps[swap]);\r\n        AssetSwap s = AssetSwap(swap);\r\n        s.withdrawFromAssetSwap();\r\n    }\r\n\r\n    function seeAUM()\r\n        external\r\n        view\r\n        returns (uint totTakerBalance, uint totLPBalance, uint thisAccountBalance, uint _managerBalance)\r\n    {\r\n        totLPBalance = 0;\r\n        uint lpMargin = 0;\r\n        for (uint i = 0; i \u003c ourSwaps.length; i++) {\r\n            address ourswap = ourSwaps[i];\r\n            AssetSwap s = AssetSwap(ourswap);\r\n            (, lpMargin, , , , , , , , ) = s.getBookData(address(this));\r\n            totLPBalance += lpMargin;\r\n        }\r\n        totTakerBalance = 0;\r\n        uint takerMargin = 0;\r\n        for (uint i = 0; i \u003c ourTakerContracts.length; i++) {\r\n            Takercontract storage k = takercontracts[ourTakerContracts[i]];\r\n            AssetSwap s = AssetSwap(k.swapAddress);\r\n            (, takerMargin, ) = s.getSubkData1(k.lp, ourTakerContracts[i]);\r\n            totTakerBalance += takerMargin;\r\n        }\r\n        thisAccountBalance = address(this).balance;\r\n        _managerBalance = managerBalance;\r\n    }\r\n\r\n    function updateFee()\r\n        public\r\n        onlyApproved\r\n        {\r\n        uint totAUM = 0;\r\n        uint lpMargin;\r\n        for (uint i = 0; i \u003c ourSwaps.length; i++) {\r\n            AssetSwap s = AssetSwap(ourSwaps[i]);\r\n            (, lpMargin, , , , , , , , ) = s.getBookData(address(this));\r\n            totAUM += lpMargin;\r\n        }\r\n        uint takerMargin = 0;\r\n        for (uint i = 0; i \u003c ourTakerContracts.length; i++) {\r\n            Takercontract storage k = takercontracts[ourTakerContracts[i]];\r\n            AssetSwap s = AssetSwap(k.swapAddress);\r\n            (, takerMargin, ) = s.getSubkData1(k.lp, ourTakerContracts[i]);\r\n            totAUM += takerMargin;\r\n        }\r\n        generateFee(totAUM);\r\n    }\r\n\r\n    function generateFee(uint newAUM)\r\n    internal\r\n    {\r\n      /// this applies the management fee to to assets under management. The fee is in\r\n      /// basis points, so dividing by 10000 turns 100 into 0.01.\r\n        uint mgmtAccrual = (now - lastUpdateTime) * totAUMlag * mgmtFee / 10000 / 365 / 86400;\r\n        lastUpdateTime = now;\r\n        totAUMlag = newAUM;\r\n        managerBalance += mgmtAccrual;\r\n    }\r\n\r\n    function subzero(uint _a, uint _b)\r\n        internal\r\n        pure\r\n        returns (uint)\r\n    {\r\n        if (_b \u003e= _a) {\r\n            return 0;\r\n        }\r\n        return _a - _b;\r\n    }\r\n\r\n\r\n}\r\n"},"Oracle.sol":{"content":"pragma solidity 0.6.3;\n\nimport \"./AssetSwap.sol\";\n\n/**\nMIT License\nCopyright © 2020 Eric G. Falkenstein\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\n OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\ncontract Oracle {\n\n    constructor (uint ethPrice, uint spxPrice, uint btcPrice) public {\n        admins[msg.sender] = true;\n        prices[0][5] = ethPrice;\n        prices[1][5] = spxPrice;\n        prices[2][5] = btcPrice;\n        lastUpdateTime = now;\n        lastSettleTime = now;\n        currentDay = 5;\n        levRatio[0] = 250;  // ETH contract 2.5 leverage\n        levRatio[1] = 1000; /// SPX contract 10.0 leverage\n        levRatio[2] = 250;  // BTC contract 2.5 leverage\n    }\n\n    address[3] public assetSwaps;\n    uint[6][3] private prices;\n    uint public lastUpdateTime;\n    uint public lastSettleTime;\n    int[3] public levRatio;\n    uint8 public currentDay;\n    bool public nextUpdateSettle;\n    mapping(address =\u003e bool) public admins;\n    mapping(address =\u003e bool) public readers;\n\n    event PriceUpdated(\n        uint ethPrice,\n        uint spxPrice,\n        uint btcPrice,\n        uint eUTCTime,\n        uint eDayNumber,\n        bool eisCorrection\n    );\n\n    event AssetSwapContractsChange(\n        address ethSwapContract,\n        address spxSwapContract,\n        address btcSwapContract\n    );\n\n    event ChangeReaderStatus(\n        address reader,\n        bool onOrOff\n    );\n\n    modifier onlyAdmin() {\n        require(admins[msg.sender]);\n        _;\n    }\n    /** Grant write priviledges to a user,\n    * mainly intended for when the admin wants to switch accounts, ie, paired with a removal\n    */\n\n    function addAdmin(address newAdmin)\n        external\n        onlyAdmin\n    {\n        admins[newAdmin] = true;\n    }\n\n    function removeAdmin(address toRemove)\n            external\n            onlyAdmin\n    {\n        require(toRemove != msg.sender);\n        admins[toRemove] = false;\n    }\n    /** Grant priviledges to a user accessing price data on the blockchain\n    * @param newReader the address. Any reader is thus approved by the oracle/admin\n    * useful for new contracts that  use this oracle, in that the oracle would not\n    * need to create a new oracle contract for ETH prices\n    */\n\n    function addReaders(address newReader)\n        external\n        onlyAdmin\n    {\n        readers[newReader] = true;\n        emit ChangeReaderStatus(newReader, true);\n    }\n\n    function removeReaders(address oldReader)\n        external\n        onlyAdmin\n    {\n        readers[oldReader] = false;\n        emit ChangeReaderStatus(oldReader, false);\n    }\n    /** this can only be done once, so this oracle is solely for working with\n    * three AssetSwap contracts\n    * assetswap 0 is the ETH, at 2.5 leverage\n    * assetswap 1 is the SPX, at 10x leverage\n    * assetswap 2 is the BTC, at 2.5 leverage\n    *\n    */\n\n    function changeAssetSwaps(address newAS0, address newAS1, address newAS2)\n        external\n        onlyAdmin\n    {\n        require(now \u003e lastSettleTime \u0026\u0026 now \u003c lastSettleTime + 1 days, \"only 1 day after settle\");\n        assetSwaps[0] = newAS0;\n        assetSwaps[1] = newAS1;\n        assetSwaps[2] = newAS2;\n        readers[newAS0] = true;\n        readers[newAS1] = true;\n        readers[newAS2] = true;\n        emit AssetSwapContractsChange(newAS0, newAS1, newAS2);\n    }\n    /** Quickly fix an erroneous price, or correct the fact that 50% movements are\n    * not allowed in the standard price input\n    * this must be called within 60 minutes of the initial price update occurence\n    */\n\n    function editPrice(uint _ethprice, uint _spxprice, uint _btcprice)\n        external\n        onlyAdmin\n    {\n        require(now \u003c lastUpdateTime + 60 minutes);\n        prices[0][currentDay] = _ethprice;\n        prices[1][currentDay] = _spxprice;\n        prices[2][currentDay] = _btcprice;\n        emit PriceUpdated(_ethprice, _spxprice, _btcprice, now, currentDay, true);\n    }\n\n    function updatePrices(uint ethp, uint spxp, uint btcp, bool _newFinalDay)\n        external\n        onlyAdmin\n    {\n\n             /// no updates within 20 hours of last update\n        require(now \u003e lastUpdateTime + 20 hours);\n            /** can\u0027t be executed if the next price should be a settlement price\n            * settlement prices are special because they need to update the asset returns\n            * and sent to the AssetSwap contracts\n            */\n        require(!nextUpdateSettle);\n         /// after settlement update, at least 48 hours until new prices are posted\n        require(now \u003e lastSettleTime + 48 hours, \"too soon after last settle\");\n          /// prevents faulty prices, as stale prices are a common source of bad prices.\n        require(ethp != prices[0][currentDay] \u0026\u0026 spxp != prices[1][currentDay] \u0026\u0026 btcp != prices[2][currentDay]);\n            /// extreme price movements are probably mistakes. They can be posted\n          /// but only via a \u0027price edit\u0027 that must be done within 60 minutes of the initial update\n          /// many errors generate inputs off by orders of magnitude, which imply returns of \u003e100% or \u003c-90%\n        require((ethp * 10 \u003c prices[0][currentDay] * 15) \u0026\u0026 (ethp * 10 \u003e prices[0][currentDay] * 5));\n        require((spxp * 10 \u003c prices[1][currentDay] * 15) \u0026\u0026 (spxp * 10 \u003e prices[1][currentDay] * 5));\n        require((btcp * 10 \u003c prices[2][currentDay] * 15) \u0026\u0026 (btcp * 10 \u003e prices[2][currentDay] * 5));\n        if (currentDay == 5) {\n            currentDay = 1;\n        } else {\n            currentDay += 1;\n            nextUpdateSettle = _newFinalDay;\n        }\n        if (currentDay == 4)\n            nextUpdateSettle = true;\n        updatePriceSingle(0, ethp);\n        updatePriceSingle(1, spxp);\n        updatePriceSingle(2, btcp);\n        emit PriceUpdated(ethp, spxp, btcp, now, currentDay, false);\n        lastUpdateTime = now;\n    }\n\n    function settlePrice(uint ethp, uint spxp, uint btcp)\n        external\n        onlyAdmin\n    {\n        require(nextUpdateSettle);\n        require(now \u003e lastUpdateTime + 20 hours);\n        require(ethp != prices[0][currentDay] \u0026\u0026 spxp != prices[1][currentDay] \u0026\u0026 btcp != prices[2][currentDay]);\n        require((ethp * 10 \u003c prices[0][currentDay] * 15) \u0026\u0026 (ethp * 10 \u003e prices[0][currentDay] * 5));\n        require((spxp * 10 \u003c prices[1][currentDay] * 15) \u0026\u0026 (spxp * 10 \u003e prices[1][currentDay] * 5));\n        require((btcp * 10 \u003c prices[2][currentDay] * 15) \u0026\u0026 (btcp * 10 \u003e prices[2][currentDay] * 5));\n        currentDay = 5;\n        nextUpdateSettle = false;\n        updatePriceSingle(0, ethp);\n        updatePriceSingle(1, spxp);\n        updatePriceSingle(2, btcp);\n        int[5] memory assetReturnsNew;\n        int[5] memory assetReturnsExpiring;\n        int cap = 975 * 1 szabo / 1000;\n        for (uint j = 0; j \u003c 3; j++) {\n                  /**  asset return from start day j to settle day (ie, day 5),\n                  * and also the prior settle day (day 0) to the end day.\n                  * returns are normalized from 0.975 szabo to - 0.975 szabo\n                  * where 0.9 szabo is a 90% of RM profit for the long taker,\n                  * 0.2 szabo means a 20% of RM profit for the long taker.\n                  */\n            for (uint i = 0; i \u003c 5; i++) {\n                if (prices[0][i] != 0) {\n                    int assetRetFwd = int(prices[j][5] * 1 szabo / prices[j][i]) - 1 szabo;\n                    assetReturnsNew[i] = assetRetFwd * int(prices[0][i]) * levRatio[j] /\n                        int(prices[0][5]) / 100;\n                /** as funding rates are maxed out at 2.5% of RM, the return must\n                * max out at 97.5% of RM so that required margins cover all\n                * potential payment scenarios\n                */\n                    assetReturnsNew[i] = bound(assetReturnsNew[i], cap);\n                }\n                if (prices[0][i+1] != 0) {\n                    int assetRetBack = int(prices[j][i+1] * 1 szabo / prices[j][0]) - 1 szabo;\n                    assetReturnsExpiring[i] = assetRetBack * int(prices[0][0]) * levRatio[j] /\n                        int(prices[0][i+1]) / 100;\n\n                    assetReturnsExpiring[i] = bound(assetReturnsExpiring[i], cap);\n                }\n            }\n    /// this updates the AssetSwap contract with the vector of returns,\n    /// one for each day of the week\n            AssetSwap asw = AssetSwap(assetSwaps[j]);\n            asw.updateReturns(assetReturnsNew, assetReturnsExpiring);\n        }\n        lastSettleTime = now;\n        emit PriceUpdated(ethp, spxp, btcp, now, currentDay, false);\n        lastUpdateTime = now;\n    }\n    /** Return the entire current price array for a given asset\n    * @param _assetID the asset id of the desired asset\n    * @return _priceHist the price array in USD for the asset\n    * @dev only the admin and addresses granted readership may call this function\n    * While only an admin or reader can access this within the EVM\n    * anyone can access these prices outside the EVM\n    * eg, in javascript: OracleAddress.methods.getUsdPrices.cacheCall(0, { \u0027from\u0027: \u0027AdminAddress\u0027 }\n    */\n\n    function getUsdPrices(uint _assetID)\n        public\n        view\n        returns (uint[6] memory _priceHist)\n    {\n        require(admins[msg.sender] || readers[msg.sender]);\n        _priceHist = prices[_assetID];\n    }\n\n        /** Return only the latest prices\n        * @param _assetID the asset id of the desired asset\n        * @return _price the latest price of the given asset\n        * @dev only the admin or a designated reader may call this function within the EVM\n        */\n    function getCurrentPrice(uint _assetID)\n        public\n        view\n        returns (uint _price)\n    {\n        require(admins[msg.sender] || readers[msg.sender]);\n        _price = prices[_assetID][currentDay];\n    }\n\n    /**\n    * @return _startDay relevant for trades done now\n    * pulls the day relevant for new AssetSwap subcontracts\n    * startDay 2 means the 2 slot (ie, the third) of prices will be the initial\n    * price for the subcontract. As 5 is the top slot, and rolls into slot 0\n    * the next week, the next pricing day is 1 when the current day == 5\n    * (this would be a weekend or Monday morning)\n    */\n    function getStartDay()\n        public\n        view\n        returns (uint8 _startDay)\n    {\n        if (nextUpdateSettle) {\n            _startDay = 5;\n        } else if (currentDay == 5) {\n            _startDay = 1;\n        } else {\n            _startDay = currentDay + 1;\n        }\n    }\n\n    function updatePriceSingle(uint _assetID, uint _price)\n        internal\n    {\n        if (currentDay == 1) {\n            uint[6] memory newPrices;\n            newPrices[0] = prices[_assetID][5];\n            newPrices[1] = _price;\n            prices[_assetID] = newPrices;\n        } else {\n            prices[_assetID][currentDay] = _price;\n        }\n    }\n\n    function bound(int a, int b)\n        internal\n        pure\n        returns (int)\n    {\n        if (a \u003e b)\n            a = b;\n        if (a \u003c -b)\n            a = -b;\n        return a;\n    }\n\n}\n"}}