{"BasicToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./ERC20Basic.sol\";\nimport \"./SafeMath.sol\";\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address =\u003e uint256) balances;\n\n  uint256 totalSupply_;\n\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value \u003c= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}"},"CanReclaimToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./Ownable.sol\";\nimport \"./ERC20Basic.sol\";\nimport \"./SafeERC20.sol\";\n\ncontract CanReclaimToken is Ownable {\n  using SafeERC20 for ERC20Basic;\n\n  function reclaimToken(ERC20Basic token) external onlyOwner {\n    uint256 balance = token.balanceOf(this);\n    token.safeTransfer(owner, balance);\n  }\n  }"},"Claimable.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./Ownable.sol\";\n\ncontract Claimable is Ownable {\n  address public pendingOwner;\n\n  modifier onlyPendingOwner() {\n    require(msg.sender == pendingOwner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) onlyOwner public {\n    pendingOwner = newOwner;\n  }\n\n  function claimOwnership() onlyPendingOwner public {\n    OwnershipTransferred(owner, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n  }"},"ERC20.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./ERC20Basic.sol\";\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"ERC20Basic.sol":{"content":"pragma solidity ^0.4.18;\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}"},"MintableToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./StandardToken.sol\";\nimport \"./Ownable.sol\";\nimport \"./Claimable.sol\";\n\ncontract MintableToken is StandardToken, Ownable, Claimable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n  uint public maxSupply = 400000000 * (10 ** 18);\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n    if (maxSupply \u003c totalSupply_.add(_amount) ) {\n        revert();\n    }\n\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    Mint(_to, _amount);\n    Transfer(address(0), _to, _amount);\n    return true;\n  }\n  function finishMinting() onlyOwner canMint public returns (bool) {\n    mintingFinished = true;\n    MintFinished();\n    return true;\n  }\n  }"},"MOOVEToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./StandardToken.sol\";\nimport \"./PausableToken.sol\";\nimport \"./MintableToken.sol\";\nimport \"./CanReclaimToken.sol\";\n\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\n\ncontract MOOVEToken is StandardToken, PausableToken, MintableToken {\n\n  string public constant name = \"MOOVE CURRENCY\"; \n  string public constant symbol = \"MOOVE\"; \n  uint8 public constant decimals = 18; \n\n  uint256 public constant INITIAL_SUPPLY = 0 * (10 ** uint256(decimals));\n\n  function MOOVEToken() public {\n    totalSupply_ = INITIAL_SUPPLY;\n    balances[msg.sender] = INITIAL_SUPPLY;\n    maxSupply = 400000000 * (10 ** uint256(decimals));\n\n    Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n  }\n\n  function approveAndCall(address spender, uint _value, bytes data) public returns (bool success) {\n    approve(spender, _value);\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, _value, address(this), data);\n    return true;\n  }\n}"},"Ownable.sol":{"content":"pragma solidity ^0.4.18;\n\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n  }\n"},"Pausable.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./Ownable.sol\";\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n  }"},"PausableToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./StandardToken.sol\";\nimport \"./Pausable.sol\";\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n    return super.increaseApproval(_spender, _addedValue);\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n    return super.decreaseApproval(_spender, _subtractedValue);\n  }\n  }"},"SafeERC20.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./ERC20Basic.sol\";\nimport \"./ERC20.sol\";\n\nlibrary SafeERC20 {\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n    assert(token.transfer(to, value));\n  }\n\n  function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n    assert(token.transferFrom(from, to, value));\n  }\n\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\n    assert(token.approve(spender, value));\n  }\n  }"},"SafeMath.sol":{"content":"pragma solidity ^0.4.18;\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n  }"},"StandardToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./BasicToken.sol\";\nimport \"./ERC20.sol\";\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value \u003c= balances[_from]);\n    require(_value \u003c= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue \u003e oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n  }"},"TestTokenFallback.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./Ownable.sol\";\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\ncontract TestTokenFallback is Ownable {\n    bool public requireFlag = true;\n    bool public successFlag = true;\n\n    event LogTokenFallback(address indexed msgSender, address indexed from, uint256 amount, bytes data);\n    event LogReceiveApproval(address indexed msgSender, uint256 amount, address indexed token, bytes data);\n\n    function setRequireFlag(bool _requireFlag) public onlyOwner {\n        requireFlag = _requireFlag;\n    }\n\n    function setSuccessFlag(bool _successFlag) public onlyOwner {\n        successFlag = _successFlag;\n    }\n\n    function tokenFallback(address from, uint256 amount, bytes data) public returns (bool success) {\n        // ERC20Interface(token).transferFrom(from, address(this), tokens);\n        require(requireFlag);\n        LogTokenFallback(msg.sender, from, amount, data);\n        return successFlag;\n    }\n\n    function receiveApproval(address from, uint256 amount, address token, bytes data) public {\n        require(requireFlag);\n        ERC20Interface(token).transferFrom(from, address(this), amount);\n        LogReceiveApproval(msg.sender, amount, token, data);\n    }\n}"}}