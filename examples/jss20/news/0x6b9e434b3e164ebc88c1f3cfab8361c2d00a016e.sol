{"CTPurchaseOffer.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./GTTokenInterface.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title CTPurchaseOffer\n * @dev The CTPurchaseOffer contract helps in creating a purchase offer contract\n */\ncontract CTPurchaseOffer {\n\n    // Struct Offer to define parameters for the purchase offer\n    struct Offer {\n        address buyer;\n        address seller;\n        uint gtAmount;\n        string companyTokenName;\n        uint companyTokenAmount;\n        bool active;\n        bool completed;\n    }\n\n    // Event to be emitted when purchase offer is withdrawn\n    event WithdrawPurchaseOffer(address indexed buyerAddress);\n\n    using SafeMath for uint256;\n\n    GTTokenInterface public tokenController;\n    Offer public offer;\n\n    /**\n     * @dev Constructor, sets the defining parameters for the company token purchase contract by the buyer\n     */\n    constructor(\n        address gtTokenAddress,\n        address seller,\n        uint gtAmount,\n        string memory companyTokenName,\n        uint companyTokenAmount\n    )\n        public\n    {\n        require(gtTokenAddress != address(0x0));\n        tokenController = GTTokenInterface(gtTokenAddress);\n\n        require(tokenController.isInvestorRegistered(msg.sender));\n        require(tokenController.isInvestorRegistered(seller));\n        require(companyTokenAmount \u003e 0);\n\n        require(tokenController.balanceOf(msg.sender) \u003e= gtAmount);\n\n        offer = Offer(\n            msg.sender,\n            seller,\n            gtAmount,\n            companyTokenName,\n            companyTokenAmount,\n            false,\n            false\n        );\n    }\n\n    modifier onlyTokenContract() {\n        require(msg.sender == address(tokenController));\n        _;\n    }\n\n    function getSeller() external view returns(address) {\n        return offer.seller;\n    }\n\n    function getBuyer() external view returns(address) {\n        return offer.buyer;\n    }\n\n    function isOfferCompleted() external view returns(bool) {\n        return offer.completed;\n    }\n\n    function isOfferActive() external view returns(bool) {\n        return offer.active;\n    }\n\n    function getCompanyTokenName() external view returns(string memory) {\n        return offer.companyTokenName;\n    }\n\n    function getCompanyTokenAmount() external view returns(uint) {\n        return offer.companyTokenAmount;\n    }\n\n    function getGTAmount() external view returns(uint) {\n        return offer.gtAmount;\n    }\n\n    /**\n     * @dev Allows activation of purchase offer contract by the buyer.\n     * Can only be called from GT Token contract\n     */\n    function activateOffer() external onlyTokenContract {\n        offer.active = true;\n    }\n\n    /**\n     * @dev Allows withdrawal of purchase offer contract by the buyer.\n     * Can only be called by the buyer or the seller\n     */\n    function withdrawOffer() external {\n        require(offer.buyer == msg.sender || offer.seller == msg.sender);\n        require(offer.active);\n\n        tokenController.transfer(offer.buyer, offer.gtAmount);\n        offer.active = false;\n\n        emit WithdrawPurchaseOffer(address(this));\n    }\n\n    /**\n     * @dev Allows acceptance of purchase offer contract by the seller.\n     * Can only be caller from GT Token contract\n     */\n    function acceptOffer() external onlyTokenContract {\n        uint fee = (offer.gtAmount).div(100);\n\n        tokenController.transfer(offer.seller, (offer.gtAmount).sub(fee));\n        tokenController.burnTokens(fee);\n\n        offer.active = false;\n        offer.completed = true;\n    }\n}\n"},"CTSellOffer.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./GTTokenInterface.sol\";\n\n\n/**\n * @title CTSellOffer\n * @dev The CTSellOffer contract helps in creating a sell offer contract\n */\ncontract CTSellOffer {\n\n    // Struct Offer to define parameters for the sell offer\n    struct Offer {\n        address buyer;\n        address seller;\n        uint gtAmount;\n        string companyTokenName;\n        uint companyTokenAmount;\n        bool active;\n        bool completed;\n    }\n\n    GTTokenInterface public tokenController;\n    Offer public offer;\n\n    /**\n     * @dev Constructor, sets the defining parameters for the company token sell contract by the seller\n     */\n    constructor(\n        address gtTokenAddress,\n        address buyer,\n        uint gtAmount,\n        string memory companyTokenName,\n        uint companyTokenAmount\n    )\n        public\n    {\n        require(gtTokenAddress != address(0x0));\n        tokenController = GTTokenInterface(gtTokenAddress);\n\n        require(tokenController.isInvestorRegistered(msg.sender));\n        require(tokenController.isInvestorRegistered(buyer));\n        require(gtAmount \u003e 0);\n\n        require(tokenController.getCompanyTokenBalance(companyTokenName, msg.sender) \u003e= companyTokenAmount);\n\n        offer = Offer(\n            buyer,\n            msg.sender,\n            gtAmount,\n            companyTokenName,\n            companyTokenAmount,\n            false,\n            false\n        );\n    }\n\n    modifier onlyTokenContract() {\n        require(msg.sender == address(tokenController));\n        _;\n    }\n\n    function getSeller() external view returns(address) {\n        return offer.seller;\n    }\n\n    function getBuyer() external view returns(address) {\n        return offer.buyer;\n    }\n\n    function isOfferCompleted() external view returns(bool) {\n        return offer.completed;\n    }\n\n    function isOfferActive() external view returns(bool) {\n        return offer.active;\n    }\n\n    function getCompanyTokenName() external view returns(string memory) {\n        return offer.companyTokenName;\n    }\n\n    function getCompanyTokenAmount() external view returns(uint) {\n        return offer.companyTokenAmount;\n    }\n\n    function getGTAmount() external view returns(uint) {\n        return offer.gtAmount;\n    }\n\n    /**\n     * @dev Allows activation of sell offer contract by the seller.\n     * Can only be called from GT Token contract\n     */\n    function activateOffer() external onlyTokenContract {\n        offer.active = true;\n    }\n\n    /**\n     * @dev Allows de-activation of sell offer contract by the seller.\n     * Can only be called from GT Token contract\n     */\n    function deActivateOffer() external onlyTokenContract {\n        offer.active = false;\n    }\n\n    /**\n     * @dev Allows acceptance of sell offer contract by the buyer.\n     * Can only be called from GT Token contract\n     */\n    function acceptOffer() external onlyTokenContract {\n        offer.completed = true;\n        offer.active = false;\n    }\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of `from`\u0027s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of `from`\u0027s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal { }\n}\n"},"GTToken.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./CTPurchaseOffer.sol\";\nimport \"./CTSellOffer.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Ownable.sol\";\nimport \"./Implementation.sol\";\nimport \"./ERC20.sol\";\n\n\n/**\n * @title GTToken\n * @dev The GTToken contract is an ERC20 standard based token implementation\n * It extends the Burnable, Detailed, Mintable, Pausable and Ownable functionalities\n */\ncontract GTToken is Implementation, Ownable, ERC20 {\n\n\n    /* Usings */\n\n    using SafeMath for uint256;\n\n\n    /* Events */\n\n    event GTTokenSetup(bool isSetup);\n    event InvestorRegistered(address indexed investorRegistered);\n    event CompanyTokenRegistered(\n        string companyTokenName,\n        uint indexed companyTokenAmounts\n    );\n    event CompanyTokenDistributed(\n        string companyTokenName,\n        address indexed initialShareHolders,\n        uint indexed companyTokenAmounts,\n        uint indexed distributedAmount\n    );\n    event CompanyTokenTransferred(\n        string companyTokenName,\n        address indexed fromAddress,\n        address indexed toAddress,\n        uint indexed amount\n    );\n    event AllocateTokens(\n        address indexed investorAddress,\n        uint indexed tokenAmount\n    );\n    event BurnTokens(\n        address indexed investorAddress,\n        uint indexed gtBalance\n    );\n    event ActivatePurchaseOffer(address indexed purchaseContract);\n    event ActivateSellOffer(address indexed sellContract);\n    event AcceptPurchaseOffer(address indexed purchaseContract);\n    event AcceptSellOffer(address indexed sellContract);\n    event WithdrawSellOffer(address indexed sellContract);\n\n\n    /* Modifiers */\n\n    modifier isGTTokenSetup() {\n        require(isSetup);\n        _;\n    }\n\n    modifier isAddressValid(address addr) {\n        require(addr != address(0x0));\n        _;\n    }\n\n\n    /* Storage */\n\n    mapping (address =\u003e bool) investorRegistered;\n    mapping (string =\u003e bool) companyTokenRegistered;\n    mapping (string =\u003e uint) companyTokenCurrentSupply;\n    mapping (string =\u003e uint) companyTokenCap;\n    mapping (string =\u003e mapping (address =\u003e uint)) companyToken;\n\n    string private name_;\n    string private symbol_;\n    uint8 private decimals_;\n\n\n    /* External functions */\n\n    /**\n     * @dev Allows setting up of GTToken, sets the isSetup to true\n     * @param _name string The name of the token\n     * @param _symbol string The symbol of the token\n     * @param _decimals uint The decimals for the token\n     */\n    function setup(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    )\n        external\n        returns(bool)\n    {\n        require(bytes(name_).length == 0 \u0026\u0026 bytes(_name).length \u003e 0);\n        require(bytes(symbol_).length == 0 \u0026\u0026 bytes(_symbol).length \u003e 0);\n        require(decimals_ == 0 \u0026\u0026 _decimals \u003e 0);\n\n        name_ = _name;\n        symbol_ = _symbol;\n        decimals_ = _decimals;\n\n        isSetup = true;\n        emit GTTokenSetup(isSetup);\n\n        return true;\n    }\n\n    /**\n     * @dev Allows registration of investor\n     */\n    function registerInvestor() external isGTTokenSetup returns(bool) {\n        require(!investorRegistered[msg.sender]);\n\n        investorRegistered[msg.sender] = true;\n\n        emit InvestorRegistered(msg.sender);\n\n        return true;\n    }\n\n    /**\n     * @dev Returns true if the investor is registered\n     * @param investorAddress address The address of the investor\n     */\n    function isInvestorRegistered(\n        address investorAddress\n    )\n        external\n        view\n        returns(bool)\n    {\n        return investorRegistered[investorAddress];\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external view returns (string memory) {\n        return name_;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() external view returns (string memory) {\n        return symbol_;\n    }\n\n    function decimals() external view returns (uint8) {\n        return decimals_;\n    }\n\n    /**\n     * @dev Allows allocation of GT Token to investors\n     * @param investorAddress address The address of the investor\n     * @param tokenAmount uint The GT token amount to be allocated\n     */\n    function allocateTokens(\n        address investorAddress,\n        uint tokenAmount\n    )\n        external\n        isGTTokenSetup\n        onlyOwner\n\n        returns(bool)\n    {\n        require(investorRegistered[investorAddress]);\n\n        _mint(investorAddress, tokenAmount);\n\n        emit AllocateTokens(investorAddress, balanceOf(investorAddress));\n\n        return true;\n    }\n\n    /**\n     * @dev Allows registration of a new company token. Can be called by the GT Admin/Owner only\n     * @param companyTokenName string The name of company token\n     */\n    function registerCompanyToken(\n        string calldata companyTokenName,\n        uint ctTokenCap\n    )\n        external\n        isGTTokenSetup\n        onlyOwner\n        returns(bool)\n    {\n        require(!companyTokenRegistered[companyTokenName]);\n        require(ctTokenCap \u003e 0);\n\n        companyTokenRegistered[companyTokenName] = true;\n        companyTokenCap[companyTokenName] = ctTokenCap;\n\n        companyToken[companyTokenName][msg.sender] = ctTokenCap;\n\n        emit CompanyTokenRegistered(companyTokenName, ctTokenCap);\n\n        return true;\n    }\n\n    /**\n     * @dev Provides functionality to distribute company token. Can be called by the GT Admin/Owner only\n     * @param companyTokenName string The name of company token\n     * @param initialShareHolders address[] The addresses of the investors for company token distribution\n     * @param companyTokenAmounts uint[] The amount of the company token amount to be distributed\n     */\n    function distributeCompanyToken(\n        string calldata companyTokenName,\n        address[] calldata initialShareHolders,\n        uint[] calldata companyTokenAmounts\n    )\n        external\n        isGTTokenSetup\n        onlyOwner\n        returns(bool)\n    {\n        require(companyTokenRegistered[companyTokenName]);\n        require(initialShareHolders.length == companyTokenAmounts.length);\n\n        for (uint i = 0; i \u003c initialShareHolders.length; i++) {\n            require(investorRegistered[initialShareHolders[i]]);\n        }\n\n        uint askedSupply = companyTokenCurrentSupply[companyTokenName];\n\n        for (uint i = 0; i \u003c initialShareHolders.length; i++) {\n            askedSupply = askedSupply.add(companyTokenAmounts[i]);\n        }\n\n        require(askedSupply \u003c= companyTokenCap[companyTokenName]);\n\n        for (uint i = 0; i \u003c initialShareHolders.length; i++) {\n            companyToken[companyTokenName][initialShareHolders[i]] = companyToken[companyTokenName][initialShareHolders[i]]\n                .add(companyTokenAmounts[i]);\n            companyToken[companyTokenName][msg.sender] = companyToken[companyTokenName][msg.sender].sub(companyTokenAmounts[i]);\n\n            emit CompanyTokenDistributed(\n                companyTokenName,\n                initialShareHolders[i],\n                companyToken[companyTokenName][initialShareHolders[i]],\n                companyTokenAmounts[i]\n            );\n        }\n\n        companyTokenCurrentSupply[companyTokenName] = askedSupply;\n\n        return true;\n    }\n\n    /**\n     * @dev Allows activation of purchase offer contracts\n     * @param ctPurchaseOfferContract address The address of the purchase offer contract to be activated.\n     * Can only be called by the purchase offer contract creator\n     */\n    function activatePurchaseOffer(\n        address ctPurchaseOfferContract\n    )\n        external\n        isAddressValid(ctPurchaseOfferContract)\n        returns(bool)\n    {\n        CTPurchaseOffer ctPurchaseController = CTPurchaseOffer(ctPurchaseOfferContract);\n\n        require(!ctPurchaseController.isOfferActive());\n        require(!ctPurchaseController.isOfferCompleted());\n\n        address buyer = ctPurchaseController.getBuyer();\n        require(msg.sender == buyer);\n\n        uint gtAmount = ctPurchaseController.getGTAmount();\n        require(balanceOf(buyer) \u003e= gtAmount);\n\n        transfer(ctPurchaseOfferContract, gtAmount);\n        ctPurchaseController.activateOffer();\n\n        emit ActivatePurchaseOffer(ctPurchaseOfferContract);\n\n        return true;\n    }\n\n    /**\n     * @dev Allows activation of sell offer contracts\n     * @param ctSellOfferContract address The address of the sell offer contract to be activated.\n     * Can only be called by the sell offer contract creator\n     */\n    function activateSellOffer(\n        address ctSellOfferContract\n    )\n        external\n        isAddressValid(ctSellOfferContract)\n        returns(bool)\n    {\n        CTSellOffer ctSellController = CTSellOffer(ctSellOfferContract);\n\n        require(!ctSellController.isOfferActive());\n        require(!ctSellController.isOfferCompleted());\n\n        address seller = ctSellController.getSeller();\n        require(msg.sender == seller);\n\n        uint companyTokenAmount = ctSellController.getCompanyTokenAmount();\n        string memory companyTokenName = ctSellController.getCompanyTokenName();\n\n        require(getCompanyTokenBalance(companyTokenName, seller) \u003e= companyTokenAmount);\n\n        companyToken[companyTokenName][seller] = companyToken[companyTokenName][seller].sub(companyTokenAmount);\n        companyToken[companyTokenName][ctSellOfferContract] = companyTokenAmount;\n        ctSellController.activateOffer();\n\n        emit ActivateSellOffer(ctSellOfferContract);\n\n        return true;\n    }\n\n    /**\n     * @dev Allows processing of acceptance of purchase offer contracts by a seller\n     * @param ctPurchaseOfferContract address The address of the purchase offer contract to be accepted.\n     * Can only be called by the registered seller of the purchase offer contract creator\n     */\n    function acceptPurchaseOffer(\n        address ctPurchaseOfferContract\n    )\n        external\n        isAddressValid(ctPurchaseOfferContract)\n        returns(bool)\n    {\n        CTPurchaseOffer ctPurchaseController = CTPurchaseOffer(ctPurchaseOfferContract);\n        require(ctPurchaseController.isOfferActive());\n\n        address seller = ctPurchaseController.getSeller();\n        require(seller == msg.sender);\n\n        uint gtAmount = ctPurchaseController.getGTAmount();\n        require(balanceOf(ctPurchaseOfferContract) == gtAmount);\n\n        string memory companyTokenName = ctPurchaseController.getCompanyTokenName();\n        uint tokenAmount = ctPurchaseController.getCompanyTokenAmount();\n\n        require(getCompanyTokenBalance(companyTokenName, seller) \u003e= tokenAmount);\n\n        address buyer = ctPurchaseController.getBuyer();\n\n        companyToken[companyTokenName][seller] = companyToken[companyTokenName][seller].sub(tokenAmount);\n        companyToken[companyTokenName][buyer] = companyToken[companyTokenName][buyer].add(tokenAmount);\n\n        ctPurchaseController.acceptOffer();\n\n        emit AcceptPurchaseOffer(ctPurchaseOfferContract);\n        emit CompanyTokenTransferred(\n            companyTokenName,\n            seller,\n            buyer,\n            tokenAmount\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Allows processing of acceptance of sell offer contracts by a buyer\n     * @param ctSellOfferContract address The address of the sell offer contract to be accepted.\n     * Can only be called by the registered buyer of the sell offer contract creator\n     */\n    function acceptSellOffer(\n        address ctSellOfferContract\n    )\n        external\n        isAddressValid(ctSellOfferContract)\n        returns(bool)\n    {\n        CTSellOffer ctSellController = CTSellOffer(ctSellOfferContract);\n        require(ctSellController.isOfferActive());\n\n        address buyer = ctSellController.getBuyer();\n        require(msg.sender == buyer);\n\n\n        uint companyTokenAmount = ctSellController.getCompanyTokenAmount();\n        uint gtAmount = ctSellController.getGTAmount();\n        string memory companyTokenName = ctSellController.getCompanyTokenName();\n\n        require(balanceOf(buyer) \u003e= gtAmount);\n        require(getCompanyTokenBalance(companyTokenName, ctSellOfferContract) == companyTokenAmount);\n\n        uint fee = gtAmount.div(100);\n\n        delete companyToken[companyTokenName][ctSellOfferContract];\n        companyToken[companyTokenName][buyer] = companyToken[companyTokenName][buyer].add(companyTokenAmount);\n\n        address seller = ctSellController.getSeller();\n        transfer(seller, gtAmount.sub(fee));\n        burnTokens(fee);\n\n        ctSellController.acceptOffer();\n\n        emit AcceptSellOffer(ctSellOfferContract);\n        emit CompanyTokenTransferred(\n            companyTokenName,\n            seller,\n            buyer,\n            companyTokenAmount\n        );\n\n        return true;\n    }\n\n    /**\n     * @dev Allows withdrawal of the sell offer contracts by a seller\n     * @param ctSellOfferContract address The address of the sell offer contract to be withdrawn.\n     * Can only be called by the seller or buyer registered in the sell contract offer\n     */\n    function withdrawSellOffer(\n        address ctSellOfferContract\n    )\n        external\n        isAddressValid(ctSellOfferContract)\n        returns(bool)\n    {\n        CTSellOffer ctSellController = CTSellOffer(ctSellOfferContract);\n        require(ctSellController.isOfferActive());\n\n        address seller = ctSellController.getSeller();\n        address buyer = ctSellController.getBuyer();\n        require(msg.sender == seller || msg.sender == buyer);\n\n        uint companyTokenAmount = ctSellController.getCompanyTokenAmount();\n        string memory companyTokenName = ctSellController.getCompanyTokenName();\n\n        require(getCompanyTokenBalance(companyTokenName, ctSellOfferContract) == companyTokenAmount);\n\n        companyToken[companyTokenName][seller] = companyToken[companyTokenName][seller].add(companyTokenAmount);\n        delete companyToken[companyTokenName][ctSellOfferContract];\n\n        ctSellController.deActivateOffer();\n\n        emit WithdrawSellOffer(ctSellOfferContract);\n\n        return true;\n    }\n\n    /* Public Functions */\n\n    /**\n     * @dev Returns the Company token balance of the investor\n     * @param companyTokenName string The name of company token\n     * @param investorAddress address The address of the investor\n     */\n    function getCompanyTokenBalance(\n        string memory companyTokenName,\n        address investorAddress\n    )\n        public\n        view\n        returns(uint)\n    {\n        return companyToken[companyTokenName][investorAddress];\n    }\n\n    /**\n     * @dev Allows burning of investor GT Token\n     * @param gtAmount uint The GT token amount to be allocated\n     */\n    function burnTokens(uint gtAmount) public returns(bool) {\n        CTPurchaseOffer ctPurchaseController = CTPurchaseOffer(msg.sender);\n        require(investorRegistered[msg.sender] || ctPurchaseController.isOfferActive());\n\n        _burn(msg.sender, gtAmount);\n\n        emit BurnTokens(msg.sender, balanceOf(msg.sender));\n\n        return true;\n    }\n}\n"},"GTTokenInterface.sol":{"content":"pragma solidity ^0.5.17;\n\ninterface GTTokenInterface {\n    function isInvestorRegistered(address addr) external view returns(bool);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function owner() external view returns (address);\n\n    function getCompanyTokenBalance(string calldata companyTokenName, address addr) external view returns(uint);\n\n    function burnTokens(uint gtAmount) external returns(bool);\n}\n"},"GTTokenV2.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./GTToken.sol\";\n\n\n/**\n * @title GTTokenV2\n * @dev The GTTokenV2 contract extends GTToken contract for upgradability testing\n */\ncontract GTTokenV2 is GTToken {\n\n\n    /* Storage */\n\n    uint256 public updatedTokenAmount;\n\n\n    /* External functions */\n\n    /**\n     * @dev Allows setting up of GTTokenV2, sets the isSetup to true\n     * @param _updatedTokenAmount uint The updated fixed token amount value\n     */\n    function setupV2(uint256 _updatedTokenAmount)\n        external\n        onlyOwner\n    {\n        require(updatedTokenAmount == 0 \u0026\u0026 _updatedTokenAmount \u003e 0);\n\n        updatedTokenAmount = _updatedTokenAmount;\n        isSetup = true;\n    }\n\n    /**\n     * @dev Allows allocation of GT Token to investors with V2 logic\n     * @param investorAddress address The address of the investor\n     * @param tokenAmount uint The GT token amount to be allocated\n     */\n    function allocateTokens(\n        address investorAddress,\n        uint tokenAmount\n    )\n        external\n\n        isGTTokenSetup\n        returns(bool)\n    {\n        require(investorRegistered[investorAddress]);\n        require(tokenAmount == updatedTokenAmount);\n\n        _mint(investorAddress, tokenAmount);\n\n        emit AllocateTokens(investorAddress, balanceOf(investorAddress));\n\n        return true;\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.17;\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Implementation.sol":{"content":"pragma solidity ^0.5.17;\n\n\ncontract Implementation {\n\n    bool public isSetup;\n    address implementation;\n\n    /**\n     * @dev Sets the address of the current implementation\n     * @param _newImp address of the new implementation\n     */\n    function _setImplementation(address _newImp) internal {\n        implementation = _newImp;\n    }\n}\n"},"Migrations.sol":{"content":"pragma solidity ^0.5.17;\n\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.17;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     * @notice Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"Proxy.sol":{"content":"pragma solidity ^0.5.17;\n\nimport \"./Implementation.sol\";\nimport \"./Ownable.sol\";\n\n\ncontract Proxy is Implementation, Ownable {\n\n    constructor(address _implementation) public Ownable() {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall\n     * to the given implementation. This function will return\n     * whatever the implementation call returns\n     */\n    function ()\n        external\n        payable\n    {\n        address impl = implementation;\n        require(impl != address(0), \"Implementation address is invalid\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, impl, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n\n    /**\n     * @dev Upgrades the implementation address\n     * @param _newImplementation address of the new implementation\n     */\n    function upgradeTo(address _newImplementation)\n        external onlyOwner\n    {\n        require(\n            implementation != _newImplementation,\n            \"New implementation address already set\"\n        );\n        isSetup = false;\n        _setImplementation(_newImplementation);\n    }\n\n    /**\n     * @dev Sets the address of the current implementation\n     * @param _newImp address of the new implementation\n     */\n    function _setImplementation(address _newImp) internal {\n        implementation = _newImp;\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.17;\n\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}