{"InfinestEthPublisher.sol":{"content":"pragma solidity ^0.5.11;\n\nimport \"./SafeMath.sol\";\n\ncontract InfinestEthPublisher\n{\n    using SafeMath for uint256;\n\n    address public _owner;\n    mapping(address =\u003e bool) public _approved;\n\n    uint256 balance = 0;\n\n    event Drop(address payable[] _toList, uint256[] _amountList);\n\n    constructor() public\n    {\n        _owner = msg.sender;\n        _approved[_owner] = true;\n    }\n\n    function () payable external\n    {\n        balance = balance.add(msg.value);\n    }\n\n    function getBalance() view external returns(uint256)\n    {\n        return balance;\n    }\n\n    function approve(address _target) external\n    {\n        require(msg.sender == _owner, \u0027unauthorized\u0027);\n        _approved[_target] = true;\n    }\n\n    function reject(address _target) external\n    {\n        require(msg.sender == _owner, \u0027unauthorized\u0027);\n        _approved[_target] = false;\n    }\n\n    function isApproved(address _target) view external returns(bool)\n    {\n        return _approved[_target];\n    }\n\n    function withdraw(uint256 value) external\n    {\n        require(balance \u003e= value, \u0027not enough\u0027);\n        require(msg.sender == _owner, \u0027unauthorized\u0027);\n        msg.sender.transfer(value);\n    }\n\n    function drop(address payable[] calldata _toList, uint256[] calldata _amountList) external\n    {\n        require(_approved[msg.sender], \u0027unauthorized\u0027);\n        require(_toList.length == _amountList.length, \u0027Not valid list length\u0027);\n\n        uint256 sumOfBalances = 0;\n        for(uint256 i=0; i\u003c_amountList.length; i++)\n        {\n            sumOfBalances = sumOfBalances.add(_amountList[i]);\n        }\n\n        require(balance \u003e= sumOfBalances, \u0027not enough\u0027);\n\n        for(uint256 i=0; i\u003c_toList.length; i++)\n        {\n            _toList[i].transfer(_amountList[i]);\n        }\n\n        emit Drop(_toList, _amountList);\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.5.11;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}"}}