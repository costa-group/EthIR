{"Context.sol":{"content":"pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ERC1820Client.sol":{"content":"pragma solidity ^0.5.3;\n\n\ncontract ERC1820Registry {\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\n    function setManager(address _addr, address _newManager) external;\n    function getManager(address _addr) public view returns (address);\n}\n\n\n/// Base client to interact with the registry.\ncontract ERC1820Client {\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\n    }\n\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        ERC1820REGISTRY.setManager(address(this), _newManager);\n    }\n}\n"},"ICALL.sol":{"content":"pragma solidity 0.5.8;\n\ninterface ICALL {\n    function multiPartySend(address[] calldata _toAddresses, uint256[] calldata _amounts, bytes calldata _userData) external;\n    function send(address to, uint256 amount, bytes calldata data) external;\n    function balanceOf(address owner) external view returns (uint256);\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"ProjectVoting.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./ICALL.sol\";\nimport {Ownable} from \"./Ownable.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {ERC1820Client} from \"./ERC1820Client.sol\";\n\ncontract ProjectVoting is Ownable, ERC1820Client { // solhint-disable-line max-states-count\n\n    using SafeMath for uint256;\n\n    event PVoteStateChanged(PVoteState old_state, PVoteState new_state, uint256 indexed round);\n\n    event Vote(address voter, uint256 power, uint256 indexed project_id, uint256 indexed round);\n\n    event Winner(uint256 project_id, uint256 indexed round);\n\n    event ProjectAdded(bytes32 title, bytes32 ipfsData, uint8 hashFunction, uint8 size, uint256 indexed id, uint256 indexed round);\n\n    enum PVoteState {\n        ADD_PROJECTS,\n        VOTE,\n        REFUND,\n        CLEAR\n    }\n\n    ICALL public callObj;\n\n    /*                                         GENERAL VARIABLES                                          */\n    /*                                               START                                                */\n    /* ================================================================================================== */\n\n    uint256 public voteEndTime;\n    uint256 public votingTime; //timestamp for vote to end\n    uint256 public clearTime;\n    PVoteState public state; //0-\u003eadd projects 1-\u003evote 2-\u003erefunding 3-\u003eclearing\n\n    uint256 public totalVoters;\n    uint256 public totalToRefund;\n\n    mapping(address =\u003e uint256) public powerOf; //totalAmount each address submitted\n    mapping(uint256 =\u003e address) public voters; //mapping finding voters, so as to iterate\n    mapping(address =\u003e uint256) public votedFor; //mapping so as to know that each address votes exactly for one project\n\n    /*                                         GENERAL VARIABLES                                          */\n    /*                                                END                                                 */\n    /* ================================================================================================== */\n\n    /*                                          STEP VARIABLES                                            */\n    /*                                               START                                                */\n    /* ================================================================================================== */\n\n    mapping(uint256 =\u003e Project) public projects; //mapping holding info about the steps\n\n    mapping(uint256 =\u003e Ipfs) public ipfses;\n\n    struct Ipfs {\n        bytes32 data;\n        uint8 hashFunction;\n        uint8 size;\n    }\n\n    struct Project {\n        bytes32 title;\n        uint256 value;\n        uint256 id;\n    }\n\n    uint256 public winningId;\n    uint256 public winnerId;\n\n    uint256 public noOfProjects;\n    uint256 public noOfProjectsAdded;\n\n    uint256 public round = 1;\n\n    /*                                          STEP VARIABLES                                            */\n    /*                                               END                                                  */\n    /* ================================================================================================== */\n\n\n    /*                                             MODIFIERS                                              */\n    /*                                               START                                                */\n    /* ================================================================================================== */\n    modifier onlyCall() {\n        require(address(callObj) == msg.sender, \"ProjectVoting: only from CALL\");\n        _;\n    }\n\n    modifier onlyAddProjectsState() {\n        require(state == PVoteState.ADD_PROJECTS, \"ProjectVoting: only in add projects state\");\n        _;\n    }\n\n    modifier onlyVoteState() {\n        require(state == PVoteState.VOTE, \"ProjectVoting: only in vote state\");\n        _;\n    }\n\n    modifier onlyInVoteTime() {\n        require(voteEndTime \u003e now, \"ProjectVoting: Time for vote has ended\");\n        _;\n    }\n\n\n    modifier onlyRefundState() {\n        require(state == PVoteState.REFUND, \"ProjectVoting: only in refund state\");\n        _;\n    }\n\n    modifier onlyInRefundTime() {\n        require(voteEndTime.add(clearTime) \u003e now, \"ProjectVoting: Time for refund has ended\");\n        _;\n    }\n\n    modifier onlyClearState() {\n        require(state == PVoteState.CLEAR, \"ProjectVoting: only in clear state\");\n        _;\n    }\n\n    /*                                             MODIFIERS                                              */\n    /*                                                END                                                 */\n    /* ================================================================================================== */\n\n\n    constructor(address _callAddress, uint256 _votingTime, uint256 _clearTime, uint256 _noOfProjects) public {\n        clearTime = _clearTime;\n        votingTime = _votingTime;\n        callObj = ICALL(_callAddress);\n        noOfProjects = _noOfProjects;\n        setInterfaceImplementation(\"ERC777TokensRecipient\", address(this));\n    }\n\n\n    /**\n     * @notice Set the CALL address\n     * @param _callAddress The address of CALL contract\n     */\n    function setCallAddress(address _callAddress)\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        callObj = ICALL(_callAddress);\n    }\n\n    function setClearTime(uint256 _clearTime)\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        clearTime = _clearTime;\n    }\n\n    function setVoteTime(uint256 _votingTime)\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        votingTime = _votingTime;\n    }\n\n    function setLimit(uint256 _noOfProjects)\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        noOfProjects = _noOfProjects;\n    }\n\n    function checkVoteState()\n    public\n    onlyVoteState\n    {\n        if (voteEndTime \u003c= now) _startRefundState(); // solhint-disable-line not-rely-on-time\n    }\n\n    function checkRefundState()\n    public\n    {\n        if (voteEndTime.add(clearTime) \u003c= now) _startClearState(); // solhint-disable-line not-rely-on-time\n    }\n\n    /*                                            STEP FUNCTIONS                                          */\n    /*                                                START                                               */\n    /* ================================================================================================== */\n\n\n    function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax \u003e 10) loopMax = 10;\n\n        for (uint256 i = 0; i \u003c loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }\n\n    function addProject(\n        bytes32 _title,\n        bytes32 _ipfsData,\n        uint8 _ipfsHashFunction,\n        uint8 _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        noOfProjectsAdded = noOfProjectsAdded.add(1);\n        Ipfs memory ipfs = Ipfs(_ipfsData, _ipfsHashFunction, _ipfsSize);\n        Project memory project;\n        project.title = _title;\n        project.id = noOfProjectsAdded;\n\n        emit ProjectAdded(_title, _ipfsData, _ipfsHashFunction, _ipfsSize, noOfProjectsAdded, round);\n\n        projects[noOfProjectsAdded] = project;\n        ipfses[noOfProjectsAdded] = ipfs;\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }\n\n    function restartAddProjectsState()\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        noOfProjectsAdded = 0;\n    }\n\n    /*                                           STEP FUNCTIONS                                           */\n    /*                                                END                                                 */\n    /* ================================================================================================== */\n\n\n    /*                                          VOTING FUNCTIONS                                          */\n    /*                                                START                                               */\n    /* ================================================================================================== */\n\n\n    /**\n     * @notice function called when this contract receives tokens\n     * @param operator Address sending the tx\n     * @param from Address that sending the funds for the tx\n     * @param to Address in which tx is sent\n     * @param amount Amount of tokens sent\n     * @param userData Data of the from address\n     * @param operatorData Data of the operator address\n     */\n    function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] \u003c= bytes1(uint8(noOfProjects)) \u0026\u0026 userData[0] \u003e 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }\n\n    /*                                          VOTING FUNCTIONS                                          */\n    /*                                                END                                                 */\n    /* ================================================================================================== */\n\n    /*                                          ENDING FUNCTIONS                                          */\n    /*                                               START                                                */\n    /* ================================================================================================== */\n\n     /**\n     * @notice This function returns funds to the voters\n     */\n    function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos \u003c _positions.length; pos++) {\n            if (_positions[pos] \u003c totalVoters \u0026\u0026 powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos \u003c _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 \u0026\u0026 _positions[pos] \u003c totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }\n\n    function returnFunds(uint256 _start, uint256 _stop)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        if (_stop \u003e totalVoters) _stop = totalVoters;\n        uint256 size = _stop.sub(_start);\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n        uint256 arrCurr = 0;\n        for (uint256 pos = _start; pos \u003c _stop; pos++) {\n            addresses[arrCurr] = voters[pos];\n            amounts[arrCurr] = powerOf[addresses[arrCurr]];\n            if (amounts[arrCurr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[arrCurr]] = 0;\n            }\n            arrCurr = arrCurr.add(1);\n        }\n        callObj.multiPartySend(addresses, amounts, \"\"); // solhint-disable-line check-send-result\n        _startAddProjectsState();\n    }\n\n    function returnFunds()\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 amount = powerOf[msg.sender];\n        if (amount == 0) return;\n        totalToRefund = totalToRefund.sub(1);\n        powerOf[msg.sender] = 0;\n        callObj.send(msg.sender, amount, \"\"); // solhint-disable-line check-send-result\n        _startAddProjectsState();\n    }\n\n    function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos \u003c _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }\n\n    /*** State Transitions ***/\n\n    function _startAddProjectsState() internal {\n        if (totalToRefund == 0) {\n            voteEndTime = 0;\n            uint256 balance = callObj.balanceOf(address(this));\n            PVoteState oldState = state; //we don\u0027t know if it was clear or refund before\n\n            state = PVoteState.ADD_PROJECTS; // solhint-disable-line reentrancy\n            emit PVoteStateChanged(oldState, PVoteState.ADD_PROJECTS, round);\n            round = round.add(1);\n            if (balance != 0) callObj.send(owner(), balance, \"\"); // solhint-disable-line check-send-result\n        }\n    }\n\n    function _startVoteState(uint256 _endTime) internal {\n        // solhint-disable-next-line not-rely-on-time\n        require(_endTime \u003e now, \"ProjectVoting: timestamp must be a point in the future\");\n        voteEndTime = _endTime;\n        state = PVoteState.VOTE;\n        emit PVoteStateChanged(PVoteState.ADD_PROJECTS, PVoteState.VOTE, round);\n        totalVoters = 0; //Maybe another place\n    }\n\n    function _startRefundState() internal {\n        state = PVoteState.REFUND;\n        emit PVoteStateChanged(PVoteState.VOTE, PVoteState.REFUND, round);\n        winnerId = winningId;\n        emit Winner(winnerId, round);\n        winningId = 0;\n        totalToRefund = totalVoters;\n        // event for Winner\n    }\n\n    function _startClearState() internal {\n        state = PVoteState.CLEAR;\n        emit PVoteStateChanged(PVoteState.REFUND, PVoteState.CLEAR, round);\n    }\n\n    /**\n     * @notice This function is called by CALL contract, when a client decides that he likes changes, in tokensReceived step\n     * @param _sender the sender of the tx\n     * @param _power The value of tokens _sender moved to this contract\n     */\n    function _vote(address _sender, uint256 _power, uint256 _id)\n    internal\n    onlyVoteState\n    onlyInVoteTime\n    {\n        require(_power != 0, \"ProjectVoting: Cannot vote with 0 value\");\n\n        if (powerOf[_sender] == 0) {\n            powerOf[_sender] = _power;\n            voters[totalVoters] = _sender;\n            totalVoters = totalVoters.add(1);\n            votedFor[_sender] = _id;\n        } else {\n            require(votedFor[_sender] == _id, \"ProjectVoting: Cannot vote for different projects\");\n            powerOf[_sender] = powerOf[_sender].add(_power);\n        }\n        projects[_id].value = projects[_id].value.add(_power);\n\n        emit Vote(_sender, _power, _id, round);\n\n        if (projects[_id].value \u003e projects[winningId].value) winningId = _id;\n    }\n\n    /*                                          ENDING FUNCTIONS                                          */\n    /*                                                END                                                 */\n    /* ================================================================================================== */\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}