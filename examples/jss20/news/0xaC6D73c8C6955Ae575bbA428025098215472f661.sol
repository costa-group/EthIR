{"Address.sol":{"content":"pragma solidity ^0.5.3;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size \u003e 0;\n    }\n}\n"},"iERC20Token.sol":{"content":"pragma solidity ^0.5.3;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20Token {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"Migrations.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.3;\n\ncontract Owned {\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function changeOwner(address _newOwner) public onlyOwner returns (bool success) {\n        owner = _newOwner;\n        return true;\n    }\n}\n"},"Pausable.sol":{"content":"pragma solidity ^0.5.3;\n\nimport { Owned } from \"./Ownable.sol\";\n\ncontract Pausable is Owned{\n    bool public isPaused;\n    \n    event Pause(address _owner, uint _timestamp);\n    event Unpause(address _owner, uint _timestamp);\n    \n    modifier whenPaused {\n        require(isPaused);\n        _;\n    }\n    \n    modifier whenNotPaused {\n        require(!isPaused);\n        _;\n    }\n    \n    function pause() public onlyOwner whenNotPaused {\n        isPaused = true;\n        emit Pause(msg.sender, now);\n    }\n    \n    function unpause() public onlyOwner whenPaused {\n        isPaused = false;\n        emit Unpause(msg.sender, now);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.3;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"},"Token.sol":{"content":"pragma solidity ^0.5.3;\n\n// ----------------------------------------------------------------------------\n// \u0027CRYPTOBUCKS\u0027 Token Contract\n//\n// Deployed To : 0x4d9ee34b7ee0d3cef04e5909c27a266e7eb14712\n// Symbol      : CBUCKS\n// Name        : CRYPTOBUCKS\n// Total Supply: 1,000,000,000 CBUCKS\n// Decimals    : 2\n//\n// (c) By \u0027ANONYMOUS\u0027 With \u0027CBUCKS\u0027 Symbol 2019.\n//\n// ----------------------------------------------------------------------------\n\n// Interfaces\nimport { IERC20Token } from \"./iERC20Token.sol\";\n// Libraries\nimport { SafeMath } from \"./SafeMath.sol\";\nimport { Whitelist } from \"./Whitelist.sol\";\nimport { Address } from \"./Address.sol\";\n// Inherited Contracts\nimport { Pausable } from \"./Pausable.sol\";\n\ncontract Token is IERC20Token, Whitelist, Pausable {\n  using SafeMath for uint256;\n  using Address for address;\n\n  string _name;\n  string _symbol;\n  uint256 _totalSupply;\n  uint256 _decimals;\n  uint256 _burnRate;\n  uint256 _totalBurned;\n\n  constructor () public {\n    _name = \"CRYPTOBUCKS\";\n    _symbol = \"CBUCKS\";\n    _totalSupply = 100000000000;\n    _decimals = 2;\n    _burnRate = 100;\n    _totalBurned = 0;\n    balances[0xE43eBCb96564a6FB3B7A4AbbfD7008b415591b09] = _totalSupply;\n    emit Transfer(address(this), 0xE43eBCb96564a6FB3B7A4AbbfD7008b415591b09, _totalSupply);\n  }\n\n  mapping(address =\u003e uint256) private balances;\n  mapping(address =\u003e mapping(address =\u003e uint256)) private allowed;\n  event Burned(address indexed from, uint256 value, uint256 timestamp);\n  event BurnRateChanged(address indexed from, uint256 value, uint256 timestamp);\n\n  function name() external view returns (string memory) {\n    return _name;\n  }\n\n  function symbol() external view returns (string memory) {\n    return _symbol;\n  }\n\n  function totalSupply() external view returns (uint256) {\n    return _totalSupply;\n  }\n\n  function decimals() external view returns (uint256) {\n    return _decimals;\n  }\n\n  function balanceOf(address account) external view returns (uint256) {\n    return balances[account];\n  }\n\n  function allowance(address owner, address spender) external view returns (uint256) {\n    return allowed[owner][spender];\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n    ) external whenNotPaused onlyWhitelisted(msg.sender, recipient) validRecipient(recipient)\n    validAmount(amount) validAddress(recipient) sufficientBalance(msg.sender, amount) returns (bool) {\n      balances[msg.sender] = balances[msg.sender].sub(amount);\n      balances[recipient] = balances[recipient].add(amount);\n      burn();\n      emit Transfer(msg.sender, recipient, amount);\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n    ) external whenNotPaused validAddress(spender) validRecipient(spender)\n    validAmount(amount) sufficientBalance(msg.sender, amount) returns (bool) {\n    allowed[msg.sender][spender] = allowed[msg.sender][spender].add(amount);\n    emit Approval(msg.sender, spender, amount);\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n    ) external whenNotPaused validAddress(recipient) validRecipient(recipient)\n    validAmount(amount) sufficientBalance(msg.sender, amount) returns (bool) {\n      require(allowed[sender][msg.sender] \u003e= amount, \"Above spender allowance.\");\n      allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(amount);\n      balances[recipient] = balances[recipient].add(amount);\n      burn();\n      emit Transfer(sender, recipient, amount);\n    }\n\n  modifier validAddress(address _address) {\n    require(_address != address(0), \"Cannot send to address 0x0.\");\n    _;\n  }\n\n  modifier validAmount(uint256 _amount) {\n    require(_amount \u003e 0, \"Amount must be greater than 0.\");\n    _;\n  } \n\n  modifier sufficientBalance(address _sender, uint256 _amount) {\n    require(balances[_sender] \u003e= _amount.add(_burnRate), \"Insufficient Funds.\");\n    _;\n  }\n\n  modifier validRecipient(address _address) {\n    require(msg.sender != _address, \"Cannot send to yourself.\");\n    _;\n  }\n\n  // BURN FUNCTIONALITIES\n\n  function burnRate() external view returns (uint256) {\n    return _burnRate;\n  }\n\n  function totalBurned() external view returns (uint256) {\n    return _totalBurned;\n  }\n\n  function burn() internal whenNotPaused returns (bool) {\n      balances[msg.sender] = balances[msg.sender].sub(_burnRate);\n      _totalSupply = _totalSupply.sub(_burnRate);\n      _totalBurned = _totalBurned.add(_burnRate);\n      emit Burned(msg.sender, _burnRate, now);\n  }\n\n  function changeBurnRate(\n    uint256 _amount) external onlyOwner returns (bool) {\n      _burnRate = _amount;\n      emit BurnRateChanged(msg.sender, _amount, now);\n    }\n}"},"Whitelist.sol":{"content":"pragma solidity ^0.5.3;\n\nimport { Owned } from \"./Ownable.sol\";\n\ncontract Whitelist is Owned{\n    \n    bool public whitelistToggle = false;\n    \n    mapping(address =\u003e bool) whitelistedAccounts;\n    \n    modifier onlyWhitelisted(address from, address to) {\n        if(whitelistToggle){\n            require(whitelistedAccounts[from], \"Sender account is not whitelisted\");\n            require(whitelistedAccounts[to], \"Receiver account is not whitelisted\");\n        }\n        _;\n    }\n    \n    event Whitelisted(address account);\n    event UnWhitelisted(address account);\n    \n    event ToggleWhitelist(address sender, uint timestamp);\n    event UntoggleWhitelist(address sender, uint timestamp);\n    \n    function addWhitelist(address account) public onlyOwner returns(bool) {\n        whitelistedAccounts[account] = true;\n        emit Whitelisted(account);\n    }\n        \n    function removeWhitelist(address account) public onlyOwner returns(bool) {\n        whitelistedAccounts[account] = false;\n        emit UnWhitelisted(account);\n    }\n    \n    function toggle() external onlyOwner {\n        whitelistToggle = true;\n        emit ToggleWhitelist(msg.sender, now);\n    }\n    \n    function untoggle() external onlyOwner {\n        whitelistToggle = false;\n        emit UntoggleWhitelist(msg.sender, now);\n    }\n    \n    function isWhiteListed(address account) public view returns(bool){\n        return whitelistedAccounts[account];\n    }\n    \n}\n"}}