{"newinsurancecontract.sol":{"content":"pragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\nimport \"./token.sol\";\n\ncontract globalinsurance {\n\n    constructor(address paxtoken) public{\n        token = PAXImplementation(paxtoken);\n        deployTime = now;\n        tokenAdd = paxtoken;\n        sAd = msg.sender;\n        releaseTime = deployTime;\n        mAd = msg.sender;\n    }\n     \n    using SafeMath for uint256;\n    \n    PAXImplementation token;\n    address public sAd;\n    address public tokenAdd;\n    address public mAd;\n    \n    address public insurance1;\n    address public insurance2;\n    address public insurance3;\n    address public insurance4;\n    address public insurance5;\n    address public insurance6;\n    address public insurance7;\n    address public insurance8;\n    \n    \n    uint256 public insurance14Bal;              \n    uint256 public insurance25Bal;       \n    uint256 public insurance36Bal;         \n    uint256 public insurance78Bal;\n\n    uint256 public deployTime;\n    uint256 public releaseTime;\n   \n\n    event PoolAddressAdded(\n        string pool, \n        address seAdd);\n\n    event Insurance1FundsUpdated(uint256 insurance14Bal);\n    event Insurance2FundsUpdated(uint256 insurance25Bal);\n    event Insurance3FundsUpdated(uint256 insurance36Bal);\n    event Insurance4FundsUpdated(uint256 insurance14Bal);\n    event Insurance5FundsUpdated(uint256 insurance25Bal);\n    event Insurance6FundsUpdated(uint256 insurance36Bal);\n    event Insurance7FundsUpdated(uint256 insurance78Bal);\n    event Insurance8FundsUpdated(uint256 insurance78Bal);\n\n\n    modifier onSAd() {\n        require(msg.sender == sAd, \"onSad\");\n        _;\n    }\n    \n     modifier onMan() {\n        require(msg.sender == mAd || msg.sender == sAd, \"onMan\");\n        _;\n    }\n    \n    function adMan(address _manAd) public onSAd {\n        mAd = _manAd;\n    \n    }\n    \n    function remMan() public onSAd {\n        mAd = sAd;\n    }\n    \n\n    function jackAd(address[8] calldata pool) external onSAd  returns(bool){\n\n\n        if(pool[0] != address(0)){\n          insurance1 = pool[0];\n          emit PoolAddressAdded(\"jackpot1\", insurance1);\n        }\n        if(pool[1] != address(0)){\n          insurance2 = pool[1];\n          emit PoolAddressAdded(\"jackpot2\", insurance2);\n        }\n        if(pool[2] != address(0)){\n          insurance3 = pool[2];\n          emit PoolAddressAdded(\"jackpot3\", insurance3);\n        }\n\n        if(pool[3] != address(0)){\n          insurance4 = pool[3];\n          emit PoolAddressAdded(\"jackpot4\", insurance4);\n        }\n        if(pool[4] != address(0)){\n          insurance5 = pool[4];\n          emit PoolAddressAdded(\"jackpot5\", insurance5);\n        }\n        if(pool[5] != address(0)){\n          insurance6 = pool[5];\n          emit PoolAddressAdded(\"jackpot6\", insurance6);\n        }\n        if(pool[6] != address(0)){\n          insurance7 = pool[6];\n          emit PoolAddressAdded(\"jackpot7\", insurance7);\n        }\n        if(pool[7] != address(0)){\n          insurance8 = pool[7];\n          emit PoolAddressAdded(\"jackpot8\", insurance8);\n        }\n        return true;\n      }\n\n    function witAd(uint256[8] calldata pool) external onMan returns(bool){\n      \n        token.transfer(insurance1, pool[0]);\n        token.transfer(insurance2, pool[1]);\n        token.transfer(insurance3, pool[2]);\n        token.transfer(insurance4, pool[3]);\n        token.transfer(insurance5, pool[4]);\n        token.transfer(insurance6, pool[5]);\n        token.transfer(insurance7, pool[6]);\n        token.transfer(insurance8, pool[7]);\n        \n        insurance14Bal = insurance14Bal+pool[0]+pool[3];\n        insurance25Bal = insurance25Bal+pool[1]+pool[4];\n        insurance36Bal = insurance36Bal+pool[2]+pool[5];\n        insurance78Bal = insurance78Bal+pool[6]+pool[7];\n        \n        emit Insurance1FundsUpdated(pool[0]);\n        emit Insurance2FundsUpdated(pool[1]);\n        emit Insurance3FundsUpdated(pool[2]);\n        emit Insurance4FundsUpdated(pool[3]);\n        emit Insurance5FundsUpdated(pool[4]);\n        emit Insurance6FundsUpdated(pool[5]);\n        emit Insurance7FundsUpdated(pool[6]);\n        emit Insurance8FundsUpdated(pool[7]);\n    \n        releaseTime = now;\n        return true;\n        \n    }\n\n\n    \n    function feeC() public view returns (uint256) {\n        return address(this).balance;\n    }\n    \n    function witE() public onMan{\n        msg.sender.transfer(address(this).balance);\n    }\n    \n    function tokC() public view returns (uint256){\n        return token.balanceOf(address(this));\n    }\n\n  \n}"},"SafeMath.sol":{"content":"pragma solidity ^0.5.16;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"},"token.sol":{"content":"pragma solidity ^0.5.16;\n\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title PAXImplementation\n * @dev this contract is a Pausable ERC20 token with Burn and Mint\n * controleld by a central SupplyController. By implementing PaxosImplementation\n * this contract also includes external methods for setting\n * a new implementation contract for the Proxy.\n * NOTE: The storage defined here will actually be held in the Proxy\n * contract and all calls to this contract should be made through\n * the proxy, including admin actions done as owner or supplyController.\n * Any call to transfer against this contract should fail\n * with insufficient funds since no tokens will be issued there.\n */\n \n \ncontract PAXImplementation {\n\n    /**\n     * MATH\n     */\n\n    using SafeMath for uint256;\n\n    /**\n     * DATA\n     */\n\n    // INITIALIZATION DATA\n    bool private initialized = false;\n\n    // ERC20 BASIC DATA\n    mapping(address =\u003e uint256) internal balances;\n    uint256 internal totalSupply_;\n    string public constant name = \"PAX\"; // solium-disable-line uppercase\n    string public constant symbol = \"PAX\"; // solium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    // ERC20 DATA\n    mapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n\n    // OWNER DATA\n    address public owner;\n\n    // PAUSABILITY DATA\n    bool public paused = false;\n\n    // LAW ENFORCEMENT DATA\n    address public lawEnforcementRole;\n    mapping(address =\u003e bool) internal frozen;\n\n    // SUPPLY CONTROL DATA\n    address public supplyController;\n\n    /**\n     * EVENTS\n     */\n\n    // ERC20 BASIC EVENTS\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // ERC20 EVENTS\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    // OWNABLE EVENTS\n    event OwnershipTransferred(\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n    // PAUSABLE EVENTS\n    event Pause();\n    event Unpause();\n\n    // LAW ENFORCEMENT EVENTS\n    event AddressFrozen(address indexed addr);\n    event AddressUnfrozen(address indexed addr);\n    event FrozenAddressWiped(address indexed addr);\n    event LawEnforcementRoleSet (\n        address indexed oldLawEnforcementRole,\n        address indexed newLawEnforcementRole\n    );\n\n    // SUPPLY CONTROL EVENTS\n    event SupplyIncreased(address indexed to, uint256 value);\n    event SupplyDecreased(address indexed from, uint256 value);\n    event SupplyControllerSet(\n        address indexed oldSupplyController,\n        address indexed newSupplyController\n    );\n\n    /**\n     * FUNCTIONALITY\n     */\n\n    // INITIALIZATION FUNCTIONALITY\n\n    /**\n     * @dev sets 0 initials tokens, the owner, and the supplyController.\n     * this serves as the constructor for the proxy but compiles to the\n     * memory model of the Implementation contract.\n     */\n    function initialize() public {\n        require(!initialized, \"already initialized\");\n        owner = msg.sender;\n        lawEnforcementRole = address(0);\n        totalSupply_ = 0;\n        supplyController = msg.sender;\n        initialized = true;\n    }\n\n    /**\n     * The constructor is used here to ensure that the implementation\n     * contract is initialized. An uncontrolled implementation\n     * contract might lead to misleading state\n     * for users who accidentally interact with it.\n     */\n    constructor() public {\n        initialize();\n        pause();\n    }\n\n    // ERC20 BASIC FUNCTIONALITY\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n        require(_to != address(0), \"cannot transfer to address zero\");\n        require(!frozen[_to] \u0026\u0026 !frozen[msg.sender], \"address frozen\");\n        require(_value \u003c= balances[msg.sender], \"insufficient funds\");\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _addr The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _addr) public view returns (uint256) {\n        return balances[_addr];\n    }\n\n    // ERC20 FUNCTIONALITY\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    public\n    whenNotPaused\n    returns (bool)\n    {\n        require(_to != address(0), \"cannot transfer to address zero\");\n        require(!frozen[_to] \u0026\u0026 !frozen[_from] \u0026\u0026 !frozen[msg.sender], \"address frozen\");\n        require(_value \u003c= balances[_from], \"insufficient funds\");\n        require(_value \u003c= allowed[_from][msg.sender], \"insufficient allowance\");\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n        require(!frozen[_spender] \u0026\u0026 !frozen[msg.sender], \"address frozen\");\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n    public\n    view\n    returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    // OWNER FUNCTIONALITY\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"onlyOwner\");\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"cannot transfer ownership to address zero\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n\n    // PAUSABILITY FUNCTIONALITY\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused, \"whenNotPaused\");\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner {\n        require(!paused, \"already paused\");\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner {\n        require(paused, \"already unpaused\");\n        paused = false;\n        emit Unpause();\n    }\n\n    // LAW ENFORCEMENT FUNCTIONALITY\n\n    /**\n     * @dev Sets a new law enforcement role address.\n     * @param _newLawEnforcementRole The new address allowed to freeze/unfreeze addresses and seize their tokens.\n     */\n    function setLawEnforcementRole(address _newLawEnforcementRole) public {\n        require(msg.sender == lawEnforcementRole || msg.sender == owner, \"only lawEnforcementRole or Owner\");\n        emit LawEnforcementRoleSet(lawEnforcementRole, _newLawEnforcementRole);\n        lawEnforcementRole = _newLawEnforcementRole;\n    }\n\n    modifier onlyLawEnforcementRole() {\n        require(msg.sender == lawEnforcementRole, \"onlyLawEnforcementRole\");\n        _;\n    }\n\n    /**\n     * @dev Freezes an address balance from being transferred.\n     * @param _addr The new address to freeze.\n     */\n    function freeze(address _addr) public onlyLawEnforcementRole {\n        require(!frozen[_addr], \"address already frozen\");\n        frozen[_addr] = true;\n        emit AddressFrozen(_addr);\n    }\n\n    /**\n     * @dev Unfreezes an address balance allowing transfer.\n     * @param _addr The new address to unfreeze.\n     */\n    function unfreeze(address _addr) public onlyLawEnforcementRole {\n        require(frozen[_addr], \"address already unfrozen\");\n        frozen[_addr] = false;\n        emit AddressUnfrozen(_addr);\n    }\n\n    /**\n     * @dev Wipes the balance of a frozen address, burning the tokens\n     * and setting the approval to zero.\n     * @param _addr The new frozen address to wipe.\n     */\n    function wipeFrozenAddress(address _addr) public onlyLawEnforcementRole {\n        require(frozen[_addr], \"address is not frozen\");\n        uint256 _balance = balances[_addr];\n        balances[_addr] = 0;\n        totalSupply_ = totalSupply_.sub(_balance);\n        emit FrozenAddressWiped(_addr);\n        emit SupplyDecreased(_addr, _balance);\n        emit Transfer(_addr, address(0), _balance);\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _addr The address to check if frozen.\n    * @return A bool representing whether the given address is frozen.\n    */\n    function isFrozen(address _addr) public view returns (bool) {\n        return frozen[_addr];\n    }\n\n    // SUPPLY CONTROL FUNCTIONALITY\n\n    /**\n     * @dev Sets a new supply controller address.\n     * @param _newSupplyController The address allowed to burn/mint tokens to control supply.\n     */\n    function setSupplyController(address _newSupplyController) public {\n        require(msg.sender == supplyController || msg.sender == owner, \"only SupplyController or Owner\");\n        require(_newSupplyController != address(0), \"cannot set supply controller to address zero\");\n        emit SupplyControllerSet(supplyController, _newSupplyController);\n        supplyController = _newSupplyController;\n    }\n\n    modifier onlySupplyController() {\n        require(msg.sender == supplyController, \"onlySupplyController\");\n        _;\n    }\n\n    /**\n     * @dev Increases the total supply by minting the specified number of tokens to the supply controller account.\n     * @param _value The number of tokens to add.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function increaseSupply(uint256 _value) public onlySupplyController returns (bool success) {\n        totalSupply_ = totalSupply_.add(_value);\n        balances[supplyController] = balances[supplyController].add(_value);\n        emit SupplyIncreased(supplyController, _value);\n        emit Transfer(address(0), supplyController, _value);\n        return true;\n    }\n\n    /**\n     * @dev Decreases the total supply by burning the specified number of tokens from the supply controller account.\n     * @param _value The number of tokens to remove.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function decreaseSupply(uint256 _value) public onlySupplyController returns (bool success) {\n        require(_value \u003c= balances[supplyController], \"not enough supply\");\n        balances[supplyController] = balances[supplyController].sub(_value);\n        totalSupply_ = totalSupply_.sub(_value);\n        emit SupplyDecreased(supplyController, _value);\n        emit Transfer(supplyController, address(0), _value);\n        return true;\n    }\n}\n"}}