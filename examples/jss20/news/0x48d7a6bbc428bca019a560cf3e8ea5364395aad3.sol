{{
  "language": "Solidity",
  "sources": {
    "/Users/jake/plasma-contracts/plasma_framework/contracts/Migrations.sol": {
      "content": "pragma solidity >=0.4.21 <0.6.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/Imports.sol": {
      "content": "pragma solidity 0.5.11;\n\n// Import contracts from third party Solidity libraries to make them available in tests.\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol\";\n\ncontract Import {\n    // dummy empty contract to allow the compiler not always trying to re-compile this file.\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/attackers/FailFastReentrancyGuardAttacker.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/utils/FailFastReentrancyGuard.sol\";\nimport \"../../src/framework/PlasmaFramework.sol\";\n\ncontract FailFastReentrancyGuardAttacker is FailFastReentrancyGuard {\n    PlasmaFramework private framework;\n\n    event RemoteCallFailed();\n\n    constructor(PlasmaFramework plasmaFramework) public {\n        framework = plasmaFramework;\n    }\n\n    function guardedLocal() public nonReentrant(framework) {\n        guardedLocal();\n    }\n\n    function guardedRemote() external nonReentrant(framework) {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = address(this).call(abi.encodeWithSignature(\"guardedRemote()\"));\n        if (!success) {\n            emit RemoteCallFailed();\n        }\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/attackers/FallbackFunctionFailAttacker.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\ncontract FallbackFunctionFailAttacker {\n    function () external payable {\n        revert(\"fail on fallback function\");\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/attackers/OutOfGasFallbackAttacker.sol": {
      "content": "pragma solidity 0.5.11;\n\ncontract OutOfGasFallbackAttacker {\n    function () external payable {\n        while (true) {}\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/SpendingConditionMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/exits/interfaces/ISpendingCondition.sol\";\n\ncontract SpendingConditionMock is ISpendingCondition {\n    bool internal expectedResult;\n    bool internal shouldRevert;\n    Args internal expectedArgs;\n\n    string constant internal REVERT_MESSAGE = \"Test spending condition reverts\";\n\n    struct Args {\n        bytes inputTx;\n        uint256 utxoPos;\n        bytes spendingTx;\n        uint16 inputIndex;\n        bytes witness;\n    }\n\n    /** mock what would \"verify()\" returns */\n    function mockResult(bool result) public {\n        expectedResult = result;\n    }\n\n    /** when called, the spending condition would always revert on purpose */\n    function mockRevert() public {\n        shouldRevert = true;\n    }\n\n    /** provide the expected args, it would check with the value called for \"verify()\" */\n    function shouldVerifyArgumentEquals(Args memory args) public {\n        expectedArgs = args;\n    }\n\n    /** override */\n    function verify(\n        bytes calldata inputTx,\n        uint256 utxoPos,\n        bytes calldata spendingTx,\n        uint16 inputIndex,\n        bytes calldata witness\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (shouldRevert) {\n            revert(REVERT_MESSAGE);\n        }\n\n        // only run the check when \"shouldVerifyArgumentEqauals\" is called\n        if (expectedArgs.inputTx.length > 0) {\n            require(keccak256(expectedArgs.inputTx) == keccak256(inputTx), \"input tx not as expected\");\n            require(expectedArgs.utxoPos == utxoPos, \"utxoPos not as expected\");\n            require(keccak256(expectedArgs.spendingTx) == keccak256(spendingTx), \"spending tx not as expected\");\n            require(expectedArgs.inputIndex == inputIndex, \"input index not as expected\");\n            require(keccak256(expectedArgs.witness) == keccak256(witness), \"witness not as expected\");\n        }\n        return expectedResult;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/SpyPlasmaFrameworkForExitGame.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/framework/PlasmaFramework.sol\";\nimport \"../../src/utils/PosLib.sol\";\nimport \"../../src/framework/models/BlockModel.sol\";\n\ncontract SpyPlasmaFrameworkForExitGame is PlasmaFramework {\n    using PosLib for PosLib.Position;\n\n    uint256 public enqueuedCount = 0;\n    mapping (uint256 => BlockModel.Block) public blocks;\n\n    event EnqueueTriggered(\n        uint256 vaultId,\n        address token,\n        uint64 exitableAt,\n        uint256 txPos,\n        uint256 exitId,\n        address exitProcessor\n    );\n\n    /** This spy contract set the authority and maintainer both to the caller */\n    constructor(uint256 _minExitPeriod, uint256 _initialImmuneVaults, uint256 _initialImmuneExitGames)\n        public\n        PlasmaFramework(_minExitPeriod, _initialImmuneVaults, _initialImmuneExitGames, msg.sender, msg.sender)\n    {\n    }\n\n    /** override for test */\n    function enqueue(\n        uint256 _vaultId,\n        address _token,\n        uint64 _exitableAt,\n        PosLib.Position calldata _txPos,\n        uint160 _exitId,\n        IExitProcessor _exitProcessor\n    )\n        external\n        returns (uint256)\n    {\n        enqueuedCount += 1;\n        emit EnqueueTriggered(\n            _vaultId,\n            _token,\n            _exitableAt,\n            _txPos.getTxPositionForExitPriority(),\n            _exitId,\n            address(_exitProcessor)\n        );\n        return enqueuedCount;\n    }\n\n    /**\n     Custom test helpers\n     */\n    function setBlock(uint256 _blockNum, bytes32 _root, uint256 _timestamp) external {\n        blocks[_blockNum] = BlockModel.Block(_root, _timestamp);\n    }\n\n    function setOutputFinalized(bytes32 _outputId, uint160 _exitId) external {\n        outputsFinalizations[_outputId] = _exitId;\n    }\n\n    /**\n     * Override to remove check that block exists\n     */\n    function isDeposit(uint256 blockNum) public view returns (bool) {\n        return blockNum % childBlockInterval != 0;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/StateTransitionVerifierMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/exits/interfaces/IStateTransitionVerifier.sol\";\n\ncontract StateTransitionVerifierMock is IStateTransitionVerifier {\n    bool public expectedResult;\n    bool public shouldRevert;\n    Args public expectedArgs;\n\n    struct Args {\n        bytes inFlightTx;\n        bytes[] inputTxs;\n        uint16[] outputIndexOfInputTxs;\n    }\n\n    /** mock what \"isCorrectStateTransition()\" returns */\n    function mockResult(bool result) public {\n        expectedResult = result;\n    }\n\n    /** when called, the \"isCorrectStateTransition\" function reverts on purpose */\n    function mockRevert() public {\n        shouldRevert = true;\n    }\n\n    /** provide the expected args, it would check with the value called for \"verify()\" */\n    function shouldVerifyArgumentEquals(Args memory args)\n        public\n    {\n        expectedArgs = args;\n    }\n\n    function isCorrectStateTransition(\n        bytes calldata inFlightTx,\n        bytes[] calldata inputTxs,\n        uint16[] calldata outputIndexOfInputTxs\n    )\n        external\n        view\n        returns (bool)\n    {\n        if (shouldRevert) {\n            revert(\"Failing on purpose\");\n        }\n\n        // only run the check when \"shouldVerifyArgumentEqauals\" is called\n        if (expectedArgs.inFlightTx.length > 0) {\n            require(keccak256(inFlightTx) == keccak256(expectedArgs.inFlightTx), \"in-flight tx is not as expected\");\n\n            require(inputTxs.length == expectedArgs.inputTxs.length, \"input txs array length mismatches expected data\");\n            for (uint i = 0; i < expectedArgs.inputTxs.length; i++) {\n                require(keccak256(inputTxs[i]) == keccak256(expectedArgs.inputTxs[i]), \"input tx is not as expected\");\n            }\n\n            require(outputIndexOfInputTxs.length == expectedArgs.outputIndexOfInputTxs.length, \"outputIndex array length mismatches expected data\");\n            for (uint i = 0; i < expectedArgs.outputIndexOfInputTxs.length; i++) {\n                require(outputIndexOfInputTxs[i] == expectedArgs.outputIndexOfInputTxs[i], \"output index of input txs is not as expected\");\n            }\n        }\n\n        return expectedResult;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/dummyVaults/SpyErc20VaultForExitGame.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/vaults/Erc20Vault.sol\";\nimport \"../../../src/framework/PlasmaFramework.sol\";\n\ncontract SpyErc20VaultForExitGame is Erc20Vault {\n    event Erc20WithdrawCalled(\n        address target,\n        address token,\n        uint256 amount\n    );\n\n    constructor(PlasmaFramework _framework) public Erc20Vault(_framework) {}\n\n    /** override for test */\n    function withdraw(address payable _target, address _token, uint256 _amount) external {\n        emit Erc20WithdrawCalled(_target, _token, _amount);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/dummyVaults/SpyEthVaultForExitGame.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/vaults/EthVault.sol\";\nimport \"../../../src/framework/PlasmaFramework.sol\";\n\ncontract SpyEthVaultForExitGame is EthVault {\n    uint256 public constant SAFE_GAS_STIPEND = 2300;\n\n    event EthWithdrawCalled(\n        address target,\n        uint256 amount\n    );\n\n    constructor(PlasmaFramework _framework) public EthVault(_framework, SAFE_GAS_STIPEND) {}\n\n    /** override for test */\n    function withdraw(address payable _target, uint256 _amount) external {\n        emit EthWithdrawCalled(_target, _amount);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/payment/PaymentInFlightExitModelUtilsMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../../src/exits/payment/PaymentInFlightExitModelUtils.sol\";\nimport { PaymentExitDataModel as ExitModel } from \"../../../src/exits/payment/PaymentExitDataModel.sol\";\n\ncontract PaymentInFlightExitModelUtilsMock {\n\n    ExitModel.InFlightExit public ife;\n\n    constructor(uint256 exitMap, uint64 exitStartTimestamp) public {\n        ife.exitMap = exitMap;\n        ife.exitStartTimestamp = exitStartTimestamp;\n    }\n\n    /** Helper functions */\n    function setWithdrawData(\n        string memory target,\n        uint16 index,\n        ExitModel.WithdrawData memory data\n    )\n        public\n    {\n        if (stringEquals(target, \"inputs\")) {\n            ife.inputs[index] = data;\n        } else if (stringEquals(target, \"outputs\")) {\n            ife.outputs[index] = data;\n        } else {\n            revert(\"target should be either inputs or outputs\");\n        }\n    }\n\n    function stringEquals(string memory a, string memory b) private pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n\n    /** Wrapper functions */\n    function isInputEmpty(uint16 index)\n        external\n        view\n        returns (bool)\n    {\n        return PaymentInFlightExitModelUtils.isInputEmpty(ife, index);\n    }\n\n    function isOutputEmpty(uint16 index)\n        external\n        view\n        returns (bool)\n    {\n        return PaymentInFlightExitModelUtils.isOutputEmpty(ife, index);\n    }\n\n    function isInputPiggybacked(uint16 index)\n        external\n        view\n        returns (bool)\n    {\n        return PaymentInFlightExitModelUtils.isInputPiggybacked(ife, index);\n    }\n\n    function isOutputPiggybacked(uint16 index)\n        external\n        view\n        returns (bool)\n    {\n        return PaymentInFlightExitModelUtils.isOutputPiggybacked(ife, index);\n    }\n\n    function setInputPiggybacked(uint16 index)\n        external\n    {\n        PaymentInFlightExitModelUtils.setInputPiggybacked(ife, index);\n    }\n\n    function clearInputPiggybacked(uint16 index)\n        external\n    {\n        PaymentInFlightExitModelUtils.clearInputPiggybacked(ife, index);\n    }\n\n    function setOutputPiggybacked(uint16 index)\n        external\n    {\n        PaymentInFlightExitModelUtils.setOutputPiggybacked(ife, index);\n    }\n\n    function clearOutputPiggybacked(uint16 index)\n        external\n    {\n        PaymentInFlightExitModelUtils.clearOutputPiggybacked(ife, index);\n    }\n\n    function isInFirstPhase(uint256 minExitPeriod)\n        external\n        view\n        returns (bool)\n    {\n        return PaymentInFlightExitModelUtils.isInFirstPhase(ife, minExitPeriod);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/payment/routers/PaymentInFlightExitRouterMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../../../src/exits/payment/PaymentExitDataModel.sol\";\nimport \"../../../../src/exits/payment/routers/PaymentInFlightExitRouter.sol\";\nimport \"../../../../src/exits/payment/routers/PaymentInFlightExitRouterArgs.sol\";\nimport \"../../../../src/framework/PlasmaFramework.sol\";\nimport \"../../../../src/exits/interfaces/IStateTransitionVerifier.sol\";\nimport \"../../../../src/exits/payment/PaymentInFlightExitModelUtils.sol\";\n\nimport \"../../../../src/utils/FailFastReentrancyGuard.sol\";\n\ncontract PaymentInFlightExitRouterMock is FailFastReentrancyGuard, PaymentInFlightExitRouter {\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    PlasmaFramework public framework;\n\n    PaymentInFlightExitRouterArgs.StartExitArgs private startIfeArgs;\n    PaymentInFlightExitRouterArgs.PiggybackInFlightExitOnInputArgs private piggybackInputArgs;\n    PaymentInFlightExitRouterArgs.PiggybackInFlightExitOnOutputArgs private piggybackOutputArgs;\n    PaymentInFlightExitRouterArgs.ChallengeCanonicityArgs private challengeCanonicityArgs;\n    PaymentInFlightExitRouterArgs.ChallengeInputSpentArgs private challengeInputSpentArgs;\n    PaymentInFlightExitRouterArgs.ChallengeOutputSpent private challengeOutputSpentArgs;\n\n    constructor(PaymentExitGameArgs.Args memory args)\n        public\n        PaymentInFlightExitRouter(args)\n    {\n        framework = args.framework;\n    }\n\n    /** override and calls processInFlightExit for test */\n    function processExit(uint160 exitId, uint256, address ercContract) external {\n        PaymentInFlightExitRouter.processInFlightExit(exitId, ercContract);\n    }\n\n    function setInFlightExit(uint160 exitId, PaymentExitDataModel.InFlightExit memory exit) public {\n        PaymentExitDataModel.InFlightExit storage ife = inFlightExitMap.exits[exitId];\n        ife.isCanonical = exit.isCanonical;\n        ife.exitStartTimestamp = exit.exitStartTimestamp;\n        ife.exitMap = exit.exitMap;\n        ife.position = exit.position;\n        ife.bondOwner = exit.bondOwner;\n        ife.bondSize = exit.bondSize;\n        ife.oldestCompetitorPosition = exit.oldestCompetitorPosition;\n\n        for (uint i = 0; i < exit.inputs.length; i++) {\n            ife.inputs[i] = exit.inputs[i];\n        }\n\n        for (uint i = 0; i < exit.outputs.length; i++) {\n            ife.outputs[i] = exit.outputs[i];\n        }\n    }\n\n    function getInFlightExitInput(uint160 exitId, uint16 inputIndex) public view returns (PaymentExitDataModel.WithdrawData memory) {\n        return inFlightExitMap.exits[exitId].inputs[inputIndex];\n    }\n\n    function setInFlightExitInputPiggybacked(uint160 exitId, uint16 inputIndex) public payable {\n        inFlightExitMap.exits[exitId].setInputPiggybacked(inputIndex);\n    }\n\n    function setInFlightExitOutputPiggybacked(uint160 exitId, uint16 outputIndex) public payable {\n        inFlightExitMap.exits[exitId].setOutputPiggybacked(outputIndex);\n    }\n\n    function getInFlightExitOutput(uint160 exitId, uint16 outputIndex) public view returns (PaymentExitDataModel.WithdrawData memory) {\n        return inFlightExitMap.exits[exitId].outputs[outputIndex];\n    }\n\n    /** calls the flagOutputFinalized function on behalf of the exit game */\n    function proxyFlagOutputFinalized(bytes32 outputId, uint160 exitId) public {\n        framework.flagOutputFinalized(outputId, exitId);\n    }\n\n    /**\n     * This function helps test reentrant by making this function itself the first call with 'nonReentrant' protection\n     * So all other PaymentExitGame functions that is protected by 'nonReentrant' too would fail as it would be considered as re-entrancy\n     */\n    function testNonReentrant(string memory testTarget) public nonReentrant(framework) {\n        if (stringEquals(testTarget, \"startInFlightExit\")) {\n            PaymentInFlightExitRouter.startInFlightExit(startIfeArgs);\n        } else if (stringEquals(testTarget, \"piggybackInFlightExitOnInput\")) {\n            PaymentInFlightExitRouter.piggybackInFlightExitOnInput(piggybackInputArgs);\n        } else if (stringEquals(testTarget, \"piggybackInFlightExitOnOutput\")) {\n            PaymentInFlightExitRouter.piggybackInFlightExitOnOutput(piggybackOutputArgs);\n        } else if (stringEquals(testTarget, \"challengeInFlightExitNotCanonical\")) {\n            PaymentInFlightExitRouter.challengeInFlightExitNotCanonical(challengeCanonicityArgs);\n        } else if (stringEquals(testTarget, \"respondToNonCanonicalChallenge\")) {\n            PaymentInFlightExitRouter.respondToNonCanonicalChallenge(bytes(\"\"), 0, bytes(\"\"));\n        } else if (stringEquals(testTarget, \"challengeInFlightExitInputSpent\")) {\n            PaymentInFlightExitRouter.challengeInFlightExitInputSpent(challengeInputSpentArgs);\n        } else if (stringEquals(testTarget, \"challengeInFlightExitOutputSpent\")) {\n            PaymentInFlightExitRouter.challengeInFlightExitOutputSpent(challengeOutputSpentArgs);\n        } else if (stringEquals(testTarget, \"deleteNonPiggybackedInFlightExit\")) {\n            PaymentInFlightExitRouter.deleteNonPiggybackedInFlightExit(uint160(0));\n        }\n\n        revert(\"non defined function\");\n    }\n\n    /** empty function that accepts ETH to fund the contract as test setup */\n    function depositFundForTest() public payable {}\n\n    function stringEquals(string memory a, string memory b) private pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/payment/routers/PaymentStandardExitRouterMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../../../src/exits/payment/PaymentExitGameArgs.sol\";\nimport \"../../../../src/exits/payment/routers/PaymentStandardExitRouter.sol\";\nimport \"../../../../src/exits/payment/routers/PaymentStandardExitRouterArgs.sol\";\nimport \"../../../../src/framework/PlasmaFramework.sol\";\n\ncontract PaymentStandardExitRouterMock is PaymentStandardExitRouter {\n    PlasmaFramework private framework;\n\n    PaymentStandardExitRouterArgs.StartStandardExitArgs private startStandardExitArgs;\n    PaymentStandardExitRouterArgs.ChallengeStandardExitArgs private challengeStandardExitArgs;\n\n    constructor(PaymentExitGameArgs.Args memory args)\n        public\n        PaymentStandardExitRouter(args)\n    {\n        framework = args.framework;\n    }\n\n    /** override and calls processStandardExit for test */\n    function processExit(uint160 exitId, uint256, address ercContract) external {\n        PaymentStandardExitRouter.processStandardExit(exitId, ercContract);\n    }\n\n    /** helper functions for testing */\n    function setExit(uint160 exitId, PaymentExitDataModel.StandardExit memory exitData) public {\n        PaymentStandardExitRouter.standardExitMap.exits[exitId] = exitData;\n    }\n\n    function proxyFlagOutputFinalized(bytes32 outputId, uint160 exitId) public {\n        framework.flagOutputFinalized(outputId, exitId);\n    }\n\n    function depositFundForTest() public payable {}\n\n    /**\n     * This function helps test reentrant by making this function itself the first call with 'nonReentrant' protection\n     * So all other PaymentExitGame functions that is protected by 'nonReentrant' too would fail as it would be considered as re-entrancy\n     */\n    function testNonReentrant(string memory testTarget) public nonReentrant(framework) {\n        if (stringEquals(testTarget, \"startStandardExit\")) {\n            PaymentStandardExitRouter.startStandardExit(startStandardExitArgs);\n        } else if (stringEquals(testTarget, \"challengeStandardExit\")) {\n            PaymentStandardExitRouter.challengeStandardExit(challengeStandardExitArgs);\n        }\n    }\n\n    function stringEquals(string memory a, string memory b) private pure returns (bool) {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/utils/ExitIdWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/utils/PosLib.sol\";\nimport \"../../../src/exits/utils/ExitId.sol\";\n\ncontract ExitIdWrapper {\n    function isStandardExit(uint160 _exitId) public pure returns (bool) {\n        return ExitId.isStandardExit(_exitId);\n    }\n\n    function getStandardExitId(bool _isDeposit, bytes memory _txBytes, uint256 _utxoPos)\n        public\n        pure\n        returns (uint160)\n    {\n        PosLib.Position memory utxoPos = PosLib.decode(_utxoPos);\n        return ExitId.getStandardExitId(_isDeposit, _txBytes, utxoPos);\n    }\n\n    function getInFlightExitId(bytes memory _txBytes)\n        public\n        pure\n        returns (uint160)\n    {\n        return ExitId.getInFlightExitId(_txBytes);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/utils/ExitableTimestampWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/exits/utils/ExitableTimestamp.sol\";\n\ncontract ExitableTimestampWrapper {\n    using ExitableTimestamp for ExitableTimestamp.Calculator;\n    ExitableTimestamp.Calculator internal calculator;\n\n    constructor(uint256 _minExitPeriod) public {\n        calculator = ExitableTimestamp.Calculator(_minExitPeriod);\n    }\n\n    function calculateDepositTxOutputExitableTimestamp(\n        uint256 _now\n    )\n        public\n        view\n        returns (uint64)\n    {\n        return calculator.calculateDepositTxOutputExitableTimestamp(_now);\n    }\n\n    function calculateTxExitableTimestamp(\n        uint256 _now,\n        uint256 _blockTimestamp\n    )\n        public\n        view\n        returns (uint64)\n    {\n        return calculator.calculateTxExitableTimestamp(_now, _blockTimestamp);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/utils/MoreVpFinalizationWrapper.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../../src/exits/utils/MoreVpFinalization.sol\";\n\ncontract MoreVpFinalizationWrapper {\n    function isStandardFinalized(\n        PlasmaFramework framework,\n        bytes memory txBytes,\n        uint256 txPos,\n        bytes memory inclusionProof\n    )\n        public\n        view\n        returns (bool)\n    {\n        return MoreVpFinalization.isStandardFinalized(\n            framework,\n            txBytes,\n            PosLib.decode(txPos),\n            inclusionProof\n        );\n    }\n\n    function isProtocolFinalized(\n        PlasmaFramework framework,\n        bytes memory txBytes\n    )\n        public\n        view\n        returns (bool)\n    {\n        return MoreVpFinalization.isProtocolFinalized(\n            framework,\n            txBytes\n        );\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/exits/utils/OutputIdWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/exits/utils/OutputId.sol\";\n\ncontract OutputIdWrapper {\n    function computeDepositOutputId(\n        bytes memory _txBytes,\n        uint8 _outputIndex,\n        uint256 _utxoPosValue\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        return OutputId.computeDepositOutputId(_txBytes, _outputIndex, _utxoPosValue);\n    }\n\n    function computeNormalOutputId(\n        bytes memory _txBytes,\n        uint8 _outputIndex\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        return OutputId.computeNormalOutputId(_txBytes, _outputIndex);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/BlockControllerMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/framework/BlockController.sol\";\n\ncontract BlockControllerMock is BlockController {\n    address private maintainer;\n\n    constructor(\n        uint256 interval,\n        uint256 minExitPeriod,\n        uint256 initialImmuneVaults,\n        address authority\n    )\n        public\n        BlockController(\n            interval,\n            minExitPeriod,\n            initialImmuneVaults,\n            authority\n        )\n    {\n        maintainer = msg.sender;\n    }\n\n    /**\n     * override to make it non-abstract contract\n     * this mock file set the user that deploys the contract as maintainer to simplify the test.\n     */\n    function getMaintainer() public view returns (address) {\n        return maintainer;\n    }\n\n    function setBlock(uint256 _blockNum, bytes32 _root, uint256 _timestamp) external {\n        blocks[_blockNum] = BlockModel.Block(_root, _timestamp);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/DummyExitGame.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./registries/ExitGameRegistryMock.sol\";\nimport \"../../src/framework/ExitGameController.sol\";\nimport \"../../src/framework/interfaces/IExitProcessor.sol\";\nimport \"../../src/vaults/Erc20Vault.sol\";\nimport \"../../src/vaults/EthVault.sol\";\nimport \"../../src/utils/PosLib.sol\";\n\ncontract DummyExitGame is IExitProcessor {\n    uint256 public priorityFromEnqueue;\n\n    ExitGameRegistryMock public exitGameRegistry;\n    ExitGameController public exitGameController;\n    EthVault public ethVault;\n    Erc20Vault public erc20Vault;\n\n    event ExitFinalizedFromDummyExitGame (\n        uint256 indexed exitId,\n        uint256 vaultId,\n        address ercContract\n    );\n\n    // override ExitProcessor interface\n    function processExit(uint160 exitId, uint256 vaultId, address ercContract) public {\n        emit ExitFinalizedFromDummyExitGame(exitId, vaultId, ercContract);\n    }\n\n    // setter function only for test, not a real Exit Game function\n    function setExitGameRegistry(address _contract) public {\n        exitGameRegistry = ExitGameRegistryMock(_contract);\n    }\n\n    function checkOnlyFromNonQuarantinedExitGame() public view returns (bool) {\n        return exitGameRegistry.checkOnlyFromNonQuarantinedExitGame();\n    }\n\n    // setter function only for test, not a real Exit Game function\n    function setExitGameController(address _contract) public {\n        exitGameController = ExitGameController(_contract);\n    }\n\n    function enqueue(uint256 vaultId, address token, uint64 exitableAt, uint256 txPos, uint160 exitId, IExitProcessor exitProcessor)\n        public\n    {\n        priorityFromEnqueue = exitGameController.enqueue(vaultId, token, exitableAt, PosLib.decode(txPos), exitId, exitProcessor);\n    }\n\n    function proxyBatchFlagOutputsFinalized(bytes32[] memory outputIds, uint160 exitId) public {\n        exitGameController.batchFlagOutputsFinalized(outputIds, exitId);\n    }\n\n    function proxyFlagOutputFinalized(bytes32 outputId, uint160 exitId) public {\n        exitGameController.flagOutputFinalized(outputId, exitId);\n    }\n\n    // setter function only for test, not a real Exit Game function\n    function setEthVault(EthVault vault) public {\n        ethVault = vault;\n    }\n\n    function proxyEthWithdraw(address payable target, uint256 amount) public {\n        ethVault.withdraw(target, amount);\n    }\n\n    // setter function only for test, not a real Exit Game function\n    function setErc20Vault(Erc20Vault vault) public {\n        erc20Vault = vault;\n    }\n\n    function proxyErc20Withdraw(address payable target, address token, uint256 amount) public {\n        erc20Vault.withdraw(target, token, amount);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/DummyVault.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"./registries/VaultRegistryMock.sol\";\nimport \"../../src/framework/BlockController.sol\";\n\ncontract DummyVault {\n    VaultRegistryMock internal vaultRegistry;\n    BlockController internal blockController;\n\n    // setter function only for test, not a real Vault function\n    function setVaultRegistry(address _contract) public {\n        vaultRegistry = VaultRegistryMock(_contract);\n    }\n\n    function checkOnlyFromNonQuarantinedVault() public view returns (bool) {\n        return vaultRegistry.checkOnlyFromNonQuarantinedVault();\n    }\n\n    // setter function only for test, not a real Vault function\n    function setBlockController(address _contract) public {\n        blockController = BlockController(_contract);\n    }\n\n    function submitDepositBlock(bytes32 _blockRoot) public {\n        blockController.submitDepositBlock(_blockRoot);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/ExitGameControllerMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/framework/ExitGameController.sol\";\n\ncontract ExitGameControllerMock is ExitGameController {\n    address private maintainer;\n\n    constructor(uint256 _minExitPeriod, uint256 _initialImmuneExitGames)\n        public\n        ExitGameController(_minExitPeriod, _initialImmuneExitGames)\n    {\n        maintainer = msg.sender;\n    }\n\n    /**\n     * override to make it non-abstract contract\n     * this mock file set the user that deploys the contract as maintainer to simplify the test.\n     */\n    function getMaintainer() public view returns (address) {\n        return maintainer;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/ProtocolWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/framework/Protocol.sol\";\n\ncontract ProtocolWrapper {\n    // solhint-disable-next-line func-name-mixedcase\n    function MVP() public pure returns (uint8) {\n        return Protocol.MVP();\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MORE_VP() public pure returns (uint8) {\n        return Protocol.MORE_VP();\n    }\n\n    function isValidProtocol(uint8 protocol) public pure returns (bool) {\n        return Protocol.isValidProtocol(protocol);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/ReentrancyExitGame.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/framework/ExitGameController.sol\";\nimport \"../../src/framework/interfaces/IExitProcessor.sol\";\n\ncontract ReentrancyExitGame is IExitProcessor {\n    ExitGameController public exitGameController;\n    uint256 public vaultId;\n    address public testToken;\n    uint256 public reentryMaxExitToProcess;\n\n    constructor(ExitGameController _controller, uint256 _vaultId, address _token, uint256 _reentryMaxExitToProcess) public {\n        exitGameController = _controller;\n        vaultId = _vaultId;\n        testToken = _token;\n        reentryMaxExitToProcess = _reentryMaxExitToProcess;\n    }\n\n    // override ExitProcessor interface\n    // This would call the processExits back to mimic reentracy attack\n    function processExit(uint160, uint256, address) public {\n        exitGameController.processExits(vaultId, testToken, 0, reentryMaxExitToProcess);\n    }\n\n    function enqueue(uint256 _vaultId, address _token, uint64 _exitableAt, uint256 _txPos, uint160 _exitId, IExitProcessor _exitProcessor)\n        public\n    {\n        exitGameController.enqueue(_vaultId, _token, _exitableAt, PosLib.decode(_txPos), _exitId, _exitProcessor);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/registries/ExitGameRegistryMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/framework/registries/ExitGameRegistry.sol\";\n\ncontract ExitGameRegistryMock is ExitGameRegistry {\n    address private maintainer;\n\n    constructor (uint256 _minExitPeriod, uint256 _initialImmuneExitGames)\n        public\n        ExitGameRegistry(_minExitPeriod, _initialImmuneExitGames)\n    {\n    }\n\n    /** override to make it non-abstract contract */\n    function getMaintainer() public view returns (address) {\n        return maintainer;\n    }\n\n    /** test helper function */\n    function setMaintainer(address maintainerToSet) public {\n        maintainer = maintainerToSet;\n    }\n\n    function checkOnlyFromNonQuarantinedExitGame() public onlyFromNonQuarantinedExitGame view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/registries/VaultRegistryMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/framework/registries/VaultRegistry.sol\";\n\ncontract VaultRegistryMock is VaultRegistry {\n    address private maintainer;\n\n    constructor (uint256 _minExitPeriod, uint256 _initialImmuneVaults)\n        public\n        VaultRegistry(_minExitPeriod, _initialImmuneVaults)\n    {\n    }\n\n    /** override to make it non-abstract contract */\n    function getMaintainer() public view returns (address) {\n        return maintainer;\n    }\n\n    /** test helper function */\n    function setMaintainer(address maintainerToSet) public {\n        maintainer = maintainerToSet;\n    }\n\n    function checkOnlyFromNonQuarantinedVault() public onlyFromNonQuarantinedVault view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/utils/ExitPriorityWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/framework/utils/ExitPriority.sol\";\nimport \"../../../src/utils/PosLib.sol\";\n\ncontract ExitPriorityWrapper {\n    function computePriority(uint64 exitableAt, uint256 txPos, uint160 exitId) public pure returns (uint256) {\n        return ExitPriority.computePriority(exitableAt, PosLib.decode(txPos), exitId);\n    }\n\n    function parseExitableAt(uint256 priority) public pure returns (uint64) {\n        return ExitPriority.parseExitableAt(priority);\n    }\n\n    function parseExitId(uint256 priority) public pure returns (uint160) {\n        return ExitPriority.parseExitId(priority);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/framework/utils/PriorityQueueLoadTest.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/framework/utils/PriorityQueue.sol\";\n\ncontract PriorityQueueLoadTest is PriorityQueue {\n\n    /**\n     * Helper function to inject heap data. It only appends batch of data to the end of array used as heap.\n     * The client using this should make sure the data is in the order of an valid heap.\n     */\n    function setHeapData(uint256[] calldata heapList) external {\n        for (uint i = 0; i < heapList.length; i++) {\n            PriorityQueue.queue.heapList.push(heapList[i]);\n        }\n        PriorityQueue.queue.currentSize += heapList.length;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/python_tests_wrappers/PriorityQueueTest.sol": {
      "content": "pragma solidity ^0.5.0;\nimport \"../../src/framework/utils/PriorityQueue.sol\";\n\n/**\n * @title PriorityQueue\n * @dev Min-heap priority queue implementation.\n */\ncontract PriorityQueueTest{\n\n    /*\n     * Events\n     */\n\n    event DelMin(uint256 val);\n\n    /*\n     *  Storage\n     */\n\n    PriorityQueue public queue;\n    /*\n     *  Public functions\n     */\n\n    constructor()\n        public\n    {\n        queue = new PriorityQueue();\n    }\n\n    /**\n     * @dev Inserts an element into the queue. Does not perform deduplication.\n     */\n    function insert(uint256 _element)\n        public\n    {\n        queue.insert(_element);\n    }\n\n    /**\n     * @dev Overrides the default implementation, by simply emitting an even on deletion, so that the result is testable.\n     * @return The smallest element in the priority queue.\n     */\n    function delMin()\n        public\n        returns (uint256 value)\n    {\n        value = queue.delMin();\n        emit DelMin(value);\n    }\n\n    /*\n     * Read-only functions\n     */\n    /**\n     * @dev Returns the top element of the heap.\n     * @return The smallest element in the priority queue.\n     */\n    function getMin()\n        public\n        view\n        returns (uint256)\n    {\n        return queue.getMin();\n    }\n\n    function currentSize()\n        external\n        view\n        returns (uint256)\n    {\n        return queue.currentSize();\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/python_tests_wrappers/RLPTest.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../../src/utils/RLPReader.sol\";\n\n\n/**\n * @title RLPTest\n * @dev Contract for testing RLP decoding.\n */\ncontract RLPTest {\n    function eight(bytes memory tx_bytes)\n        public\n        pure\n        returns (uint256, address, address)\n    {\n        RLPReader.RLPItem[] memory txList = RLPReader.toList(RLPReader.toRlpItem(tx_bytes));\n        return (\n            RLPReader.toUint(txList[5]),\n            RLPReader.toAddress(txList[6]),\n            RLPReader.toAddress(txList[7])\n        );\n    }\n\n    function eleven(bytes memory tx_bytes)\n        public\n        pure\n        returns (uint256, address, address, address)\n    {\n        RLPReader.RLPItem[] memory  txList = RLPReader.toList(RLPReader.toRlpItem(tx_bytes));\n        return (\n            RLPReader.toUint(txList[7]),\n            RLPReader.toAddress(txList[8]),\n            RLPReader.toAddress(txList[9]),\n            RLPReader.toAddress(txList[10])\n        );\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/transactions/FungibleTokenOutputWrapper.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/transactions/FungibleTokenOutputModel.sol\";\n\ncontract FungibleTokenOutputWrapper {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    function decodeOutput(bytes memory encodedOutput)\n        public\n        pure\n        returns (FungibleTokenOutputModel.Output memory)\n    {\n        GenericTransaction.Output memory genericOutput = GenericTransaction.decodeOutput(encodedOutput.toRlpItem());\n        return FungibleTokenOutputModel.decodeOutput(genericOutput);\n    }\n\n    function getOutput(bytes memory transaction, uint16 outputIndex)\n        public\n        pure\n        returns (FungibleTokenOutputModel.Output memory)\n    {\n        GenericTransaction.Transaction memory genericTx = GenericTransaction.decode(transaction);\n        return FungibleTokenOutputModel.getOutput(genericTx, outputIndex);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/transactions/GenericTransactionWrapper.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/transactions/GenericTransaction.sol\";\n\ncontract GenericTransactionWrapper {\n\n    function decode(bytes memory transaction) public pure returns (GenericTransaction.Transaction memory) {\n        return GenericTransaction.decode(transaction);\n    }\n\n    function getOutput(bytes memory transaction, uint16 outputIndex) public pure returns (GenericTransaction.Output memory) {\n        GenericTransaction.Transaction memory genericTx = GenericTransaction.decode(transaction);\n        return GenericTransaction.getOutput(genericTx, outputIndex);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/transactions/PaymentTransactionModelMock.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/transactions/PaymentTransactionModel.sol\";\n\ncontract PaymentTransactionModelMock {\n    using RLPReader for bytes;\n\n    function decode(bytes memory transaction) public pure returns (PaymentTransactionModel.Transaction memory) {\n        return PaymentTransactionModel.decode(transaction);\n    }\n\n    function getOutputOwner(uint256 outputType, address owner, address token, uint256 amount) public pure returns (address payable) {\n        FungibleTokenOutputModel.Output memory output = FungibleTokenOutputModel.Output({\n            outputType: outputType,\n            outputGuard: bytes20(owner),\n            token: token,\n            amount: amount\n        });\n        return PaymentTransactionModel.getOutputOwner(output);\n    }\n\n    function getOutput(bytes memory transaction, uint16 outputIndex) public pure returns (FungibleTokenOutputModel.Output memory) {\n        PaymentTransactionModel.Transaction memory decodedTx = PaymentTransactionModel.decode(transaction);\n        return PaymentTransactionModel.getOutput(decodedTx, outputIndex);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/transactions/eip712Libs/PaymentEip712LibMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../../src/transactions/eip712Libs/PaymentEip712Lib.sol\";\nimport \"../../../src/transactions/PaymentTransactionModel.sol\";\n\ncontract PaymentEip712LibMock {\n    function hashTx(address _verifyingContract, bytes memory _rlpTx)\n        public\n        pure\n        returns (bytes32)\n    {\n        PaymentEip712Lib.Constants memory eip712 = PaymentEip712Lib.initConstants(_verifyingContract);\n        return PaymentEip712Lib.hashTx(eip712, PaymentTransactionModel.decode(_rlpTx));\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/BitsWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/utils/Bits.sol\";\n\ncontract BitsWrapper {\n    function setBit(uint _self, uint8 _index) public pure returns (uint)\n    {\n        return Bits.setBit(_self, _index);\n    }\n\n    function clearBit(uint _self, uint8 _index) public pure returns (uint)\n    {\n        return Bits.clearBit(_self, _index);\n    }\n\n    /**\n     * @dev It makes sense to expose just `bitSet` to be able to test both of Bits `getBit` and `bitSet`\n     */\n    function bitSet(uint _self, uint8 _index) public pure returns (bool)\n    {\n        return Bits.bitSet(_self, _index);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/BondSizeMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/exits/utils/BondSize.sol\";\n\ncontract BondSizeMock {\n    using BondSize for BondSize.Params;\n\n    BondSize.Params public bond;\n\n    constructor (uint128 initialBondSize, uint16 lowerBoundDivisor, uint16 upperBoundMultiplier) public {\n        bond = BondSize.buildParams(initialBondSize, lowerBoundDivisor, upperBoundMultiplier);\n    }\n\n    function bondSize() public view returns (uint128) {\n        return bond.bondSize();\n    }\n\n    function updateBondSize(uint128 newBondSize) public {\n        bond.updateBondSize(newBondSize);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/MerkleWrapper.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/utils/Merkle.sol\";\n\ncontract MerkleWrapper {\n\n    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n        public\n        pure\n        returns (bool)\n    {\n        return Merkle.checkMembership(leaf, index, rootHash, proof);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/OnlyWithValueMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/utils/OnlyWithValue.sol\";\n\ncontract OnlyWithValueMock is OnlyWithValue {\n    event OnlyWithValuePassed();\n\n    function checkOnlyWithValue(uint256 _value) public payable onlyWithValue(_value) {\n        emit OnlyWithValuePassed();\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/PosLibWrapper.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../src/utils/PosLib.sol\";\n\ncontract PosLibWrapper {\n    using PosLib for PosLib.Position;\n\n    function toStrictTxPos(PosLib.Position memory pos)\n        public\n        pure\n        returns (PosLib.Position memory)\n    {\n        return pos.toStrictTxPos();\n    }\n\n    function getTxPositionForExitPriority(PosLib.Position memory pos)\n        public\n        pure\n        returns (uint256)\n    {\n        return pos.getTxPositionForExitPriority();\n    }\n\n    function encode(PosLib.Position memory pos) public pure returns (uint256) {\n        return pos.encode();\n    }\n\n    function decode(uint256 pos) public pure returns (PosLib.Position memory) {\n        return PosLib.decode(pos);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/QuarantineMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/framework/utils/Quarantine.sol\";\n\ncontract QuarantineMock {\n    using Quarantine for Quarantine.Data;\n    Quarantine.Data internal _quarantine;\n\n    constructor(uint256 _period, uint256 _initialImmuneCount)\n        public\n    {\n        _quarantine.quarantinePeriod = _period;\n        _quarantine.immunitiesRemaining = _initialImmuneCount;\n    }\n\n    function quarantineContract(address _contractAddress) public {\n        _quarantine.quarantine(_contractAddress);\n    }\n\n    function isQuarantined(address _contractAddress) public view returns (bool) {\n        return _quarantine.isQuarantined(_contractAddress);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/RLPMock.sol": {
      "content": "pragma solidity 0.5.11;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../src/utils/RLPReader.sol\";\n\ncontract RLPMock {\n\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint8 constant internal WORD_SIZE = 32;\n\n    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n        return _data.toRlpItem().toBytes32();\n    }\n\n    function decodeAddress(bytes memory _data) public pure returns (address) {\n        return _data.toRlpItem().toAddress();\n    }\n    \n    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n        return bytes20(_data.toRlpItem().toAddress());\n    }\n\n    function decodeBytes(bytes memory _data) public pure returns (bytes memory) {\n        return toBytes(_data.toRlpItem());\n    }\n\n    function decodeUint(bytes memory _data) public pure returns (uint) {\n        return _data.toRlpItem().toUint();\n    }\n\n    function decodeInt(bytes memory _data) public pure returns (int) {\n        return int(_data.toRlpItem().toUint());\n    }\n\n    function decodeString(bytes memory _data) public pure returns (string memory) {\n        return string(toBytes(_data.toRlpItem()));\n    }\n\n    function decodeList(bytes memory _data) public pure returns (bytes[] memory) {\n\n        RLPReader.RLPItem[] memory items = _data.toRlpItem().toList();\n\n        bytes[] memory result =  new bytes[](items.length);\n        for (uint i = 0; i < items.length; i++) {\n            result[i] = toRlpBytes(items[i]);\n        }\n        return result;\n    }\n\n    function toBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0, \"Item length must be > 0\");\n\n        (uint256 itemLen, uint256 offset) = RLPReader.decodeLengthAndOffset(item.memPtr);\n        require(itemLen == item.len, \"Decoded RLP length is invalid\");\n        uint len = itemLen - offset;\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copyUnsafe(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    function copyUnsafe(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n        uint remainingLength = len;\n\n        // copy as many word sizes as possible\n        for (uint i = WORD_SIZE; len >= i; i += WORD_SIZE) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n            remainingLength -= WORD_SIZE;\n            require(remainingLength < len, \"Remaining length not less than original length\");\n        }\n\n        // left over bytes. Mask is used to remove unwanted bytes from the word\n        uint mask = 256 ** (WORD_SIZE - remainingLength) - 1;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let srcpart := and(mload(src), not(mask)) // zero out src\n            let destpart := and(mload(dest), mask) // retrieve the bytes\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function toRlpBytes(RLPReader.RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint resultPtr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            resultPtr := add(0x20, result)\n        }\n\n        copyUnsafe(item.memPtr, resultPtr, item.len);\n        return result;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/RLPMockSecurity.sol": {
      "content": "pragma solidity 0.5.11;\n\npragma experimental ABIEncoderV2;\n\nimport \"../../src/utils/RLPReader.sol\";\n\ncontract RLPMockSecurity {\n\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    function decodeBytes32(bytes memory _data) public pure returns (bytes32) {\n        return bytes32(_data.toRlpItem().toUint());\n    }\n\n    function decodeBytes20(bytes memory _data) public pure returns (bytes20) {\n        return bytes20(_data.toRlpItem().toAddress());\n    }\n\n    function decodeUint(bytes memory _data) public pure returns (uint) {\n        return _data.toRlpItem().toUint();\n    }\n\n    function decodeList(bytes memory _data) public pure returns (RLPReader.RLPItem[] memory) {\n        return _data.toRlpItem().toList();\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/utils/SafeEthTransferMock.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../src/utils/SafeEthTransfer.sol\";\n\ncontract SafeEthTransferMock {\n    bool public transferResult;\n\n    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n        public\n    {\n        SafeEthTransfer.transferRevertOnError(receiver, amount, gasStipend);\n    }\n\n    function transferReturnResult(address payable receiver, uint256 amount, uint256 gasStipend)\n        public\n    {\n        transferResult = SafeEthTransfer.transferReturnResult(receiver, amount, gasStipend);\n    }\n\n    /** helper function to pre-fund the contract to test */\n    function setupInitialFundToTestTransfer() external payable {}\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/mocks/vaults/NonCompliantERC20.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n// A 'NonCompliantERC20' token is one that uses an old version of the ERC20 standard,\n// as described here https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n// Basically, this version does not return anything from `transfer` and `transferFrom`,\n// whereas most modern implementions of ERC20 return a boolean to indicate success or failure.\ncontract NonCompliantERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private balances;\n    mapping (address => mapping (address => uint256)) private allowances;\n    uint256 private totalSupply;\n\n    constructor(uint256 _initialAmount) public {\n        balances[msg.sender] = _initialAmount;\n        totalSupply = _initialAmount;\n    }\n\n    function balanceOf(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function transfer(address _to, uint _value) public {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public {\n        uint256 _allowance = allowances[_from][msg.sender];\n\n        balances[_to] = balances[_to].add(_value);\n        balances[_from] = balances[_from].sub(_value);\n        allowances[_from][msg.sender] = _allowance.sub(_value);\n    }\n\n    function approve(address _spender, uint _value) public {\n        allowances[msg.sender][_spender] = _value;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowances[_owner][_spender];\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/fee/FeeClaimOutputToPaymentTxCondition.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\nimport \"../interfaces/ISpendingCondition.sol\";\nimport \"../utils/OutputId.sol\";\nimport \"../../framework/PlasmaFramework.sol\";\nimport \"../../transactions/FungibleTokenOutputModel.sol\";\nimport \"../../transactions/GenericTransaction.sol\";\nimport \"../../transactions/PaymentTransactionModel.sol\";\nimport \"../../transactions/eip712Libs/PaymentEip712Lib.sol\";\nimport \"../../utils/PosLib.sol\";\n\ncontract FeeClaimOutputToPaymentTxCondition is ISpendingCondition {\n    using PaymentEip712Lib for PaymentEip712Lib.Constants;\n    using PosLib for PosLib.Position;\n\n    uint256 public feeTxType;\n    uint256 public feeClaimOutputType;\n    uint256 public paymentTxType;\n    PaymentEip712Lib.Constants internal eip712;\n\n    constructor(\n        PlasmaFramework _framework,\n        uint256 _feeTxType,\n        uint256 _feeClaimOutputType,\n        uint256 _paymentTxType\n    )\n        public\n    {\n        eip712 = PaymentEip712Lib.initConstants(address(_framework));\n        feeTxType = _feeTxType;\n        feeClaimOutputType = _feeClaimOutputType;\n        paymentTxType = _paymentTxType;\n    }\n\n    /**\n     * @dev This implementation checks signature for spending fee claim output. It should be signed with the owner signature.\n     *      The fee claim output that is spendable follows Fungible Token Output format.\n     * @param feeTxBytes Encoded fee transaction\n     * @param utxoPos Position of the fee utxo\n     * @param paymentTxBytes Payment transaction (in bytes) that spends the fee claim output\n     * @param inputIndex Input index of the payment tx that points to the fee claim output\n     * @param signature Signature of the owner of fee claiming output\n     */\n    function verify(\n        bytes calldata feeTxBytes,\n        uint256 utxoPos,\n        bytes calldata paymentTxBytes,\n        uint16 inputIndex,\n        bytes calldata signature\n    )\n        external\n        view\n        returns (bool)\n    {\n        PosLib.Position memory decodedUtxoPos = PosLib.decode(utxoPos);\n        require(decodedUtxoPos.outputIndex == 0, \"Fee claim output must be the first output of fee tx\");\n\n        GenericTransaction.Transaction memory feeTx = GenericTransaction.decode(feeTxBytes);\n        FungibleTokenOutputModel.Output memory feeClaimOutput = FungibleTokenOutputModel.getOutput(feeTx, decodedUtxoPos.outputIndex);\n\n        require(feeTx.txType == feeTxType, \"Unexpected tx type for fee transaction\");\n        require(feeClaimOutput.outputType == feeClaimOutputType, \"Unexpected output type for fee claim output\");\n\n        PaymentTransactionModel.Transaction memory paymentTx = PaymentTransactionModel.decode(paymentTxBytes);\n        require(paymentTx.txType == paymentTxType, \"Unexpected tx type for payment transaction\");\n\n        require(\n            paymentTx.inputs[inputIndex] == bytes32(decodedUtxoPos.encode()),\n            \"Payment tx points to the incorrect output UTXO position of the fee claim output\"\n        );\n\n        address owner = address(feeClaimOutput.outputGuard);\n        address signer = ECDSA.recover(eip712.hashTx(paymentTx), signature);\n        require(signer != address(0), \"Failed to recover the signer from the signature\");\n        require(owner == signer, \"Tx is not signed correctly\");\n\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/fee/FeeExitGame.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n* It is an empty contract by design. We only want to be able to register the tx type to the framework.\n* For simplicity, a fee claiming tx does not have the ability to exit directly.\n* It should be first spend to a Payment tx and then exit the fund from Payment tx.\n*/\ncontract FeeExitGame {\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/interfaces/ISpendingCondition.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @notice Interface of the spending condition\n * @dev For the interface design and discussion, see the following GH issue\n *      https://github.com/omisego/plasma-contracts/issues/214\n */\ninterface ISpendingCondition {\n\n    /**\n     * @notice Verifies the spending condition\n     * @param inputTx Encoded input transaction, in bytes\n     * @param utxoPos Position of the utxo\n     * @param spendingTx Spending transaction, in bytes\n     * @param inputIndex The input index of the spending tx that points to the output\n     * @param witness The witness data of the spending condition\n     */\n    function verify(\n        bytes calldata inputTx,\n        uint256 utxoPos,\n        bytes calldata spendingTx,\n        uint16 inputIndex,\n        bytes calldata witness\n    ) external view returns (bool);\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/interfaces/IStateTransitionVerifier.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\ninterface IStateTransitionVerifier {\n\n    /**\n    * @notice Verifies state transition logic\n    * @param txBytes The transaction that does the state transition to verify\n    * @param inputTxs Input transaction to the transaction to verify\n    * @param outputIndexOfInputTxs Output index of the input txs that the transaction input points to\n    */\n    function isCorrectStateTransition(\n        bytes calldata txBytes,\n        bytes[] calldata inputTxs,\n        uint16[] calldata outputIndexOfInputTxs\n    )\n        external\n        view\n        returns (bool);\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/PaymentExitDataModel.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @notice Model library for PaymentExit\n */\nlibrary PaymentExitDataModel {\n    uint8 constant public MAX_INPUT_NUM = 4;\n    uint8 constant public MAX_OUTPUT_NUM = 4;\n\n    /**\n     * @dev Exit model for a standard exit\n     * @param exitable Boolean that defines whether exit is possible. Used by the challenge game to flag the result.\n     * @param utxoPos The UTXO position of the transaction's exiting output\n     * @param outputId The output identifier, in OutputId format\n     * @param exitTarget The address to which the exit withdraws funds\n     * @param amount The amount of funds to withdraw with this exit\n     * @param bondSize The size of the bond put up for this exit to start, and which is used to cover the cost of challenges\n     */\n    struct StandardExit {\n        bool exitable;\n        uint256 utxoPos;\n        bytes32 outputId;\n        address payable exitTarget;\n        uint256 amount;\n        uint256 bondSize;\n    }\n\n    /**\n     * @dev Mapping of (exitId => StandardExit) that stores all standard exit data\n     */\n    struct StandardExitMap {\n        mapping (uint160 => PaymentExitDataModel.StandardExit) exits;\n    }\n\n    /**\n     * @dev The necessary data needed for processExit for in-flight exit inputs/outputs\n     */\n    struct WithdrawData {\n        bytes32 outputId;\n        address payable exitTarget;\n        address token;\n        uint256 amount;\n        uint256 piggybackBondSize;\n    }\n\n    /**\n     * @dev Exit model for an in-flight exit\n     * @param isCanonical A boolean that defines whether the exit is canonical\n     *                    A canonical exit withdraws the outputs while a non-canonical exit withdraws the  inputs\n     * @param exitStartTimestamp Timestamp for the start of the exit\n     * @param exitMap A bitmap that stores piggyback flags\n     * @param position The position of the youngest input of the in-flight exit transaction\n     * @param inputs Fixed-size array of data required to withdraw inputs (if undefined, the default value is empty)\n     * @param outputs Fixed-size array of data required to withdraw outputs (if undefined, the default value is empty)\n     * @param bondOwner Recipient of the bond, when the in-flight exit is processed\n     * @param bondSize The size of the bond put up for this exit to start. Used to cover the cost of challenges.\n     * @param oldestCompetitorPosition The position of the oldest competing transaction\n     *                                 The exiting transaction is only canonical if all competing transactions are younger.\n     */\n    struct InFlightExit {\n        // Canonicity is assumed at start, and can be challenged and set to `false` after start\n        // Response to non-canonical challenge can set it back to `true`\n        bool isCanonical;\n        uint64 exitStartTimestamp;\n\n        /**\n         * exit map Stores piggybacks and finalized exits\n         * right most 0 ~ MAX_INPUT bits is flagged when input is piggybacked\n         * right most MAX_INPUT ~ MAX_INPUT + MAX_OUTPUT bits is flagged when output is piggybacked\n         */\n        uint256 exitMap;\n        uint256 position;\n        WithdrawData[MAX_INPUT_NUM] inputs;\n        WithdrawData[MAX_OUTPUT_NUM] outputs;\n        address payable bondOwner;\n        uint256 bondSize;\n        uint256 oldestCompetitorPosition;\n    }\n\n    /**\n     * @dev Mapping of (exitId => InFlightExit) that stores all in-flight exit data\n     */\n    struct InFlightExitMap {\n        mapping (uint160 => PaymentExitDataModel.InFlightExit) exits;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/PaymentExitGame.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./PaymentExitGameArgs.sol\";\nimport \"./routers/PaymentStandardExitRouter.sol\";\nimport \"./routers/PaymentInFlightExitRouter.sol\";\nimport \"../utils/ExitId.sol\";\nimport \"../registries/SpendingConditionRegistry.sol\";\nimport \"../../framework/interfaces/IExitProcessor.sol\";\nimport \"../../framework/PlasmaFramework.sol\";\nimport \"../../utils/OnlyFromAddress.sol\";\n\n/**\n * @notice The exit game contract implementation for Payment Transaction\n */\ncontract PaymentExitGame is IExitProcessor, OnlyFromAddress, PaymentStandardExitRouter, PaymentInFlightExitRouter {\n    PlasmaFramework private plasmaFramework;\n\n    /**\n     * @dev use struct PaymentExitGameArgs to avoid stack too deep compilation error.\n     */\n    constructor(PaymentExitGameArgs.Args memory args)\n        public\n        PaymentStandardExitRouter(args)\n        PaymentInFlightExitRouter(args)\n    {\n        plasmaFramework = args.framework;\n\n        // makes sure that the spending condition has already renounced ownership\n        require(args.spendingConditionRegistry.owner() == address(0), \"Spending condition registry ownership needs to be renounced\");\n    }\n\n    /**\n     * @notice Callback processes exit function for the PlasmaFramework to call\n     * @param exitId The exit ID\n     * @param token Token (ERC20 address or address(0) for ETH) of the exiting output\n     */\n    function processExit(uint160 exitId, uint256, address token) external onlyFrom(address(plasmaFramework)) {\n        if (ExitId.isStandardExit(exitId)) {\n            PaymentStandardExitRouter.processStandardExit(exitId, token);\n        } else {\n            PaymentInFlightExitRouter.processInFlightExit(exitId, token);\n        }\n    }\n\n    /**\n     * @notice Helper function to compute the standard exit ID\n     */\n    function getStandardExitId(bool _isDeposit, bytes memory _txBytes, uint256 _utxoPos)\n        public\n        pure\n        returns (uint160)\n    {\n        PosLib.Position memory utxoPos = PosLib.decode(_utxoPos);\n        return ExitId.getStandardExitId(_isDeposit, _txBytes, utxoPos);\n    }\n\n    /**\n     * @notice Helper function to compute the in-flight exit ID\n     */\n    function getInFlightExitId(bytes memory _txBytes)\n        public\n        pure\n        returns (uint160)\n    {\n        return ExitId.getInFlightExitId(_txBytes);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/PaymentExitGameArgs.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../registries/SpendingConditionRegistry.sol\";\nimport \"../interfaces/IStateTransitionVerifier.sol\";\nimport \"../../framework/PlasmaFramework.sol\";\n\nlibrary PaymentExitGameArgs {\n    /**\n     * @param framework The Plasma framework\n     * @param ethVaultId Vault id for EthVault\n     * @param erc20VaultId Vault id for the Erc20Vault\n     * @param spendingConditionRegistry the spendingConditionRegistry that can provide spending condition implementation by types\n     * @param stateTransitionVerifier state transition verifier predicate contract that checks the transaction correctness\n     * @param supportTxType the tx type of this exit game is using\n     * @param safeGasStipend a gas amount limit when transferring Eth to protect from attack with draining gas\n     */\n    struct Args {\n        PlasmaFramework framework;\n        uint256 ethVaultId;\n        uint256 erc20VaultId;\n        SpendingConditionRegistry spendingConditionRegistry;\n        IStateTransitionVerifier stateTransitionVerifier;\n        uint256 supportTxType;\n        uint256 safeGasStipend;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/PaymentInFlightExitModelUtils.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/Bits.sol\";\nimport \"../../transactions/PaymentTransactionModel.sol\";\nimport { PaymentExitDataModel as ExitModel } from \"./PaymentExitDataModel.sol\";\n\nlibrary PaymentInFlightExitModelUtils {\n    using Bits for uint256;\n\n    function isInputEmpty(ExitModel.InFlightExit memory ife, uint16 index)\n        internal\n        pure\n        returns (bool)\n    {\n        require(index < PaymentTransactionModel.MAX_INPUT_NUM(), \"Invalid input index\");\n        return isEmptyWithdrawData(ife.inputs[index]);\n    }\n\n    function isOutputEmpty(ExitModel.InFlightExit memory ife, uint16 index)\n        internal\n        pure\n        returns (bool)\n    {\n        require(index < PaymentTransactionModel.MAX_OUTPUT_NUM(), \"Invalid output index\");\n        return isEmptyWithdrawData(ife.outputs[index]);\n    }\n\n    function isInputPiggybacked(ExitModel.InFlightExit memory ife, uint16 index)\n        internal\n        pure\n        returns (bool)\n    {\n        require(index < PaymentTransactionModel.MAX_INPUT_NUM(), \"Invalid input index\");\n        return ife.exitMap.bitSet(uint8(index));\n    }\n\n    function isOutputPiggybacked(ExitModel.InFlightExit memory ife, uint16 index)\n        internal\n        pure\n        returns (bool)\n    {\n        require(index < PaymentTransactionModel.MAX_OUTPUT_NUM(), \"Invalid output index\");\n        uint8 indexInExitMap = uint8(index + PaymentTransactionModel.MAX_INPUT_NUM());\n        return ife.exitMap.bitSet(indexInExitMap);\n    }\n\n    function setInputPiggybacked(ExitModel.InFlightExit storage ife, uint16 index)\n        internal\n    {\n        require(index < PaymentTransactionModel.MAX_INPUT_NUM(), \"Invalid input index\");\n        ife.exitMap = ife.exitMap.setBit(uint8(index));\n    }\n\n    function clearInputPiggybacked(ExitModel.InFlightExit storage ife, uint16 index)\n        internal\n    {\n        require(index < PaymentTransactionModel.MAX_INPUT_NUM(), \"Invalid input index\");\n        ife.exitMap = ife.exitMap.clearBit(uint8(index));\n    }\n\n    function setOutputPiggybacked(ExitModel.InFlightExit storage ife, uint16 index)\n        internal\n    {\n        require(index < PaymentTransactionModel.MAX_OUTPUT_NUM(), \"Invalid output index\");\n        uint8 indexInExitMap = uint8(index + PaymentTransactionModel.MAX_INPUT_NUM());\n        ife.exitMap = ife.exitMap.setBit(indexInExitMap);\n    }\n\n    function clearOutputPiggybacked(ExitModel.InFlightExit storage ife, uint16 index)\n        internal\n    {\n        require(index < PaymentTransactionModel.MAX_OUTPUT_NUM(), \"Invalid output index\");\n        uint8 indexInExitMap = uint8(index + PaymentTransactionModel.MAX_INPUT_NUM());\n        ife.exitMap = ife.exitMap.clearBit(indexInExitMap);\n    }\n\n    function isInFirstPhase(ExitModel.InFlightExit memory ife, uint256 minExitPeriod)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 periodTime = minExitPeriod / 2;\n        return ((block.timestamp - ife.exitStartTimestamp) / periodTime) < 1;\n    }\n\n    function isEmptyWithdrawData(ExitModel.WithdrawData memory data) private pure returns (bool) {\n        return data.outputId == bytes32(\"\") &&\n                data.exitTarget == address(0) &&\n                data.token == address(0) &&\n                data.amount == 0 &&\n                data.piggybackBondSize == 0;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/PaymentTransactionStateTransitionVerifier.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IStateTransitionVerifier.sol\";\nimport \"../payment/PaymentExitDataModel.sol\";\nimport \"../../transactions/FungibleTokenOutputModel.sol\";\nimport \"../../transactions/PaymentTransactionModel.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n* @notice Verifies state transitions for payment transaction\n* @dev For payment transaction to be valid, the state transition should check that the sum of the inputs is larger than the sum of the outputs\n*/\ncontract PaymentTransactionStateTransitionVerifier {\n    using SafeMath for uint256;\n\n    /**\n     * @dev For payment transaction to be valid, the state transition should check that the sum of the inputs is larger than the sum of the outputs\n     */\n    function isCorrectStateTransition(\n        bytes calldata txBytes,\n        bytes[] calldata inputTxs,\n        uint16[] calldata outputIndexOfInputTxs\n    )\n        external\n        pure\n        returns (bool)\n    {\n        if (inputTxs.length != outputIndexOfInputTxs.length) {\n            return false;\n        }\n\n        FungibleTokenOutputModel.Output[] memory inputs = new FungibleTokenOutputModel.Output[](inputTxs.length);\n        for (uint i = 0; i < inputTxs.length; i++) {\n            uint16 outputIndex = outputIndexOfInputTxs[i];\n            FungibleTokenOutputModel.Output memory output = FungibleTokenOutputModel.getOutput(\n                GenericTransaction.decode(inputTxs[i]),\n                outputIndex\n            );\n            inputs[i] = output;\n        }\n\n        PaymentTransactionModel.Transaction memory transaction = PaymentTransactionModel.decode(txBytes);\n        FungibleTokenOutputModel.Output[] memory outputs = new FungibleTokenOutputModel.Output[](transaction.outputs.length);\n        for (uint i = 0; i < transaction.outputs.length; i++) {\n            outputs[i] = FungibleTokenOutputModel.Output(\n                    transaction.outputs[i].outputType,\n                    transaction.outputs[i].outputGuard,\n                    transaction.outputs[i].token,\n                    transaction.outputs[i].amount\n                );\n        }\n\n        return _isCorrectStateTransition(inputs, outputs);\n    }\n\n    function _isCorrectStateTransition(\n        FungibleTokenOutputModel.Output[] memory inputs,\n        FungibleTokenOutputModel.Output[] memory outputs\n    )\n        private\n        pure\n        returns (bool)\n    {\n        bool correctTransition = true;\n        uint i = 0;\n        while (correctTransition && i < outputs.length) {\n            address token = outputs[i].token;\n            FungibleTokenOutputModel.Output[] memory inputsForToken = filterWithToken(inputs, token);\n            FungibleTokenOutputModel.Output[] memory outputsForToken = filterWithToken(outputs, token);\n\n            correctTransition = isCorrectSpend(inputsForToken, outputsForToken);\n            i += 1;\n        }\n        return correctTransition;\n    }\n\n    function filterWithToken(\n        FungibleTokenOutputModel.Output[] memory outputs,\n        address token\n    )\n        private\n        pure\n        returns (FungibleTokenOutputModel.Output[] memory)\n    {\n        // Required for calculating the size of the filtered array\n        uint256 arraySize = 0;\n        for (uint i = 0; i < outputs.length; ++i) {\n            if (outputs[i].token == token) {\n                arraySize += 1;\n            }\n        }\n\n        FungibleTokenOutputModel.Output[] memory outputsWithToken = new FungibleTokenOutputModel.Output[](arraySize);\n        uint j = 0;\n        for (uint i = 0; i < outputs.length; ++i) {\n            if (outputs[i].token == token) {\n                outputsWithToken[j] = outputs[i];\n                j += 1;\n            }\n        }\n\n        return outputsWithToken;\n    }\n\n    function isCorrectSpend(\n        FungibleTokenOutputModel.Output[] memory inputs,\n        FungibleTokenOutputModel.Output[] memory outputs\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        uint256 amountIn = sumAmounts(inputs);\n        uint256 amountOut = sumAmounts(outputs);\n        return amountIn >= amountOut;\n    }\n\n    function sumAmounts(FungibleTokenOutputModel.Output[] memory outputs) private pure returns (uint256) {\n        uint256 amount = 0;\n        for (uint i = 0; i < outputs.length; i++) {\n            amount = amount.add(outputs[i].amount);\n        }\n        return amount;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEInputSpent.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../routers/PaymentInFlightExitRouterArgs.sol\";\nimport \"../../interfaces/ISpendingCondition.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../utils/ExitId.sol\";\nimport \"../../utils/OutputId.sol\";\nimport \"../../utils/MoreVpFinalization.sol\";\nimport \"../../../utils/Merkle.sol\";\nimport \"../../../utils/SafeEthTransfer.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../transactions/GenericTransaction.sol\";\n\nlibrary PaymentChallengeIFEInputSpent {\n    using PosLib for PosLib.Position;\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    struct Controller {\n        PlasmaFramework framework;\n        SpendingConditionRegistry spendingConditionRegistry;\n        uint256 safeGasStipend;\n    }\n\n    event InFlightExitInputBlocked(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint16 inputIndex\n    );\n\n    /**\n     * @dev Data to be passed around helper functions\n     */\n    struct ChallengeIFEData {\n        Controller controller;\n        PaymentInFlightExitRouterArgs.ChallengeInputSpentArgs args;\n        PaymentExitDataModel.InFlightExit ife;\n    }\n\n    /**\n     * @notice Function that builds the controller struct\n     * @return Controller struct of PaymentChallengeIFEInputSpent\n     */\n    function buildController(\n        PlasmaFramework framework,\n        SpendingConditionRegistry spendingConditionRegistry,\n        uint256 safeGasStipend\n    )\n        public\n        pure\n        returns (Controller memory)\n    {\n        return Controller({\n            framework: framework,\n            spendingConditionRegistry: spendingConditionRegistry,\n            safeGasStipend: safeGasStipend\n        });\n    }\n\n    /**\n     * @notice Main logic implementation for 'challengeInFlightExitInputSpent'\n     * @dev emits InFlightExitInputBlocked event on success\n     * @param self The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param args Arguments of 'challengeInFlightExitInputSpent' function from client\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        PaymentInFlightExitRouterArgs.ChallengeInputSpentArgs memory args\n    )\n        public\n    {\n        require(args.senderData == keccak256(abi.encodePacked(msg.sender)), \"Incorrect senderData\");\n\n        uint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n        PaymentExitDataModel.InFlightExit storage ife = inFlightExitMap.exits[exitId];\n\n        require(ife.exitStartTimestamp != 0, \"In-flight exit does not exist\");\n        require(ife.isInputPiggybacked(args.inFlightTxInputIndex), \"The indexed input has not been piggybacked\");\n\n        require(\n            keccak256(args.inFlightTx) != keccak256(args.challengingTx),\n            \"The challenging transaction is the same as the in-flight transaction\"\n        );\n\n        ChallengeIFEData memory data = ChallengeIFEData({\n            controller: self,\n            args: args,\n            ife: inFlightExitMap.exits[exitId]\n        });\n\n        verifySpentInputEqualsIFEInput(data);\n        verifyChallengingTransactionProtocolFinalized(data);\n        verifySpendingCondition(data);\n\n        // Remove the input from the piggyback map\n        ife.clearInputPiggybacked(args.inFlightTxInputIndex);\n\n        uint256 piggybackBondSize = ife.inputs[args.inFlightTxInputIndex].piggybackBondSize;\n        SafeEthTransfer.transferRevertOnError(msg.sender, piggybackBondSize, self.safeGasStipend);\n\n        emit InFlightExitInputBlocked(msg.sender, keccak256(args.inFlightTx), args.inFlightTxInputIndex);\n    }\n\n    function verifySpentInputEqualsIFEInput(ChallengeIFEData memory data) private view {\n        bytes32 ifeInputOutputId = data.ife.inputs[data.args.inFlightTxInputIndex].outputId;\n\n        PosLib.Position memory utxoPos = PosLib.decode(data.args.inputUtxoPos);\n        bytes32 challengingTxInputOutputId = data.controller.framework.isDeposit(utxoPos.blockNum)\n                ? OutputId.computeDepositOutputId(data.args.inputTx, utxoPos.outputIndex, utxoPos.encode())\n                : OutputId.computeNormalOutputId(data.args.inputTx, utxoPos.outputIndex);\n\n        require(ifeInputOutputId == challengingTxInputOutputId, \"Spent input is not the same as piggybacked input\");\n    }\n\n    function verifyChallengingTransactionProtocolFinalized(ChallengeIFEData memory data)\n        private\n        view\n    {\n        bool isProtocolFinalized = MoreVpFinalization.isProtocolFinalized(\n            data.controller.framework,\n            data.args.challengingTx\n        );\n\n        // MoreVP protocol finalization would only return false only when tx does not exists.\n        // Should fail already in early stages (eg. decode)\n        assert(isProtocolFinalized);\n    }\n\n    function verifySpendingCondition(ChallengeIFEData memory data) private view {\n        GenericTransaction.Transaction memory challengingTx = GenericTransaction.decode(data.args.challengingTx);\n\n        GenericTransaction.Transaction memory inputTx = GenericTransaction.decode(data.args.inputTx);\n        PosLib.Position memory utxoPos = PosLib.decode(data.args.inputUtxoPos);\n        GenericTransaction.Output memory output = GenericTransaction.getOutput(inputTx, utxoPos.outputIndex);\n\n        ISpendingCondition condition = data.controller.spendingConditionRegistry.spendingConditions(\n            output.outputType, challengingTx.txType\n        );\n        require(address(condition) != address(0), \"Spending condition contract not found\");\n\n        bool isSpent = condition.verify(\n            data.args.inputTx,\n            data.args.inputUtxoPos,\n            data.args.challengingTx,\n            data.args.challengingTxInputIndex,\n            data.args.challengingTxWitness\n        );\n        require(isSpent, \"Spending condition failed\");\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFENotCanonical.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../routers/PaymentInFlightExitRouterArgs.sol\";\nimport \"../../interfaces/ISpendingCondition.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../utils/ExitId.sol\";\nimport \"../../utils/OutputId.sol\";\nimport \"../../utils/MoreVpFinalization.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../utils/Merkle.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../transactions/GenericTransaction.sol\";\n\nlibrary PaymentChallengeIFENotCanonical {\n    using PosLib for PosLib.Position;\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    /**\n     * @dev supportedTxType Allows reuse of code in different Payment Tx versions\n     */\n    struct Controller {\n        PlasmaFramework framework;\n        SpendingConditionRegistry spendingConditionRegistry;\n        uint256 supportedTxType;\n    }\n\n    event InFlightExitChallenged(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint256 challengeTxPosition\n    );\n\n    event InFlightExitChallengeResponded(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint256 challengeTxPosition\n    );\n\n    /**\n     * @notice Function that builds the controller struct\n     * @return Controller struct of PaymentChallengeIFENotCanonical\n     */\n    function buildController(\n        PlasmaFramework framework,\n        SpendingConditionRegistry spendingConditionRegistry,\n        uint256 supportedTxType\n    )\n        public\n        pure\n        returns (Controller memory)\n    {\n        return Controller({\n            framework: framework,\n            spendingConditionRegistry: spendingConditionRegistry,\n            supportedTxType: supportedTxType\n        });\n    }\n\n    /**\n     * @notice Main logic implementation for 'challengeInFlightExitNotCanonical'\n     * @dev emits InFlightExitChallenged event on success\n     * @param self The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param args Arguments of 'challengeInFlightExitNotCanonical' function from client\n     */\n    function challenge(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        PaymentInFlightExitRouterArgs.ChallengeCanonicityArgs memory args\n    )\n        public\n    {\n        uint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n        PaymentExitDataModel.InFlightExit storage ife = inFlightExitMap.exits[exitId];\n        require(args.inFlightTxInputIndex < ife.inputs.length, \"Input index out of bounds\");\n        require(ife.exitStartTimestamp != 0, \"In-flight exit does not exist\");\n\n        require(ife.isInFirstPhase(self.framework.minExitPeriod()),\n                \"Canonicity challenge phase for this exit has ended\");\n\n        require(\n            keccak256(args.inFlightTx) != keccak256(args.competingTx),\n            \"The competitor transaction is the same as transaction in-flight\"\n        );\n\n        PosLib.Position memory inputUtxoPos = PosLib.decode(args.inputUtxoPos);\n\n        bytes32 outputId;\n        if (self.framework.isDeposit(inputUtxoPos.blockNum)) {\n            outputId = OutputId.computeDepositOutputId(args.inputTx, inputUtxoPos.outputIndex, args.inputUtxoPos);\n        } else {\n            outputId = OutputId.computeNormalOutputId(args.inputTx, inputUtxoPos.outputIndex);\n        }\n        require(outputId == ife.inputs[args.inFlightTxInputIndex].outputId,\n                \"Provided inputs data does not point to the same outputId from the in-flight exit\");\n\n        GenericTransaction.Output memory output = GenericTransaction.getOutput(\n            GenericTransaction.decode(args.inputTx),\n            inputUtxoPos.outputIndex\n        );\n\n        ISpendingCondition condition = self.spendingConditionRegistry.spendingConditions(\n            output.outputType, self.supportedTxType\n        );\n        require(address(condition) != address(0), \"Spending condition contract not found\");\n\n        bool isSpentByCompetingTx = condition.verify(\n            args.inputTx,\n            args.inputUtxoPos,\n            args.competingTx,\n            args.competingTxInputIndex,\n            args.competingTxWitness\n        );\n        require(isSpentByCompetingTx, \"Competing input spending condition is not met\");\n\n        // Determine the position of the competing transaction\n        uint256 competitorPosition = verifyCompetingTxFinalizedInThePosition(self, args);\n\n        require(\n            ife.oldestCompetitorPosition == 0 || ife.oldestCompetitorPosition > competitorPosition,\n            \"Competing transaction is not older than already known competitor\"\n        );\n\n        ife.oldestCompetitorPosition = competitorPosition;\n        ife.bondOwner = msg.sender;\n\n        // Set a flag so that only the inputs are exitable, unless a response is received.\n        ife.isCanonical = false;\n\n        emit InFlightExitChallenged(msg.sender, keccak256(args.inFlightTx), competitorPosition);\n    }\n\n    /**\n     * @notice Main logic implementation for 'respondToNonCanonicalChallenge'\n     * @dev emits InFlightExitChallengeResponded event on success\n     * @param self The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param inFlightTx The in-flight tx, in RLP-encoded bytes\n     * @param inFlightTxPos The UTXO position of the in-flight exit. Should hardcode 0 for the outputIndex.\n     * @param inFlightTxInclusionProof Inclusion proof for the in-flight tx\n     */\n    function respond(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        bytes memory inFlightTx,\n        uint256 inFlightTxPos,\n        bytes memory inFlightTxInclusionProof\n    )\n        public\n    {\n        uint160 exitId = ExitId.getInFlightExitId(inFlightTx);\n        PaymentExitDataModel.InFlightExit storage ife = inFlightExitMap.exits[exitId];\n        require(ife.exitStartTimestamp != 0, \"In-flight exit does not exist\");\n        require(inFlightTxPos > 0, \"In-flight transaction position must not be 0\");\n\n        require(\n            ife.oldestCompetitorPosition > inFlightTxPos,\n            \"In-flight transaction must be older than competitors to respond to non-canonical challenge\");\n\n        PosLib.Position memory txPos = PosLib.decode(inFlightTxPos);\n        (bytes32 root, ) = self.framework.blocks(txPos.blockNum);\n        require(root != bytes32(\"\"), \"Failed to get the block root hash of the tx position\");\n\n        verifyPositionOfTransactionIncludedInBlock(\n            inFlightTx, txPos, root, inFlightTxInclusionProof\n        );\n\n        ife.oldestCompetitorPosition = inFlightTxPos;\n        ife.isCanonical = true;\n        ife.bondOwner = msg.sender;\n\n        emit InFlightExitChallengeResponded(msg.sender, keccak256(inFlightTx), inFlightTxPos);\n    }\n\n    function verifyPositionOfTransactionIncludedInBlock(\n        bytes memory txbytes,\n        PosLib.Position memory txPos,\n        bytes32 root,\n        bytes memory inclusionProof\n    )\n        private\n        pure\n    {\n        require(txPos.outputIndex == 0, \"Output index of txPos has to be 0\");\n        require(\n            Merkle.checkMembership(txbytes, txPos.txIndex, root, inclusionProof),\n            \"Transaction is not included in block of Plasma chain\"\n        );\n    }\n\n    function verifyCompetingTxFinalizedInThePosition(\n        Controller memory self,\n        PaymentInFlightExitRouterArgs.ChallengeCanonicityArgs memory args\n    )\n        private\n        view\n        returns (uint256)\n    {\n        // default to infinite low priority position\n        uint256 competitorPosition = ~uint256(0);\n\n        if (args.competingTxPos == 0) {\n            bool isProtocolFinalized = MoreVpFinalization.isProtocolFinalized(\n                self.framework,\n                args.competingTx\n            );\n            // MoreVP protocol finalization would only return false only when tx does not exists.\n            // Should fail already in early stages (eg. decode)\n            assert(isProtocolFinalized);\n        } else {\n            PosLib.Position memory competingTxPos = PosLib.decode(args.competingTxPos);\n            require(competingTxPos.outputIndex == 0, \"OutputIndex of competingTxPos should be 0\");\n\n            bool isStandardFinalized = MoreVpFinalization.isStandardFinalized(\n                self.framework,\n                args.competingTx,\n                competingTxPos,\n                args.competingTxInclusionProof\n            );\n            require(isStandardFinalized, \"Competing tx is not standard finalized with the given tx position\");\n            competitorPosition = args.competingTxPos;\n        }\n        return competitorPosition;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentChallengeIFEOutputSpent.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../routers/PaymentInFlightExitRouterArgs.sol\";\nimport \"../../interfaces/ISpendingCondition.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../utils/ExitId.sol\";\nimport \"../../utils/MoreVpFinalization.sol\";\nimport \"../../../utils/Merkle.sol\";\nimport \"../../../utils/SafeEthTransfer.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../transactions/GenericTransaction.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\n\nlibrary PaymentChallengeIFEOutputSpent {\n    using PosLib for PosLib.Position;\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    struct Controller {\n        PlasmaFramework framework;\n        SpendingConditionRegistry spendingConditionRegistry;\n        uint256 safeGasStipend;\n    }\n\n    event InFlightExitOutputBlocked(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint16 outputIndex\n    );\n\n    /**\n     * @notice Main logic implementation for 'challengeInFlightExitOutputSpent'\n     * @dev emits InFlightExitOutputBlocked event on success\n     * @param controller The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param args Arguments of 'challengeInFlightExitOutputSpent' function from client\n     */\n    function run(\n        Controller memory controller,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        PaymentInFlightExitRouterArgs.ChallengeOutputSpent memory args\n    )\n        public\n    {\n        require(args.senderData == keccak256(abi.encodePacked(msg.sender)), \"Incorrect senderData\");\n\n        uint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n        PaymentExitDataModel.InFlightExit storage ife = inFlightExitMap.exits[exitId];\n        require(ife.exitStartTimestamp != 0, \"In-flight exit does not exist\");\n\n        PosLib.Position memory utxoPos = PosLib.decode(args.outputUtxoPos);\n        uint16 outputIndex = utxoPos.outputIndex;\n        require(\n            ife.isOutputPiggybacked(outputIndex),\n            \"Output is not piggybacked\"\n        );\n\n        verifyInFlightTransactionStandardFinalized(controller, args);\n        verifyChallengingTransactionProtocolFinalized(controller, args);\n        verifyChallengingTransactionSpendsOutput(controller, args);\n\n        ife.clearOutputPiggybacked(outputIndex);\n\n        uint256 piggybackBondSize = ife.outputs[outputIndex].piggybackBondSize;\n        SafeEthTransfer.transferRevertOnError(msg.sender, piggybackBondSize, controller.safeGasStipend);\n\n        emit InFlightExitOutputBlocked(msg.sender, keccak256(args.inFlightTx), outputIndex);\n    }\n\n    function verifyInFlightTransactionStandardFinalized(\n        Controller memory controller,\n        PaymentInFlightExitRouterArgs.ChallengeOutputSpent memory args\n    )\n        private\n        view\n    {\n        PosLib.Position memory utxoPos = PosLib.decode(args.outputUtxoPos);\n        bool isStandardFinalized = MoreVpFinalization.isStandardFinalized(\n            controller.framework,\n            args.inFlightTx,\n            utxoPos.toStrictTxPos(),\n            args.inFlightTxInclusionProof\n        );\n\n        require(isStandardFinalized, \"In-flight transaction must be standard finalized (included in Plasma) to be able to spend\");\n    }\n\n    function verifyChallengingTransactionProtocolFinalized(\n        Controller memory controller,\n        PaymentInFlightExitRouterArgs.ChallengeOutputSpent memory args\n    )\n        private\n        view\n    {\n        bool isProtocolFinalized = MoreVpFinalization.isProtocolFinalized(\n            controller.framework,\n            args.challengingTx\n        );\n\n        // MoreVP protocol finalization would only return false only when tx does not exists.\n        // Should fail already in early stages (eg. decode)\n        assert(isProtocolFinalized);\n    }\n\n    function verifyChallengingTransactionSpendsOutput(\n        Controller memory controller,\n        PaymentInFlightExitRouterArgs.ChallengeOutputSpent memory args\n    )\n        private\n        view\n    {\n        PosLib.Position memory utxoPos = PosLib.decode(args.outputUtxoPos);\n        GenericTransaction.Transaction memory challengingTx = GenericTransaction.decode(args.challengingTx);\n\n        GenericTransaction.Transaction memory ifeTx = GenericTransaction.decode(args.inFlightTx);\n        GenericTransaction.Output memory ifeTxOutput = GenericTransaction.getOutput(ifeTx, utxoPos.outputIndex);\n\n        ISpendingCondition condition = controller.spendingConditionRegistry.spendingConditions(\n            ifeTxOutput.outputType,\n            challengingTx.txType\n        );\n        require(address(condition) != address(0), \"Spending condition contract not found\");\n\n        bool isSpentBySpendingTx = condition.verify(\n            args.inFlightTx,\n            utxoPos.encode(),\n            args.challengingTx,\n            args.challengingTxInputIndex,\n            args.challengingTxWitness\n        );\n\n        require(isSpentBySpendingTx, \"Challenging transaction does not spend the output\");\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentChallengeStandardExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../routers/PaymentStandardExitRouterArgs.sol\";\nimport \"../../interfaces/ISpendingCondition.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../utils/MoreVpFinalization.sol\";\nimport \"../../utils/OutputId.sol\";\nimport \"../../../vaults/EthVault.sol\";\nimport \"../../../vaults/Erc20Vault.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../framework/Protocol.sol\";\nimport \"../../../utils/SafeEthTransfer.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../transactions/GenericTransaction.sol\";\n\nlibrary PaymentChallengeStandardExit {\n    using PosLib for PosLib.Position;\n    using PaymentTransactionModel for PaymentTransactionModel.Transaction;\n\n    struct Controller {\n        PlasmaFramework framework;\n        SpendingConditionRegistry spendingConditionRegistry;\n        uint256 safeGasStipend;\n    }\n\n    event ExitChallenged(\n        uint256 indexed utxoPos\n    );\n\n    /**\n     * @dev Data to be passed around helper functions\n     */\n    struct ChallengeStandardExitData {\n        Controller controller;\n        PaymentStandardExitRouterArgs.ChallengeStandardExitArgs args;\n        PaymentExitDataModel.StandardExit exitData;\n        uint256 challengeTxType;\n    }\n\n    /**\n     * @notice Function that builds the controller struct\n     * @return Controller struct of PaymentChallengeStandardExit\n     */\n    function buildController(\n        PlasmaFramework framework,\n        SpendingConditionRegistry spendingConditionRegistry,\n        uint256 safeGasStipend\n    )\n        public\n        pure\n        returns (Controller memory)\n    {\n        return Controller({\n            framework: framework,\n            spendingConditionRegistry: spendingConditionRegistry,\n            safeGasStipend: safeGasStipend\n        });\n    }\n\n    /**\n     * @notice Main logic function to challenge standard exit\n     * @dev emits ExitChallenged event on success\n     * @param self The controller struct\n     * @param exitMap The storage of all standard exit data\n     * @param args Arguments of challenge standard exit function from client\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.StandardExitMap storage exitMap,\n        PaymentStandardExitRouterArgs.ChallengeStandardExitArgs memory args\n    )\n        public\n    {\n        require(args.senderData == keccak256(abi.encodePacked(msg.sender)), \"Incorrect senderData\");\n\n        GenericTransaction.Transaction memory challengeTx = GenericTransaction.decode(args.challengeTx);\n\n        ChallengeStandardExitData memory data = ChallengeStandardExitData({\n            controller: self,\n            args: args,\n            exitData: exitMap.exits[args.exitId],\n            challengeTxType: challengeTx.txType\n        });\n        verifyChallengeExitExists(data);\n        verifyChallengeTxProtocolFinalized(data);\n        verifySpendingCondition(data);\n\n        exitMap.exits[args.exitId].exitable = false;\n\n        SafeEthTransfer.transferRevertOnError(msg.sender, data.exitData.bondSize, self.safeGasStipend);\n\n        emit ExitChallenged(data.exitData.utxoPos);\n    }\n\n    function verifyChallengeExitExists(ChallengeStandardExitData memory data) private pure {\n        require(data.exitData.exitable == true, \"The exit does not exist\");\n    }\n\n    function verifyChallengeTxProtocolFinalized(ChallengeStandardExitData memory data) private view {\n        bool isProtocolFinalized = MoreVpFinalization.isProtocolFinalized(data.controller.framework, data.args.challengeTx);\n        // MoreVP protocol finalization would only return false only when tx does not exists.\n        // Should fail already in early stages (eg. decode)\n        assert(isProtocolFinalized);\n    }\n\n    function verifySpendingCondition(ChallengeStandardExitData memory data) private view {\n        PaymentStandardExitRouterArgs.ChallengeStandardExitArgs memory args = data.args;\n\n        PosLib.Position memory utxoPos = PosLib.decode(data.exitData.utxoPos);\n        FungibleTokenOutputModel.Output memory output = PaymentTransactionModel\n            .decode(args.exitingTx)\n            .getOutput(utxoPos.outputIndex);\n\n        ISpendingCondition condition = data.controller.spendingConditionRegistry.spendingConditions(\n            output.outputType, data.challengeTxType\n        );\n        require(address(condition) != address(0), \"Spending condition contract not found\");\n\n        bytes32 outputId = data.controller.framework.isDeposit(utxoPos.blockNum)\n                ? OutputId.computeDepositOutputId(args.exitingTx, utxoPos.outputIndex, utxoPos.encode())\n                : OutputId.computeNormalOutputId(args.exitingTx, utxoPos.outputIndex);\n        require(outputId == data.exitData.outputId, \"Invalid exiting tx causing outputId mismatch\");\n\n        bool isSpentByChallengeTx = condition.verify(\n            args.exitingTx,\n            utxoPos.encode(),\n            args.challengeTx,\n            args.inputIndex,\n            args.witness\n        );\n        require(isSpentByChallengeTx, \"Spending condition failed\");\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentDeleteInFlightExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../../../utils/SafeEthTransfer.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\n\nlibrary PaymentDeleteInFlightExit {\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    struct Controller {\n        uint256 minExitPeriod;\n        uint256 safeGasStipend;\n    }\n\n    event InFlightExitDeleted(\n        uint160 indexed exitId\n    );\n\n    /**\n     * @notice Main logic function to delete the non piggybacked in-flight exit\n     * @param exitId The exitId of the standard exit\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage exitMap,\n        uint160 exitId\n    )\n        public\n    {\n        PaymentExitDataModel.InFlightExit memory ife = exitMap.exits[exitId];\n        require(ife.exitStartTimestamp != 0, \"In-flight exit does not exist\");\n        require(!ife.isInFirstPhase(self.minExitPeriod), \"Cannot delete in-flight exit still in first phase\");\n        require(!isPiggybacked(ife), \"The in-flight exit is already piggybacked\");\n\n        delete exitMap.exits[exitId];\n        SafeEthTransfer.transferRevertOnError(ife.bondOwner, ife.bondSize, self.safeGasStipend);\n        emit InFlightExitDeleted(exitId);\n    }\n\n    function isPiggybacked(ExitModel.InFlightExit memory ife)\n        private\n        pure\n        returns (bool)\n    {\n        for (uint16 i = 0; i < PaymentTransactionModel.MAX_INPUT_NUM(); i++) {\n            if (ife.isInputPiggybacked(i)) {\n                return true;\n            }\n        }\n\n        for (uint16 i = 0; i < PaymentTransactionModel.MAX_OUTPUT_NUM(); i++) {\n            if (ife.isOutputPiggybacked(i)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentPiggybackInFlightExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../routers/PaymentInFlightExitRouterArgs.sol\";\nimport \"../../utils/ExitableTimestamp.sol\";\nimport \"../../utils/ExitId.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../framework/interfaces/IExitProcessor.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../utils/PosLib.sol\";\n\nlibrary PaymentPiggybackInFlightExit {\n    using PosLib for PosLib.Position;\n    using ExitableTimestamp for ExitableTimestamp.Calculator;\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    struct Controller {\n        PlasmaFramework framework;\n        ExitableTimestamp.Calculator exitableTimestampCalculator;\n        IExitProcessor exitProcessor;\n        uint256 minExitPeriod;\n        uint256 ethVaultId;\n        uint256 erc20VaultId;\n    }\n\n    event InFlightExitInputPiggybacked(\n        address indexed exitTarget,\n        bytes32 indexed txHash,\n        uint16 inputIndex\n    );\n\n    event InFlightExitOutputPiggybacked(\n        address indexed exitTarget,\n        bytes32 indexed txHash,\n        uint16 outputIndex\n    );\n\n    /**\n     * @notice Function that builds the controller struct\n     * @return Controller struct of PaymentPiggybackInFlightExit\n     */\n    function buildController(\n        PlasmaFramework framework,\n        IExitProcessor exitProcessor,\n        uint256 ethVaultId,\n        uint256 erc20VaultId\n    )\n        public\n        view\n        returns (Controller memory)\n    {\n        return Controller({\n            framework: framework,\n            exitableTimestampCalculator: ExitableTimestamp.Calculator(framework.minExitPeriod()),\n            exitProcessor: exitProcessor,\n            minExitPeriod: framework.minExitPeriod(),\n            ethVaultId: ethVaultId,\n            erc20VaultId: erc20VaultId\n        });\n    }\n\n    /**\n     * @notice The main controller logic for 'piggybackInFlightExitOnInput'\n     * @dev emits InFlightExitInputPiggybacked event on success\n     * @param self The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param args Arguments of 'piggybackInFlightExitOnInput' function from client\n     */\n    function piggybackInput(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        PaymentInFlightExitRouterArgs.PiggybackInFlightExitOnInputArgs memory args\n    )\n        public\n    {\n        uint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n        PaymentExitDataModel.InFlightExit storage exit = inFlightExitMap.exits[exitId];\n\n        require(exit.exitStartTimestamp != 0, \"No in-flight exit to piggyback on\");\n        require(exit.isInFirstPhase(self.minExitPeriod), \"Piggyback is possible only in the first phase of the exit period\");\n\n        require(!exit.isInputEmpty(args.inputIndex), \"Indexed input is empty\");\n        require(!exit.isInputPiggybacked(args.inputIndex), \"Indexed input already piggybacked\");\n\n        PaymentExitDataModel.WithdrawData storage withdrawData = exit.inputs[args.inputIndex];\n\n        require(withdrawData.exitTarget == msg.sender, \"Can be called only by the exit target\");\n        withdrawData.piggybackBondSize = msg.value;\n\n        if (isFirstPiggybackOfTheToken(exit, withdrawData.token)) {\n            enqueue(self, withdrawData.token, PosLib.decode(exit.position), exitId);\n        }\n\n        exit.setInputPiggybacked(args.inputIndex);\n\n        emit InFlightExitInputPiggybacked(msg.sender, keccak256(args.inFlightTx), args.inputIndex);\n    }\n\n    /**\n     * @notice The main controller logic for 'piggybackInFlightExitOnOutput'\n     * @dev emits InFlightExitOutputPiggybacked event on success\n     * @param self The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param args Arguments of 'piggybackInFlightExitOnOutput' function from client\n     */\n    function piggybackOutput(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        PaymentInFlightExitRouterArgs.PiggybackInFlightExitOnOutputArgs memory args\n    )\n        public\n    {\n        uint160 exitId = ExitId.getInFlightExitId(args.inFlightTx);\n        PaymentExitDataModel.InFlightExit storage exit = inFlightExitMap.exits[exitId];\n\n        require(exit.exitStartTimestamp != 0, \"No in-flight exit to piggyback on\");\n        require(exit.isInFirstPhase(self.minExitPeriod), \"Piggyback is possible only in the first phase of the exit period\");\n\n        require(!exit.isOutputEmpty(args.outputIndex), \"Indexed output is empty\");\n        require(!exit.isOutputPiggybacked(args.outputIndex), \"Indexed output already piggybacked\");\n\n        PaymentExitDataModel.WithdrawData storage withdrawData = exit.outputs[args.outputIndex];\n\n        require(withdrawData.exitTarget == msg.sender, \"Can be called only by the exit target\");\n        withdrawData.piggybackBondSize = msg.value;\n\n        if (isFirstPiggybackOfTheToken(exit, withdrawData.token)) {\n            enqueue(self, withdrawData.token, PosLib.decode(exit.position), exitId);\n        }\n\n        exit.setOutputPiggybacked(args.outputIndex);\n\n        emit InFlightExitOutputPiggybacked(msg.sender, keccak256(args.inFlightTx), args.outputIndex);\n    }\n\n    function enqueue(\n        Controller memory controller,\n        address token,\n        PosLib.Position memory utxoPos,\n        uint160 exitId\n    )\n        private\n    {\n        (, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum);\n        require(blockTimestamp != 0, \"There is no block for the exit position to enqueue\");\n\n        uint64 exitableAt = controller.exitableTimestampCalculator.calculateTxExitableTimestamp(now, blockTimestamp);\n\n        uint256 vaultId;\n        if (token == address(0)) {\n            vaultId = controller.ethVaultId;\n        } else {\n            vaultId = controller.erc20VaultId;\n        }\n\n        controller.framework.enqueue(vaultId, token, exitableAt, utxoPos.toStrictTxPos(), exitId, controller.exitProcessor);\n    }\n\n    function isFirstPiggybackOfTheToken(ExitModel.InFlightExit memory ife, address token)\n        private\n        pure\n        returns (bool)\n    {\n        for (uint i = 0; i < PaymentTransactionModel.MAX_INPUT_NUM(); i++) {\n            if (ife.isInputPiggybacked(uint16(i)) && ife.inputs[i].token == token) {\n                return false;\n            }\n        }\n\n        for (uint i = 0; i < PaymentTransactionModel.MAX_OUTPUT_NUM(); i++) {\n            if (ife.isOutputPiggybacked(uint16(i)) && ife.outputs[i].token == token) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentProcessInFlightExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../utils/SafeEthTransfer.sol\";\nimport \"../../../vaults/EthVault.sol\";\nimport \"../../../vaults/Erc20Vault.sol\";\n\nlibrary PaymentProcessInFlightExit {\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n\n    struct Controller {\n        PlasmaFramework framework;\n        EthVault ethVault;\n        Erc20Vault erc20Vault;\n        uint256 safeGasStipend;\n    }\n\n    event InFlightExitOmitted(\n        uint160 indexed exitId,\n        address token\n    );\n\n    event InFlightExitOutputWithdrawn(\n        uint160 indexed exitId,\n        uint16 outputIndex\n    );\n\n    event InFlightExitInputWithdrawn(\n        uint160 indexed exitId,\n        uint16 inputIndex\n    );\n\n    event InFlightBondReturnFailed(\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @notice Main logic function to process in-flight exit\n     * @dev emits InFlightExitOmitted event if the exit is omitted\n     * @dev emits InFlightBondReturnFailed event if failed to pay out bond. Would continue to process the exit.\n     * @dev emits InFlightExitInputWithdrawn event if the input of IFE is withdrawn successfully\n     * @dev emits InFlightExitOutputWithdrawn event if the output of IFE is withdrawn successfully\n     * @param self The controller struct\n     * @param exitMap The storage of all in-flight exit data\n     * @param exitId The exitId of the in-flight exit\n     * @param token The ERC20 token address of the exit; uses address(0) to represent ETH\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage exitMap,\n        uint160 exitId,\n        address token\n    )\n        public\n    {\n        PaymentExitDataModel.InFlightExit storage exit = exitMap.exits[exitId];\n\n        if (exit.exitStartTimestamp == 0) {\n            emit InFlightExitOmitted(exitId, token);\n            return;\n        }\n\n        /* To prevent a double spend, it is needed to know if an output can be exited.\n         * An output can not be exited if:\n         * - it is finalized by a standard exit\n         * - it is finalized by an in-flight exit as input of a non-canonical transaction\n         * - it is blocked from exiting, because it is an input of a canonical transaction\n         *   that exited from one of it's outputs\n         * - it is finalized by an in-flight exit as an output of a canonical transaction\n         * - it is an output of a transaction for which at least one of its inputs is already finalized\n         *\n         * Hence, Plasma Framework stores each output with an exit id that finalized it.\n         * When transaction is marked as canonical but any of it's input was finalized by\n         * other exit, it is not allowed to exit from the transaction's outputs.\n         * In that case exit from an unspent input is possible.\n         * When all inputs of a transaction that is marked as canonical are either not finalized or finalized\n         * by the same exit (which means they were marked as finalized when processing the same exit for a different token),\n         * only exit from outputs is possible.\n         *\n         * See: https://github.com/omisego/plasma-contracts/issues/102#issuecomment-495809967 for more details\n         */\n        if (!exit.isCanonical || isAnyInputFinalizedByOtherExit(self.framework, exit, exitId)) {\n            for (uint16 i = 0; i < exit.inputs.length; i++) {\n                PaymentExitDataModel.WithdrawData memory withdrawal = exit.inputs[i];\n\n                if (shouldWithdrawInput(self, exit, withdrawal, token, i)) {\n                    withdrawFromVault(self, withdrawal);\n                    emit InFlightExitInputWithdrawn(exitId, i);\n                }\n            }\n\n            flagOutputsWhenNonCanonical(self.framework, exit, token, exitId);\n        } else {\n            for (uint16 i = 0; i < exit.outputs.length; i++) {\n                PaymentExitDataModel.WithdrawData memory withdrawal = exit.outputs[i];\n\n                if (shouldWithdrawOutput(self, exit, withdrawal, token, i)) {\n                    withdrawFromVault(self, withdrawal);\n                    emit InFlightExitOutputWithdrawn(exitId, i);\n                }\n            }\n\n            flagOutputsWhenCanonical(self.framework, exit, token, exitId);\n        }\n\n        returnInputPiggybackBonds(self, exit, token);\n        returnOutputPiggybackBonds(self, exit, token);\n\n        clearPiggybackInputFlag(exit, token);\n        clearPiggybackOutputFlag(exit, token);\n\n        if (allPiggybacksCleared(exit)) {\n            bool success = SafeEthTransfer.transferReturnResult(\n                exit.bondOwner, exit.bondSize, self.safeGasStipend\n            );\n\n            // we do not want to block a queue if bond return is unsuccessful\n            if (!success) {\n                emit InFlightBondReturnFailed(exit.bondOwner, exit.bondSize);\n            }\n            delete exitMap.exits[exitId];\n        }\n    }\n\n    function isAnyInputFinalizedByOtherExit(\n        PlasmaFramework framework,\n        PaymentExitDataModel.InFlightExit memory exit,\n        uint160 exitId\n    )\n        private\n        view\n        returns (bool)\n    {\n        uint256 nonEmptyInputIndex;\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (!exit.isInputEmpty(i)) {\n                nonEmptyInputIndex++;\n            }\n        }\n        bytes32[] memory outputIdsOfInputs = new bytes32[](nonEmptyInputIndex);\n        nonEmptyInputIndex = 0;\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (!exit.isInputEmpty(i)) {\n                outputIdsOfInputs[nonEmptyInputIndex] = exit.inputs[i].outputId;\n                nonEmptyInputIndex++;\n            }\n        }\n        return framework.isAnyInputFinalizedByOtherExit(outputIdsOfInputs, exitId);\n    }\n\n    function shouldWithdrawInput(\n        Controller memory controller,\n        PaymentExitDataModel.InFlightExit memory exit,\n        PaymentExitDataModel.WithdrawData memory withdrawal,\n        address token,\n        uint16 index\n    )\n        private\n        view\n        returns (bool)\n    {\n        return withdrawal.token == token &&\n                exit.isInputPiggybacked(index) &&\n                !controller.framework.isOutputFinalized(withdrawal.outputId);\n    }\n\n    function shouldWithdrawOutput(\n        Controller memory controller,\n        PaymentExitDataModel.InFlightExit memory exit,\n        PaymentExitDataModel.WithdrawData memory withdrawal,\n        address token,\n        uint16 index\n    )\n        private\n        view\n        returns (bool)\n    {\n        return withdrawal.token == token &&\n                exit.isOutputPiggybacked(index) &&\n                !controller.framework.isOutputFinalized(withdrawal.outputId);\n    }\n\n    function withdrawFromVault(\n        Controller memory self,\n        PaymentExitDataModel.WithdrawData memory withdrawal\n    )\n        private\n    {\n        if (withdrawal.token == address(0)) {\n            self.ethVault.withdraw(withdrawal.exitTarget, withdrawal.amount);\n        } else {\n            self.erc20Vault.withdraw(withdrawal.exitTarget, withdrawal.token, withdrawal.amount);\n        }\n    }\n\n    function flagOutputsWhenNonCanonical(\n        PlasmaFramework framework,\n        PaymentExitDataModel.InFlightExit memory exit,\n        address token,\n        uint160 exitId\n    )\n        private\n    {\n        uint256 piggybackedInputNumOfTheToken;\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (exit.inputs[i].token == token && exit.isInputPiggybacked(i)) {\n                piggybackedInputNumOfTheToken++;\n            }\n        }\n\n        bytes32[] memory outputIdsToFlag = new bytes32[](piggybackedInputNumOfTheToken);\n        uint indexForOutputIds = 0;\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (exit.inputs[i].token == token && exit.isInputPiggybacked(i)) {\n                outputIdsToFlag[indexForOutputIds] = exit.inputs[i].outputId;\n                indexForOutputIds++;\n            }\n        }\n        framework.batchFlagOutputsFinalized(outputIdsToFlag, exitId);\n    }\n\n    function flagOutputsWhenCanonical(\n        PlasmaFramework framework,\n        PaymentExitDataModel.InFlightExit memory exit,\n        address token,\n        uint160 exitId\n    )\n        private\n    {\n        uint256 inputNumOfTheToken;\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (!exit.isInputEmpty(i)) {\n                inputNumOfTheToken++;\n            }\n        }\n\n        uint256 piggybackedOutputNumOfTheToken;\n        for (uint16 i = 0; i < exit.outputs.length; i++) {\n            if (exit.outputs[i].token == token && exit.isOutputPiggybacked(i)) {\n                piggybackedOutputNumOfTheToken++;\n            }\n        }\n\n        bytes32[] memory outputIdsToFlag = new bytes32[](inputNumOfTheToken + piggybackedOutputNumOfTheToken);\n        uint indexForOutputIds = 0;\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (!exit.isInputEmpty(i)) {\n                outputIdsToFlag[indexForOutputIds] = exit.inputs[i].outputId;\n                indexForOutputIds++;\n            }\n        }\n        for (uint16 i = 0; i < exit.outputs.length; i++) {\n            if (exit.outputs[i].token == token && exit.isOutputPiggybacked(i)) {\n                outputIdsToFlag[indexForOutputIds] = exit.outputs[i].outputId;\n                indexForOutputIds++;\n            }\n        }\n        framework.batchFlagOutputsFinalized(outputIdsToFlag, exitId);\n    }\n\n    function returnInputPiggybackBonds(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExit storage exit,\n        address token\n    )\n        private\n    {\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            PaymentExitDataModel.WithdrawData memory withdrawal = exit.inputs[i];\n\n            // If the input has been challenged, isInputPiggybacked() will return false\n            if (token == withdrawal.token && exit.isInputPiggybacked(i)) {\n                bool success = SafeEthTransfer.transferReturnResult(\n                    withdrawal.exitTarget, withdrawal.piggybackBondSize, self.safeGasStipend\n                );\n\n                // we do not want to block a queue if bond return is unsuccessful\n                if (!success) {\n                    emit InFlightBondReturnFailed(withdrawal.exitTarget, withdrawal.piggybackBondSize);\n                }\n            }\n        }\n    }\n\n    function returnOutputPiggybackBonds(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExit storage exit,\n        address token\n    )\n        private\n    {\n        for (uint16 i = 0; i < exit.outputs.length; i++) {\n            PaymentExitDataModel.WithdrawData memory withdrawal = exit.outputs[i];\n\n            // If the output has been challenged, isOutputPiggybacked() will return false\n            if (token == withdrawal.token && exit.isOutputPiggybacked(i)) {\n                bool success = SafeEthTransfer.transferReturnResult(\n                    withdrawal.exitTarget, withdrawal.piggybackBondSize, self.safeGasStipend\n                );\n\n                // we do not want to block a queue if bond return is unsuccessful\n                if (!success) {\n                    emit InFlightBondReturnFailed(withdrawal.exitTarget, withdrawal.piggybackBondSize);\n                }\n            }\n        }\n    }\n\n    function clearPiggybackInputFlag(\n        PaymentExitDataModel.InFlightExit storage exit,\n        address token\n    )\n        private\n    {\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (token == exit.inputs[i].token) {\n                exit.clearInputPiggybacked(i);\n            }\n        }\n    }\n\n    function clearPiggybackOutputFlag(\n        PaymentExitDataModel.InFlightExit storage exit,\n        address token\n    )\n        private\n    {\n        for (uint16 i = 0; i < exit.outputs.length; i++) {\n            if (token == exit.outputs[i].token) {\n                exit.clearOutputPiggybacked(i);\n            }\n        }\n    }\n\n    function allPiggybacksCleared(PaymentExitDataModel.InFlightExit memory exit) private pure returns (bool) {\n        for (uint16 i = 0; i < exit.inputs.length; i++) {\n            if (exit.isInputPiggybacked(i))\n                return false;\n        }\n\n        for (uint16 i = 0; i < exit.outputs.length; i++) {\n            if (exit.isOutputPiggybacked(i))\n                return false;\n        }\n\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentProcessStandardExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../routers/PaymentStandardExitRouterArgs.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../utils/SafeEthTransfer.sol\";\nimport \"../../../vaults/EthVault.sol\";\nimport \"../../../vaults/Erc20Vault.sol\";\n\nlibrary PaymentProcessStandardExit {\n    struct Controller {\n        PlasmaFramework framework;\n        EthVault ethVault;\n        Erc20Vault erc20Vault;\n        uint256 safeGasStipend;\n    }\n\n    event ExitOmitted(\n        uint160 indexed exitId\n    );\n\n    event ExitFinalized(\n        uint160 indexed exitId\n    );\n\n    event BondReturnFailed(\n        address indexed receiver,\n        uint256 amount\n    );\n\n    /**\n     * @notice Main logic function to process standard exit\n     * @dev emits ExitOmitted event if the exit is omitted\n     * @dev emits ExitFinalized event if the exit is processed and funds are withdrawn\n     * @param self The controller struct\n     * @param exitMap The storage of all standard exit data\n     * @param exitId The exitId of the standard exit\n     * @param token The ERC20 token address of the exit. Uses address(0) to represent ETH.\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.StandardExitMap storage exitMap,\n        uint160 exitId,\n        address token\n    )\n        public\n    {\n        PaymentExitDataModel.StandardExit memory exit = exitMap.exits[exitId];\n\n        if (!exit.exitable || self.framework.isOutputFinalized(exit.outputId)) {\n            emit ExitOmitted(exitId);\n            delete exitMap.exits[exitId];\n            return;\n        }\n\n        self.framework.flagOutputFinalized(exit.outputId, exitId);\n\n        // we do not want to block a queue if bond return is unsuccessful\n        bool success = SafeEthTransfer.transferReturnResult(exit.exitTarget, exit.bondSize, self.safeGasStipend);\n        if (!success) {\n            emit BondReturnFailed(exit.exitTarget, exit.bondSize);\n        }\n\n        if (token == address(0)) {\n            self.ethVault.withdraw(exit.exitTarget, exit.amount);\n        } else {\n            self.erc20Vault.withdraw(exit.exitTarget, token, exit.amount);\n        }\n\n        delete exitMap.exits[exitId];\n\n        emit ExitFinalized(exitId);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentStartInFlightExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentInFlightExitModelUtils.sol\";\nimport \"../routers/PaymentInFlightExitRouterArgs.sol\";\nimport \"../../interfaces/ISpendingCondition.sol\";\nimport \"../../interfaces/IStateTransitionVerifier.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../utils/ExitableTimestamp.sol\";\nimport \"../../utils/ExitId.sol\";\nimport \"../../utils/OutputId.sol\";\nimport \"../../utils/MoreVpFinalization.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../utils/Merkle.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../transactions/GenericTransaction.sol\";\n\nlibrary PaymentStartInFlightExit {\n    using ExitableTimestamp for ExitableTimestamp.Calculator;\n    using PosLib for PosLib.Position;\n    using PaymentInFlightExitModelUtils for PaymentExitDataModel.InFlightExit;\n    using PaymentTransactionModel for PaymentTransactionModel.Transaction;\n\n    /**\n     * @dev supportedTxType enables code reuse in different Payment Tx versions\n     */\n    struct Controller {\n        PlasmaFramework framework;\n        ExitableTimestamp.Calculator exitTimestampCalculator;\n        SpendingConditionRegistry spendingConditionRegistry;\n        IStateTransitionVerifier transitionVerifier;\n        uint256 supportedTxType;\n    }\n\n    event InFlightExitStarted(\n        address indexed initiator,\n        bytes32 indexed txHash\n    );\n\n     /**\n     * @dev data to be passed around start in-flight exit helper functions\n     * @param controller the Controller struct of this library\n     * @param exitId ID of the exit\n     * @param inFlightTxRaw In-flight transaction as bytes\n     * @param inFlightTx Decoded in-flight transaction\n     * @param inFlightTxHash Hash of in-flight transaction\n     * @param inputTxs Input transactions as bytes\n     * @param inputUtxosPos Postions of input utxos coded as integers\n     * @param inputTxsInclusionProofs Merkle proofs for input transactions\n     * @param inFlightTxWitnesses Witnesses for in-flight transactions\n     * @param outputIds Output IDs for input transactions.\n     */\n    struct StartExitData {\n        Controller controller;\n        uint160 exitId;\n        bytes inFlightTxRaw;\n        PaymentTransactionModel.Transaction inFlightTx;\n        bytes32 inFlightTxHash;\n        bytes[] inputTxs;\n        PosLib.Position[] inputUtxosPos;\n        bytes[] inputTxsInclusionProofs;\n        bytes[] inFlightTxWitnesses;\n        bytes32[] outputIds;\n    }\n\n    /**\n     * @notice Function that builds the controller struct\n     * @return Controller struct of PaymentStartInFlightExit\n     */\n    function buildController(\n        PlasmaFramework framework,\n        SpendingConditionRegistry spendingConditionRegistry,\n        IStateTransitionVerifier transitionVerifier,\n        uint256 supportedTxType\n    )\n        public\n        view\n        returns (Controller memory)\n    {\n        return Controller({\n            framework: framework,\n            exitTimestampCalculator: ExitableTimestamp.Calculator(framework.minExitPeriod()),\n            spendingConditionRegistry: spendingConditionRegistry,\n            transitionVerifier: transitionVerifier,\n            supportedTxType: supportedTxType\n        });\n    }\n\n    /**\n     * @notice Main logic function to start in-flight exit\n     * @dev emits InFlightExitStarted event on success\n     * @param self The controller struct\n     * @param inFlightExitMap The storage of all in-flight exit data\n     * @param args Arguments of start in-flight exit function from client\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap,\n        PaymentInFlightExitRouterArgs.StartExitArgs memory args\n    )\n        public\n    {\n        StartExitData memory startExitData = createStartExitData(self, args);\n        verifyStart(startExitData, inFlightExitMap);\n        startExit(startExitData, inFlightExitMap);\n        emit InFlightExitStarted(msg.sender, startExitData.inFlightTxHash);\n    }\n\n    function createStartExitData(\n        Controller memory controller,\n        PaymentInFlightExitRouterArgs.StartExitArgs memory args\n    )\n        private\n        view\n        returns (StartExitData memory)\n    {\n        StartExitData memory exitData;\n        exitData.controller = controller;\n        exitData.exitId = ExitId.getInFlightExitId(args.inFlightTx);\n        exitData.inFlightTxRaw = args.inFlightTx;\n        exitData.inFlightTx = PaymentTransactionModel.decode(args.inFlightTx);\n        exitData.inFlightTxHash = keccak256(args.inFlightTx);\n        exitData.inputTxs = args.inputTxs;\n        exitData.inputUtxosPos = decodeInputTxsPositions(args.inputUtxosPos);\n        exitData.inputTxsInclusionProofs = args.inputTxsInclusionProofs;\n        exitData.inFlightTxWitnesses = args.inFlightTxWitnesses;\n        exitData.outputIds = getOutputIds(controller, exitData.inputTxs, exitData.inputUtxosPos);\n        return exitData;\n    }\n\n    function decodeInputTxsPositions(uint256[] memory inputUtxosPos) private pure returns (PosLib.Position[] memory) {\n        require(inputUtxosPos.length <= PaymentTransactionModel.MAX_INPUT_NUM(), \"Too many transactions provided\");\n\n        PosLib.Position[] memory utxosPos = new PosLib.Position[](inputUtxosPos.length);\n        for (uint i = 0; i < inputUtxosPos.length; i++) {\n            utxosPos[i] = PosLib.decode(inputUtxosPos[i]);\n        }\n        return utxosPos;\n    }\n\n    function getOutputIds(Controller memory controller, bytes[] memory inputTxs, PosLib.Position[] memory utxoPos)\n        private\n        view\n        returns (bytes32[] memory)\n    {\n        require(inputTxs.length == utxoPos.length, \"Number of input transactions does not match number of provided input utxos positions\");\n        bytes32[] memory outputIds = new bytes32[](inputTxs.length);\n        for (uint i = 0; i < inputTxs.length; i++) {\n            bool isDepositTx = controller.framework.isDeposit(utxoPos[i].blockNum);\n            outputIds[i] = isDepositTx\n                ? OutputId.computeDepositOutputId(inputTxs[i], utxoPos[i].outputIndex, utxoPos[i].encode())\n                : OutputId.computeNormalOutputId(inputTxs[i], utxoPos[i].outputIndex);\n        }\n        return outputIds;\n    }\n\n    function verifyStart(\n        StartExitData memory exitData,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap\n    )\n        private\n        view\n    {\n        verifyExitNotStarted(exitData.exitId, inFlightExitMap);\n        verifyInFlightTxType(exitData);\n        verifyNumberOfInputsMatchesNumberOfInFlightTransactionInputs(exitData);\n        verifyNoInputSpentMoreThanOnce(exitData.inFlightTx);\n        verifyInputTransactionIsStandardFinalized(exitData);\n        verifyInputsSpent(exitData);\n        verifyStateTransition(exitData);\n    }\n\n    function verifyExitNotStarted(\n        uint160 exitId,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap\n    )\n        private\n        view\n    {\n        PaymentExitDataModel.InFlightExit storage exit = inFlightExitMap.exits[exitId];\n        require(exit.exitStartTimestamp == 0, \"There is an active in-flight exit from this transaction\");\n    }\n\n    function verifyInFlightTxType(StartExitData memory exitData) private pure {\n        require(exitData.inFlightTx.txType == exitData.controller.supportedTxType, \"Unsupported transaction type of the exit game\");\n    }\n\n    function verifyNumberOfInputsMatchesNumberOfInFlightTransactionInputs(StartExitData memory exitData) private pure {\n        require(exitData.inputTxs.length != 0, \"In-flight transaction must have inputs\");\n        require(\n            exitData.inputTxs.length == exitData.inFlightTx.inputs.length,\n            \"Number of input transactions does not match number of in-flight transaction inputs\"\n        );\n        require(\n            exitData.inputTxsInclusionProofs.length == exitData.inFlightTx.inputs.length,\n            \"Number of input transactions inclusion proofs does not match the number of in-flight transaction inputs\"\n        );\n        require(\n            exitData.inFlightTxWitnesses.length == exitData.inFlightTx.inputs.length,\n            \"Number of input transaction witnesses does not match the number of in-flight transaction inputs\"\n        );\n    }\n\n    function verifyNoInputSpentMoreThanOnce(PaymentTransactionModel.Transaction memory inFlightTx) private pure {\n        if (inFlightTx.inputs.length > 1) {\n            for (uint i = 0; i < inFlightTx.inputs.length; i++) {\n                for (uint j = i + 1; j < inFlightTx.inputs.length; j++) {\n                    require(inFlightTx.inputs[i] != inFlightTx.inputs[j], \"In-flight transaction must have unique inputs\");\n                }\n            }\n        }\n    }\n\n    function verifyInputTransactionIsStandardFinalized(StartExitData memory exitData) private view {\n        for (uint i = 0; i < exitData.inputTxs.length; i++) {\n            bool isStandardFinalized = MoreVpFinalization.isStandardFinalized(\n                exitData.controller.framework,\n                exitData.inputTxs[i],\n                exitData.inputUtxosPos[i].toStrictTxPos(),\n                exitData.inputTxsInclusionProofs[i]\n            );\n            require(isStandardFinalized, \"Input transaction is not standard finalized\");\n        }\n    }\n\n    function verifyInputsSpent(StartExitData memory exitData) private view {\n        for (uint16 i = 0; i < exitData.inputTxs.length; i++) {\n            uint16 outputIndex = exitData.inputUtxosPos[i].outputIndex;\n            GenericTransaction.Output memory output = GenericTransaction.getOutput(\n                GenericTransaction.decode(exitData.inputTxs[i]),\n                outputIndex\n            );\n\n            ISpendingCondition condition = exitData.controller.spendingConditionRegistry.spendingConditions(\n                output.outputType, exitData.controller.supportedTxType\n            );\n\n            require(address(condition) != address(0), \"Spending condition contract not found\");\n\n            bool isSpentByInFlightTx = condition.verify(\n                exitData.inputTxs[i],\n                exitData.inputUtxosPos[i].encode(),\n                exitData.inFlightTxRaw,\n                i,\n                exitData.inFlightTxWitnesses[i]\n            );\n            require(isSpentByInFlightTx, \"Spending condition failed\");\n        }\n    }\n\n    function verifyStateTransition(StartExitData memory exitData) private view {\n        uint16[] memory outputIndexForInputTxs = new uint16[](exitData.inputTxs.length);\n        for (uint i = 0; i < exitData.inFlightTx.inputs.length; i++) {\n            outputIndexForInputTxs[i] = exitData.inputUtxosPos[i].outputIndex;\n        }\n\n        require(\n            exitData.controller.transitionVerifier.isCorrectStateTransition(exitData.inFlightTxRaw, exitData.inputTxs, outputIndexForInputTxs),\n            \"Invalid state transition\"\n        );\n    }\n\n    function startExit(\n        StartExitData memory startExitData,\n        PaymentExitDataModel.InFlightExitMap storage inFlightExitMap\n    )\n        private\n    {\n        PaymentExitDataModel.InFlightExit storage ife = inFlightExitMap.exits[startExitData.exitId];\n        ife.isCanonical = true;\n        ife.bondOwner = msg.sender;\n        ife.bondSize = msg.value;\n        ife.position = getYoungestInputUtxoPosition(startExitData.inputUtxosPos);\n        ife.exitStartTimestamp = uint64(block.timestamp);\n        setInFlightExitInputs(ife, startExitData);\n        setInFlightExitOutputs(ife, startExitData);\n    }\n\n    function getYoungestInputUtxoPosition(PosLib.Position[] memory inputUtxosPos) private pure returns (uint256) {\n        uint256 youngest = inputUtxosPos[0].encode();\n        for (uint i = 1; i < inputUtxosPos.length; i++) {\n            uint256 encodedUtxoPos = inputUtxosPos[i].encode();\n            if (encodedUtxoPos > youngest) {\n                youngest = encodedUtxoPos;\n            }\n        }\n        return youngest;\n    }\n\n    function setInFlightExitInputs(\n        PaymentExitDataModel.InFlightExit storage ife,\n        StartExitData memory exitData\n    )\n        private\n    {\n        for (uint i = 0; i < exitData.inputTxs.length; i++) {\n            uint16 outputIndex = exitData.inputUtxosPos[i].outputIndex;\n            FungibleTokenOutputModel.Output memory output = FungibleTokenOutputModel.getOutput(\n                GenericTransaction.decode(exitData.inputTxs[i]),\n                outputIndex\n            );\n\n            ife.inputs[i].outputId = exitData.outputIds[i];\n            ife.inputs[i].exitTarget = address(uint160(output.outputGuard));\n            ife.inputs[i].token = output.token;\n            ife.inputs[i].amount = output.amount;\n        }\n    }\n\n    function setInFlightExitOutputs(\n        PaymentExitDataModel.InFlightExit storage ife,\n        StartExitData memory exitData\n    )\n        private\n    {\n        for (uint16 i = 0; i < exitData.inFlightTx.outputs.length; i++) {\n            // deposit transaction can't be in-flight exited\n            bytes32 outputId = OutputId.computeNormalOutputId(exitData.inFlightTxRaw, i);\n            FungibleTokenOutputModel.Output memory output = exitData.inFlightTx.getOutput(i);\n\n            ife.outputs[i].outputId = outputId;\n            ife.outputs[i].exitTarget = address(uint160(output.outputGuard));\n            ife.outputs[i].token = output.token;\n            ife.outputs[i].amount = output.amount;\n        }\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/controllers/PaymentStartStandardExit.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentExitDataModel.sol\";\nimport \"../routers/PaymentStandardExitRouterArgs.sol\";\nimport \"../../utils/ExitableTimestamp.sol\";\nimport \"../../utils/ExitId.sol\";\nimport \"../../utils/OutputId.sol\";\nimport \"../../utils/MoreVpFinalization.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../utils/ExitableTimestamp.sol\";\n\nlibrary PaymentStartStandardExit {\n    using ExitableTimestamp for ExitableTimestamp.Calculator;\n    using PosLib for PosLib.Position;\n    using PaymentTransactionModel for PaymentTransactionModel.Transaction;\n\n    struct Controller {\n        IExitProcessor exitProcessor;\n        PlasmaFramework framework;\n        ExitableTimestamp.Calculator exitableTimestampCalculator;\n        uint256 ethVaultId;\n        uint256 erc20VaultId;\n        uint256 supportedTxType;\n    }\n\n    /**\n     * @dev Data to be passed around startStandardExit helper functions\n     */\n    struct StartStandardExitData {\n        Controller controller;\n        PaymentStandardExitRouterArgs.StartStandardExitArgs args;\n        PosLib.Position utxoPos;\n        PaymentTransactionModel.Transaction outputTx;\n        FungibleTokenOutputModel.Output output;\n        uint160 exitId;\n        bool isTxDeposit;\n        uint256 txBlockTimeStamp;\n        bytes32 outputId;\n    }\n\n    event ExitStarted(\n        address indexed owner,\n        uint160 exitId\n    );\n\n    /**\n     * @notice Function that builds the controller struct\n     * @return Controller struct of PaymentStartStandardExit\n     */\n    function buildController(\n        IExitProcessor exitProcessor,\n        PlasmaFramework framework,\n        uint256 ethVaultId,\n        uint256 erc20VaultId,\n        uint256 supportedTxType\n    )\n        public\n        view\n        returns (Controller memory)\n    {\n        return Controller({\n            exitProcessor: exitProcessor,\n            framework: framework,\n            exitableTimestampCalculator: ExitableTimestamp.Calculator(framework.minExitPeriod()),\n            ethVaultId: ethVaultId,\n            erc20VaultId: erc20VaultId,\n            supportedTxType: supportedTxType\n        });\n    }\n\n    /**\n     * @notice Main logic function to start standard exit\n     * @dev emits ExitStarted event on success\n     * @param self The controller struct\n     * @param exitMap The storage of all standard exit data\n     * @param args Arguments of start standard exit function from client\n     */\n    function run(\n        Controller memory self,\n        PaymentExitDataModel.StandardExitMap storage exitMap,\n        PaymentStandardExitRouterArgs.StartStandardExitArgs memory args\n    )\n        public\n    {\n        StartStandardExitData memory data = setupStartStandardExitData(self, args);\n        verifyStartStandardExitData(self, data, exitMap);\n        saveStandardExitData(data, exitMap);\n        enqueueStandardExit(data);\n\n        emit ExitStarted(msg.sender, data.exitId);\n    }\n\n    function setupStartStandardExitData(\n        Controller memory controller,\n        PaymentStandardExitRouterArgs.StartStandardExitArgs memory args\n    )\n        private\n        view\n        returns (StartStandardExitData memory)\n    {\n        PosLib.Position memory utxoPos = PosLib.decode(args.utxoPos);\n        PaymentTransactionModel.Transaction memory outputTx = PaymentTransactionModel.decode(args.rlpOutputTx);\n        FungibleTokenOutputModel.Output memory output = outputTx.getOutput(utxoPos.outputIndex);\n        bool isTxDeposit = controller.framework.isDeposit(utxoPos.blockNum);\n        uint160 exitId = ExitId.getStandardExitId(isTxDeposit, args.rlpOutputTx, utxoPos);\n        (, uint256 blockTimestamp) = controller.framework.blocks(utxoPos.blockNum);\n\n        bytes32 outputId = isTxDeposit\n            ? OutputId.computeDepositOutputId(args.rlpOutputTx, utxoPos.outputIndex, utxoPos.encode())\n            : OutputId.computeNormalOutputId(args.rlpOutputTx, utxoPos.outputIndex);\n\n        return StartStandardExitData({\n            controller: controller,\n            args: args,\n            utxoPos: utxoPos,\n            outputTx: outputTx,\n            output: output,\n            exitId: exitId,\n            isTxDeposit: isTxDeposit,\n            txBlockTimeStamp: blockTimestamp,\n            outputId: outputId\n        });\n    }\n\n    function verifyStartStandardExitData(\n        Controller memory self,\n        StartStandardExitData memory data,\n        PaymentExitDataModel.StandardExitMap storage exitMap\n    )\n        private\n        view\n    {\n        require(data.outputTx.txType == data.controller.supportedTxType, \"Unsupported transaction type of the exit game\");\n        require(data.txBlockTimeStamp != 0, \"There is no block for the position\");\n\n        require(PaymentTransactionModel.getOutputOwner(data.output) == msg.sender, \"Only output owner can start an exit\");\n\n        require(isStandardFinalized(data), \"The transaction must be standard finalized\");\n        PaymentExitDataModel.StandardExit memory exit = exitMap.exits[data.exitId];\n        require(exit.amount == 0, \"Exit has already started\");\n\n        require(self.framework.isOutputFinalized(data.outputId) == false, \"Output is already spent\");\n    }\n\n    function isStandardFinalized(StartStandardExitData memory data)\n        private\n        view\n        returns (bool)\n    {\n        return MoreVpFinalization.isStandardFinalized(\n            data.controller.framework,\n            data.args.rlpOutputTx,\n            data.utxoPos.toStrictTxPos(),\n            data.args.outputTxInclusionProof\n        );\n    }\n\n    function saveStandardExitData(\n        StartStandardExitData memory data,\n        PaymentExitDataModel.StandardExitMap storage exitMap\n    )\n        private\n    {\n        exitMap.exits[data.exitId] = PaymentExitDataModel.StandardExit({\n            exitable: true,\n            utxoPos: data.utxoPos.encode(),\n            outputId: data.outputId,\n            exitTarget: msg.sender,\n            amount: data.output.amount,\n            bondSize: msg.value\n        });\n    }\n\n    function enqueueStandardExit(StartStandardExitData memory data) private {\n\n        uint64 exitableAt;\n        ExitableTimestamp.Calculator memory exitableTimestampCalculator = data.controller.exitableTimestampCalculator;\n\n        if (data.isTxDeposit){\n            exitableAt = exitableTimestampCalculator.calculateDepositTxOutputExitableTimestamp(block.timestamp);\n        } else {\n            exitableAt = exitableTimestampCalculator.calculateTxExitableTimestamp(block.timestamp, data.txBlockTimeStamp);\n        }\n\n        uint256 vaultId;\n        if (data.output.token == address(0)) {\n            vaultId = data.controller.ethVaultId;\n        } else {\n            vaultId = data.controller.erc20VaultId;\n        }\n\n        data.controller.framework.enqueue(\n            vaultId, data.output.token, exitableAt, data.utxoPos.toStrictTxPos(),\n            data.exitId, data.controller.exitProcessor\n        );\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/routers/PaymentInFlightExitRouter.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./PaymentInFlightExitRouterArgs.sol\";\nimport \"../PaymentExitDataModel.sol\";\nimport \"../PaymentExitGameArgs.sol\";\nimport \"../controllers/PaymentStartInFlightExit.sol\";\nimport \"../controllers/PaymentPiggybackInFlightExit.sol\";\nimport \"../controllers/PaymentChallengeIFENotCanonical.sol\";\nimport \"../controllers/PaymentChallengeIFEInputSpent.sol\";\nimport \"../controllers/PaymentChallengeIFEOutputSpent.sol\";\nimport \"../controllers/PaymentDeleteInFlightExit.sol\";\nimport \"../controllers/PaymentProcessInFlightExit.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../interfaces/IStateTransitionVerifier.sol\";\nimport \"../../utils/BondSize.sol\";\nimport \"../../../utils/FailFastReentrancyGuard.sol\";\nimport \"../../../utils/OnlyFromAddress.sol\";\nimport \"../../../utils/OnlyWithValue.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../framework/interfaces/IExitProcessor.sol\";\n\n\ncontract PaymentInFlightExitRouter is\n    IExitProcessor,\n    OnlyFromAddress,\n    OnlyWithValue,\n    FailFastReentrancyGuard\n{\n    using PaymentStartInFlightExit for PaymentStartInFlightExit.Controller;\n    using PaymentPiggybackInFlightExit for PaymentPiggybackInFlightExit.Controller;\n    using PaymentChallengeIFENotCanonical for PaymentChallengeIFENotCanonical.Controller;\n    using PaymentChallengeIFEInputSpent for PaymentChallengeIFEInputSpent.Controller;\n    using PaymentChallengeIFEOutputSpent for PaymentChallengeIFEOutputSpent.Controller;\n    using PaymentDeleteInFlightExit for PaymentDeleteInFlightExit.Controller;\n    using PaymentProcessInFlightExit for PaymentProcessInFlightExit.Controller;\n    using BondSize for BondSize.Params;\n\n    // Initial IFE bond size = 185000 (gas cost of challenge) * 20 gwei (current fast gas price) * 10 (safety margin)\n    uint128 public constant INITIAL_IFE_BOND_SIZE = 37000000000000000 wei;\n\n    // Initial piggyback bond size = 140000 (gas cost of challenge) * 20 gwei (current fast gas price) * 10 (safety margin)\n    uint128 public constant INITIAL_PB_BOND_SIZE = 28000000000000000 wei;\n\n    // Each bond size upgrade can increase to a maximum of 200% or decrease to 50% of the current bond\n    uint16 public constant BOND_LOWER_BOUND_DIVISOR = 2;\n    uint16 public constant BOND_UPPER_BOUND_MULTIPLIER = 2;\n\n    PaymentExitDataModel.InFlightExitMap internal inFlightExitMap;\n    PaymentStartInFlightExit.Controller internal startInFlightExitController;\n    PaymentPiggybackInFlightExit.Controller internal piggybackInFlightExitController;\n    PaymentChallengeIFENotCanonical.Controller internal challengeCanonicityController;\n    PaymentChallengeIFEInputSpent.Controller internal challengeInputSpentController;\n    PaymentChallengeIFEOutputSpent.Controller internal challengeOutputSpentController;\n    PaymentDeleteInFlightExit.Controller internal deleteNonPiggybackIFEController;\n    PaymentProcessInFlightExit.Controller internal processInflightExitController;\n    BondSize.Params internal startIFEBond;\n    BondSize.Params internal piggybackBond;\n\n    PlasmaFramework private framework;\n\n    event IFEBondUpdated(uint128 bondSize);\n    event PiggybackBondUpdated(uint128 bondSize);\n\n    event InFlightExitStarted(\n        address indexed initiator,\n        bytes32 indexed txHash\n    );\n\n    event InFlightExitInputPiggybacked(\n        address indexed exitTarget,\n        bytes32 indexed txHash,\n        uint16 inputIndex\n    );\n\n    event InFlightExitOmitted(\n        uint160 indexed exitId,\n        address token\n    );\n\n    event InFlightBondReturnFailed(\n        address indexed receiver,\n        uint256 amount\n    );\n\n    event InFlightExitOutputWithdrawn(\n        uint160 indexed exitId,\n        uint16 outputIndex\n    );\n\n    event InFlightExitInputWithdrawn(\n        uint160 indexed exitId,\n        uint16 inputIndex\n    );\n\n    event InFlightExitOutputPiggybacked(\n        address indexed exitTarget,\n        bytes32 indexed txHash,\n        uint16 outputIndex\n    );\n\n    event InFlightExitChallenged(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint256 challengeTxPosition\n    );\n\n    event InFlightExitChallengeResponded(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint256 challengeTxPosition\n    );\n\n    event InFlightExitInputBlocked(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint16 inputIndex\n    );\n\n    event InFlightExitOutputBlocked(\n        address indexed challenger,\n        bytes32 indexed txHash,\n        uint16 outputIndex\n    );\n\n    event InFlightExitDeleted(\n        uint160 indexed exitId\n    );\n\n    constructor(PaymentExitGameArgs.Args memory args)\n        public\n    {\n        framework = args.framework;\n\n        EthVault ethVault = EthVault(args.framework.vaults(args.ethVaultId));\n        require(address(ethVault) != address(0), \"Invalid ETH vault\");\n\n        Erc20Vault erc20Vault = Erc20Vault(args.framework.vaults(args.erc20VaultId));\n        require(address(erc20Vault) != address(0), \"Invalid ERC20 vault\");\n\n        startInFlightExitController = PaymentStartInFlightExit.buildController(\n            args.framework,\n            args.spendingConditionRegistry,\n            args.stateTransitionVerifier,\n            args.supportTxType\n        );\n\n        piggybackInFlightExitController = PaymentPiggybackInFlightExit.buildController(\n            args.framework,\n            this,\n            args.ethVaultId,\n            args.erc20VaultId\n        );\n\n        challengeCanonicityController = PaymentChallengeIFENotCanonical.buildController(\n            args.framework,\n            args.spendingConditionRegistry,\n            args.supportTxType\n        );\n\n        challengeInputSpentController = PaymentChallengeIFEInputSpent.buildController(\n            args.framework,\n            args.spendingConditionRegistry,\n            args.safeGasStipend\n        );\n\n        challengeOutputSpentController = PaymentChallengeIFEOutputSpent.Controller(\n            args.framework,\n            args.spendingConditionRegistry,\n            args.safeGasStipend\n        );\n\n        deleteNonPiggybackIFEController = PaymentDeleteInFlightExit.Controller({\n            minExitPeriod: args.framework.minExitPeriod(),\n            safeGasStipend: args.safeGasStipend\n        });\n\n        processInflightExitController = PaymentProcessInFlightExit.Controller({\n            framework: args.framework,\n            ethVault: ethVault,\n            erc20Vault: erc20Vault,\n            safeGasStipend: args.safeGasStipend\n        });\n        startIFEBond = BondSize.buildParams(INITIAL_IFE_BOND_SIZE, BOND_LOWER_BOUND_DIVISOR, BOND_UPPER_BOUND_MULTIPLIER);\n        piggybackBond = BondSize.buildParams(INITIAL_PB_BOND_SIZE, BOND_LOWER_BOUND_DIVISOR, BOND_UPPER_BOUND_MULTIPLIER);\n    }\n\n    /**\n     * @notice Getter functions to retrieve in-flight exit data of the PaymentExitGame\n     * @param exitIds The exit IDs of the in-flight exits\n     */\n    function inFlightExits(uint160[] calldata exitIds) external view returns (PaymentExitDataModel.InFlightExit[] memory) {\n        PaymentExitDataModel.InFlightExit[] memory exits = new PaymentExitDataModel.InFlightExit[](exitIds.length);\n        for (uint i = 0; i < exitIds.length; i++) {\n            uint160 exitId = exitIds[i];\n            exits[i] = inFlightExitMap.exits[exitId];\n        }\n        return exits;\n    }\n\n    /**\n     * @notice Starts withdrawal from a transaction that may be in-flight\n     * @param args Input argument data to challenge (see also struct 'StartExitArgs')\n     */\n    function startInFlightExit(PaymentInFlightExitRouterArgs.StartExitArgs memory args)\n        public\n        payable\n        nonReentrant(framework)\n        onlyWithValue(startIFEBondSize())\n    {\n        startInFlightExitController.run(inFlightExitMap, args);\n    }\n\n    /**\n     * @notice Piggyback on an input of an in-flight exiting tx. Processed only if the in-flight exit is non-canonical.\n     * @param args Input argument data to piggyback (see also struct 'PiggybackInFlightExitOnInputArgs')\n     */\n    function piggybackInFlightExitOnInput(\n        PaymentInFlightExitRouterArgs.PiggybackInFlightExitOnInputArgs memory args\n    )\n        public\n        payable\n        nonReentrant(framework)\n        onlyWithValue(piggybackBondSize())\n    {\n        piggybackInFlightExitController.piggybackInput(inFlightExitMap, args);\n    }\n\n    /**\n     * @notice Piggyback on an output of an in-flight exiting tx. Processed only if the in-flight exit is canonical.\n     * @param args Input argument data to piggyback (see also struct 'PiggybackInFlightExitOnOutputArgs')\n     */\n    function piggybackInFlightExitOnOutput(\n        PaymentInFlightExitRouterArgs.PiggybackInFlightExitOnOutputArgs memory args\n    )\n        public\n        payable\n        nonReentrant(framework)\n        onlyWithValue(piggybackBondSize())\n    {\n        piggybackInFlightExitController.piggybackOutput(inFlightExitMap, args);\n    }\n\n    /**\n     * @notice Challenges an in-flight exit to be non-canonical\n     * @param args Input argument data to challenge (see also struct 'ChallengeCanonicityArgs')\n     */\n    function challengeInFlightExitNotCanonical(PaymentInFlightExitRouterArgs.ChallengeCanonicityArgs memory args)\n        public\n        nonReentrant(framework)\n    {\n        challengeCanonicityController.challenge(inFlightExitMap, args);\n    }\n\n    /**\n     * @notice Respond to a non-canonical challenge by providing its position and by proving its correctness\n     * @param inFlightTx The RLP-encoded in-flight transaction\n     * @param inFlightTxPos The position of the in-flight exiting transaction. The output index within the position is unused and should be set to 0\n     * @param inFlightTxInclusionProof Proof that the in-flight exiting transaction is included in a Plasma block\n     */\n    function respondToNonCanonicalChallenge(\n        bytes memory inFlightTx,\n        uint256 inFlightTxPos,\n        bytes memory inFlightTxInclusionProof\n    )\n        public\n        nonReentrant(framework)\n    {\n        challengeCanonicityController.respond(inFlightExitMap, inFlightTx, inFlightTxPos, inFlightTxInclusionProof);\n    }\n\n    /**\n     * @notice Challenges an exit from in-flight transaction input\n     * @param args Argument data to challenge (see also struct 'ChallengeInputSpentArgs')\n     */\n    function challengeInFlightExitInputSpent(PaymentInFlightExitRouterArgs.ChallengeInputSpentArgs memory args)\n        public\n        nonReentrant(framework)\n    {\n        challengeInputSpentController.run(inFlightExitMap, args);\n    }\n\n     /**\n     * @notice Challenges an exit from in-flight transaction output\n     * @param args Argument data to challenge (see also struct 'ChallengeOutputSpent')\n     */\n    function challengeInFlightExitOutputSpent(PaymentInFlightExitRouterArgs.ChallengeOutputSpent memory args)\n        public\n        nonReentrant(framework)\n    {\n        challengeOutputSpentController.run(inFlightExitMap, args);\n    }\n\n    /**\n     * @notice Deletes in-flight exit if the first phase has passed and not being piggybacked\n     * @dev Since IFE is enqueued during piggyback, a non-piggybacked IFE means that it will never be processed.\n     *      This means that the IFE bond will never be returned.\n     *      see: https://github.com/omisego/plasma-contracts/issues/440\n     * @param exitId The exitId of the in-flight exit\n     */\n    function deleteNonPiggybackedInFlightExit(uint160 exitId) public nonReentrant(framework) {\n        deleteNonPiggybackIFEController.run(inFlightExitMap, exitId);\n    }\n\n    /**\n     * @notice Process in-flight exit\n     * @dev This function is designed to be called in the main processExit function, thus, using internal\n     * @param exitId The in-flight exit ID\n     * @param token The token (in erc20 address or address(0) for ETH) of the exiting output\n     */\n    function processInFlightExit(uint160 exitId, address token) internal {\n        processInflightExitController.run(inFlightExitMap, exitId, token);\n    }\n\n    /**\n     * @notice Retrieves the in-flight exit bond size\n     */\n    function startIFEBondSize() public view returns (uint128) {\n        return startIFEBond.bondSize();\n    }\n\n    /**\n     * @notice Updates the in-flight exit bond size, taking two days to become effective.\n     * @param newBondSize The new bond size\n     */\n    function updateStartIFEBondSize(uint128 newBondSize) public onlyFrom(framework.getMaintainer()) {\n        startIFEBond.updateBondSize(newBondSize);\n        emit IFEBondUpdated(newBondSize);\n    }\n\n    /**\n     * @notice Retrieves the piggyback bond size\n     */\n    function piggybackBondSize() public view returns (uint128) {\n        return piggybackBond.bondSize();\n    }\n\n    /**\n     * @notice Updates the piggyback bond size, taking two days to become effective\n     * @param newBondSize The new bond size\n     */\n    function updatePiggybackBondSize(uint128 newBondSize) public onlyFrom(framework.getMaintainer()) {\n        piggybackBond.updateBondSize(newBondSize);\n        emit PiggybackBondUpdated(newBondSize);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/routers/PaymentInFlightExitRouterArgs.sol": {
      "content": "pragma solidity 0.5.11;\n\nlibrary PaymentInFlightExitRouterArgs {\n    /**\n    * @notice Wraps arguments for startInFlightExit.\n    * @param inFlightTx RLP encoded in-flight transaction.\n    * @param inputTxs Transactions that created the inputs to the in-flight transaction. In the same order as in-flight transaction inputs.\n    * @param inputUtxosPos Utxos that represent in-flight transaction inputs. In the same order as input transactions.\n    * @param inputTxsInclusionProofs Merkle proofs that show the input-creating transactions are valid. In the same order as input transactions.\n    * @param inFlightTxWitnesses Witnesses for in-flight transaction. In the same order as input transactions.\n    */\n    struct StartExitArgs {\n        bytes inFlightTx;\n        bytes[] inputTxs;\n        uint256[] inputUtxosPos;\n        bytes[] inputTxsInclusionProofs;\n        bytes[] inFlightTxWitnesses;\n    }\n\n    /**\n    * @notice Wraps arguments for piggybacking on in-flight transaction input exit\n    * @param inFlightTx RLP-encoded in-flight transaction\n    * @param inputIndex Index of the input to piggyback on\n    */\n    struct PiggybackInFlightExitOnInputArgs {\n        bytes inFlightTx;\n        uint16 inputIndex;\n    }\n\n    /**\n    * @notice Wraps arguments for piggybacking on in-flight transaction output exit\n    * @param inFlightTx RLP-encoded in-flight transaction\n    * @param outputIndex Index of the output to piggyback on\n    */\n    struct PiggybackInFlightExitOnOutputArgs {\n        bytes inFlightTx;\n        uint16 outputIndex;\n    }\n\n    /**\n     * @notice Wraps arguments for challenging non-canonical in-flight exits\n     * @param inputTx Transaction that created the input shared by the in-flight transaction and its competitor\n     * @param inputUtxoPos Position of input utxo\n     * @param inFlightTx RLP-encoded in-flight transaction\n     * @param inFlightTxInputIndex Index of the shared input in the in-flight transaction\n     * @param competingTx RLP-encoded competing transaction\n     * @param competingTxInputIndex Index of shared input in competing transaction\n     * @param competingTxPos (Optional) Position of competing transaction in the chain, if included. OutputIndex of the position should be 0.\n     * @param competingTxInclusionProof (Optional) Merkle proofs showing that the competing transaction was contained in chain\n     * @param competingTxWitness Witness for competing transaction\n     */\n    struct ChallengeCanonicityArgs {\n        bytes inputTx;\n        uint256 inputUtxoPos;\n        bytes inFlightTx;\n        uint16 inFlightTxInputIndex;\n        bytes competingTx;\n        uint16 competingTxInputIndex;\n        uint256 competingTxPos;\n        bytes competingTxInclusionProof;\n        bytes competingTxWitness;\n    }\n\n    /**\n     * @notice Wraps arguments for challenging in-flight exit input spent\n     * @param inFlightTx RLP-encoded in-flight transaction\n     * @param inFlightTxInputIndex Index of spent input\n     * @param challengingTx RLP-encoded challenging transaction\n     * @param challengingTxInputIndex Index of spent input in a challenging transaction\n     * @param challengingTxWitness Witness for challenging transactions\n     * @param inputTx RLP-encoded input transaction\n     * @param inputUtxoPos UTXO position of input transaction's output\n     * @param senderData A keccak256 hash of the sender's address\n     */\n    struct ChallengeInputSpentArgs {\n        bytes inFlightTx;\n        uint16 inFlightTxInputIndex;\n        bytes challengingTx;\n        uint16 challengingTxInputIndex;\n        bytes challengingTxWitness;\n        bytes inputTx;\n        uint256 inputUtxoPos;\n        bytes32 senderData;\n    }\n\n     /**\n     * @notice Wraps arguments for challenging in-flight transaction output exit\n     * @param inFlightTx RLP-encoded in-flight transaction\n     * @param inFlightTxInclusionProof Proof that an in-flight transaction is included in Plasma\n     * @param outputUtxoPos UTXO position of challenged output\n     * @param challengingTx RLP-encoded challenging transaction\n     * @param challengingTxInputIndex Input index of challenged output in a challenging transaction\n     * @param challengingTxWitness Witness for challenging transaction\n     * @param senderData A keccak256 hash of the sender's address\n     */\n    struct ChallengeOutputSpent {\n        bytes inFlightTx;\n        bytes inFlightTxInclusionProof;\n        uint256 outputUtxoPos;\n        bytes challengingTx;\n        uint16 challengingTxInputIndex;\n        bytes challengingTxWitness;\n        bytes32 senderData;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/routers/PaymentStandardExitRouter.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./PaymentStandardExitRouterArgs.sol\";\nimport \"../PaymentExitGameArgs.sol\";\nimport \"../PaymentExitDataModel.sol\";\nimport \"../controllers/PaymentStartStandardExit.sol\";\nimport \"../controllers/PaymentProcessStandardExit.sol\";\nimport \"../controllers/PaymentChallengeStandardExit.sol\";\nimport \"../../registries/SpendingConditionRegistry.sol\";\nimport \"../../utils/BondSize.sol\";\nimport \"../../../vaults/EthVault.sol\";\nimport \"../../../vaults/Erc20Vault.sol\";\nimport \"../../../framework/PlasmaFramework.sol\";\nimport \"../../../framework/interfaces/IExitProcessor.sol\";\nimport \"../../../utils/OnlyWithValue.sol\";\nimport \"../../../utils/OnlyFromAddress.sol\";\nimport \"../../../utils/FailFastReentrancyGuard.sol\";\n\ncontract PaymentStandardExitRouter is\n    IExitProcessor,\n    OnlyFromAddress,\n    OnlyWithValue,\n    FailFastReentrancyGuard\n{\n    using PaymentStartStandardExit for PaymentStartStandardExit.Controller;\n    using PaymentChallengeStandardExit for PaymentChallengeStandardExit.Controller;\n    using PaymentProcessStandardExit for PaymentProcessStandardExit.Controller;\n    using BondSize for BondSize.Params;\n\n    // Initial bond size = 70000 (gas cost of challenge) * 20 gwei (current fast gas price) * 10 (safety margin)\n    uint128 public constant INITIAL_BOND_SIZE = 14000000000000000 wei;\n\n    // Each bond size upgrade can either at most increase to 200% or decrease to 50% of current bond\n    uint16 public constant BOND_LOWER_BOUND_DIVISOR = 2;\n    uint16 public constant BOND_UPPER_BOUND_MULTIPLIER = 2;\n\n    PaymentExitDataModel.StandardExitMap internal standardExitMap;\n    PaymentStartStandardExit.Controller internal startStandardExitController;\n    PaymentProcessStandardExit.Controller internal processStandardExitController;\n    PaymentChallengeStandardExit.Controller internal challengeStandardExitController;\n    BondSize.Params internal startStandardExitBond;\n\n    PlasmaFramework private framework;\n\n    event StandardExitBondUpdated(uint128 bondSize);\n\n    event ExitStarted(\n        address indexed owner,\n        uint160 exitId\n    );\n\n    event ExitChallenged(\n        uint256 indexed utxoPos\n    );\n\n    event ExitOmitted(\n        uint160 indexed exitId\n    );\n\n    event ExitFinalized(\n        uint160 indexed exitId\n    );\n\n    event BondReturnFailed(\n        address indexed receiver,\n        uint256 amount\n    );\n\n    constructor(PaymentExitGameArgs.Args memory args)\n        public\n    {\n        framework = args.framework;\n\n        EthVault ethVault = EthVault(args.framework.vaults(args.ethVaultId));\n        require(address(ethVault) != address(0), \"Invalid ETH vault\");\n\n        Erc20Vault erc20Vault = Erc20Vault(args.framework.vaults(args.erc20VaultId));\n        require(address(erc20Vault) != address(0), \"Invalid ERC20 vault\");\n\n        startStandardExitController = PaymentStartStandardExit.buildController(\n            this,\n            args.framework,\n            args.ethVaultId,\n            args.erc20VaultId,\n            args.supportTxType\n        );\n\n        challengeStandardExitController = PaymentChallengeStandardExit.buildController(\n            args.framework,\n            args.spendingConditionRegistry,\n            args.safeGasStipend\n        );\n\n        processStandardExitController = PaymentProcessStandardExit.Controller(\n            args.framework, ethVault, erc20Vault, args.safeGasStipend\n        );\n\n        startStandardExitBond = BondSize.buildParams(INITIAL_BOND_SIZE, BOND_LOWER_BOUND_DIVISOR, BOND_UPPER_BOUND_MULTIPLIER);\n    }\n\n    /**\n     * @notice Getter retrieves standard exit data of the PaymentExitGame\n     * @param exitIds Exit IDs of the standard exits\n     */\n    function standardExits(uint160[] calldata exitIds) external view returns (PaymentExitDataModel.StandardExit[] memory) {\n        PaymentExitDataModel.StandardExit[] memory exits = new PaymentExitDataModel.StandardExit[](exitIds.length);\n        for (uint i = 0; i < exitIds.length; i++){\n            uint160 exitId = exitIds[i];\n            exits[i] = standardExitMap.exits[exitId];\n        }\n        return exits;\n    }\n\n    /**\n     * @notice Retrieves the standard exit bond size\n     */\n    function startStandardExitBondSize() public view returns (uint128) {\n        return startStandardExitBond.bondSize();\n    }\n\n    /**\n     * @notice Updates the standard exit bond size, taking two days to become effective\n     * @param newBondSize The new bond size\n     */\n    function updateStartStandardExitBondSize(uint128 newBondSize) public onlyFrom(framework.getMaintainer()) {\n        startStandardExitBond.updateBondSize(newBondSize);\n        emit StandardExitBondUpdated(newBondSize);\n    }\n\n    /**\n     * @notice Starts a standard exit of a given output, using output-age priority\n     */\n    function startStandardExit(\n        PaymentStandardExitRouterArgs.StartStandardExitArgs memory args\n    )\n        public\n        payable\n        nonReentrant(framework)\n        onlyWithValue(startStandardExitBondSize())\n    {\n        startStandardExitController.run(standardExitMap, args);\n    }\n\n    /**\n     * @notice Challenge a standard exit by showing the exiting output was spent\n     */\n    function challengeStandardExit(PaymentStandardExitRouterArgs.ChallengeStandardExitArgs memory args)\n        public\n        nonReentrant(framework)\n    {\n        challengeStandardExitController.run(standardExitMap, args);\n    }\n\n    /**\n     * @notice Process standard exit\n     * @dev This function is designed to be called in the main processExit function, using internal\n     * @param exitId The standard exit ID\n     * @param token The token (in erc20 address or address(0) for ETH) of the exiting output\n     */\n    function processStandardExit(uint160 exitId, address token) internal {\n        processStandardExitController.run(standardExitMap, exitId, token);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/routers/PaymentStandardExitRouterArgs.sol": {
      "content": "pragma solidity 0.5.11;\n\nlibrary PaymentStandardExitRouterArgs {\n    /**\n     * @notice Wraps arguments for startStandardExit\n     * @param utxoPos Position of the exiting output\n     * @param rlpOutputTx The RLP-encoded transaction that creates the exiting output\n     * @param outputTxInclusionProof A Merkle proof showing that the transaction was included\n    */\n    struct StartStandardExitArgs {\n        uint256 utxoPos;\n        bytes rlpOutputTx;\n        bytes outputTxInclusionProof;\n    }\n\n    /**\n     * @notice Input args data for challengeStandardExit\n     * @param exitId Identifier of the standard exit to challenge\n     * @param exitingTx RLP-encoded transaction that creates the exiting output\n     * @param challengeTx RLP-encoded transaction that spends the exiting output\n     * @param inputIndex Input of the challenging tx, corresponding to the exiting output\n     * @param witness Witness data that proves the exiting output is spent\n     * @param senderData A keccak256 hash of the sender's address\n     */\n    struct ChallengeStandardExitArgs {\n        uint160 exitId;\n        bytes exitingTx;\n        bytes challengeTx;\n        uint16 inputIndex;\n        bytes witness;\n        bytes32 senderData;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/payment/spendingConditions/PaymentOutputToPaymentTxCondition.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\nimport \"../../interfaces/ISpendingCondition.sol\";\nimport \"../../../utils/PosLib.sol\";\nimport \"../../../transactions/PaymentTransactionModel.sol\";\nimport \"../../../transactions/eip712Libs/PaymentEip712Lib.sol\";\n\ncontract PaymentOutputToPaymentTxCondition is ISpendingCondition {\n    using PaymentEip712Lib for PaymentEip712Lib.Constants;\n    using PosLib for PosLib.Position;\n    using PaymentTransactionModel for PaymentTransactionModel.Transaction;\n\n    uint256 internal supportInputTxType;\n    uint256 internal supportSpendingTxType;\n    PaymentEip712Lib.Constants internal eip712;\n\n    /**\n     * @dev This is designed to be re-useable for all versions of payment transaction, so that\n     *      inputTxType and spendingTxType of the payment output is injected instead\n     */\n    constructor(address framework, uint256 inputTxType, uint256 spendingTxType) public {\n        eip712 = PaymentEip712Lib.initConstants(framework);\n        supportInputTxType = inputTxType;\n        supportSpendingTxType = spendingTxType;\n    }\n\n    /**\n     * @notice Verifies the spending condition\n     * @param inputTxBytes Encoded input transaction, in bytes\n     * @param utxoPos Position of the utxo\n     * @param spendingTxBytes Spending transaction, in bytes\n     * @param inputIndex Input index of the spending tx that points to the output\n     * @param signature Signature of the output owner\n     */\n    function verify(\n        bytes calldata inputTxBytes,\n        uint256 utxoPos,\n        bytes calldata spendingTxBytes,\n        uint16 inputIndex,\n        bytes calldata signature\n    )\n        external\n        view\n        returns (bool)\n    {\n        PaymentTransactionModel.Transaction memory inputTx = PaymentTransactionModel.decode(inputTxBytes);\n        require(inputTx.txType == supportInputTxType, \"Input tx is an unsupported payment tx type\");\n\n        PaymentTransactionModel.Transaction memory spendingTx = PaymentTransactionModel.decode(spendingTxBytes);\n        require(spendingTx.txType == supportSpendingTxType, \"The spending tx is an unsupported payment tx type\");\n\n        require(\n            spendingTx.inputs[inputIndex] == bytes32(utxoPos),\n            \"Spending tx points to the incorrect output UTXO position\"\n        );\n\n        PosLib.Position memory decodedUtxoPos = PosLib.decode(utxoPos);\n        address owner = PaymentTransactionModel.getOutputOwner(inputTx.getOutput(decodedUtxoPos.outputIndex));\n        address signer = ECDSA.recover(eip712.hashTx(spendingTx), signature);\n        require(signer != address(0), \"Failed to recover the signer from the signature\");\n        require(owner == signer, \"Tx is not signed correctly\");\n\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/registries/SpendingConditionRegistry.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"../interfaces/ISpendingCondition.sol\";\n\n/**\n * @title SpendingConditionRegistry\n * @notice The registry contracts of the spending condition\n * @dev This is designed to renounce ownership before injecting the registry contract to ExitGame contracts\n *      After registering all the essential condition contracts, the owner should renounce its ownership to\n *      ensure no further conditions are registered for an ExitGame contract.\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/ownership/Ownable.sol#L55\n */\ncontract SpendingConditionRegistry is Ownable {\n    // mapping of hash(outputType, spendingTxTpye) => ISpendingCondition\n    mapping(bytes32 => ISpendingCondition) internal _spendingConditions;\n\n    function spendingConditions(uint256 outputType, uint256 spendingTxType) public view returns (ISpendingCondition) {\n        bytes32 key = keccak256(abi.encode(outputType, spendingTxType));\n        return _spendingConditions[key];\n    }\n\n    /**\n     * @notice Register the spending condition contract\n     * @param outputType The output type of the spending condition\n     * @param spendingTxType Spending tx type of the spending condition\n     * @param condition The spending condition contract\n     */\n    function registerSpendingCondition(uint256 outputType, uint256 spendingTxType, ISpendingCondition condition)\n        public\n        onlyOwner\n    {\n        require(outputType != 0, \"Registration not possible with output type 0\");\n        require(spendingTxType != 0, \"Registration not possible with spending tx type 0\");\n        require(Address.isContract(address(condition)), \"Registration not possible with a non-contract address\");\n\n        bytes32 key = keccak256(abi.encode(outputType, spendingTxType));\n        require(address(_spendingConditions[key]) == address(0), \"The (output type, spending tx type) pair is already registered\");\n\n        _spendingConditions[key] = condition;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/utils/BondSize.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @notice Stores an updateable bond size\n * @dev Bond design details at https://github.com/omisego/research/issues/107#issuecomment-525267486\n * @dev Security depends on the min/max value, which can be updated to compare to the current bond size, plus the waiting period\n *      Min/max value of the next bond size prevents the possibility to set bond size too low or too high, which risks breaking the system\n *      Waiting period ensures that a user does not get an unexpected bond without notice.\n */\nlibrary BondSize {\n    uint64 constant public WAITING_PERIOD = 2 days;\n\n    /**\n     * @dev Struct is designed to be packed into two 32-bytes storage slots\n     * @param previousBondSize The bond size prior to upgrade, which should remain the same until the waiting period completes\n     * @param updatedBondSize The bond size to use once the waiting period completes\n     * @param effectiveUpdateTime A timestamp for the end of the waiting period, when the updated bond size is implemented\n     * @param lowerBoundDivisor The divisor that checks the lower bound for an update. Each update cannot be lower than (current bond / lowerBoundDivisor)\n     * @param upperBoundMultiplier The multiplier that checks the upper bound for an update. Each update cannot be larger than (current bond * upperBoundMultiplier)\n     */\n    struct Params {\n        uint128 previousBondSize;\n        uint128 updatedBondSize;\n        uint128 effectiveUpdateTime;\n        uint16 lowerBoundDivisor;\n        uint16 upperBoundMultiplier;\n    }\n\n    function buildParams(uint128 initialBondSize, uint16 lowerBoundDivisor, uint16 upperBoundMultiplier)\n        internal\n        pure\n        returns (Params memory)\n    {\n        // Set the initial value far into the future\n        uint128 initialEffectiveUpdateTime = 2 ** 63;\n        return Params({\n            previousBondSize: initialBondSize,\n            updatedBondSize: 0,\n            effectiveUpdateTime: initialEffectiveUpdateTime,\n            lowerBoundDivisor: lowerBoundDivisor,\n            upperBoundMultiplier: upperBoundMultiplier\n        });\n    }\n\n    /**\n    * @notice Updates the bond size\n    * @dev The new bond size value updates once the two day waiting period completes\n    * @param newBondSize The new bond size\n    */\n    function updateBondSize(Params storage self, uint128 newBondSize) internal {\n        validateBondSize(self, newBondSize);\n\n        if (self.updatedBondSize != 0 && now >= self.effectiveUpdateTime) {\n            self.previousBondSize = self.updatedBondSize;\n        }\n        self.updatedBondSize = newBondSize;\n        self.effectiveUpdateTime = uint64(now) + WAITING_PERIOD;\n    }\n\n    /**\n    * @notice Returns the current bond size\n    */\n    function bondSize(Params memory self) internal view returns (uint128) {\n        if (now < self.effectiveUpdateTime) {\n            return self.previousBondSize;\n        } else {\n            return self.updatedBondSize;\n        }\n    }\n\n    function validateBondSize(Params memory self, uint128 newBondSize) private view {\n        uint128 currentBondSize = bondSize(self);\n        require(newBondSize > 0, \"Bond size cannot be zero\");\n        require(newBondSize >= currentBondSize / self.lowerBoundDivisor, \"Bond size is too low\");\n        require(uint256(newBondSize) <= uint256(currentBondSize) * self.upperBoundMultiplier, \"Bond size is too high\");\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/utils/ExitId.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../utils/Bits.sol\";\nimport \"../../utils/PosLib.sol\";\n\nlibrary ExitId {\n    using PosLib for PosLib.Position;\n    using Bits for uint160;\n    using Bits for uint256;\n\n    /**\n     * @notice Checks whether exitId is a standard exit ID\n     */\n    function isStandardExit(uint160 _exitId) internal pure returns (bool) {\n        return _exitId.getBit(151) == 0;\n    }\n\n    /**\n     * @notice Given transaction bytes and UTXO position, returns its exit ID\n     * @dev Computation of a deposit ID is different to any other tx because txBytes of a deposit tx can be a non-unique value\n     * @notice Output index must be within range 0 - 255\n     * @param _isDeposit Defines whether the tx for the exitId is a deposit tx\n     * @param _txBytes Transaction bytes\n     * @param _utxoPos UTXO position of the exiting output\n     * @return _standardExitId Unique ID of the standard exit\n     *     Anatomy of returned value, most significant bits first:\n     *     8-bits - output index\n     *     1-bit - in-flight flag (0 for standard exit)\n     *     151-bits - hash(tx) or hash(tx|utxo) for deposit\n     */\n    function getStandardExitId(\n        bool _isDeposit,\n        bytes memory _txBytes,\n        PosLib.Position memory _utxoPos\n    )\n        internal\n        pure\n        returns (uint160)\n    {\n        if (_isDeposit) {\n            bytes32 hashData = keccak256(abi.encodePacked(_txBytes, _utxoPos.encode()));\n            return _computeStandardExitId(hashData, _utxoPos.outputIndex);\n        }\n\n        return _computeStandardExitId(keccak256(_txBytes), _utxoPos.outputIndex);\n    }\n\n    /**\n    * @notice Given transaction bytes, returns in-flight exit ID\n    * @param _txBytes Transaction bytes\n    * @return Unique in-flight exit ID\n    */\n    function getInFlightExitId(bytes memory _txBytes) internal pure returns (uint160) {\n        return uint160((uint256(keccak256(_txBytes)) >> 105).setBit(151));\n    }\n\n    function _computeStandardExitId(bytes32 _txhash, uint16 _outputIndex)\n        private\n        pure\n        returns (uint160)\n    {\n        uint256 exitId = (uint256(_txhash) >> 105) | (uint256(_outputIndex) << 152);\n        uint160 croppedExitId = uint160(exitId);\n\n        require(uint256(croppedExitId) == exitId, \"ExitId overflows\");\n\n        return croppedExitId;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/utils/ExitableTimestamp.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\n\nlibrary ExitableTimestamp {\n    struct Calculator {\n        uint256 minExitPeriod;\n    }\n\n    /**\n     * @notice Calculates the exitable timestamp for a mined transaction\n     * @dev This is the main function when asking for exitable timestamp in most cases.\n     *      The only exception is to calculate the exitable timestamp for a deposit output in standard exit.\n     *      Should use the function 'calculateDepositTxOutputExitableTimestamp' for that case.\n     */\n    function calculateTxExitableTimestamp(\n        Calculator memory _calculator,\n        uint256 _now,\n        uint256 _blockTimestamp\n    )\n        internal\n        pure\n        returns (uint64)\n    {\n        return uint64(Math.max(_blockTimestamp + (_calculator.minExitPeriod * 2), _now + _calculator.minExitPeriod));\n    }\n\n    /**\n     * @notice Calculates the exitable timestamp for deposit transaction output for standard exit\n     * @dev This function should only be used in standard exit for calculating exitable timestamp of a deposit output.\n     *      For in-fight exit, the priority of a input tx which is a deposit tx should still be using the another function 'calculateTxExitableTimestamp'.\n     *      See discussion here: https://git.io/Je4N5\n     *      Reason of deposit output has different exitable timestamp: https://git.io/JecCV\n     */\n    function calculateDepositTxOutputExitableTimestamp(\n        Calculator memory _calculator,\n        uint256 _now\n    )\n        internal\n        pure\n        returns (uint64)\n    {\n        return uint64(_now + _calculator.minExitPeriod);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/utils/MoreVpFinalization.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../../framework/PlasmaFramework.sol\";\nimport \"../../framework/Protocol.sol\";\nimport \"../../utils/Merkle.sol\";\nimport \"../../utils/PosLib.sol\";\nimport \"../../transactions/GenericTransaction.sol\";\n\n/**\n * @notice Library to check finalization for MoreVP protocol\n * @dev This library assumes that the tx is of the GenericTransaction format\n */\nlibrary MoreVpFinalization {\n    using PosLib for PosLib.Position;\n\n    /**\n    * @notice Checks whether a transaction is \"standard finalized\".\n    *         For MoreVP, it means the transaction should be included in a plasma block.\n    */\n    function isStandardFinalized(\n        PlasmaFramework framework,\n        bytes memory txBytes,\n        PosLib.Position memory txPos,\n        bytes memory inclusionProof\n    )\n        internal\n        view\n        returns (bool)\n    {\n        require(txPos.outputIndex == 0, \"Invalid transaction position\");\n        GenericTransaction.Transaction memory genericTx = GenericTransaction.decode(txBytes);\n        uint8 protocol = framework.protocols(genericTx.txType);\n        require(protocol == Protocol.MORE_VP(), \"MoreVpFinalization: not a MoreVP protocol tx\");\n\n        (bytes32 root,) = framework.blocks(txPos.blockNum);\n        require(root != bytes32(\"\"), \"Failed to get the root hash of the block num\");\n\n        return Merkle.checkMembership(\n            txBytes, txPos.txIndex, root, inclusionProof\n        );\n    }\n\n    /**\n    * @notice Checks whether a transaction is \"protocol finalized\"\n    *         For MoreVP, since it allows in-flight tx, so only checks for the existence of the transaction\n    */\n    function isProtocolFinalized(\n        PlasmaFramework framework,\n        bytes memory txBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (txBytes.length == 0) {\n            return false;\n        }\n\n        GenericTransaction.Transaction memory genericTx = GenericTransaction.decode(txBytes);\n        uint8 protocol = framework.protocols(genericTx.txType);\n        require(protocol == Protocol.MORE_VP(), \"MoreVpFinalization: not a MoreVP protocol tx\");\n\n        return true;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/exits/utils/OutputId.sol": {
      "content": "pragma solidity 0.5.11;\n\nlibrary OutputId {\n    /**\n     * @notice Computes the output ID for a deposit tx\n     * @dev Deposit tx bytes might not be unique because all inputs are empty\n     *      Two deposits with the same output value would result in the same tx bytes\n     *      As a result, we need to hash with utxoPos to ensure uniqueness\n     * @param _txBytes Transaction bytes\n     * @param _outputIndex Output index of the output\n     * @param _utxoPosValue (Optional) UTXO position of the deposit output\n     */\n    function computeDepositOutputId(bytes memory _txBytes, uint256 _outputIndex, uint256 _utxoPosValue)\n        internal\n        pure\n        returns(bytes32)\n    {\n        return keccak256(abi.encodePacked(_txBytes, _outputIndex, _utxoPosValue));\n    }\n\n    /**\n     * @notice Computes the output ID for normal (non-deposit) tx\n     * @dev Since txBytes for non-deposit tx is unique, directly hash the txBytes with outputIndex\n     * @param _txBytes Transaction bytes\n     * @param _outputIndex Output index of the output\n     */\n    function computeNormalOutputId(bytes memory _txBytes, uint256 _outputIndex)\n        internal\n        pure\n        returns(bytes32)\n    {\n        return keccak256(abi.encodePacked(_txBytes, _outputIndex));\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/BlockController.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"./models/BlockModel.sol\";\nimport \"./registries/VaultRegistry.sol\";\nimport \"../utils/OnlyFromAddress.sol\";\n\n/**\n* @notice Controls the logic and functions for block submissions in PlasmaFramework\n* @dev There are two types of blocks: child block and deposit block\n*      Each child block has an interval of 'childBlockInterval'\n*      The interval is preserved for deposits. Each deposit results in one deposit block.\n*      For instance, a child block would be in block 1000 and the next deposit would result in block 1001.\n*\n*      Only the authority address can perform a block submission.\n*      Details on limitations for the authority address can be found here: https://github.com/omisego/elixir-omg#managing-the-operator-address\n*/\ncontract BlockController is OnlyFromAddress, VaultRegistry {\n    address public authority;\n    uint256 public childBlockInterval;\n    uint256 public nextChildBlock;\n    uint256 public nextDeposit;\n    bool public isChildChainActivated;\n\n    mapping (uint256 => BlockModel.Block) public blocks; // block number => Block data\n\n    event BlockSubmitted(\n        uint256 blknum\n    );\n\n    event ChildChainActivated(\n        address authority\n    );\n\n    constructor(\n        uint256 _interval,\n        uint256 _minExitPeriod,\n        uint256 _initialImmuneVaults,\n        address _authority\n    )\n        public\n        VaultRegistry(_minExitPeriod, _initialImmuneVaults)\n    {\n        authority = _authority;\n        childBlockInterval = _interval;\n        nextChildBlock = childBlockInterval;\n        nextDeposit = 1;\n        isChildChainActivated = false;\n    }\n\n    /**\n     * @notice Activates the child chain so that child chain can start to submit child blocks to root chain\n     * @notice Can only be called once by the authority.\n     * @notice Sets isChildChainActivated to true and emits the ChildChainActivated event.\n     * @dev This is a preserved action for authority account to start its nonce with 1.\n     *      Child chain rely ethereum nonce to protect re-org: https://git.io/JecDG\n     *      see discussion: https://git.io/JenaT, https://git.io/JecDO\n     */\n    function activateChildChain() external onlyFrom(authority) {\n        require(isChildChainActivated == false, \"Child chain already activated\");\n        isChildChainActivated = true;\n        emit ChildChainActivated(authority);\n    }\n\n    /**\n     * @notice Allows the authority to submit the Merkle root of a Plasma block\n     * @dev emit BlockSubmitted event\n     * @dev Block number jumps 'childBlockInterval' per submission\n     * @dev See discussion in https://github.com/omisego/plasma-contracts/issues/233\n     * @param _blockRoot Merkle root of the Plasma block\n     */\n    function submitBlock(bytes32 _blockRoot) external onlyFrom(authority) {\n        require(isChildChainActivated == true, \"Child chain has not been activated by authority address yet\");\n        uint256 submittedBlockNumber = nextChildBlock;\n\n        blocks[submittedBlockNumber] = BlockModel.Block({\n            root: _blockRoot,\n            timestamp: block.timestamp\n        });\n\n        nextChildBlock += childBlockInterval;\n        nextDeposit = 1;\n\n        emit BlockSubmitted(submittedBlockNumber);\n    }\n\n    /**\n     * @notice Submits a block for deposit\n     * @dev Block number adds 1 per submission; it's possible to have at most 'childBlockInterval' deposit blocks between two child chain blocks\n     * @param _blockRoot Merkle root of the Plasma block\n     * @return The deposit block number\n     */\n    function submitDepositBlock(bytes32 _blockRoot) public onlyFromNonQuarantinedVault returns (uint256) {\n        require(isChildChainActivated == true, \"Child chain has not been activated by authority address yet\");\n        require(nextDeposit < childBlockInterval, \"Exceeded limit of deposits per child block interval\");\n\n        uint256 blknum = nextDepositBlock();\n        blocks[blknum] = BlockModel.Block({\n            root : _blockRoot,\n            timestamp : block.timestamp\n        });\n\n        nextDeposit++;\n        return blknum;\n    }\n\n    function nextDepositBlock() public view returns (uint256) {\n        return nextChildBlock - childBlockInterval + nextDeposit;\n    }\n\n    function isDeposit(uint256 blockNum) public view returns (bool) {\n        require(blocks[blockNum].timestamp != 0, \"Block does not exist\");\n        return blockNum % childBlockInterval != 0;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/ExitGameController.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IExitProcessor.sol\";\nimport \"./registries/ExitGameRegistry.sol\";\nimport \"./utils/PriorityQueue.sol\";\nimport \"./utils/ExitPriority.sol\";\nimport \"../utils/PosLib.sol\";\n\n/**\n * @notice Controls the logic and functions for ExitGame to interact with the PlasmaFramework\n *         Plasma M(ore)VP relies on exit priority to secure the user from invalid transactions\n *         The priority queue ensures the exit is processed with the exit priority\n *         For details, see the Plasma MVP spec: https://ethresear.ch/t/minimal-viable-plasma/426\n */\ncontract ExitGameController is ExitGameRegistry {\n    // exit hashed (priority, vault id, token) => IExitProcessor\n    mapping (bytes32 => IExitProcessor) public delegations;\n    // hashed (vault id, token) => PriorityQueue\n    mapping (bytes32 => PriorityQueue) public exitsQueues;\n    // outputId => exitId\n    mapping (bytes32 => uint160) public outputsFinalizations;\n    bool private mutex = false;\n\n    event ExitQueueAdded(\n        uint256 vaultId,\n        address token\n    );\n\n    event ProcessedExitsNum(\n        uint256 processedNum,\n        uint256 vaultId,\n        address token\n    );\n\n    event ExitQueued(\n        uint160 indexed exitId,\n        uint256 priority\n    );\n\n    constructor(uint256 _minExitPeriod, uint256 _initialImmuneExitGames)\n        public\n        ExitGameRegistry(_minExitPeriod, _initialImmuneExitGames)\n    {\n    }\n\n    /**\n     * @dev Prevents reentrant calls by using a mutex.\n     */\n    modifier nonReentrant() {\n        require(!mutex, \"Reentrant call\");\n        mutex = true;\n        _;\n        assert(mutex);\n        mutex = false;\n    }\n\n    /**\n     * @notice Activates non reentrancy mode\n     *         Guards against reentering into publicly accessible code that modifies state related to exits\n     * @dev Accessible only from non quarantined exit games, uses a mutex\n     */\n    function activateNonReentrant() external onlyFromNonQuarantinedExitGame() {\n        require(!mutex, \"Reentrant call\");\n        mutex = true;\n    }\n\n    /**\n     * @notice Deactivates non reentrancy mode\n     * @dev Accessible only from non quarantined exit games, uses a mutex\n     */\n    function deactivateNonReentrant() external onlyFromNonQuarantinedExitGame() {\n        assert(mutex);\n        mutex = false;\n    }\n\n    /**\n     * @notice Checks if the queue for a specified token was created\n     * @param vaultId ID of the vault that handles the token\n     * @param token Address of the token\n     * @return bool Defines whether the queue for a token was created\n     */\n    function hasExitQueue(uint256 vaultId, address token) public view returns (bool) {\n        bytes32 key = exitQueueKey(vaultId, token);\n        return hasExitQueue(key);\n    }\n\n    /**\n     * @notice Adds queue to the Plasma framework\n     * @dev The queue is created as a new contract instance\n     * @param vaultId ID of the vault\n     * @param token Address of the token\n     */\n    function addExitQueue(uint256 vaultId, address token) external {\n        require(vaultId != 0, \"Vault ID must not be 0\");\n        bytes32 key = exitQueueKey(vaultId, token);\n        require(!hasExitQueue(key), \"Exit queue exists\");\n        exitsQueues[key] = new PriorityQueue();\n        emit ExitQueueAdded(vaultId, token);\n    }\n\n    /**\n     * @notice Enqueue exits from exit game contracts is a function that places the exit into the\n     *         priority queue to enforce the priority of exit during 'processExits'\n     * @dev emits ExitQueued event, which can be used to back trace the priority inside the queue\n     * @dev Caller of this function should add \"pragma experimental ABIEncoderV2;\" on top of file\n     * @dev Priority (exitableAt, txPos, exitId) must be unique per queue. Do not enqueue when the same priority is already in the queue.\n     * @param vaultId Vault ID of the vault that stores exiting funds\n     * @param token Token for the exit\n     * @param exitableAt The earliest time a specified exit can be processed\n     * @param txPos Transaction position for the exit priority. For SE it should be the exit tx, for IFE it should be the youngest input tx position.\n     * @param exitId ID used by the exit processor contract to determine how to process the exit\n     * @param exitProcessor The exit processor contract, called during \"processExits\"\n     * @return A unique priority number computed for the exit\n     */\n    function enqueue(\n        uint256 vaultId,\n        address token,\n        uint64 exitableAt,\n        PosLib.Position calldata txPos,\n        uint160 exitId,\n        IExitProcessor exitProcessor\n    )\n        external\n        onlyFromNonQuarantinedExitGame\n        returns (uint256)\n    {\n        bytes32 key = exitQueueKey(vaultId, token);\n        require(hasExitQueue(key), \"The queue for the (vaultId, token) pair is not yet added to the Plasma framework\");\n        PriorityQueue queue = exitsQueues[key];\n\n        uint256 priority = ExitPriority.computePriority(exitableAt, txPos, exitId);\n\n        queue.insert(priority);\n\n        bytes32 delegationKey = getDelegationKey(priority, vaultId, token);\n        require(address(delegations[delegationKey]) == address(0), \"The same priority is already enqueued\");\n        delegations[delegationKey] = exitProcessor;\n\n        emit ExitQueued(exitId, priority);\n        return priority;\n    }\n\n    /**\n     * @notice Processes any exits that have completed the challenge period. Exits are processed according to the exit priority.\n     * @dev Emits ProcessedExitsNum event\n     * @param vaultId Vault ID of the vault that stores exiting funds\n     * @param token The token type to process\n     * @param topExitId Unique identifier for prioritizing the first exit to process. Set to zero to skip this check.\n     * @param maxExitsToProcess Maximum number of exits to process\n     * @return Total number of processed exits\n     */\n    function processExits(uint256 vaultId, address token, uint160 topExitId, uint256 maxExitsToProcess) external nonReentrant {\n        bytes32 key = exitQueueKey(vaultId, token);\n        require(hasExitQueue(key), \"The token is not yet added to the Plasma framework\");\n        PriorityQueue queue = exitsQueues[key];\n        require(queue.currentSize() > 0, \"Exit queue is empty\");\n\n        uint256 uniquePriority = queue.getMin();\n        uint160 exitId = ExitPriority.parseExitId(uniquePriority);\n        require(topExitId == 0 || exitId == topExitId,\n            \"Top exit ID of the queue is different to the one specified\");\n\n        bytes32 delegationKey = getDelegationKey(uniquePriority, vaultId, token);\n        IExitProcessor processor = delegations[delegationKey];\n        uint256 processedNum = 0;\n\n        while (processedNum < maxExitsToProcess && ExitPriority.parseExitableAt(uniquePriority) < block.timestamp) {\n            delete delegations[delegationKey];\n            queue.delMin();\n            processedNum++;\n\n            processor.processExit(exitId, vaultId, token);\n\n            if (queue.currentSize() == 0) {\n                break;\n            }\n\n            uniquePriority = queue.getMin();\n            delegationKey = getDelegationKey(uniquePriority, vaultId, token);\n            exitId = ExitPriority.parseExitId(uniquePriority);\n            processor = delegations[delegationKey];\n        }\n\n        emit ProcessedExitsNum(processedNum, vaultId, token);\n    }\n\n    /**\n     * @notice Checks whether any of the output with the given outputIds is already spent\n     * @param _outputIds Output IDs to check\n     */\n    function isAnyInputFinalizedByOtherExit(bytes32[] calldata _outputIds, uint160 exitId) external view returns (bool) {\n        for (uint i = 0; i < _outputIds.length; i++) {\n            uint160 finalizedExitId = outputsFinalizations[_outputIds[i]];\n            if (finalizedExitId != 0 && finalizedExitId != exitId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Batch flags already spent outputs (only not already spent)\n     * @param outputIds Output IDs to flag\n     */\n    function batchFlagOutputsFinalized(bytes32[] calldata outputIds, uint160 exitId) external onlyFromNonQuarantinedExitGame {\n        for (uint i = 0; i < outputIds.length; i++) {\n            require(outputIds[i] != bytes32(\"\"), \"Should not flag with empty outputId\");\n            if (outputsFinalizations[outputIds[i]] == 0) {\n                outputsFinalizations[outputIds[i]] = exitId;\n            }\n        }\n    }\n\n    /**\n     * @notice Flags a single output as spent if it is not flagged already\n     * @param outputId The output ID to flag as spent\n     */\n    function flagOutputFinalized(bytes32 outputId, uint160 exitId) external onlyFromNonQuarantinedExitGame {\n        require(outputId != bytes32(\"\"), \"Should not flag with empty outputId\");\n        if (outputsFinalizations[outputId] == 0) {\n            outputsFinalizations[outputId] = exitId;\n        }\n    }\n\n     /**\n     * @notice Checks whether output with a given outputId is finalized\n     * @param outputId Output ID to check\n     */\n    function isOutputFinalized(bytes32 outputId) external view returns (bool) {\n        return outputsFinalizations[outputId] != 0;\n    }\n\n    function getNextExit(uint256 vaultId, address token) external view returns (uint256) {\n        bytes32 key = exitQueueKey(vaultId, token);\n        return exitsQueues[key].getMin();\n    }\n\n    function exitQueueKey(uint256 vaultId, address token) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(vaultId, token));\n    }\n\n    function hasExitQueue(bytes32 queueKey) private view returns (bool) {\n        return address(exitsQueues[queueKey]) != address(0);\n    }\n\n    function getDelegationKey(uint256 priority, uint256 vaultId, address token) private pure returns (bytes32) {\n        return keccak256(abi.encodePacked(priority, vaultId, token));\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/PlasmaFramework.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./BlockController.sol\";\nimport \"./ExitGameController.sol\";\nimport \"./registries/VaultRegistry.sol\";\nimport \"./registries/ExitGameRegistry.sol\";\n\ncontract PlasmaFramework is VaultRegistry, ExitGameRegistry, ExitGameController, BlockController {\n    uint256 public constant CHILD_BLOCK_INTERVAL = 1000;\n\n    /**\n     * The minimum finalization period is the Plasma guarantee that all exits are safe provided the user takes action within the specified time period\n     * When the child chain is rogue, user should start their exit and challenge any invalid exit within this period\n     * An exit can be processed/finalized after minimum two finalization periods from its inclusion position, unless it is an exit for a deposit,\n     * which would use one finalization period, instead of two\n     *\n     * For the Abstract Layer Design, OmiseGO also uses some multitude of this period to update its framework\n     * See also ExitGameRegistry.sol, VaultRegistry.sol, and Vault.sol for more information on the update waiting time (the quarantined period)\n     *\n     * MVP: https://ethresear.ch/t/minimal-viable-plasma/426\n     * MoreVP: https://github.com/omisego/elixir-omg/blob/master/docs/morevp.md#timeline\n     * Special period for deposit: https://git.io/JecCV\n     */\n    uint256 public minExitPeriod;\n    address private maintainer;\n    string public version;\n\n    constructor(\n        uint256 _minExitPeriod,\n        uint256 _initialImmuneVaults,\n        uint256 _initialImmuneExitGames,\n        address _authority,\n        address _maintainer\n    )\n        public\n        BlockController(CHILD_BLOCK_INTERVAL, _minExitPeriod, _initialImmuneVaults, _authority)\n        ExitGameController(_minExitPeriod, _initialImmuneExitGames)\n    {\n        minExitPeriod = _minExitPeriod;\n        maintainer = _maintainer;\n    }\n\n    function getMaintainer() public view returns (address) {\n        return maintainer;\n    }\n\n    /**\n     * @notice Gets the semantic version of the current deployed contracts\n    */\n    function getVersion() external view returns (string memory) {\n        return version;\n    }\n    \n    /**\n     * @notice Sets the semantic version of the current deployed contracts\n     * @param _version is semver string\n     */\n    function setVersion(string memory _version) public onlyFrom(getMaintainer()) {\n        version = _version;\n    }\n}"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/Protocol.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @notice Protocols for the PlasmaFramework\n */\nlibrary Protocol {\n    uint8 constant internal MVP_VALUE = 1;\n    uint8 constant internal MORE_VP_VALUE = 2;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MVP() internal pure returns (uint8) {\n        return MVP_VALUE;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MORE_VP() internal pure returns (uint8) {\n        return MORE_VP_VALUE;\n    }\n\n    function isValidProtocol(uint8 protocol) internal pure returns (bool) {\n        return protocol == MVP_VALUE || protocol == MORE_VP_VALUE;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/interfaces/IExitProcessor.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @dev An interface that allows custom logic to process exits for different requirements.\n *      This interface is used to dispatch to each custom processor when 'processExits' is called on PlasmaFramework.\n */\ninterface IExitProcessor {\n    /**\n     * @dev Function interface for processing exits.\n     * @param exitId Unique ID for exit per tx type\n     * @param vaultId ID of the vault that funds the exit\n     * @param token Address of the token contract\n     */\n    function processExit(uint160 exitId, uint256 vaultId, address token) external;\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/models/BlockModel.sol": {
      "content": "pragma solidity 0.5.11;\n\nlibrary BlockModel {\n    /**\n     * @notice Block data structure that is stored in the contract\n     * @param root The Merkle root block hash of the Plasma blocks\n     * @param timestamp The timestamp, in seconds, when the block is saved\n     */\n    struct Block {\n        bytes32 root;\n        uint256 timestamp;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/registries/ExitGameRegistry.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"../Protocol.sol\";\nimport \"../utils/Quarantine.sol\";\nimport \"../../utils/OnlyFromAddress.sol\";\n\ncontract ExitGameRegistry is OnlyFromAddress {\n    using Quarantine for Quarantine.Data;\n\n    mapping(uint256 => address) private _exitGames; // txType => exit game contract address\n    mapping(address => uint256) private _exitGameToTxType; // exit game contract address => tx type\n    mapping(uint256 => uint8) private _protocols; // tx type => protocol (MVP/MORE_VP)\n    Quarantine.Data private _exitGameQuarantine;\n\n    event ExitGameRegistered(\n        uint256 txType,\n        address exitGameAddress,\n        uint8 protocol\n    );\n\n    /**\n     * @dev It takes at least 3 * minExitPeriod before each new exit game contract is able to start protecting existing transactions\n     *      see: https://github.com/omisego/plasma-contracts/issues/172\n     *           https://github.com/omisego/plasma-contracts/issues/197\n     */\n    constructor (uint256 _minExitPeriod, uint256 _initialImmuneExitGames)\n        public\n    {\n        _exitGameQuarantine.quarantinePeriod = 4 * _minExitPeriod;\n        _exitGameQuarantine.immunitiesRemaining = _initialImmuneExitGames;\n    }\n\n    /**\n     * @notice A modifier to verify that the call is from a non-quarantined exit game\n     */\n    modifier onlyFromNonQuarantinedExitGame() {\n        require(_exitGameToTxType[msg.sender] != 0, \"The call is not from a registered exit game contract\");\n        require(!_exitGameQuarantine.isQuarantined(msg.sender), \"ExitGame is quarantined\");\n        _;\n    }\n\n    /**\n     * @notice interface to get the 'maintainer' address.\n     * @dev see discussion here: https://git.io/Je8is\n     */\n    function getMaintainer() public view returns (address);\n\n    /**\n     * @notice Checks whether the contract is safe to use and is not under quarantine\n     * @dev Exposes information about exit games quarantine\n     * @param _contract Address of the exit game contract\n     * @return boolean Whether the contract is safe to use and is not under quarantine\n     */\n    function isExitGameSafeToUse(address _contract) public view returns (bool) {\n        return _exitGameToTxType[_contract] != 0 && !_exitGameQuarantine.isQuarantined(_contract);\n    }\n\n    /**\n     * @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n     * @dev Emits ExitGameRegistered event to notify clients\n     * @param _txType The tx type where the exit game wants to register\n     * @param _contract Address of the exit game contract\n     * @param _protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n     */\n    function registerExitGame(uint256 _txType, address _contract, uint8 _protocol) public onlyFrom(getMaintainer()) {\n        require(_txType != 0, \"Should not register with tx type 0\");\n        require(Address.isContract(_contract), \"Should not register with a non-contract address\");\n        require(_exitGames[_txType] == address(0), \"The tx type is already registered\");\n        require(_exitGameToTxType[_contract] == 0, \"The exit game contract is already registered\");\n        require(Protocol.isValidProtocol(_protocol), \"Invalid protocol value\");\n\n        _exitGames[_txType] = _contract;\n        _exitGameToTxType[_contract] = _txType;\n        _protocols[_txType] = _protocol;\n        _exitGameQuarantine.quarantine(_contract);\n\n        emit ExitGameRegistered(_txType, _contract, _protocol);\n    }\n\n    /**\n     * @notice Public getter for retrieving protocol with tx type\n     */\n    function protocols(uint256 _txType) public view returns (uint8) {\n        return _protocols[_txType];\n    }\n\n    /**\n     * @notice Public getter for retrieving exit game address with tx type\n     */\n    function exitGames(uint256 _txType) public view returns (address) {\n        return _exitGames[_txType];\n    }\n\n    /**\n     * @notice Public getter for retrieving tx type with exit game address\n     */\n    function exitGameToTxType(address _exitGame) public view returns (uint256) {\n        return _exitGameToTxType[_exitGame];\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/registries/VaultRegistry.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"../utils/Quarantine.sol\";\nimport \"../../utils/OnlyFromAddress.sol\";\n\ncontract VaultRegistry is OnlyFromAddress {\n    using Quarantine for Quarantine.Data;\n\n    mapping(uint256 => address) private _vaults; // vault id => vault address\n    mapping(address => uint256) private _vaultToId; // vault address => vault id\n    Quarantine.Data private _vaultQuarantine;\n\n    event VaultRegistered(\n        uint256 vaultId,\n        address vaultAddress\n    );\n\n    /**\n     * @dev It takes at least 2 minExitPeriod for each new vault contract to start.\n     *      This is to protect deposit transactions already in mempool,\n     *      and also make sure user only needs to SE within first week when invalid vault is registered.\n     *      see: https://github.com/omisego/plasma-contracts/issues/412\n     *           https://github.com/omisego/plasma-contracts/issues/173\n     */\n    constructor(uint256 _minExitPeriod, uint256 _initialImmuneVaults)\n        public\n    {\n        _vaultQuarantine.quarantinePeriod = 2 * _minExitPeriod;\n        _vaultQuarantine.immunitiesRemaining = _initialImmuneVaults;\n    }\n\n    /**\n     * @notice interface to get the 'maintainer' address.\n     * @dev see discussion here: https://git.io/Je8is\n     */\n    function getMaintainer() public view returns (address);\n\n    /**\n     * @notice A modifier to check that the call is from a non-quarantined vault\n     */\n    modifier onlyFromNonQuarantinedVault() {\n        require(_vaultToId[msg.sender] > 0, \"The call is not from a registered vault\");\n        require(!_vaultQuarantine.isQuarantined(msg.sender), \"Vault is quarantined\");\n        _;\n    }\n\n    /**\n     * @notice Register a vault within the PlasmaFramework. Only a maintainer can make the call.\n     * @dev emits VaultRegistered event to notify clients\n     * @param _vaultId The ID for the vault contract to register\n     * @param _vaultAddress Address of the vault contract\n     */\n    function registerVault(uint256 _vaultId, address _vaultAddress) public onlyFrom(getMaintainer()) {\n        require(_vaultId != 0, \"Should not register with vault ID 0\");\n        require(Address.isContract(_vaultAddress), \"Should not register with a non-contract address\");\n        require(_vaults[_vaultId] == address(0), \"The vault ID is already registered\");\n        require(_vaultToId[_vaultAddress] == 0, \"The vault contract is already registered\");\n\n        _vaults[_vaultId] = _vaultAddress;\n        _vaultToId[_vaultAddress] = _vaultId;\n        _vaultQuarantine.quarantine(_vaultAddress);\n\n        emit VaultRegistered(_vaultId, _vaultAddress);\n    }\n\n    /**\n     * @notice Public getter for retrieving vault address with vault ID\n     */\n    function vaults(uint256 _vaultId) public view returns (address) {\n        return _vaults[_vaultId];\n    }\n\n    /**\n     * @notice Public getter for retrieving vault ID with vault address\n     */\n    function vaultToId(address _vaultAddress) public view returns (uint256) {\n        return _vaultToId[_vaultAddress];\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/utils/ExitPriority.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../utils/PosLib.sol\";\n\nlibrary ExitPriority {\n\n    using PosLib for PosLib.Position;\n\n    /**\n     * @dev Returns an exit priority for a given UTXO position and a unique ID.\n     * The priority for Plasma M(ore)VP protocol is a combination of 'exitableAt' and 'txPos'.\n     * Since 'exitableAt' only provides granularity of block, add 'txPos' to provide priority for a transaction.\n     * @notice Detailed explanation on field lengths can be found at https://github.com/omisego/plasma-contracts/pull/303#discussion_r328850572\n     * @param exitId Unique exit identifier\n     * @return An exit priority\n     *   Anatomy of returned value, most significant bits first\n     *   42 bits  - timestamp in seconds (exitable_at); we can represent dates until year 141431\n     *   54 bits  - blocknum * 10^5 + txindex; 54 bits represent all transactions for 85 years. Be aware that child chain block number jumps with the interval of CHILD_BLOCK_INTERVAL, which would be 1000 in production.\n     *   160 bits - exit id\n     */\n    function computePriority(uint64 exitableAt, PosLib.Position memory txPos, uint160 exitId)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (uint256(exitableAt) << 214) | (txPos.getTxPositionForExitPriority() << 160) | uint256(exitId);\n    }\n\n    function parseExitableAt(uint256 priority) internal pure returns (uint64) {\n        return uint64(priority >> 214);\n    }\n\n    function parseExitId(uint256 priority) internal pure returns (uint160) {\n        // Exit ID uses only 160 least significant bits\n        return uint160(priority);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/utils/PriorityQueue.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../../utils/OnlyFromAddress.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title PriorityQueue\n * @dev Min-heap priority queue implementation\n */\ncontract PriorityQueue is OnlyFromAddress {\n    using SafeMath for uint256;\n\n    struct Queue {\n        uint256[] heapList;\n        uint256 currentSize;\n    }\n\n    Queue public queue;\n    address public framework;\n\n    constructor() public {\n        queue.heapList = [0];\n        queue.currentSize = 0;\n\n        // it is expected that this should be called by PlasmaFramework\n        // and only PlasmaFramework contract can add things to the queue\n        framework = msg.sender;\n    }\n\n    /**\n     * @notice Gets num of elements in the queue\n     */\n    function currentSize() external view returns (uint256) {\n        return queue.currentSize;\n    }\n\n    /**\n     * @notice Gets all elements in the queue\n     */\n    function heapList() external view returns (uint256[] memory) {\n        return queue.heapList;\n    }\n\n    /**\n     * @notice Inserts an element into the queue by the framework\n     * @dev Does not perform deduplication\n     */\n    function insert(uint256 _element) external onlyFrom(framework) {\n        queue.heapList.push(_element);\n        queue.currentSize = queue.currentSize.add(1);\n        percUp(queue, queue.currentSize);\n    }\n\n    /**\n     * @notice Deletes the smallest element from the queue by the framework\n     * @dev Fails when queue is empty\n     * @return The smallest element in the priority queue\n     */\n    function delMin() external onlyFrom(framework) returns (uint256) {\n        require(queue.currentSize > 0, \"Queue is empty\");\n        uint256 retVal = queue.heapList[1];\n        queue.heapList[1] = queue.heapList[queue.currentSize];\n        delete queue.heapList[queue.currentSize];\n        queue.currentSize = queue.currentSize.sub(1);\n        percDown(queue, 1);\n        queue.heapList.length = queue.heapList.length.sub(1);\n        return retVal;\n    }\n\n    /**\n     * @notice Returns the smallest element from the queue\n     * @dev Fails when queue is empty\n     * @return The smallest element in the priority queue\n     */\n    function getMin() external view returns (uint256) {\n        require(queue.currentSize > 0, \"Queue is empty\");\n        return queue.heapList[1];\n    }\n\n    function percUp(Queue storage self, uint256 pointer) private {\n        uint256 i = pointer;\n        uint256 j = i;\n        uint256 newVal = self.heapList[i];\n        while (newVal < self.heapList[i.div(2)]) {\n            self.heapList[i] = self.heapList[i.div(2)];\n            i = i.div(2);\n        }\n        if (i != j) {\n            self.heapList[i] = newVal;\n        }\n    }\n\n    function percDown(Queue storage self, uint256 pointer) private {\n        uint256 i = pointer;\n        uint256 j = i;\n        uint256 newVal = self.heapList[i];\n        uint256 mc = minChild(self, i);\n        while (mc <= self.currentSize && newVal > self.heapList[mc]) {\n            self.heapList[i] = self.heapList[mc];\n            i = mc;\n            mc = minChild(self, i);\n        }\n        if (i != j) {\n            self.heapList[i] = newVal;\n        }\n    }\n\n    function minChild(Queue storage self, uint256 i) private view returns (uint256) {\n        if (i.mul(2).add(1) > self.currentSize) {\n            return i.mul(2);\n        } else {\n            if (self.heapList[i.mul(2)] < self.heapList[i.mul(2).add(1)]) {\n                return i.mul(2);\n            } else {\n                return i.mul(2).add(1);\n            }\n        }\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/framework/utils/Quarantine.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @notice Provides a way to quarantine (disable) contracts for a specified period of time\n * @dev The immunitiesRemaining member allows deployment to the platform with some\n * pre-verified contracts that don't get quarantined\n */\nlibrary Quarantine {\n    struct Data {\n        mapping(address => uint256) store;\n        uint256 quarantinePeriod;\n        uint256 immunitiesRemaining;\n    }\n\n    /**\n     * @notice Checks whether a contract is quarantined\n     */\n    function isQuarantined(Data storage _self, address _contractAddress) internal view returns (bool) {\n        return block.timestamp < _self.store[_contractAddress];\n    }\n\n    /**\n     * @notice Places a contract into quarantine\n     * @param _contractAddress The address of the contract\n     */\n    function quarantine(Data storage _self, address _contractAddress) internal {\n        require(_contractAddress != address(0), \"An empty address cannot be quarantined\");\n        require(_self.store[_contractAddress] == 0, \"The contract is already quarantined\");\n\n        if (_self.immunitiesRemaining == 0) {\n            _self.store[_contractAddress] = block.timestamp + _self.quarantinePeriod;\n        } else {\n            _self.immunitiesRemaining--;\n        }\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/transactions/FungibleTokenOutputModel.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./GenericTransaction.sol\";\nimport \"../utils/RLPReader.sol\";\n\n/**\n * @notice Data structure and its decode function for ouputs of fungible token transactions\n */\nlibrary FungibleTokenOutputModel {\n    using RLPReader for RLPReader.RLPItem;\n\n    struct Output {\n        uint256 outputType;\n        bytes20 outputGuard;\n        address token;\n        uint256 amount;\n    }\n\n    /**\n     * @notice Given a GenericTransaction.Output, decodes the `data` field.\n     * The data field is an RLP list that must satisfy the following conditions:\n     *      - It must have 3 elements: [`outputGuard`, `token`, `amount`]\n     *      - `outputGuard` is a 20 byte long array\n     *      - `token` is a 20 byte long array\n     *      - `amount` must be an integer value with no leading zeros. It may not be zero.\n     * @param genericOutput A GenericTransaction.Output\n     * @return A fully decoded FungibleTokenOutputModel.Output struct\n     */\n    function decodeOutput(GenericTransaction.Output memory genericOutput)\n        internal\n        pure\n        returns (Output memory)\n    {\n        RLPReader.RLPItem[] memory dataList = genericOutput.data.toList();\n        require(dataList.length == 3, \"Output data must have 3 items\");\n\n        Output memory outputData = Output({\n            outputType: genericOutput.outputType,\n            outputGuard: bytes20(dataList[0].toAddress()),\n            token: dataList[1].toAddress(),\n            amount: dataList[2].toUint()\n        });\n\n        require(outputData.amount != 0, \"Output amount must not be 0\");\n        require(outputData.outputGuard != bytes20(0), \"Output outputGuard must not be 0\");\n        return outputData;\n    }\n\n    /**\n    * @dev Decodes and returns the output at a specific index in the transaction\n    */\n    function getOutput(GenericTransaction.Transaction memory transaction, uint16 outputIndex)\n        internal\n        pure\n        returns\n        (Output memory)\n    {\n        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n        return decodeOutput(transaction.outputs[outputIndex]);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/transactions/GenericTransaction.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../utils/RLPReader.sol\";\n\n/**\n * @title GenericTransaction\n * @notice GenericTransaction is a generic transaction format that makes few assumptions about the\n * content of the transaction. A transaction must satisy the following requirements:\n * - It must be a list of 5 items: [txType, inputs, outputs, txData, metaData]\n * - `txType` must be a uint not equal to zero\n * - inputs must be a list of RLP items.\n * - outputs must be a list of `Output`s\n * - an `Output` is a list of 2 items: [outputType, data]\n * - `Output.outputType` must be a uint not equal to zero\n * - `Output.data` is an RLP item. It can be a list.\n * - no assumptions are made about `txData`. Note that `txData` can be a list.\n * - `metaData` must be 32 bytes long.\n */\nlibrary GenericTransaction {\n\n    uint8 constant private TX_NUM_ITEMS = 5;\n\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    struct Transaction {\n        uint256 txType;\n        RLPReader.RLPItem[] inputs;\n        Output[] outputs;\n        RLPReader.RLPItem txData;\n        bytes32 metaData;\n    }\n\n    struct Output {\n        uint256 outputType;\n        RLPReader.RLPItem data;\n    }\n\n    /**\n    * @dev Decodes an RLP encoded transaction into the generic format.\n    */\n    function decode(bytes memory transaction) internal pure returns (Transaction memory) {\n        RLPReader.RLPItem[] memory rlpTx = transaction.toRlpItem().toList();\n        require(rlpTx.length == TX_NUM_ITEMS, \"Invalid encoding of transaction\");\n        uint256 txType = rlpTx[0].toUint();\n        require(txType > 0, \"Transaction type must not be 0\");\n\n        RLPReader.RLPItem[] memory outputList = rlpTx[2].toList();\n        Output[] memory outputs = new Output[](outputList.length);\n        for (uint i = 0; i < outputList.length; i++) {\n            outputs[i] = decodeOutput(outputList[i]);\n        }\n\n        bytes32 metaData = rlpTx[4].toBytes32();\n\n        return Transaction({\n            txType: txType,\n            inputs: rlpTx[1].toList(),\n            outputs: outputs,\n            txData: rlpTx[3],\n            metaData: metaData\n        });\n    }\n\n    /**\n    * @dev Returns the output at a specific index in the transaction\n    */\n    function getOutput(Transaction memory transaction, uint16 outputIndex)\n        internal\n        pure\n        returns (Output memory)\n    {\n        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n        return transaction.outputs[outputIndex];\n    }\n\n    /**\n    * @dev Decodes an RLPItem to an output\n    */\n    function decodeOutput(RLPReader.RLPItem memory encodedOutput)\n        internal\n        pure\n        returns (Output memory)\n    {\n        RLPReader.RLPItem[] memory rlpList = encodedOutput.toList();\n        require(rlpList.length == 2, \"Output must have 2 items\");\n\n        Output memory output = Output({\n            outputType: rlpList[0].toUint(),\n            data: rlpList[1]\n        });\n\n        require(output.outputType != 0, \"Output type must not be 0\");\n        return output;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/transactions/PaymentTransactionModel.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"./FungibleTokenOutputModel.sol\";\nimport \"../utils/RLPReader.sol\";\n\n/**\n * @notice Data structure and its decode function for Payment transaction\n */\nlibrary PaymentTransactionModel {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n\n    uint8 constant private _MAX_INPUT_NUM = 4;\n    uint8 constant private _MAX_OUTPUT_NUM = 4;\n\n    uint8 constant private ENCODED_LENGTH = 4;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MAX_INPUT_NUM() internal pure returns (uint8) {\n        return _MAX_INPUT_NUM;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MAX_OUTPUT_NUM() internal pure returns (uint8) {\n        return _MAX_OUTPUT_NUM;\n    }\n\n    struct Transaction {\n        uint256 txType;\n        bytes32[] inputs;\n        FungibleTokenOutputModel.Output[] outputs;\n        uint256 txData;\n        bytes32 metaData;\n    }\n\n    /**\n     * @notice Decodes a encoded byte array into a PaymentTransaction\n     * The following rules about the rlp-encoded transaction are enforced:\n     *      - `txType` must be an integer value with no leading zeros\n     *      - `inputs` is an list of 0 to 4 elements\n     *      - Each `input` is a 32 byte long array\n     *      - An `input` may not be all zeros\n     *      - `outputs` is an list of 0 to 4 elements\n     *      - Each `output` is a list of 2 elements: [`outputType`, `data`]\n     *      - `output.outputType` must be an integer value with no leading zeros\n     *      - See FungibleTokenOutputModel for deatils on `output.data` encoding.\n     *      - An `output` may not be null; A null output is one whose amount is zero\n     * @param _tx An RLP-encoded transaction\n     * @return A decoded PaymentTransaction struct\n     */\n    function decode(bytes memory _tx) internal pure returns (PaymentTransactionModel.Transaction memory) {\n        return fromGeneric(GenericTransaction.decode(_tx));\n    }\n\n    /**\n     * @notice Converts a GenericTransaction to a PaymentTransaction\n     * @param genericTx A GenericTransaction.Transaction struct\n     * @return A PaymentTransaction.Transaction struct\n     */\n    function fromGeneric(GenericTransaction.Transaction memory genericTx)\n        internal\n        pure\n        returns (PaymentTransactionModel.Transaction memory)\n    {\n        require(genericTx.inputs.length <= _MAX_INPUT_NUM, \"Transaction inputs num exceeds limit\");\n        require(genericTx.outputs.length != 0, \"Transaction cannot have 0 outputs\");\n        require(genericTx.outputs.length <= _MAX_OUTPUT_NUM, \"Transaction outputs num exceeds limit\");\n\n        bytes32[] memory inputs = new bytes32[](genericTx.inputs.length);\n        for (uint i = 0; i < genericTx.inputs.length; i++) {\n            bytes32 input = genericTx.inputs[i].toBytes32();\n            require(uint256(input) != 0, \"Null input not allowed\");\n            inputs[i] = input;\n        }\n\n        FungibleTokenOutputModel.Output[] memory outputs = new FungibleTokenOutputModel.Output[](genericTx.outputs.length);\n        for (uint i = 0; i < genericTx.outputs.length; i++) {\n            outputs[i] = FungibleTokenOutputModel.decodeOutput(genericTx.outputs[i]);\n        }\n\n        // txData is unused, it must be 0\n        require(genericTx.txData.toUint() == 0, \"txData must be 0\");\n\n        return Transaction({\n            txType: genericTx.txType,\n            inputs: inputs,\n            outputs: outputs,\n            txData: 0,\n            metaData: genericTx.metaData\n        });\n    }\n\n    /**\n     * @notice Retrieve the 'owner' from the output, assuming the\n     *         'outputGuard' field directly holds the owner's address\n     */\n    function getOutputOwner(FungibleTokenOutputModel.Output memory output) internal pure returns (address payable) {\n        return address(uint160(output.outputGuard));\n    }\n\n    /**\n     * @notice Gets output at provided index\n     *\n     */\n    function getOutput(Transaction memory transaction, uint16 outputIndex) internal pure returns (FungibleTokenOutputModel.Output memory) {\n        require(outputIndex < transaction.outputs.length, \"Output index out of bounds\");\n        return transaction.outputs[outputIndex];\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/transactions/eip712Libs/PaymentEip712Lib.sol": {
      "content": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"../PaymentTransactionModel.sol\";\nimport \"../../utils/PosLib.sol\";\n\n/**\n * @title PaymentEip712Lib\n * @notice Utilities for hashing structural data for PaymentTransaction (see EIP-712)\n *\n * @dev EIP712: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\n *      We rely on the contract address to protect against replay attacks instead of using chain ID\n *      For more information, see https://github.com/omisego/plasma-contracts/issues/98#issuecomment-490792098\n */\nlibrary PaymentEip712Lib {\n    using PosLib for PosLib.Position;\n\n    bytes2 constant internal EIP191_PREFIX = \"\\x19\\x01\";\n\n    bytes32 constant internal EIP712_DOMAIN_HASH = keccak256(\n        \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n    );\n\n    bytes32 constant internal TX_TYPE_HASH = keccak256(\n        \"Transaction(uint256 txType,Input input0,Input input1,Input input2,Input input3,Output output0,Output output1,Output output2,Output output3,uint256 txData,bytes32 metadata)Input(uint256 blknum,uint256 txindex,uint256 oindex)Output(uint256 outputType,bytes20 outputGuard,address currency,uint256 amount)\"\n    );\n\n    bytes32 constant internal INPUT_TYPE_HASH = keccak256(\"Input(uint256 blknum,uint256 txindex,uint256 oindex)\");\n    bytes32 constant internal OUTPUT_TYPE_HASH = keccak256(\"Output(uint256 outputType,bytes20 outputGuard,address currency,uint256 amount)\");\n    bytes32 constant internal SALT = 0xfad5c7f626d80f9256ef01929f3beb96e058b8b4b0e3fe52d84f054c0e2a7a83;\n\n    bytes32 constant internal EMPTY_INPUT_HASH = keccak256(abi.encode(INPUT_TYPE_HASH, 0, 0, 0));\n    bytes32 constant internal EMPTY_OUTPUT_HASH = keccak256(abi.encode(OUTPUT_TYPE_HASH, 0, bytes20(0x0), address(0x0), 0));\n\n    struct Constants {\n        // solhint-disable-next-line var-name-mixedcase\n        bytes32 DOMAIN_SEPARATOR;\n    }\n\n    function initConstants(address _verifyingContract) internal pure returns (Constants memory) {\n        // solhint-disable-next-line var-name-mixedcase\n        bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(\n            EIP712_DOMAIN_HASH,\n            keccak256(\"OMG Network\"),\n            keccak256(\"1\"),\n            address(_verifyingContract),\n            SALT\n        ));\n\n        return Constants({\n            DOMAIN_SEPARATOR: DOMAIN_SEPARATOR\n        });\n    }\n\n    // The 'encode(domainSeparator, message)' of the EIP712 specification\n    // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification\n    function hashTx(Constants memory _eip712, PaymentTransactionModel.Transaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\n            EIP191_PREFIX,\n            _eip712.DOMAIN_SEPARATOR,\n            _hashTx(_tx)\n        ));\n    }\n\n    // The 'hashStruct(message)' function of transaction\n    // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#definition-of-hashstruct\n    function _hashTx(PaymentTransactionModel.Transaction memory _tx)\n        private\n        pure\n        returns (bytes32)\n    {\n        // Pad empty value to input array\n        bytes32[] memory inputs = new bytes32[](PaymentTransactionModel.MAX_INPUT_NUM());\n        for (uint i = 0; i < _tx.inputs.length; i++) {\n            inputs[i] = _tx.inputs[i];\n        }\n\n        // Pad empty value to output array\n        FungibleTokenOutputModel.Output[] memory outputs = new FungibleTokenOutputModel.Output[](PaymentTransactionModel.MAX_OUTPUT_NUM());\n        for (uint i = 0; i < _tx.outputs.length; i++) {\n            outputs[i] = _tx.outputs[i];\n        }\n\n        return keccak256(abi.encode(\n            TX_TYPE_HASH,\n            _tx.txType,\n            _hashInput(inputs[0]),\n            _hashInput(inputs[1]),\n            _hashInput(inputs[2]),\n            _hashInput(inputs[3]),\n            _hashOutput(outputs[0]),\n            _hashOutput(outputs[1]),\n            _hashOutput(outputs[2]),\n            _hashOutput(outputs[3]),\n            _tx.txData,\n            _tx.metaData\n        ));\n    }\n\n    function _hashInput(bytes32 _input) private pure returns (bytes32) {\n        uint256 inputUtxoValue = uint256(_input);\n        if (inputUtxoValue == 0) {\n            return EMPTY_INPUT_HASH;\n        }\n\n        PosLib.Position memory utxo = PosLib.decode(inputUtxoValue);\n        return keccak256(abi.encode(\n            INPUT_TYPE_HASH,\n            utxo.blockNum,\n            utxo.txIndex,\n            uint256(utxo.outputIndex)\n        ));\n    }\n\n    function _hashOutput(FungibleTokenOutputModel.Output memory _output)\n        private\n        pure\n        returns (bytes32)\n    {\n        if (_output.amount == 0) {\n            return EMPTY_OUTPUT_HASH;\n        }\n\n        return keccak256(abi.encode(\n            OUTPUT_TYPE_HASH,\n            _output.outputType,\n            _output.outputGuard,\n            _output.token,\n            _output.amount\n        ));\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/Bits.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title Bits\n * @dev Operations on individual bits of a word\n */\nlibrary Bits {\n    /*\n     * Storage\n     */\n\n    uint constant internal ONE = uint(1);\n\n    /*\n     * Internal functions\n     */\n    /**\n     * @dev Sets the bit at the given '_index' in '_self' to '1'\n     * @param _self Uint to modify\n     * @param _index Index of the bit to set\n     * @return The modified value\n     */\n    function setBit(uint _self, uint8 _index)\n        internal\n        pure\n        returns (uint)\n    {\n        return _self | ONE << _index;\n    }\n\n    /**\n     * @dev Sets the bit at the given '_index' in '_self' to '0'\n     * @param _self Uint to modify\n     * @param _index Index of the bit to set\n     * @return The modified value\n     */\n    function clearBit(uint _self, uint8 _index)\n        internal\n        pure\n        returns (uint)\n    {\n        return _self & ~(ONE << _index);\n    }\n\n    /**\n     * @dev Returns the bit at the given '_index' in '_self'\n     * @param _self Uint to check\n     * @param _index Index of the bit to retrieve\n     * @return The value of the bit at '_index'\n     */\n    function getBit(uint _self, uint8 _index)\n        internal\n        pure\n        returns (uint8)\n    {\n        return uint8(_self >> _index & 1);\n    }\n\n    /**\n     * @dev Checks if the bit at the given '_index' in '_self' is '1'\n     * @param _self Uint to check\n     * @param _index Index of the bit to check\n     * @return True, if the bit is '0'; otherwise, False\n     */\n    function bitSet(uint _self, uint8 _index)\n        internal\n        pure\n        returns (bool)\n    {\n        return getBit(_self, _index) == 1;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/FailFastReentrancyGuard.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../framework/ExitGameController.sol\";\n\n/**\n * @notice Reentrancy guard that fails immediately when a reentrace occurs\n *         Works on multi-contracts level by activating and deactivating a reentrancy guard kept in plasma framework's state\n */\ncontract FailFastReentrancyGuard {\n\n    /**\n     * @dev Prevents reentrant calls by using a mutex.\n     */\n    modifier nonReentrant(ExitGameController exitGameController) {\n        exitGameController.activateNonReentrant();\n        _;\n        exitGameController.deactivateNonReentrant();\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/Merkle.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n * @title Merkle\n * @dev Library for working with Merkle trees\n */\nlibrary Merkle {\n    byte private constant LEAF_SALT = 0x00;\n    byte private constant NODE_SALT = 0x01;\n\n    /**\n     * @notice Checks that a leaf hash is contained in a root hash\n     * @param leaf Leaf hash to verify\n     * @param index Position of the leaf hash in the Merkle tree\n     * @param rootHash Root of the Merkle tree\n     * @param proof A Merkle proof demonstrating membership of the leaf hash\n     * @return True, if the leaf hash is in the Merkle tree; otherwise, False\n    */\n    function checkMembership(bytes memory leaf, uint256 index, bytes32 rootHash, bytes memory proof)\n        internal\n        pure\n        returns (bool)\n    {\n        require(proof.length != 0, \"Merkle proof must not be empty\");\n        require(proof.length % 32 == 0, \"Length of Merkle proof must be a multiple of 32\");\n\n        // see https://github.com/omisego/plasma-contracts/issues/546\n        require(index < 2**(proof.length/32), \"Index does not match the length of the proof\");\n\n        bytes32 proofElement;\n        bytes32 computedHash = keccak256(abi.encodePacked(LEAF_SALT, leaf));\n        uint256 j = index;\n        // Note: We're skipping the first 32 bytes of `proof`, which holds the size of the dynamically sized `bytes`\n        for (uint256 i = 32; i <= proof.length; i += 32) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                proofElement := mload(add(proof, i))\n            }\n            if (j % 2 == 0) {\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, computedHash, proofElement));\n            } else {\n                computedHash = keccak256(abi.encodePacked(NODE_SALT, proofElement, computedHash));\n            }\n            j = j / 2;\n        }\n\n        return computedHash == rootHash;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/OnlyFromAddress.sol": {
      "content": "pragma solidity 0.5.11;\n\ncontract OnlyFromAddress {\n\n    modifier onlyFrom(address caller) {\n        require(msg.sender == caller, \"Caller address is unauthorized\");\n        _;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/OnlyWithValue.sol": {
      "content": "pragma solidity 0.5.11;\n\ncontract OnlyWithValue {\n    modifier onlyWithValue(uint256 _value) {\n        require(msg.value == _value, \"Input value must match msg.value\");\n        _;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/PosLib.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @dev UTXO position = (blknum * BLOCK_OFFSET + txIndex * TX_OFFSET + outputIndex).\n * TX position = (blknum * BLOCK_OFFSET + txIndex * TX_OFFSET)\n */\nlibrary PosLib {\n    struct Position {\n        uint64 blockNum;\n        uint16 txIndex;\n        uint16 outputIndex;\n    }\n\n    uint256 constant internal BLOCK_OFFSET = 1000000000;\n    uint256 constant internal TX_OFFSET = 10000;\n    \n    uint256 constant internal MAX_OUTPUT_INDEX = TX_OFFSET - 1;\n    // since we are using merkle tree of depth 16, max tx index size is 2^16 - 1\n    uint256 constant internal MAX_TX_INDEX = 2 ** 16 - 1;\n    // in ExitPriority, only 54 bits are reserved for both blockNum and txIndex\n    uint256 constant internal MAX_BLOCK_NUM = ((2 ** 54 - 1) - MAX_TX_INDEX) / (BLOCK_OFFSET / TX_OFFSET);\n\n    /**\n     * @notice Returns transaction position which is an utxo position of zero index output\n     * @param pos UTXO position of the output\n     * @return Position of a transaction\n     */\n    function toStrictTxPos(Position memory pos)\n        internal\n        pure\n        returns (Position memory)\n    {\n        return Position(pos.blockNum, pos.txIndex, 0);\n    }\n\n    /**\n     * @notice Used for calculating exit priority\n     * @param pos UTXO position for the output\n     * @return Identifier of the transaction\n     */\n    function getTxPositionForExitPriority(Position memory pos)\n        internal\n        pure\n        returns (uint256)\n    {\n        return encode(pos) / TX_OFFSET;\n    }\n\n    /**\n     * @notice Encodes a position\n     * @param pos Position\n     * @return Position encoded as an integer\n     */\n    function encode(Position memory pos) internal pure returns (uint256) {\n        require(pos.outputIndex <= MAX_OUTPUT_INDEX, \"Invalid output index\");\n        require(pos.blockNum <= MAX_BLOCK_NUM, \"Invalid block number\");\n\n        return pos.blockNum * BLOCK_OFFSET + pos.txIndex * TX_OFFSET + pos.outputIndex;\n    }\n\n    /**\n     * @notice Decodes a position from an integer value\n     * @param pos Encoded position\n     * @return Position\n     */\n    function decode(uint256 pos) internal pure returns (Position memory) {\n        uint256 blockNum = pos / BLOCK_OFFSET;\n        uint256 txIndex = (pos % BLOCK_OFFSET) / TX_OFFSET;\n        uint16 outputIndex = uint16(pos % TX_OFFSET);\n\n        require(blockNum <= MAX_BLOCK_NUM, \"blockNum exceeds max size allowed in PlasmaFramework\");\n        require(txIndex <= MAX_TX_INDEX, \"txIndex exceeds the size of uint16\");\n        return Position(uint64(blockNum), uint16(txIndex), outputIndex);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/RLPReader.sol": {
      "content": "/**\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * @notice RLP decoding library forked from https://github.com/hamdiallam/Solidity-RLP\n * @dev Some changes that were made to the library are:\n *      - Added more test cases from https://github.com/ethereum/tests/tree/master/RLPTests\n *      - Created more custom invalid test cases\n *      - Added more checks to ensure the decoder reads within bounds of the input length\n *      - Moved utility functions necessary to run some of the tests to the RLPMock.sol\n*/\n\npragma solidity 0.5.11;\n\nlibrary RLPReader {\n    uint8 constant internal STRING_SHORT_START = 0x80;\n    uint8 constant internal STRING_LONG_START  = 0xb8;\n    uint8 constant internal LIST_SHORT_START   = 0xc0;\n    uint8 constant internal LIST_LONG_START    = 0xf8;\n    uint8 constant internal MAX_SHORT_LEN      = 55;\n    uint8 constant internal WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    /**\n     * @notice Convert a dynamic bytes array into an RLPItem\n     * @param item RLP encoded bytes\n     * @return An RLPItem\n     */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint256 memPtr;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /**\n    * @notice Convert a dynamic bytes array into a list of RLPItems\n    * @param item RLP encoded list in bytes\n    * @return A list of RLPItems\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item), \"Item is not a list\");\n\n        (uint256 listLength, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n        require(listLength == item.len, \"Decoded RLP length for list is invalid\");\n\n        uint256 items = countEncodedItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 dataMemPtr = item.memPtr + offset;\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            (dataLen, ) = decodeLengthAndOffset(dataMemPtr);\n            result[i] = RLPItem(dataLen, dataMemPtr);\n            dataMemPtr = dataMemPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    /**\n    * @notice Check whether the RLPItem is either a list\n    * @param item RLP encoded list in bytes\n    * @return A boolean whether the RLPItem is a list\n    */\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /**\n     * @notice Create an address from a RLPItem\n     * @dev Function is not a standard RLP decoding function and it used to decode to the Solidity native address type\n     * @param item RLPItem\n     */\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        require(item.len == 21, \"Item length must be 21\");\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n        require(itemLen == 21, \"Decoded item length must be 21\");\n\n        uint256 dataMemPtr = item.memPtr + offset;\n        uint256 result;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(dataMemPtr)\n            // right shift by 12 to make bytes20\n            result := div(result, exp(256, 12))\n        }\n\n        return address(result);\n    }\n\n    /**\n     * @notice Create a uint256 from a RLPItem. Leading zeros are invalid.\n     * @dev Function is not a standard RLP decoding function and it used to decode to the Solidity native uint256 type\n     * @param item RLPItem\n     */\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33, \"Item length must be between 1 and 33 bytes\");\n        require(!isList(item), \"Item must not be a list\");\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n        require(itemLen == item.len, \"Decoded item length must be equal to the input data length\");\n\n        uint256 dataLen = itemLen - offset;\n\n        uint result;\n        uint dataByte0;\n        uint dataMemPtr = item.memPtr + offset;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(dataMemPtr)\n            dataByte0 := byte(0, result)\n            // shift to the correct location if necessary\n            if lt(dataLen, WORD_SIZE) {\n                result := div(result, exp(256, sub(WORD_SIZE, dataLen)))\n            }\n        }\n        // Special case: scalar 0 should be encoded as 0x80 and _not_ as 0x00\n        require(!(dataByte0 == 0 && offset == 0), \"Scalar 0 should be encoded as 0x80\");\n\n        // Disallow leading zeros\n        require(!(dataByte0 == 0 && dataLen > 1), \"Leading zeros are invalid\");\n\n        return result;\n    }\n\n    /**\n     * @notice Create a bytes32 from a RLPItem\n    * @dev Function is not a standard RLP decoding function and it used to decode to the Solidity native bytes32 type\n     * @param item RLPItem\n     */\n    function toBytes32(RLPItem memory item) internal pure returns (bytes32) {\n        // 1 byte for the length prefix\n        require(item.len == 33, \"Item length must be 33\");\n        require(!isList(item), \"Item must not be a list\");\n\n        (uint256 itemLen, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n        require(itemLen == 33, \"Decoded item length must be 33\");\n\n        uint256 dataMemPtr = item.memPtr + offset;\n        bytes32 result;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            result := mload(dataMemPtr)\n        }\n\n        return result;\n    }\n\n    /**\n    * @notice Counts the number of payload items inside an RLP encoded list\n    * @param item RLPItem\n    * @return The number of items in a inside an RLP encoded list\n    */\n    function countEncodedItems(RLPItem memory item) private pure returns (uint256) {\n        uint256 count = 0;\n        (, uint256 offset) = decodeLengthAndOffset(item.memPtr);\n        uint256 currPtr = item.memPtr + offset;\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            (uint256 currLen, ) = decodeLengthAndOffset(currPtr);\n            currPtr = currPtr + currLen;\n            require(currPtr <= endPtr, \"Invalid decoded length of RLP item found during counting items in a list\");\n            count++;\n        }\n\n        return count;\n    }\n\n    /**\n     * @notice Decodes the RLPItem's length and offset.\n     * @dev This function is dangerous. Ensure that the returned length is within bounds that memPtr points to.\n     * @param memPtr Pointer to the dynamic bytes array in memory\n     * @return The length of the RLPItem (including the length field) and the offset of the payload\n     */\n    function decodeLengthAndOffset(uint256 memPtr) internal pure returns (uint256, uint256) {\n        uint256 decodedLength;\n        uint256 offset;\n        uint256 byte0;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) {\n            // Item is a single byte\n            decodedLength = 1;\n            offset = 0;\n        } else if (STRING_SHORT_START <= byte0 && byte0 < STRING_LONG_START) {\n            // The range of the first byte is between 0x80 and 0xb7 therefore it is a short string\n            // decodedLength is between 1 and 56 bytes\n            decodedLength = (byte0 - STRING_SHORT_START) + 1;\n            if (decodedLength == 2){\n                uint256 byte1;\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    byte1 := byte(0, mload(add(memPtr, 1)))\n                }\n                // A single byte below 0x80 must be encoded as itself.\n                require(byte1 >= STRING_SHORT_START, \"Invalid short string encoding\");\n            }\n            offset = 1;\n        } else if (STRING_LONG_START <= byte0 && byte0 < LIST_SHORT_START) {\n            // The range of the first byte is between 0xb8 and 0xbf therefore it is a long string\n            // lengthLen is between 1 and 8 bytes\n            // dataLen is greater than 55 bytes\n            uint256 dataLen;\n            uint256 byte1;\n            uint256 lengthLen;\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                lengthLen := sub(byte0, 0xb7) // The length of the length of the payload is encoded in the first byte.\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                // right shift to the correct position\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n                decodedLength := add(dataLen, add(lengthLen, 1))\n                byte1 := byte(0, mload(memPtr))\n            }\n\n            // Check that the length has no leading zeros\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long string\");\n            // Check that the value of length > MAX_SHORT_LEN\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long string\");\n            // Calculate the offset\n            offset = lengthLen + 1;\n        } else if (LIST_SHORT_START <= byte0 && byte0 < LIST_LONG_START) {\n            // The range of the first byte is between 0xc0 and 0xf7 therefore it is a short list\n            // decodedLength is between 1 and 56 bytes\n            decodedLength = (byte0 - LIST_SHORT_START) + 1;\n            offset = 1;\n        } else {\n            // The range of the first byte is between 0xf8 and 0xff therefore it is a long list\n            // lengthLen is between 1 and 8 bytes\n            // dataLen is greater than 55 bytes\n            uint256 dataLen;\n            uint256 byte1;\n            uint256 lengthLen;\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                lengthLen := sub(byte0, 0xf7) // The length of the length of the payload is encoded in the first byte.\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                // right shift to the correct position\n                dataLen := div(mload(memPtr), exp(256, sub(WORD_SIZE, lengthLen)))\n                decodedLength := add(dataLen, add(lengthLen, 1))\n                byte1 := byte(0, mload(memPtr))\n            }\n\n            // Check that the length has no leading zeros\n            require(byte1 != 0, \"Invalid leading zeros in length of the length for a long list\");\n            // Check that the value of length > MAX_SHORT_LEN\n            require(dataLen > MAX_SHORT_LEN, \"Invalid length for a long list\");\n            // Calculate the offset\n            offset = lengthLen + 1;\n        }\n\n        return (decodedLength, offset);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/utils/SafeEthTransfer.sol": {
      "content": "pragma solidity 0.5.11;\n\n/**\n* @notice Utility library to safely transfer ETH\n* @dev transfer is no longer the recommended way to do ETH transfer.\n*      see issue: https://github.com/omisego/plasma-contracts/issues/312\n*\n*      This library limits the amount of gas used for external calls with value to protect against potential DOS/griefing attacks that try to use up all the gas.\n*      see issue: https://github.com/omisego/plasma-contracts/issues/385\n*/\nlibrary SafeEthTransfer {\n    /**\n     * @notice Try to transfer eth without using more gas than `gasStipend`.\n     *         Reverts if it fails to transfer the ETH.\n     * @param receiver the address to receive ETH\n     * @param amount the amount of ETH (in wei) to transfer\n     * @param gasStipend the maximum amount of gas to be used for the call\n     */\n    function transferRevertOnError(address payable receiver, uint256 amount, uint256 gasStipend)\n        internal\n    {\n        bool success = transferReturnResult(receiver, amount, gasStipend);\n        require(success, \"SafeEthTransfer: failed to transfer ETH\");\n    }\n\n    /**\n     * @notice Transfer ETH without using more gas than the `gasStipend`.\n     *         Returns whether the transfer call is successful or not.\n     * @dev EVM will revert with \"out of gas\" error if there is not enough gas left for the call\n     * @param receiver the address to receive ETH\n     * @param amount the amount of ETH (in wei) to transfer\n     * @param gasStipend the maximum amount of gas to be used during the transfer call\n     * @return a flag showing the call is successful or not\n     */\n    function transferReturnResult(address payable receiver, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool)\n    {\n        (bool success, ) = receiver.call.gas(gasStipend).value(amount)(\"\");\n        return success;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/Erc20Vault.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"./Vault.sol\";\nimport \"./verifiers/IErc20DepositVerifier.sol\";\nimport \"../framework/PlasmaFramework.sol\";\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\n\ncontract Erc20Vault is Vault {\n    using SafeERC20 for IERC20;\n\n    event Erc20Withdrawn(\n        address indexed receiver,\n        address indexed token,\n        uint256 amount\n    );\n\n    event DepositCreated(\n        address indexed depositor,\n        uint256 indexed blknum,\n        address indexed token,\n        uint256 amount\n    );\n\n    constructor(PlasmaFramework _framework) public Vault(_framework) {}\n\n    /**\n     * @notice Deposits approved amount of ERC20 token(s) into the contract\n     * Once the deposit is recognized, the owner (depositor) can transact on the OmiseGO Network\n     * The approve function of the ERC20 token contract must be called before calling this function\n     * for at least the amount that is deposited into the contract\n     * @param depositTx RLP-encoded transaction to act as the deposit\n     */\n    function deposit(bytes calldata depositTx) external {\n        address depositVerifier = super.getEffectiveDepositVerifier();\n        require(depositVerifier != address(0), \"Deposit verifier has not been set\");\n\n        (address depositor, address token, uint256 amount) = IErc20DepositVerifier(depositVerifier)\n            .verify(depositTx, msg.sender, address(this));\n\n        IERC20(token).safeTransferFrom(depositor, address(this), amount);\n\n        uint256 blknum = super.submitDepositBlock(depositTx);\n\n        emit DepositCreated(msg.sender, blknum, token, amount);\n    }\n\n    /**\n    * @notice Withdraw ERC20 tokens that have successfully exited from the OmiseGO Network\n    * @param receiver Address of the recipient\n    * @param token Address of ERC20 token contract\n    * @param amount Amount to transfer\n    */\n    function withdraw(address payable receiver, address token, uint256 amount) external onlyFromNonQuarantinedExitGame {\n        IERC20(token).safeTransfer(receiver, amount);\n        emit Erc20Withdrawn(receiver, token, amount);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/EthVault.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"./Vault.sol\";\nimport \"./verifiers/IEthDepositVerifier.sol\";\nimport \"../framework/PlasmaFramework.sol\";\nimport \"../utils/SafeEthTransfer.sol\";\n\ncontract EthVault is Vault {\n    event EthWithdrawn(\n        address indexed receiver,\n        uint256 amount\n    );\n\n    event WithdrawFailed(\n        address indexed receiver,\n        uint256 amount\n    );\n\n    event DepositCreated(\n        address indexed depositor,\n        uint256 indexed blknum,\n        address indexed token,\n        uint256 amount\n    );\n\n    uint256 public safeGasStipend;\n\n    constructor(PlasmaFramework _framework, uint256 _safeGasStipend) public Vault(_framework) {\n        safeGasStipend = _safeGasStipend;\n    }\n\n    /**\n     * @notice Allows a user to deposit ETH into the contract\n     * Once the deposit is recognized, the owner may transact on the OmiseGO Network\n     * @param _depositTx RLP-encoded transaction to act as the deposit\n     */\n    function deposit(bytes calldata _depositTx) external payable {\n        address depositVerifier = super.getEffectiveDepositVerifier();\n        require(depositVerifier != address(0), \"Deposit verifier has not been set\");\n\n        IEthDepositVerifier(depositVerifier).verify(_depositTx, msg.value, msg.sender);\n        uint256 blknum = super.submitDepositBlock(_depositTx);\n\n        emit DepositCreated(msg.sender, blknum, address(0), msg.value);\n    }\n\n    /**\n    * @notice Withdraw ETH that has successfully exited from the OmiseGO Network\n    * @dev We do not want to block exit queue if a transfer is unsuccessful, so we don't revert on transfer error.\n    *      However, if there is not enough gas left for the safeGasStipend, then the EVM _will_ revert with an 'out of gas' error.\n    *      If this happens, the user should retry with higher gas.\n    * @param receiver Address of the recipient\n    * @param amount The amount of ETH to transfer\n    */\n    function withdraw(address payable receiver, uint256 amount) external onlyFromNonQuarantinedExitGame {\n        bool success = SafeEthTransfer.transferReturnResult(receiver, amount, safeGasStipend);\n        if (success) {\n            emit EthWithdrawn(receiver, amount);\n        } else {\n            emit WithdrawFailed(receiver, amount);\n        }\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/Vault.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"../framework/PlasmaFramework.sol\";\nimport \"../utils/OnlyFromAddress.sol\";\n\n/**\n * @notice Base contract for vault implementation\n * @dev This is the functionality to swap \"deposit verifier\"\n *      Setting a new deposit verifier allows an upgrade to a new deposit tx type without upgrading the vault\n */\ncontract Vault is OnlyFromAddress {\n\n    byte private constant LEAF_SALT = 0x00;\n    byte private constant NODE_SALT = 0x01;\n\n    event SetDepositVerifierCalled(address nextDepositVerifier);\n    PlasmaFramework internal framework;\n    bytes32[16] internal zeroHashes; // Pre-computes zero hashes to be used for building merkle tree for deposit block\n\n    /**\n     * @notice Stores deposit verifier contract addresses; first contract address is effective until the\n     *  `newDepositVerifierMaturityTimestamp`; second contract address becomes effective after that timestamp\n    */\n    address[2] public depositVerifiers;\n    uint256 public newDepositVerifierMaturityTimestamp = 2 ** 255; // point far in the future\n\n    constructor(PlasmaFramework _framework) public {\n        framework = _framework;\n        zeroHashes = getZeroHashes();\n    }\n\n    /**\n     * @dev Pre-computes zero hashes to be used for building Merkle tree for deposit block\n     */\n    function getZeroHashes() private pure returns (bytes32[16] memory) {\n        bytes32[16] memory hashes;\n        bytes32 zeroHash = keccak256(abi.encodePacked(LEAF_SALT, uint256(0)));\n        for (uint i = 0; i < 16; i++) {\n            hashes[i] = zeroHash;\n            zeroHash = keccak256(abi.encodePacked(NODE_SALT, zeroHash, zeroHash));\n        }\n        return hashes;\n    }\n\n    /**\n     * @notice Checks whether the call originates from a non-quarantined exit game contract\n    */\n    modifier onlyFromNonQuarantinedExitGame() {\n        require(\n            ExitGameRegistry(framework).isExitGameSafeToUse(msg.sender),\n            \"Called from a non-registered or quarantined exit game contract\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Sets the deposit verifier contract, which may be called only by the operator\n     * @dev emit SetDepositVerifierCalled\n     * @dev When one contract is already set, the next one is effective after 2 * MIN_EXIT_PERIOD.\n     *      This is to protect deposit transactions already in mempool,\n     *      and also make sure user only needs to SE within first week when invalid vault is registered.\n     *\n     *      see: https://github.com/omisego/plasma-contracts/issues/412\n     *           https://github.com/omisego/plasma-contracts/issues/173\n     *\n     * @param _verifier Address of the verifier contract\n     */\n    function setDepositVerifier(address _verifier) public onlyFrom(framework.getMaintainer()) {\n        require(_verifier != address(0), \"Cannot set an empty address as deposit verifier\");\n\n        if (depositVerifiers[0] != address(0)) {\n            depositVerifiers[0] = getEffectiveDepositVerifier();\n            depositVerifiers[1] = _verifier;\n            newDepositVerifierMaturityTimestamp = now + 2 * framework.minExitPeriod();\n        } else {\n            depositVerifiers[0] = _verifier;\n        }\n\n        emit SetDepositVerifierCalled(_verifier);\n    }\n\n    /**\n     * @notice Retrieves the currently effective deposit verifier contract address\n     * @return Contract address of the deposit verifier\n     */\n    function getEffectiveDepositVerifier() public view returns (address) {\n        if (now < newDepositVerifierMaturityTimestamp) {\n            return depositVerifiers[0];\n        } else {\n            return depositVerifiers[1];\n        }\n    }\n\n    /**\n     * @notice Generate and submit a deposit block root to the PlasmaFramework\n     * @dev Designed to be called by the contract that inherits Vault\n     */\n    function submitDepositBlock(bytes memory depositTx) internal returns (uint256) {\n        bytes32 root = getDepositBlockRoot(depositTx);\n\n        uint256 depositBlkNum = framework.submitDepositBlock(root);\n        return depositBlkNum;\n    }\n\n    function getDepositBlockRoot(bytes memory depositTx) private view returns (bytes32) {\n        bytes32 root = keccak256(abi.encodePacked(LEAF_SALT, depositTx));\n        for (uint i = 0; i < 16; i++) {\n            root = keccak256(abi.encodePacked(NODE_SALT, root, zeroHashes[i]));\n        }\n        return root;\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/verifiers/Erc20DepositVerifier.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IErc20DepositVerifier.sol\";\nimport {PaymentTransactionModel as DepositTx} from \"../../transactions/PaymentTransactionModel.sol\";\n\n/**\n * @notice Implementation of Erc20 deposit verifier using payment transaction as the deposit tx\n */\ncontract Erc20DepositVerifier is IErc20DepositVerifier {\n    uint256 public depositTxType;\n    uint256 public supportedOutputType;\n\n    constructor(uint256 txType, uint256 outputType) public {\n        depositTxType = txType;\n        supportedOutputType = outputType;\n    }\n\n    /**\n     * @notice Overrides the function of IErc20DepositVerifier and implements the verification logic\n     *         for payment transaction\n     * @dev Vault address must be approved to transfer from the sender address before doing the deposit\n     * @return Verified (owner, token, amount) of the deposit ERC20 token data\n     */\n    function verify(bytes calldata depositTx, address sender, address vault)\n        external\n        view\n        returns (\n            address owner,\n            address token,\n            uint256 amount\n        )\n    {\n        DepositTx.Transaction memory decodedTx = DepositTx.decode(depositTx);\n\n        require(decodedTx.txType == depositTxType, \"Invalid transaction type\");\n\n        require(decodedTx.inputs.length == 0, \"Deposit must have no inputs\");\n\n        require(decodedTx.outputs.length == 1, \"Deposit must have exactly one output\");\n        require(decodedTx.outputs[0].token != address(0), \"Invalid output currency (ETH)\");\n        require(decodedTx.outputs[0].outputType == supportedOutputType, \"Invalid output type\");\n\n        address depositorsAddress = DepositTx.getOutputOwner(decodedTx.outputs[0]);\n        require(depositorsAddress == sender, \"Depositor's address must match sender's address\");\n\n        IERC20 erc20 = IERC20(decodedTx.outputs[0].token);\n        require(erc20.allowance(depositorsAddress, vault) >= decodedTx.outputs[0].amount, \"Tokens have not been approved\");\n\n        return (depositorsAddress, decodedTx.outputs[0].token, decodedTx.outputs[0].amount);\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/verifiers/EthDepositVerifier.sol": {
      "content": "pragma solidity 0.5.11;\n\nimport \"./IEthDepositVerifier.sol\";\nimport {PaymentTransactionModel as DepositTx} from \"../../transactions/PaymentTransactionModel.sol\";\n\n/**\n * @notice Implementation of ETH deposit verifier using payment transaction as the deposit transaction\n */\ncontract EthDepositVerifier is IEthDepositVerifier {\n    uint256 public depositTxType;\n    uint256 public supportedOutputType;\n\n    constructor(uint256 txType, uint256 outputType) public {\n        depositTxType = txType;\n        supportedOutputType = outputType;\n    }\n\n    /**\n     * @notice Overrides the function of IEthDepositVerifier and implements the verification logic\n     *         for payment transaction\n     */\n    function verify(bytes calldata depositTx, uint256 amount, address sender) external view {\n        DepositTx.Transaction memory decodedTx = DepositTx.decode(depositTx);\n\n        require(decodedTx.txType == depositTxType, \"Invalid transaction type\");\n\n        require(decodedTx.inputs.length == 0, \"Deposit must have no inputs\");\n\n        require(decodedTx.outputs.length == 1, \"Deposit must have exactly one output\");\n        require(decodedTx.outputs[0].amount == amount, \"Deposited value must match sent amount\");\n        require(decodedTx.outputs[0].token == address(0), \"Output requires correct currency (ETH)\");\n        require(decodedTx.outputs[0].outputType == supportedOutputType, \"Invalid output type\");\n\n        address depositorsAddress = DepositTx.getOutputOwner(decodedTx.outputs[0]);\n        require(depositorsAddress == sender, \"Depositor's address must match sender's address\");\n    }\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/verifiers/IErc20DepositVerifier.sol": {
      "content": "pragma solidity 0.5.11;\n\ninterface IErc20DepositVerifier {\n    /**\n     * @notice Verifies a deposit transaction\n     * @param depositTx The deposit transaction\n     * @param sender The owner of the deposit transaction\n     * @param vault The address of the Erc20Vault contract\n     * @return Verified (owner, token, amount) of the deposit ERC20 token data\n     */\n    function verify(bytes calldata depositTx, address sender, address vault)\n        external\n        view\n        returns (address owner, address token, uint256 amount);\n}\n"
    },
    "/Users/jake/plasma-contracts/plasma_framework/contracts/src/vaults/verifiers/IEthDepositVerifier.sol": {
      "content": "pragma solidity 0.5.11;\n\ninterface IEthDepositVerifier {\n    /**\n     * @notice Verifies a deposit transaction\n     * @param depositTx The deposit transaction\n     * @param amount The amount deposited\n     * @param sender The owner of the deposit transaction\n     */\n    function verify(bytes calldata depositTx, uint256 amount, address sender) external view;\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Mintable.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../../access/roles/MinterRole.sol\";\n\n/**\n * @dev Extension of `ERC20` that adds a set of accounts with the `MinterRole`,\n * which have permission to mint (create) new tokens as they see fit.\n *\n * At construction, the deployer of the contract is the only minter.\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev See `ERC20._mint`.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MinterRole`.\n     */\n    function mint(address account, uint256 amount) public onlyMinter returns (bool) {\n        _mint(account, amount);\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * (.note) This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * (.warning) `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise)\n     * be too long), and then calling `toEthSignedMessageHash` on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * [`eth_sign`](https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign)\n     * JSON-RPC method.\n     *\n     * See `recover`.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return msg.sender == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * > Note: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Collection of functions related to the address type,\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * > It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/Math.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/roles/MinterRole.sol": {
      "content": "pragma solidity ^0.5.0;\n\nimport \"../Roles.sol\";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender), \"MinterRole: caller does not have the Minter role\");\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    }
  },
  "settings": {
    "libraries": {
      "": {
        "PaymentStartStandardExit": "0xf38380bbf08961123960fAd630a0609906849751",
        "PaymentChallengeStandardExit": "0x24c0a84090135AD04F257C85E10db6B4A74E0738",
        "PaymentProcessStandardExit": "0x5E84DF30ce17A9AC34E5474fc37a9c2267454518",
        "PaymentStartInFlightExit": "0x081d7B167a94E7421Ea5D0016C3D01E0cFf6B557",
        "PaymentPiggybackInFlightExit": "0x5d3EE50E31293B45A7eb8B864c0B015E169AC7D8",
        "PaymentChallengeIFENotCanonical": "0x9e3108FB11cAEDA64e264B2953a0eDa81cf1a650",
        "PaymentChallengeIFEInputSpent": "0xEf6133d149460C9B79e132517934f77F1E62b23e",
        "PaymentChallengeIFEOutputSpent": "0x7A8C0D7F1e6dBe36AB3A9adE0C44a0b868bB703F",
        "PaymentDeleteInFlightExit": "0x4f05855B6dF026726037500D10D91652b5C9e784",
        "PaymentProcessInFlightExit": "0x67C3E5524dBE05B54fE08c3D4af65c273B87E630"
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}