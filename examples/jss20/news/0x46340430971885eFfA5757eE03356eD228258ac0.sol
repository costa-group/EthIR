{"EtherSwap.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./Swap.sol\";\n\n// solium-disable security/no-call-value\ncontract EtherSwap is Swap {\n    enum OrderState { HasFundingBalance, Claimed, Refunded }\n\n    struct SwapOrder {\n        address payable user;\n        bytes32 paymentHash;\n        bytes32 preimage;\n        uint onchainAmount;\n        uint refundBlockHeight;\n        OrderState state;\n        bool exist;\n    }\n\n    mapping(bytes16 =\u003e SwapOrder) orders;\n\n    event OrderFundingReceived(bytes16 orderUUID, uint onchainAmount, bytes32 paymentHash, uint refundBlockHeight);\n    event OrderClaimed(bytes16 orderUUID);\n    event OrderRefunded(bytes16 orderUUID);\n\n    /**\n     * Allow the sender to fund a swap in one or more transactions.\n     */\n    function fund(bytes16 orderUUID, bytes32 paymentHash) external payable {\n        SwapOrder storage order = orders[orderUUID];\n\n        if (!order.exist) {\n            order.user = msg.sender;\n            order.exist = true;\n            order.paymentHash = paymentHash;\n            order.refundBlockHeight = block.number + refundDelay;\n            order.state = OrderState.HasFundingBalance;\n            order.onchainAmount = 0;\n        } else {\n            require(order.state == OrderState.HasFundingBalance, \"Order already claimed or refunded.\");\n        }\n        order.onchainAmount += msg.value;\n\n        emit OrderFundingReceived(orderUUID, order.onchainAmount, order.paymentHash, order.refundBlockHeight);\n    }\n\n    /**\n     * Allow the recipient to claim the funds once they know the preimage of the hashlock.\n     * Anyone can claim but tokens only send to owner.\n     */\n    function claim(bytes16 orderUUID, bytes32 preimage) external {\n        SwapOrder storage order = orders[orderUUID];\n\n        require(order.exist == true, \"Order does not exist.\");\n        require(order.state == OrderState.HasFundingBalance, \"Order cannot be claimed.\");\n        require(sha256(abi.encodePacked(preimage)) == order.paymentHash, \"Incorrect payment preimage.\");\n        require(block.number \u003c= order.refundBlockHeight, \"Too late to claim.\");\n\n        order.preimage = preimage;\n        order.state = OrderState.Claimed;\n\n        (bool success, ) = owner.call.value(order.onchainAmount)(\"\");\n        require(success, \"Transfer failed.\");\n\n        emit OrderClaimed(orderUUID);\n    }\n\n    /**\n     * Refund the sent amount back to the funder if the timelock has expired.\n     */\n    function refund(bytes16 orderUUID) external {\n        SwapOrder storage order = orders[orderUUID];\n\n        require(order.exist == true, \"Order does not exist.\");\n        require(order.state == OrderState.HasFundingBalance, \"Order cannot be refunded.\");\n        require(block.number \u003e order.refundBlockHeight, \"Too early to refund.\");\n\n        order.state = OrderState.Refunded;\n\n        (bool success, ) = order.user.call.value(order.onchainAmount)(\"\");\n        require(success, \"Transfer failed.\");\n\n        emit OrderRefunded(orderUUID);\n    }\n}\n"},"Owned.sol":{"content":"pragma solidity ^0.5.8;\n\ncontract Owned {\n    constructor() public { owner = msg.sender; }\n    address payable public owner;\n\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n}\n"},"Swap.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./Owned.sol\";\n\ncontract Swap is Owned {\n    // Refund delay. Default: 4 hours\n    uint public refundDelay = 4 * 60 * 4;\n\n    // Max possible refund delay: 5 days\n    uint constant MAX_REFUND_DELAY = 60 * 60 * 2 * 4;\n\n    /**\n     * Set the block height at which a refund will successfully process.\n     */\n    function setRefundDelay(uint delay) external onlyOwner {\n        require(delay \u003c= MAX_REFUND_DELAY, \"Delay is too large.\");\n        refundDelay = delay;\n    }\n}\n"}}