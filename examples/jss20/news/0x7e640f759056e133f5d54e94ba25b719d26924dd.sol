{"FITHTokenSale.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMathLib.sol\";\n\n/**\n * @dev Fiatech FITH token sale contract.\n */\ncontract FITHTokenSale\n{\n\tusing SafeMathLib for uint;\n\t\n    address payable public owner;\n    \n\tIERC20 public tokenContract;\n\t\n\tuint256 public tokenPrice;\n    uint256 public tokensSold;\n\t\n\t// tokens bought event raised when buyer purchases tokens\n    event TokensBought(address _buyer, uint256 _amount, uint256 _tokensSold);\n\t\n\t// token price update event\n\tevent TokenPriceUpdate(address _admin, uint256 _tokenPrice);\n\t\n\t\n\t\n\t/**\n\t * @dev Constructor\n\t */\n    constructor(IERC20 _tokenContract, uint256 _tokenPrice) public\n\t{\n\t\trequire(_tokenPrice \u003e 0, \"_tokenPrice greater than zero required\");\n\t\t\n        owner = msg.sender;\n        tokenContract = _tokenContract;\n        tokenPrice = _tokenPrice;\n    }\n\t\n\tmodifier onlyOwner() {\n        require(msg.sender == owner, \"Owner required\");\n        _;\n    }\n\t\n\tfunction tokensAvailable() public view returns (uint) {\n\t\treturn tokenContract.balanceOf(address(this));\n\t}\n\t\n\t\n\t\n\tfunction _buyTokens(uint256 _numberOfTokens) internal returns(bool) {\n        require(tokensAvailable() \u003e= _numberOfTokens, \"insufficient tokens on token-sale contract\");\n        require(tokenContract.transfer(msg.sender, _numberOfTokens), \"Transfer tokens to buyer failed\");\n\t\t\n        tokensSold += _numberOfTokens;\n\t\t\n        emit TokensBought(msg.sender, _numberOfTokens, tokensSold);\n\t\treturn true;\n    }\n\t\n\tfunction updateTokenPrice(uint256 _tokenPrice) public onlyOwner {\n        require(_tokenPrice \u003e 0 \u0026\u0026 _tokenPrice != tokenPrice, \"Token price must be greater than zero and different than current\");\n        \n\t\ttokenPrice = _tokenPrice;\n\t\temit TokenPriceUpdate(owner, _tokenPrice);\n    }\n\t\n    function buyTokens(uint256 _numberOfTokens) public payable {\n        require(msg.value == (_numberOfTokens * tokenPrice), \"Incorrect number of tokens\");\n        _buyTokens(_numberOfTokens);\n    }\n\t\n    function endSale() public onlyOwner {\n        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))), \"Transfer token-sale token balance to owner failed\");\n\t\t\n        // Just transfer the ether balance to the owner\n        owner.transfer(address(this).balance);\n    }\n\t\n\t/**\n\t * Accept ETH for tokens\n\t */\n    function () external payable {\n\t\tuint tks = (msg.value).div(tokenPrice);\n\t\t_buyTokens(tks);\n    }\n\t\n\t\n\t\n\t/**\n\t * @dev Owner can transfer out (recover) any ERC20 tokens accidentally sent to this contract.\n\t * @param tokenAddress Token contract address we want to recover lost tokens from.\n\t * @param tokens Amount of tokens to be recovered, usually the same as the balance of this contract.\n\t * @return bool\n\t */\n    function recoverAnyERC20Token(address tokenAddress, uint tokens) external onlyOwner returns (bool ok) {\n\t\tok = IERC20(tokenAddress).transfer(owner, tokens);\n    }\n}"},"FITHTokenSaleRefAndPromo.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMathLib.sol\";\nimport \"./FITHTokenSaleReferrals.sol\";\nimport \"./OrFeedInterface.sol\";\n\n/**\n * @dev Fiatech ETH discount sale promotion contract.\n */\ncontract FITHTokenSaleRefAndPromo is FITHTokenSaleReferrals\n{\n\tusing SafeMathLib for uint;\n\t\n\t// USDT stable coin smart contrat address\n\taddress public usdtContractAddress;\n\t\n\t// Oracle feed for ETH/USDT real time exchange rate contrat address\n\taddress public orFeedContractAddress;\n\t\n\tuint public oneEthAsWei = 10**18;\n\t\n\tuint public ethDiscountPercent = 5000; // percent = ethDiscountPercent / 10000 = 0.2 = 20%\n\t\n\t\n\t// eth each token sale user used to buy tokens\n\tmapping(address =\u003e uint) public ethBalances;\n\t\n\t// USDT balances for users participating in eth promo\n\tmapping(address =\u003e uint) public usdtBalances;\n\t\n\t\n\t// Eth Discount Percent updated event\n\tevent EthDiscountPercentUpdated(address indexed admin, uint newEthDiscountPercent);\n\t\n\t// USDT deposit event\n\tevent USDTDeposit(address indexed from, uint tokens);\n\t\n\t// USDT withdrawal event\n\tevent USDTWithdrawal(address indexed from, uint tokens);\n\t\n\t// Promo ETH bought event\n\tevent PromoEthBought(address indexed user, uint ethWei, uint usdtCost);\n\t\n\t\n\t\n\t/**\n\t * @dev Constructor\n\t */\n    constructor(IERC20 _tokenContract, uint256 _tokenPrice, IERC20 _usdStableCoinContract, OrFeedInterface _orFeedContract)\n\t\tFITHTokenSaleReferrals(_tokenContract, _tokenPrice)\n\t\tpublic\n\t{\n\t\tusdtContractAddress = address(_usdStableCoinContract);\n\t\torFeedContractAddress = address(_orFeedContract);\n    }\n\t\n\t\n\t\n\tfunction setOrFeedAddress(OrFeedInterface _orFeedContract) public onlyOwner returns(bool) {\n\t\trequire(orFeedContractAddress != address(_orFeedContract), \"New orfeed address required\");\n\t\t\n\t\torFeedContractAddress = address(_orFeedContract);\n\t\treturn true;\n\t}\n\t\n\tfunction getEthUsdPrice() public view returns(uint) {\n\t\treturn OrFeedInterface(orFeedContractAddress).getExchangeRate(\"ETH\", \"USDT\", \"DEFAULT\", oneEthAsWei);\n\t}\n\t\n\tfunction getEthWeiAmountPrice(uint ethWeiAmount) public view returns(uint) {\n\t\treturn OrFeedInterface(orFeedContractAddress).getExchangeRate(\"ETH\", \"USDT\", \"DEFAULT\", ethWeiAmount);\n\t}\n\t\n\t// update eth discount percent as integer down to 0.0001 discount\n\tfunction updateEthDiscountPercent(uint newEthDiscountPercent) public onlyOwner returns(bool) {\n\t\trequire(newEthDiscountPercent != ethDiscountPercent, \"EthPromo/same-eth-discount-percent\");\n\t\trequire(newEthDiscountPercent \u003e 0 \u0026\u0026 newEthDiscountPercent \u003c 10000, \"EthPromo/eth-discount-percent-out-of-range\");\n\t\t\n\t\tethDiscountPercent = newEthDiscountPercent;\n\t\temit EthDiscountPercentUpdated(msg.sender, newEthDiscountPercent);\n\t\treturn true;\n\t}\n\t\n\t\n\t\n\t// referer is address instead of string\n\tfunction fithBalanceOf(address user) public view returns(uint) {\n\t\t\n\t\treturn IERC20(tokenContract).balanceOf(user);\n    }\n\t\n\t//---\n\t// NOTE: Prior to calling this function, user has to call \"approve\" on the USDT contract allowing this contract to transfer on his behalf.\n\t// Transfer usdt stable coins on behalf of the user and register amounts for the ETH promo.\n\t// NOTE: This is needed for the ETH prmotion:\n\t// -To register each user USDT amounts for eth promo calculations and also to be able to withdraw user USDT at any time.\n\t//---\n\tfunction depositUSDTAfterApproval(address from, uint tokens) public returns(bool) {\n\t\t\n\t\t// this contract transfers USDT for deposit on behalf of user after approval\n\t\trequire(IERC20(usdtContractAddress).transferFrom(from, address(this), tokens), \"depositUSDTAfterApproval failed\");\n\t\t\n\t\t// register USDT amounts for each user\n\t\tusdtBalances[from] = usdtBalances[from].add(tokens);\n\t\t\n\t\temit USDTDeposit(from, tokens);\n\t\t\n\t\treturn true;\n\t}\n\t\n\t//---\n\t// User withdraws from his USDT balance available\n\t// NOTE: If sender is owner, he withdraws from USDT profit balance available\n\t//---\n\tfunction withdrawUSDT(uint tokens) public returns(bool) {\n\t\trequire(usdtBalances[msg.sender] \u003e= tokens, \"EthPromo/insufficient-USDT-balance\");\n\t\t\n\t\t// this contract transfers USDT to user\n\t\trequire(IERC20(usdtContractAddress).transfer(msg.sender, tokens), \"EthPromo/USDT.transfer failed\");\n\t\t\n\t\t// register USDT withdrawals for each user\n\t\tusdtBalances[msg.sender] = usdtBalances[msg.sender].sub(tokens);\n\t\t\n\t\temit USDTWithdrawal(msg.sender, tokens);\n\t\t\n\t\treturn true;\n\t}\n\t\n\t\n\t\n\t\n\t//---\n\t// Given eth wei amount return cost in USDT stable coin wei with 6 decimals.\n\t// This function can be used for debug and testing purposes by any user\n\t// and it is useful to see the discounted price in USDT for given amount of eth a user wants to purchase.\n\t//---\n\tfunction checkEthWeiPromoCost(uint ethWei) public view returns(uint256) {\n\t\tuint usdtCost = getEthWeiAmountPrice(ethWei);\n\t\t// calculate discounted price\n\t\treturn calculateUSDTWithDiscount(usdtCost);\n\t}\n\t\n\t//---\n\t// Function similar to \"checkEthWeiPromoCost\" but using optimized calculations to compare results.\n\t//---\n\tfunction checkEthWeiPromoCost_Opt(uint ethWei) public view returns(uint256) {\n\t\tuint ethPrice = getEthUsdPrice();\n\t\trequire(ethPrice \u003e 0, \"EthPromo/ethPrice-is-zero\");\n\t\t\n\t\t// calculate final discounted price\n\t\t//uint usdtCost = ethWei / (10**18) * ethPrice * (10000 - ethDiscountPercent) / 10000;\n\t\tuint usdtCost = ethWei.mul(ethPrice).mul(10000 - ethDiscountPercent).div(oneEthAsWei).div(10000);   //oneEthAsWei = 10**18 wei\n\t\treturn usdtCost;\n\t}\n\t\n\t\n\t\n\t// returns eth cost in USDT stable coin wei with 6 decimals\n\tfunction calculateEthWeiCost(uint ethWei) public view returns(uint256) {\n\t\treturn getEthWeiAmountPrice(ethWei);\n\t}\n\t\n\tfunction calculateUSDTWithDiscount(uint usdt) public view returns(uint256) {\n\t\t// we can represent discounts precision down to 0.01% = 0.0001, so we use 10000 factor\n\t\treturn (usdt.mul(10000 - ethDiscountPercent).div(10000));\n\t}\n\t\n\t//---\n\t// User buys eth at discount according to eth promo rules and his USDT balance available\n\t//---\n\tfunction buyEthAtDiscount(uint ethWei) public returns(bool) {\n\t\trequire(ethBalances[msg.sender] \u003e= ethWei, \"EthPromo/eth-promo-limit-reached\");\n\t\t\n\t\tuint usdtCost = checkEthWeiPromoCost(ethWei);\n\t\trequire(usdtCost \u003e 0, \"EthPromo/usdtCost-is-zero\");\n\t\t\n\t\t// register USDT withdrawals for each user\n\t\tusdtBalances[msg.sender] = usdtBalances[msg.sender].sub(usdtCost);\n\t\t\n\t\t// USDT profit goes to owner that can withdraw anytime after eth sales excluding users balances\n\t\tusdtBalances[owner] = usdtBalances[owner].add(usdtCost);\n\t\t\n\t\t// register eth promo left for current user\n\t\tethBalances[msg.sender] = ethBalances[msg.sender].sub(ethWei);\n\t\t\n\t\t// transfer to the user the ether he bought at promotion\n        (msg.sender).transfer(ethWei);\n\t\t\n\t\temit PromoEthBought(msg.sender, ethWei, usdtCost);\n\t\t\n\t\treturn true;\n\t}\n\t\n\t\n\t\n\t///---\n\t/// NOTE: Having special end sale function to handle USDT stable coin profit as well is not needed,\n\t/// because owner can always withdraw that profit using \u0027withdrawUSDT\u0027 function.\n\t///---\n\t\n\t/**\n\t * This contract has special end sale function to handle USDT stable coin profit as well.\n\t */\n\t/*function endSale() public onlyOwner {\n\t\t// transfer remaining FITH tokens from this contract back to owner\n        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))), \"Transfer token-sale token balance to owner failed\");\n\t\t\n\t\t// transfer remaining USDT profit from this contract to owner\n\t\trequire(IERC20(usdtContractAddress).transfer(owner, usdtBalances[owner]), \"EthPromo/USDT.profit.transfer failed\");\n\t\t\n        // Just transfer the ether balance to the owner\n        owner.transfer(address(this).balance);\n    }*/\n\t\n\t\n\t\n\t/**\n\t * Accept ETH for tokens\n\t */\n    function () external payable {\n\t\tuint tks = (msg.value).div(tokenPrice);\n\t\t\n\t\taddress refererAddress = address(0);\n\t\tbytes memory msgData = msg.data;\n\t\t// 4 bytes for signature\n\t\tif (msgData.length \u003e 4) {\n\t\t\tassembly {\n\t\t\t\trefererAddress := mload(add(msgData, 20))\n\t\t\t}\n\t\t}\n\t\t\n\t\t_buyTokens(tks, refererAddress);\n\t\t\n\t\t// store eth of each token sale user\n\t\tethBalances[msg.sender] = ethBalances[msg.sender].add(msg.value);\n    }\n}"},"FITHTokenSaleReferrals.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMathLib.sol\";\nimport \"./FITHTokenSale.sol\";\n\n/**\n * @dev Fiatech FITH token sale contract.\n */\ncontract FITHTokenSaleReferrals is FITHTokenSale\n{\n\tusing SafeMathLib for uint;\n\t\n\tuint public referralPercent = 5; // x is x%\n\tuint public referralTokensSpent = 0; // total referral tokens given away\n\t\n\t// referral tokens bought event raised when buyer purchases tokens via referral link\n    event ReferralTokens(address indexed _buyer, address indexed _referer, uint256 _refererTokens);\n\t\n\t// referral token percent update event\n\tevent ReferralTokenPercentUpdate(address _admin, uint256 _referralPercent);\n\t\n\t\n\t\n\t/**\n\t * @dev Constructor\n\t */\n    constructor(IERC20 _tokenContract, uint256 _tokenPrice)\n\t\tFITHTokenSale(_tokenContract, _tokenPrice)\n\t\tpublic\n\t{\n    }\n\t\n\tmodifier onlyOwner() {\n        require(msg.sender == owner, \"Owner required\");\n        _;\n    }\n\t\n\t\n\t\n\t//referer is address instead of string\n\tfunction _buyTokens(uint256 _numberOfTokens, address refererAddress) internal returns(bool) {\n\t\t\n\t\trequire(super._buyTokens(_numberOfTokens), \"_buyTokens base failed!\");\n\t\t\n\t\t// only send referral tokens if buyer has a valid referer\n\t\tif (refererAddress \u003e address(0)) {\n\t\t\t\n\t\t\taddress referer = refererAddress;\n\t\t\t\n\t\t\t// self-referrer check\n\t\t\trequire(referer != msg.sender, \"Referer is sender\");\n\t\t\tuint refererTokens = _numberOfTokens.mul(referralPercent).div(100);\n\t\t\t\n\t\t\t// bonus for referrer\n\t\t\trequire(tokensAvailable() \u003e= refererTokens, \"insufficient referral tokens\");\n\t\t\trequire(tokenContract.transfer(referer, refererTokens), \"Transfer tokens to referer failed\");\n\t\t\t\n\t\t\treferralTokensSpent += refererTokens;\n\t\t\t\n\t\t\temit ReferralTokens(msg.sender, referer, refererTokens);\n\t\t}\n\t\treturn true;\n    }\n\t\n\tfunction updateReferralPercent(uint256 _referralPercent) public onlyOwner {\n        require(_referralPercent \u003e 0 \u0026\u0026 _referralPercent \u003c= 100 \u0026\u0026 _referralPercent != referralPercent, \"Referral percent must be in (0,100] range and different than current\");\n        \n\t\treferralPercent = _referralPercent;\n\t\temit ReferralTokenPercentUpdate(owner, _referralPercent);\n    }\n\t\n\t/*function buyTokens(uint256 _numberOfTokens, address refererAddress) public payable {\n        require(msg.value == (_numberOfTokens * tokenPrice), \"Incorrect number of tokens\");\n\t\t_buyTokens(_numberOfTokens, refererAddress);\n    }*/\n\t\n\t\n\t\n\t/**\n\t * Accept ETH for tokens\n\t */\n    function () external payable {\n\t\tuint tks = (msg.value).div(tokenPrice);\n\t\t\n\t\t// (c, d) = abi.decode(msg.data[4:], (uint256, uint256));\n\t\t//address refererAddress = abi.decode(msg.data[4:], (address));\n\t\t\n\t\taddress refererAddress = address(0);\n\t\tbytes memory msgData = msg.data;\n\t\t// 4 bytes for signature\n\t\tif (msgData.length \u003e 4) {\n\t\t\tassembly {\n\t\t\t\trefererAddress := mload(add(msgData, 20))\n\t\t\t}\n\t\t}\n\t\t\n\t\t_buyTokens(tks, refererAddress);\n    }\n}"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev ERC20 contract interface.\r\n */\r\ncontract IERC20\r\n{\r\n\tfunction totalSupply() public view returns (uint);\r\n\t\r\n\tfunction transfer(address _to, uint _value) public returns (bool success);\r\n\t\r\n\tfunction transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\t\r\n\tfunction balanceOf(address _owner) public view returns (uint balance);\r\n\t\r\n\tfunction approve(address _spender, uint _value) public returns (bool success);\r\n\t\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint remaining);\r\n\t\r\n\tevent Transfer(address indexed from, address indexed to, uint tokens);\r\n\tevent Approval(address indexed owner, address indexed spender, uint tokens);\r\n}"},"OrFeedInterface.sol":{"content":"pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface OrFeedInterface {\r\n  function getExchangeRate ( string calldata fromSymbol, string calldata  toSymbol, string calldata venue, uint256 amount ) external view returns ( uint256 );\r\n  function getTokenDecimalCount ( address tokenAddress ) external view returns ( uint256 );\r\n  function getTokenAddress ( string calldata  symbol ) external view returns ( address );\r\n  function getSynthBytes32 ( string calldata  symbol ) external view returns ( bytes32 );\r\n  function getForexAddress ( string calldata symbol ) external view returns ( address );\r\n  //function arb(address  fundsReturnToAddress,  address liquidityProviderContractAddress, string[] calldata   tokens,  uint256 amount, string[] calldata  exchanges) external payable returns (bool);\r\n}"},"SafeMathLib.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary SafeMathLib {\r\n\t\r\n\tusing SafeMathLib for uint;\r\n\t\r\n\t/**\r\n\t * @dev Sum two uint numbers.\r\n\t * @param a Number 1\r\n\t * @param b Number 2\r\n\t * @return uint\r\n\t */\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c \u003e= a, \"SafeMathLib.add: required c \u003e= a\");\r\n    }\r\n\t\r\n\t/**\r\n\t * @dev Substraction of uint numbers.\r\n\t * @param a Number 1\r\n\t * @param b Number 2\r\n\t * @return uint\r\n\t */\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b \u003c= a, \"SafeMathLib.sub: required b \u003c= a\");\r\n        c = a - b;\r\n    }\r\n\t\r\n\t/**\r\n\t * @dev Product of two uint numbers.\r\n\t * @param a Number 1\r\n\t * @param b Number 2\r\n\t * @return uint\r\n\t */\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require((a == 0 || c / a == b), \"SafeMathLib.mul: required (a == 0 || c / a == b)\");\r\n    }\r\n\t\r\n\t/**\r\n\t * @dev Division of two uint numbers.\r\n\t * @param a Number 1\r\n\t * @param b Number 2\r\n\t * @return uint\r\n\t */\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b \u003e 0, \"SafeMathLib.div: required b \u003e 0\");\r\n        c = a / b;\r\n    }\r\n}"}}