{"DexConstraintPoly.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\npragma solidity ^0.5.2;\n\ncontract DexConstraintPoly {\n    // The Memory map during the execution of this contract is as follows:\n    // [0x0, 0x20) - periodic_column/hash_pool_points/x.\n    // [0x20, 0x40) - periodic_column/hash_pool_points/y.\n    // [0x40, 0x60) - periodic_column/vaults_merkle_hash_points/x.\n    // [0x60, 0x80) - periodic_column/vaults_merkle_hash_points/y.\n    // [0x80, 0xa0) - periodic_column/boundary_base.\n    // [0xa0, 0xc0) - periodic_column/is_modification.\n    // [0xc0, 0xe0) - periodic_column/is_settlement.\n    // [0xe0, 0x100) - periodic_column/boundary_key.\n    // [0x100, 0x120) - periodic_column/boundary_token.\n    // [0x120, 0x140) - periodic_column/boundary_amount0.\n    // [0x140, 0x160) - periodic_column/boundary_amount1.\n    // [0x160, 0x180) - periodic_column/boundary_vault_id.\n    // [0x180, 0x1a0) - periodic_column/settlement_merkle_hash_points/x.\n    // [0x1a0, 0x1c0) - periodic_column/settlement_merkle_hash_points/y.\n    // [0x1c0, 0x1e0) - periodic_column/ecdsa_points/x.\n    // [0x1e0, 0x200) - periodic_column/ecdsa_points/y.\n    // [0x200, 0x220) - trace_length.\n    // [0x220, 0x240) - shift_point.x.\n    // [0x240, 0x260) - shift_point.y.\n    // [0x260, 0x280) - vaults_path_length.\n    // [0x280, 0x2a0) - n_modifications.\n    // [0x2a0, 0x2c0) - n_settlements.\n    // [0x2c0, 0x2e0) - amount_shift.\n    // [0x2e0, 0x300) - global_expiration_timestamp_elm.\n    // [0x300, 0x320) - sig_config.alpha.\n    // [0x320, 0x340) - sig_config.beta.\n    // [0x340, 0x360) - vault_shift.\n    // [0x360, 0x380) - nonce_shift.\n    // [0x380, 0x3a0) - expiration_timestamp_shift.\n    // [0x3a0, 0x3c0) - initial_vaults_root.\n    // [0x3c0, 0x3e0) - initial_settlement_root.\n    // [0x3e0, 0x400) - final_vaults_root.\n    // [0x400, 0x420) - n_transactions.\n    // [0x420, 0x440) - final_settlement_root.\n    // [0x440, 0x460) - trace_generator.\n    // [0x460, 0x480) - oods_point.\n    // [0x480, 0x3180) - coefficients.\n    // [0x3180, 0x49a0) - oods_values.\n    // ----------------------- end of input data - -------------------------\n    // [0x49a0, 0x49c0) - composition_degree_bound.\n    // [0x49c0, 0x49e0) - intermediate_value/hash_pool/hash/ec_subset_sum/bit.\n    // [0x49e0, 0x4a00) - intermediate_value/hash_pool/hash/ec_subset_sum/bit_neg.\n    // [0x4a00, 0x4a20) - intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0.\n    // [0x4a20, 0x4a40) - intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit.\n    // [0x4a40, 0x4a60) - intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg.\n    // [0x4a60, 0x4a80) - intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_1.\n    // [0x4a80, 0x4aa0) - intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit.\n    // [0x4aa0, 0x4ac0) - intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg.\n    // [0x4ac0, 0x4ae0) - intermediate_value/vaults_state_transition/merkle_update/prev_authentication/sibling_0.\n    // [0x4ae0, 0x4b00) - intermediate_value/vaults_state_transition/merkle_update/new_authentication/sibling_0.\n    // [0x4b00, 0x4b20) - intermediate_value/vaults_state_transition/merkle_update/prev_authentication/leaf_0.\n    // [0x4b20, 0x4b40) - intermediate_value/vaults_state_transition/merkle_update/new_authentication/leaf_0.\n    // [0x4b40, 0x4b60) - intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0.\n    // [0x4b60, 0x4b80) - intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit.\n    // [0x4b80, 0x4ba0) - intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg.\n    // [0x4ba0, 0x4bc0) - intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_1.\n    // [0x4bc0, 0x4be0) - intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit.\n    // [0x4be0, 0x4c00) - intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg.\n    // [0x4c00, 0x4c20) - intermediate_value/settlement_state_transition/merkle_update/prev_authentication/sibling_0.\n    // [0x4c20, 0x4c40) - intermediate_value/settlement_state_transition/merkle_update/new_authentication/sibling_0.\n    // [0x4c40, 0x4c60) - intermediate_value/settlement_state_transition/merkle_update/prev_authentication/leaf_0.\n    // [0x4c60, 0x4c80) - intermediate_value/settlement_state_transition/merkle_update/new_authentication/leaf_0.\n    // [0x4c80, 0x4ca0) - intermediate_value/amounts_range_check/bit_0.\n    // [0x4ca0, 0x4cc0) - intermediate_value/expiration_timestamp_range_check/bit_0.\n    // [0x4cc0, 0x4ce0) - intermediate_value/nonce_range_check/bit_0.\n    // [0x4ce0, 0x4d00) - intermediate_value/sig_verify/doubling_key/x_squared.\n    // [0x4d00, 0x4d20) - intermediate_value/sig_verify/exponentiate_generator/bit.\n    // [0x4d20, 0x4d40) - intermediate_value/sig_verify/exponentiate_generator/bit_neg.\n    // [0x4d40, 0x4d60) - intermediate_value/sig_verify/exponentiate_key/bit.\n    // [0x4d60, 0x4d80) - intermediate_value/sig_verify/exponentiate_key/bit_neg.\n    // [0x4d80, 0x4da0) - intermediate_value/party_a_packed_msg/partial.\n    // [0x4da0, 0x4dc0) - intermediate_value/party_b_packed_msg/partial.\n    // [0x4dc0, 0x4de0) - intermediate_value/party_b_packed_msg_transfer/partial.\n    // [0x4de0, 0x50e0) - expmods.\n    // [0x50e0, 0x5460) - denominator_invs.\n    // [0x5460, 0x57e0) - denominators.\n    // [0x57e0, 0x59a0) - numerators.\n    // [0x59a0, 0x5d60) - adjustments.\n    // [0x5d60, 0x5e20) - expmod_context.\n\n    function() external {\n        uint256 res;\n        assembly {\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            // Copy input from calldata to memory.\n            calldatacopy(0x0, 0x0, /*Input data size*/ 0x49a0)\n            let point := /*oods_point*/ mload(0x460)\n            // Initialize composition_degree_bound to 2 * trace_length.\n            mstore(0x49a0, mul(2, /*trace_length*/ mload(0x200)))\n            function expmod(base, exponent, modulus) -\u003e res {\n              let p := /*expmod_context*/ 0x5d60\n              mstore(p, 0x20)                 // Length of Base.\n              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n              mstore(add(p, 0x60), base)      // Base.\n              mstore(add(p, 0x80), exponent)  // Exponent.\n              mstore(add(p, 0xa0), modulus)   // Modulus.\n              // Call modexp precompile.\n              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n              }\n              res := mload(p)\n            }\n\n            function degreeAdjustment(compositionPolynomialDegreeBound, constraintDegree, numeratorDegree,\n                                       denominatorDegree) -\u003e res {\n              res := sub(sub(compositionPolynomialDegreeBound, 1),\n                         sub(add(constraintDegree, numeratorDegree), denominatorDegree))\n            }\n\n            {\n              // Prepare expmods for denominators and numerators.\n\n              // expmods[0] = point^(trace_length / 4).\n              mstore(0x4de0, expmod(point, div(/*trace_length*/ mload(0x200), 4), PRIME))\n\n              // expmods[1] = point^(trace_length / 1024).\n              mstore(0x4e00, expmod(point, div(/*trace_length*/ mload(0x200), 1024), PRIME))\n\n              // expmods[2] = point^(trace_length / 2048).\n              mstore(0x4e20, expmod(point, div(/*trace_length*/ mload(0x200), 2048), PRIME))\n\n              // expmods[3] = point^(trace_length / 4096).\n              mstore(0x4e40, expmod(point, div(/*trace_length*/ mload(0x200), 4096), PRIME))\n\n              // expmods[4] = point^(trace_length / 512).\n              mstore(0x4e60, expmod(point, div(/*trace_length*/ mload(0x200), 512), PRIME))\n\n              // expmods[5] = point^(trace_length / 16384).\n              mstore(0x4e80, expmod(point, div(/*trace_length*/ mload(0x200), 16384), PRIME))\n\n              // expmods[6] = point^trace_length.\n              mstore(0x4ea0, expmod(point, /*trace_length*/ mload(0x200), PRIME))\n\n              // expmods[7] = point^(trace_length / 256).\n              mstore(0x4ec0, expmod(point, div(/*trace_length*/ mload(0x200), 256), PRIME))\n\n              // expmods[8] = point^(trace_length / 65536).\n              mstore(0x4ee0, expmod(point, div(/*trace_length*/ mload(0x200), 65536), PRIME))\n\n              // expmods[9] = point^(trace_length / 32768).\n              mstore(0x4f00, expmod(point, div(/*trace_length*/ mload(0x200), 32768), PRIME))\n\n              // expmods[10] = point^(trace_length / 64).\n              mstore(0x4f20, expmod(point, div(/*trace_length*/ mload(0x200), 64), PRIME))\n\n              // expmods[11] = point^(trace_length / 128).\n              mstore(0x4f40, expmod(point, div(/*trace_length*/ mload(0x200), 128), PRIME))\n\n              // expmods[12] = point^(trace_length / 8192).\n              mstore(0x4f60, expmod(point, div(/*trace_length*/ mload(0x200), 8192), PRIME))\n\n              // expmods[13] = trace_generator^(255 * trace_length / 256).\n              mstore(0x4f80, expmod(/*trace_generator*/ mload(0x440), div(mul(255, /*trace_length*/ mload(0x200)), 256), PRIME))\n\n              // expmods[14] = trace_generator^(63 * trace_length / 64).\n              mstore(0x4fa0, expmod(/*trace_generator*/ mload(0x440), div(mul(63, /*trace_length*/ mload(0x200)), 64), PRIME))\n\n              // expmods[15] = trace_generator^(trace_length / 2).\n              mstore(0x4fc0, expmod(/*trace_generator*/ mload(0x440), div(/*trace_length*/ mload(0x200), 2), PRIME))\n\n              // expmods[16] = trace_generator^(31 * trace_length / 32).\n              mstore(0x4fe0, expmod(/*trace_generator*/ mload(0x440), div(mul(31, /*trace_length*/ mload(0x200)), 32), PRIME))\n\n              // expmods[17] = trace_generator^(vaults_path_length * trace_length / 32).\n              mstore(0x5000, expmod(/*trace_generator*/ mload(0x440), div(mul(/*vaults_path_length*/ mload(0x260), /*trace_length*/ mload(0x200)), 32), PRIME))\n\n              // expmods[18] = trace_generator^(15 * trace_length / 16).\n              mstore(0x5020, expmod(/*trace_generator*/ mload(0x440), div(mul(15, /*trace_length*/ mload(0x200)), 16), PRIME))\n\n              // expmods[19] = trace_generator^(11 * trace_length / 16).\n              mstore(0x5040, expmod(/*trace_generator*/ mload(0x440), div(mul(11, /*trace_length*/ mload(0x200)), 16), PRIME))\n\n              // expmods[20] = trace_generator^(251 * trace_length / 256).\n              mstore(0x5060, expmod(/*trace_generator*/ mload(0x440), div(mul(251, /*trace_length*/ mload(0x200)), 256), PRIME))\n\n              // expmods[21] = trace_generator^(65536 * (n_transactions - 1)).\n              mstore(0x5080, expmod(/*trace_generator*/ mload(0x440), mul(65536, sub(/*n_transactions*/ mload(0x400), 1)), PRIME))\n\n              // expmods[22] = trace_generator^(65536 * (trace_length / 65536 - 1) + 49152).\n              mstore(0x50a0, expmod(/*trace_generator*/ mload(0x440), add(mul(65536, sub(div(/*trace_length*/ mload(0x200), 65536), 1)), 49152), PRIME))\n\n              // expmods[23] = trace_generator^(65536 * (trace_length / 65536 - 1)).\n              mstore(0x50c0, expmod(/*trace_generator*/ mload(0x440), mul(65536, sub(div(/*trace_length*/ mload(0x200), 65536), 1)), PRIME))\n\n            }\n\n            {\n              // Prepare denominators for batch inverse.\n\n              // Denominator for constraints: \u0027hash_pool/hash/ec_subset_sum/booleanity_test\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/slope\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/x\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/y\u0027, \u0027hash_pool/hash/ec_subset_sum/copy_point/x\u0027, \u0027hash_pool/hash/ec_subset_sum/copy_point/y\u0027.\n              // denominators[0] = point^(trace_length / 4) - 1.\n              mstore(0x5460,\n                     addmod(/*point^(trace_length / 4)*/ mload(0x4de0), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027hash_pool/hash/ec_subset_sum/bit_extraction_end\u0027.\n              // denominators[1] = point^(trace_length / 1024) - trace_generator^(63 * trace_length / 64).\n              mstore(0x5480,\n                     addmod(\n                       /*point^(trace_length / 1024)*/ mload(0x4e00),\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027hash_pool/hash/ec_subset_sum/zeros_tail\u0027.\n              // denominators[2] = point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              mstore(0x54a0,\n                     addmod(\n                       /*point^(trace_length / 1024)*/ mload(0x4e00),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027hash_pool/hash/copy_point/x\u0027, \u0027hash_pool/hash/copy_point/y\u0027, \u0027nonce_range_check/bit\u0027.\n              // denominators[3] = point^(trace_length / 1024) - 1.\n              mstore(0x54c0,\n                     addmod(/*point^(trace_length / 1024)*/ mload(0x4e00), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027hash_pool/hash/init/x\u0027, \u0027hash_pool/hash/init/y\u0027.\n              // denominators[4] = point^(trace_length / 2048) - 1.\n              mstore(0x54e0,\n                     addmod(/*point^(trace_length / 2048)*/ mload(0x4e20), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027hash_pool/output_to_input\u0027.\n              // denominators[5] = point^(trace_length / 4096) - 1.\n              mstore(0x5500,\n                     addmod(/*point^(trace_length / 4096)*/ mload(0x4e40), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_update/side_bit_extraction/bit\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/init/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/init/y\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_left\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_right\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/init/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/init/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/copy_prev_to_left\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/copy_prev_to_right\u0027, \u0027vaults_state_transition/merkle_update/same_siblings\u0027, \u0027settlement_state_transition/merkle_update/side_bit_extraction/bit\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/init/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/init/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_left\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_right\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/init/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/init/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/copy_prev_to_left\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/copy_prev_to_right\u0027, \u0027settlement_state_transition/merkle_update/same_siblings\u0027, \u0027expiration_timestamp_range_check/bit\u0027.\n              // denominators[6] = point^(trace_length / 512) - 1.\n              mstore(0x5520,\n                     addmod(/*point^(trace_length / 512)*/ mload(0x4e60), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_update/side_bit_extraction/zero\u0027.\n              // denominators[7] = point^(trace_length / 16384) - trace_generator^(vaults_path_length * trace_length / 32).\n              mstore(0x5540,\n                     addmod(\n                       /*point^(trace_length / 16384)*/ mload(0x4e80),\n                       sub(PRIME, /*trace_generator^(vaults_path_length * trace_length / 32)*/ mload(0x5000)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y\u0027.\n              // denominators[8] = point^trace_length - 1.\n              mstore(0x5560,\n                     addmod(/*point^trace_length*/ mload(0x4ea0), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027.\n              // denominators[9] = point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n              mstore(0x5580,\n                     addmod(\n                       /*point^(trace_length / 256)*/ mload(0x4ec0),\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/zeros_tail\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/zeros_tail\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/zeros_tail\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/zeros_tail\u0027.\n              // denominators[10] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              mstore(0x55a0,\n                     addmod(\n                       /*point^(trace_length / 256)*/ mload(0x4ec0),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/y\u0027.\n              // denominators[11] = point^(trace_length / 256) - 1.\n              mstore(0x55c0,\n                     addmod(/*point^(trace_length / 256)*/ mload(0x4ec0), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027vaults_state_transition/merkle_set_prev_leaf\u0027, \u0027vaults_state_transition/merkle_set_new_leaf\u0027, \u0027amounts_range_check_inputs\u0027, \u0027sig_verify/init_key/x\u0027, \u0027sig_verify/init_key/y\u0027, \u0027sig_verify/r_and_w_nonzero\u0027, \u0027handle_empty_vault/consistency_key_stage0\u0027, \u0027handle_empty_vault/consistency_token_stage0\u0027, \u0027handle_empty_vault/consistency_key_stage1\u0027, \u0027handle_empty_vault/consistency_token_stage1\u0027, \u0027copy_merkle_roots\u0027.\n              // denominators[12] = point^(trace_length / 16384) - 1.\n              mstore(0x55e0,\n                     addmod(/*point^(trace_length / 16384)*/ mload(0x4e80), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027modification_boundary_key\u0027, \u0027modification_boundary_token\u0027, \u0027modification_boundary_amount0\u0027, \u0027modification_boundary_amount1\u0027, \u0027modification_boundary_vault_id\u0027, \u0027settlement_state_transition/set_prev_root\u0027, \u0027settlement_state_transition/root_consistency\u0027, \u0027settlement_state_transition/set_new_root\u0027, \u0027settlement_state_transition/dont_change_if_modification\u0027, \u0027total_token_a_not_changed\u0027, \u0027total_token_b_not_changed\u0027, \u0027party_a_fulfilled_amount\u0027, \u0027party_b_fulfilled_amount\u0027, \u0027amount_a_range_check_input\u0027, \u0027amount_b_range_check_input\u0027, \u0027ratio_party_a\u0027, \u0027ratio_party_b\u0027, \u0027capacity_party_a\u0027, \u0027capacity_party_b\u0027, \u0027is_transfer/bit\u0027, \u0027is_transfer/modification\u0027, \u0027transfer/party_a_sold\u0027, \u0027transfer/party_b_buy\u0027, \u0027transfer/party_a_sell\u0027, \u0027transfer/party_b_exact_transferred\u0027, \u0027party_a_sig_input_packed\u0027, \u0027party_b_sig_input_packed\u0027, \u0027signatures/party_b_hash_sec_msg\u0027, \u0027signatures/copy_token_b\u0027, \u0027copy_signature_input_party_a\u0027, \u0027copy_signature_input_party_b\u0027, \u0027message_hash_determines_order_id_party_a\u0027, \u0027message_hash_determines_order_id_party_b\u0027, \u0027party_a_public_key_copy\u0027, \u0027handle_empty_vault/consistency_key_change0\u0027, \u0027handle_empty_vault/consistency_token_change0\u0027, \u0027handle_empty_vault/consistency_key_change3\u0027, \u0027handle_empty_vault/consistency_token_change3\u0027, \u0027handle_empty_vault/consistency_key_change1\u0027, \u0027handle_empty_vault/consistency_token_change1\u0027, \u0027handle_empty_vault/consistency_key_change2\u0027, \u0027handle_empty_vault/consistency_token_change2\u0027, \u0027copy_settlement_merkle_roots\u0027, \u0027copy_merkle_roots_modification\u0027.\n              // denominators[13] = point^(trace_length / 65536) - 1.\n              mstore(0x5600,\n                     addmod(/*point^(trace_length / 65536)*/ mload(0x4ee0), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027settlement_state_transition/merkle_update/side_bit_extraction/zero\u0027.\n              // denominators[14] = point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64).\n              mstore(0x5620,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027settlement_state_transition/merkle_set_prev_leaf\u0027, \u0027settlement_state_transition/merkle_set_new_leaf\u0027, \u0027expiration_timestamp_range_check_input\u0027, \u0027sig_verify/init_gen/x\u0027, \u0027sig_verify/init_gen/y\u0027, \u0027sig_verify/add_results/slope\u0027, \u0027sig_verify/add_results/x\u0027, \u0027sig_verify/add_results/y\u0027, \u0027sig_verify/add_results/x_diff_inv\u0027, \u0027sig_verify/extract_r/slope\u0027, \u0027sig_verify/extract_r/x\u0027, \u0027sig_verify/extract_r/x_diff_inv\u0027, \u0027sig_verify/z_nonzero\u0027, \u0027sig_verify/q_on_curve/x_squared\u0027, \u0027sig_verify/q_on_curve/on_curve\u0027.\n              // denominators[15] = point^(trace_length / 32768) - 1.\n              mstore(0x5640,\n                     addmod(/*point^(trace_length / 32768)*/ mload(0x4f00), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027amounts_range_check/bit\u0027, \u0027sig_verify/doubling_key/slope\u0027, \u0027sig_verify/doubling_key/x\u0027, \u0027sig_verify/doubling_key/y\u0027, \u0027sig_verify/exponentiate_key/booleanity_test\u0027, \u0027sig_verify/exponentiate_key/add_points/slope\u0027, \u0027sig_verify/exponentiate_key/add_points/x\u0027, \u0027sig_verify/exponentiate_key/add_points/y\u0027, \u0027sig_verify/exponentiate_key/add_points/x_diff_inv\u0027, \u0027sig_verify/exponentiate_key/copy_point/x\u0027, \u0027sig_verify/exponentiate_key/copy_point/y\u0027.\n              // denominators[16] = point^(trace_length / 64) - 1.\n              mstore(0x5660,\n                     addmod(/*point^(trace_length / 64)*/ mload(0x4f20), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027amounts_range_check/zero\u0027.\n              // denominators[17] = point^(trace_length / 4096) - trace_generator^(63 * trace_length / 64).\n              mstore(0x5680,\n                     addmod(\n                       /*point^(trace_length / 4096)*/ mload(0x4e40),\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027expiration_timestamp_range_check/zero\u0027.\n              // denominators[18] = point^(trace_length / 16384) - trace_generator^(11 * trace_length / 16).\n              mstore(0x56a0,\n                     addmod(\n                       /*point^(trace_length / 16384)*/ mload(0x4e80),\n                       sub(PRIME, /*trace_generator^(11 * trace_length / 16)*/ mload(0x5040)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027nonce_range_check/zero\u0027.\n              // denominators[19] = point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32).\n              mstore(0x56c0,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(31 * trace_length / 32)*/ mload(0x4fe0)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027sig_verify/exponentiate_generator/booleanity_test\u0027, \u0027sig_verify/exponentiate_generator/add_points/slope\u0027, \u0027sig_verify/exponentiate_generator/add_points/x\u0027, \u0027sig_verify/exponentiate_generator/add_points/y\u0027, \u0027sig_verify/exponentiate_generator/add_points/x_diff_inv\u0027, \u0027sig_verify/exponentiate_generator/copy_point/x\u0027, \u0027sig_verify/exponentiate_generator/copy_point/y\u0027.\n              // denominators[20] = point^(trace_length / 128) - 1.\n              mstore(0x56e0,\n                     addmod(/*point^(trace_length / 128)*/ mload(0x4f40), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027sig_verify/exponentiate_generator/bit_extraction_end\u0027.\n              // denominators[21] = point^(trace_length / 32768) - trace_generator^(251 * trace_length / 256).\n              mstore(0x5700,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x5060)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027sig_verify/exponentiate_generator/zeros_tail\u0027.\n              // denominators[22] = point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              mstore(0x5720,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027sig_verify/exponentiate_key/bit_extraction_end\u0027.\n              // denominators[23] = point^(trace_length / 16384) - trace_generator^(251 * trace_length / 256).\n              mstore(0x5740,\n                     addmod(\n                       /*point^(trace_length / 16384)*/ mload(0x4e80),\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x5060)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027sig_verify/exponentiate_key/zeros_tail\u0027.\n              // denominators[24] = point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              mstore(0x5760,\n                     addmod(\n                       /*point^(trace_length / 16384)*/ mload(0x4e80),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Denominator for constraints: \u0027handle_empty_vault/vault_empty/empty_vault_booleanity\u0027, \u0027handle_empty_vault/vault_empty/amount_zero_when_empty\u0027, \u0027handle_empty_vault/vault_empty/amount_inv_zero_when_empty\u0027, \u0027handle_empty_vault/vault_empty/empty_when_amount_zero\u0027.\n              // denominators[25] = point^(trace_length / 8192) - 1.\n              mstore(0x5780,\n                     addmod(/*point^(trace_length / 8192)*/ mload(0x4f60), sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027initial_vaults_root\u0027, \u0027initial_settlement_root\u0027.\n              // denominators[26] = point - 1.\n              mstore(0x57a0,\n                     addmod(point, sub(PRIME, 1), PRIME))\n\n              // Denominator for constraints: \u0027final_vaults_root\u0027, \u0027final_settlement_root\u0027.\n              // denominators[27] = point - trace_generator^(65536 * (n_transactions - 1)).\n              mstore(0x57c0,\n                     addmod(\n                       point,\n                       sub(PRIME, /*trace_generator^(65536 * (n_transactions - 1))*/ mload(0x5080)),\n                       PRIME))\n\n            }\n\n            {\n              // Compute the inverses of the denominators into denominatorInvs using batch inverse.\n\n              // Start by computing the cumulative product.\n              // Let (d_0, d_1, d_2, ..., d_{n-1}) be the values in denominators. After this loop\n              // denominatorInvs will be (1, d_0, d_0 * d_1, ...) and prod will contain the value of\n              // d_0 * ... * d_{n-1}.\n              // Compute the offset between the partialProducts array and the input values array.\n              let productsToValuesOffset := 0x380\n              let prod := 1\n              let partialProductEndPtr := 0x5460\n              for { let partialProductPtr := 0x50e0 }\n                  lt(partialProductPtr, partialProductEndPtr)\n                  { partialProductPtr := add(partialProductPtr, 0x20) } {\n                  mstore(partialProductPtr, prod)\n                  // prod *= d_{i}.\n                  prod := mulmod(prod,\n                                 mload(add(partialProductPtr, productsToValuesOffset)),\n                                 PRIME)\n              }\n\n              let firstPartialProductPtr := 0x50e0\n              // Compute the inverse of the product.\n              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)\n\n              if eq(prodInv, 0) {\n                  // Solidity generates reverts with reason that look as follows:\n                  // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b\u0027Error(string)\u0027)[:4]).\n                  // 2. 32 bytes offset bytes (always 0x20 as far as i can tell).\n                  // 3. 32 bytes with the length of the revert reason.\n                  // 4. Revert reason string.\n\n                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                  mstore(0x4, 0x20)\n                  mstore(0x24, 0x1e)\n                  mstore(0x44, \"Batch inverse product is zero.\")\n                  revert(0, 0x62)\n              }\n\n              // Compute the inverses.\n              // Loop over denominator_invs in reverse order.\n              // currentPartialProductPtr is initialized to one past the end.\n              let currentPartialProductPtr := 0x5460\n              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {\n                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                  // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                  mstore(currentPartialProductPtr,\n                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                  // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                  prodInv := mulmod(prodInv,\n                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                     PRIME)\n              }\n            }\n\n            {\n              // Compute numerators and adjustment polynomials.\n\n              // Numerator for constraints \u0027hash_pool/hash/ec_subset_sum/booleanity_test\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/slope\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/x\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/y\u0027, \u0027hash_pool/hash/ec_subset_sum/copy_point/x\u0027, \u0027hash_pool/hash/ec_subset_sum/copy_point/y\u0027.\n              // numerators[0] = point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              mstore(0x57e0,\n                     addmod(\n                       /*point^(trace_length / 1024)*/ mload(0x4e00),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Numerator for constraints \u0027hash_pool/hash/copy_point/x\u0027, \u0027hash_pool/hash/copy_point/y\u0027.\n              // numerators[1] = point^(trace_length / 2048) - trace_generator^(trace_length / 2).\n              mstore(0x5800,\n                     addmod(\n                       /*point^(trace_length / 2048)*/ mload(0x4e20),\n                       sub(PRIME, /*trace_generator^(trace_length / 2)*/ mload(0x4fc0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027vaults_state_transition/merkle_update/side_bit_extraction/bit\u0027, \u0027vaults_state_transition/merkle_update/same_siblings\u0027, \u0027expiration_timestamp_range_check/bit\u0027.\n              // numerators[2] = point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32).\n              mstore(0x5820,\n                     addmod(\n                       /*point^(trace_length / 16384)*/ mload(0x4e80),\n                       sub(PRIME, /*trace_generator^(31 * trace_length / 32)*/ mload(0x4fe0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y\u0027.\n              // numerators[3] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              mstore(0x5840,\n                     addmod(\n                       /*point^(trace_length / 256)*/ mload(0x4ec0),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Numerator for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/y\u0027.\n              // numerators[4] = point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              mstore(0x5860,\n                     addmod(\n                       /*point^(trace_length / 512)*/ mload(0x4e60),\n                       sub(PRIME, /*trace_generator^(trace_length / 2)*/ mload(0x4fc0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_left\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_right\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/copy_prev_to_left\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/copy_prev_to_right\u0027.\n              // numerators[5] = (point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32)) * (point^(trace_length / 16384) - trace_generator^(15 * trace_length / 16)).\n              mstore(0x5880,\n                     mulmod(\n                       addmod(\n                         /*point^(trace_length / 16384)*/ mload(0x4e80),\n                         sub(PRIME, /*trace_generator^(31 * trace_length / 32)*/ mload(0x4fe0)),\n                         PRIME),\n                       addmod(\n                         /*point^(trace_length / 16384)*/ mload(0x4e80),\n                         sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x5020)),\n                         PRIME),\n                       PRIME))\n\n              // Numerator for constraints \u0027settlement_state_transition/merkle_update/side_bit_extraction/bit\u0027, \u0027settlement_state_transition/merkle_update/same_siblings\u0027.\n              // numerators[6] = point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64).\n              mstore(0x58a0,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_left\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_right\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/copy_prev_to_left\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/copy_prev_to_right\u0027.\n              // numerators[7] = (point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64)) * (point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32)).\n              mstore(0x58c0,\n                     mulmod(\n                       addmod(\n                         /*point^(trace_length / 32768)*/ mload(0x4f00),\n                         sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                         PRIME),\n                       addmod(\n                         /*point^(trace_length / 32768)*/ mload(0x4f00),\n                         sub(PRIME, /*trace_generator^(31 * trace_length / 32)*/ mload(0x4fe0)),\n                         PRIME),\n                       PRIME))\n\n              // Numerator for constraints \u0027amounts_range_check/bit\u0027.\n              // numerators[8] = point^(trace_length / 4096) - trace_generator^(63 * trace_length / 64).\n              mstore(0x58e0,\n                     addmod(\n                       /*point^(trace_length / 4096)*/ mload(0x4e40),\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4fa0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027nonce_range_check/bit\u0027.\n              // numerators[9] = point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32).\n              mstore(0x5900,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(31 * trace_length / 32)*/ mload(0x4fe0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027sig_verify/doubling_key/slope\u0027, \u0027sig_verify/doubling_key/x\u0027, \u0027sig_verify/doubling_key/y\u0027, \u0027sig_verify/exponentiate_key/booleanity_test\u0027, \u0027sig_verify/exponentiate_key/add_points/slope\u0027, \u0027sig_verify/exponentiate_key/add_points/x\u0027, \u0027sig_verify/exponentiate_key/add_points/y\u0027, \u0027sig_verify/exponentiate_key/add_points/x_diff_inv\u0027, \u0027sig_verify/exponentiate_key/copy_point/x\u0027, \u0027sig_verify/exponentiate_key/copy_point/y\u0027.\n              // numerators[10] = point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              mstore(0x5920,\n                     addmod(\n                       /*point^(trace_length / 16384)*/ mload(0x4e80),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Numerator for constraints \u0027sig_verify/exponentiate_generator/booleanity_test\u0027, \u0027sig_verify/exponentiate_generator/add_points/slope\u0027, \u0027sig_verify/exponentiate_generator/add_points/x\u0027, \u0027sig_verify/exponentiate_generator/add_points/y\u0027, \u0027sig_verify/exponentiate_generator/add_points/x_diff_inv\u0027, \u0027sig_verify/exponentiate_generator/copy_point/x\u0027, \u0027sig_verify/exponentiate_generator/copy_point/y\u0027.\n              // numerators[11] = point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              mstore(0x5940,\n                     addmod(\n                       /*point^(trace_length / 32768)*/ mload(0x4f00),\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4f80)),\n                       PRIME))\n\n              // Numerator for constraints \u0027copy_merkle_roots\u0027.\n              // numerators[12] = point - trace_generator^(65536 * (trace_length / 65536 - 1) + 49152).\n              mstore(0x5960,\n                     addmod(\n                       point,\n                       sub(\n                         PRIME,\n                         /*trace_generator^(65536 * (trace_length / 65536 - 1) + 49152)*/ mload(0x50a0)),\n                       PRIME))\n\n              // Numerator for constraints \u0027copy_settlement_merkle_roots\u0027.\n              // numerators[13] = point - trace_generator^(65536 * (trace_length / 65536 - 1)).\n              mstore(0x5980,\n                     addmod(\n                       point,\n                       sub(PRIME, /*trace_generator^(65536 * (trace_length / 65536 - 1))*/ mload(0x50c0)),\n                       PRIME))\n\n              // Adjustment polynomial for constraints \u0027hash_pool/hash/ec_subset_sum/booleanity_test\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/slope\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/x\u0027, \u0027hash_pool/hash/ec_subset_sum/add_points/y\u0027, \u0027hash_pool/hash/ec_subset_sum/copy_point/x\u0027, \u0027hash_pool/hash/ec_subset_sum/copy_point/y\u0027.\n              // adjustments[0] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 1024, trace_length / 4).\n              mstore(0x59a0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 1024), div(/*trace_length*/ mload(0x200), 4)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027hash_pool/hash/ec_subset_sum/bit_extraction_end\u0027, \u0027hash_pool/hash/ec_subset_sum/zeros_tail\u0027.\n              // adjustments[1] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 1024).\n              mstore(0x59c0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 1024)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027hash_pool/hash/copy_point/x\u0027, \u0027hash_pool/hash/copy_point/y\u0027.\n              // adjustments[2] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, trace_length / 2048, trace_length / 1024).\n              mstore(0x59e0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), div(/*trace_length*/ mload(0x200), 2048), div(/*trace_length*/ mload(0x200), 1024)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027hash_pool/hash/init/x\u0027, \u0027hash_pool/hash/init/y\u0027.\n              // adjustments[3] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 2048).\n              mstore(0x5a00,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 2048)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027hash_pool/output_to_input\u0027, \u0027amounts_range_check/zero\u0027.\n              // adjustments[4] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 4096).\n              mstore(0x5a20,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 4096)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/side_bit_extraction/bit\u0027, \u0027vaults_state_transition/merkle_update/same_siblings\u0027, \u0027expiration_timestamp_range_check/bit\u0027.\n              // adjustments[5] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 16384, trace_length / 512).\n              mstore(0x5a40,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 16384), div(/*trace_length*/ mload(0x200), 512)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/side_bit_extraction/zero\u0027, \u0027amounts_range_check_inputs\u0027, \u0027expiration_timestamp_range_check/zero\u0027, \u0027sig_verify/exponentiate_key/bit_extraction_end\u0027, \u0027sig_verify/exponentiate_key/zeros_tail\u0027, \u0027sig_verify/init_key/x\u0027, \u0027sig_verify/init_key/y\u0027.\n              // adjustments[6] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 16384).\n              mstore(0x5a60,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 16384)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y\u0027.\n              // adjustments[7] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 256, trace_length).\n              mstore(0x5a80,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 256), /*trace_length*/ mload(0x200)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/zeros_tail\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/zeros_tail\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/zeros_tail\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_extraction_end\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/zeros_tail\u0027.\n              // adjustments[8] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 256).\n              mstore(0x5aa0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 256)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/y\u0027.\n              // adjustments[9] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, trace_length / 512, trace_length / 256).\n              mstore(0x5ac0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), div(/*trace_length*/ mload(0x200), 512), div(/*trace_length*/ mload(0x200), 256)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/init/x\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/hashes/init/y\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/init/x\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/hashes/init/y\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/init/x\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/hashes/init/y\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/init/x\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/hashes/init/y\u0027.\n              // adjustments[10] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 512).\n              mstore(0x5ae0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 512)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_left\u0027, \u0027vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_right\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/copy_prev_to_left\u0027, \u0027vaults_state_transition/merkle_update/new_authentication/copy_prev_to_right\u0027.\n              // adjustments[11] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 16384 + trace_length / 16384, trace_length / 512).\n              mstore(0x5b00,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), add(\n                       div(/*trace_length*/ mload(0x200), 16384),\n                       div(/*trace_length*/ mload(0x200), 16384)), div(/*trace_length*/ mload(0x200), 512)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027vaults_state_transition/merkle_set_prev_leaf\u0027, \u0027vaults_state_transition/merkle_set_new_leaf\u0027, \u0027sig_verify/r_and_w_nonzero\u0027, \u0027handle_empty_vault/consistency_key_stage0\u0027, \u0027handle_empty_vault/consistency_token_stage0\u0027, \u0027handle_empty_vault/consistency_key_stage1\u0027, \u0027handle_empty_vault/consistency_token_stage1\u0027.\n              // adjustments[12] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 16384).\n              mstore(0x5b20,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), 0, div(/*trace_length*/ mload(0x200), 16384)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027modification_boundary_key\u0027, \u0027modification_boundary_token\u0027, \u0027modification_boundary_amount0\u0027, \u0027modification_boundary_amount1\u0027, \u0027modification_boundary_vault_id\u0027.\n              // adjustments[13] = point^degreeAdjustment(composition_degree_bound, trace_length + trace_length / 65536 - 2, 0, trace_length / 65536).\n              mstore(0x5b40,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(add(/*trace_length*/ mload(0x200), div(/*trace_length*/ mload(0x200), 65536)), 2), 0, div(/*trace_length*/ mload(0x200), 65536)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027settlement_state_transition/merkle_update/side_bit_extraction/bit\u0027, \u0027settlement_state_transition/merkle_update/same_siblings\u0027.\n              // adjustments[14] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 32768, trace_length / 512).\n              mstore(0x5b60,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 32768), div(/*trace_length*/ mload(0x200), 512)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027settlement_state_transition/merkle_update/side_bit_extraction/zero\u0027, \u0027expiration_timestamp_range_check_input\u0027, \u0027nonce_range_check/zero\u0027, \u0027sig_verify/exponentiate_generator/bit_extraction_end\u0027, \u0027sig_verify/exponentiate_generator/zeros_tail\u0027, \u0027sig_verify/init_gen/x\u0027, \u0027sig_verify/init_gen/y\u0027.\n              // adjustments[15] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 32768).\n              mstore(0x5b80,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 32768)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_left\u0027, \u0027settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_right\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/copy_prev_to_left\u0027, \u0027settlement_state_transition/merkle_update/new_authentication/copy_prev_to_right\u0027.\n              // adjustments[16] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 32768 + trace_length / 32768, trace_length / 512).\n              mstore(0x5ba0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), add(\n                       div(/*trace_length*/ mload(0x200), 32768),\n                       div(/*trace_length*/ mload(0x200), 32768)), div(/*trace_length*/ mload(0x200), 512)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027settlement_state_transition/merkle_set_prev_leaf\u0027, \u0027settlement_state_transition/merkle_set_new_leaf\u0027, \u0027sig_verify/add_results/slope\u0027, \u0027sig_verify/add_results/x\u0027, \u0027sig_verify/add_results/y\u0027, \u0027sig_verify/add_results/x_diff_inv\u0027, \u0027sig_verify/extract_r/slope\u0027, \u0027sig_verify/extract_r/x\u0027, \u0027sig_verify/extract_r/x_diff_inv\u0027, \u0027sig_verify/z_nonzero\u0027, \u0027sig_verify/q_on_curve/x_squared\u0027, \u0027sig_verify/q_on_curve/on_curve\u0027.\n              // adjustments[17] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 32768).\n              mstore(0x5bc0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), 0, div(/*trace_length*/ mload(0x200), 32768)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027settlement_state_transition/set_prev_root\u0027, \u0027settlement_state_transition/root_consistency\u0027, \u0027settlement_state_transition/set_new_root\u0027, \u0027total_token_a_not_changed\u0027, \u0027total_token_b_not_changed\u0027, \u0027party_a_fulfilled_amount\u0027, \u0027party_b_fulfilled_amount\u0027, \u0027amount_a_range_check_input\u0027, \u0027amount_b_range_check_input\u0027, \u0027party_a_sig_input_packed\u0027, \u0027copy_signature_input_party_b\u0027, \u0027message_hash_determines_order_id_party_b\u0027, \u0027handle_empty_vault/consistency_key_change0\u0027, \u0027handle_empty_vault/consistency_token_change0\u0027, \u0027handle_empty_vault/consistency_key_change3\u0027, \u0027handle_empty_vault/consistency_token_change3\u0027, \u0027handle_empty_vault/consistency_key_change1\u0027, \u0027handle_empty_vault/consistency_token_change1\u0027, \u0027handle_empty_vault/consistency_key_change2\u0027, \u0027handle_empty_vault/consistency_token_change2\u0027.\n              // adjustments[18] = point^degreeAdjustment(composition_degree_bound, trace_length + n_modifications - 1, 0, trace_length / 65536).\n              mstore(0x5be0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(add(/*trace_length*/ mload(0x200), /*n_modifications*/ mload(0x280)), 1), 0, div(/*trace_length*/ mload(0x200), 65536)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027settlement_state_transition/dont_change_if_modification\u0027, \u0027is_transfer/modification\u0027, \u0027copy_merkle_roots_modification\u0027.\n              // adjustments[19] = point^degreeAdjustment(composition_degree_bound, trace_length + n_settlements - 1, 0, trace_length / 65536).\n              mstore(0x5c00,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(add(/*trace_length*/ mload(0x200), /*n_settlements*/ mload(0x2a0)), 1), 0, div(/*trace_length*/ mload(0x200), 65536)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027amounts_range_check/bit\u0027.\n              // adjustments[20] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 4096, trace_length / 64).\n              mstore(0x5c20,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 4096), div(/*trace_length*/ mload(0x200), 64)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027ratio_party_a\u0027, \u0027ratio_party_b\u0027, \u0027is_transfer/bit\u0027, \u0027transfer/party_a_sold\u0027, \u0027transfer/party_b_buy\u0027, \u0027transfer/party_a_sell\u0027, \u0027transfer/party_b_exact_transferred\u0027, \u0027party_b_sig_input_packed\u0027, \u0027signatures/party_b_hash_sec_msg\u0027, \u0027copy_signature_input_party_a\u0027, \u0027message_hash_determines_order_id_party_a\u0027, \u0027party_a_public_key_copy\u0027.\n              // adjustments[21] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 65536).\n              mstore(0x5c40,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), 0, div(/*trace_length*/ mload(0x200), 65536)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027capacity_party_a\u0027, \u0027capacity_party_b\u0027, \u0027signatures/copy_token_b\u0027.\n              // adjustments[22] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, trace_length / 65536).\n              mstore(0x5c60,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, div(/*trace_length*/ mload(0x200), 65536)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027nonce_range_check/bit\u0027.\n              // adjustments[23] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 32768, trace_length / 1024).\n              mstore(0x5c80,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 32768), div(/*trace_length*/ mload(0x200), 1024)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027sig_verify/doubling_key/slope\u0027, \u0027sig_verify/doubling_key/x\u0027, \u0027sig_verify/doubling_key/y\u0027, \u0027sig_verify/exponentiate_key/booleanity_test\u0027, \u0027sig_verify/exponentiate_key/add_points/slope\u0027, \u0027sig_verify/exponentiate_key/add_points/x\u0027, \u0027sig_verify/exponentiate_key/add_points/y\u0027, \u0027sig_verify/exponentiate_key/add_points/x_diff_inv\u0027, \u0027sig_verify/exponentiate_key/copy_point/x\u0027, \u0027sig_verify/exponentiate_key/copy_point/y\u0027.\n              // adjustments[24] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 16384, trace_length / 64).\n              mstore(0x5ca0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 16384), div(/*trace_length*/ mload(0x200), 64)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027sig_verify/exponentiate_generator/booleanity_test\u0027, \u0027sig_verify/exponentiate_generator/add_points/slope\u0027, \u0027sig_verify/exponentiate_generator/add_points/x\u0027, \u0027sig_verify/exponentiate_generator/add_points/y\u0027, \u0027sig_verify/exponentiate_generator/add_points/x_diff_inv\u0027, \u0027sig_verify/exponentiate_generator/copy_point/x\u0027, \u0027sig_verify/exponentiate_generator/copy_point/y\u0027.\n              // adjustments[25] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), trace_length / 32768, trace_length / 128).\n              mstore(0x5cc0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), div(/*trace_length*/ mload(0x200), 32768), div(/*trace_length*/ mload(0x200), 128)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027handle_empty_vault/vault_empty/empty_vault_booleanity\u0027, \u0027handle_empty_vault/vault_empty/amount_zero_when_empty\u0027, \u0027handle_empty_vault/vault_empty/amount_inv_zero_when_empty\u0027, \u0027handle_empty_vault/vault_empty/empty_when_amount_zero\u0027.\n              // adjustments[26] = point^degreeAdjustment(composition_degree_bound, 2 * (trace_length - 1), 0, trace_length / 8192).\n              mstore(0x5ce0,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), mul(2, sub(/*trace_length*/ mload(0x200), 1)), 0, div(/*trace_length*/ mload(0x200), 8192)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027initial_vaults_root\u0027, \u0027initial_settlement_root\u0027, \u0027final_vaults_root\u0027, \u0027final_settlement_root\u0027.\n              // adjustments[27] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 0, 1).\n              mstore(0x5d00,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 0, 1), PRIME))\n\n              // Adjustment polynomial for constraints \u0027copy_merkle_roots\u0027.\n              // adjustments[28] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 1, trace_length / 16384).\n              mstore(0x5d20,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 1, div(/*trace_length*/ mload(0x200), 16384)), PRIME))\n\n              // Adjustment polynomial for constraints \u0027copy_settlement_merkle_roots\u0027.\n              // adjustments[29] = point^degreeAdjustment(composition_degree_bound, trace_length - 1, 1, trace_length / 65536).\n              mstore(0x5d40,\n                     expmod(point, degreeAdjustment(/*composition_degree_bound*/ mload(0x49a0), sub(/*trace_length*/ mload(0x200), 1), 1, div(/*trace_length*/ mload(0x200), 65536)), PRIME))\n\n            }\n\n            {\n              // Compute the result of the composition polynomial.\n\n              {\n              // hash_pool/hash/ec_subset_sum/bit = column16_row3 - (column16_row7 + column16_row7).\n              let val := addmod(\n                /*column16_row3*/ mload(0x3dc0),\n                sub(\n                  PRIME,\n                  addmod(/*column16_row7*/ mload(0x3e20), /*column16_row7*/ mload(0x3e20), PRIME)),\n                PRIME)\n              mstore(0x49c0, val)\n              }\n\n\n              {\n              // hash_pool/hash/ec_subset_sum/bit_neg = 1 - hash_pool__hash__ec_subset_sum__bit.\n              let val := addmod(\n                1,\n                sub(PRIME, /*intermediate_value/hash_pool/hash/ec_subset_sum/bit*/ mload(0x49c0)),\n                PRIME)\n              mstore(0x49e0, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/side_bit_extraction/bit_0 = column14_row255 - (column14_row767 + column14_row767).\n              let val := addmod(\n                /*column14_row255*/ mload(0x3b80),\n                sub(\n                  PRIME,\n                  addmod(/*column14_row767*/ mload(0x3bc0), /*column14_row767*/ mload(0x3bc0), PRIME)),\n                PRIME)\n              mstore(0x4a00, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit = column3_row0 - (column3_row1 + column3_row1).\n              let val := addmod(\n                /*column3_row0*/ mload(0x3300),\n                sub(\n                  PRIME,\n                  addmod(/*column3_row1*/ mload(0x3320), /*column3_row1*/ mload(0x3320), PRIME)),\n                PRIME)\n              mstore(0x4a20, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg = 1 - vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit.\n              let val := addmod(\n                1,\n                sub(\n                  PRIME,\n                  /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a20)),\n                PRIME)\n              mstore(0x4a40, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/side_bit_extraction/bit_1 = column14_row767 - (column14_row1279 + column14_row1279).\n              let val := addmod(\n                /*column14_row767*/ mload(0x3bc0),\n                sub(\n                  PRIME,\n                  addmod(/*column14_row1279*/ mload(0x3c00), /*column14_row1279*/ mload(0x3c00), PRIME)),\n                PRIME)\n              mstore(0x4a60, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit = column7_row0 - (column7_row1 + column7_row1).\n              let val := addmod(\n                /*column7_row0*/ mload(0x3520),\n                sub(\n                  PRIME,\n                  addmod(/*column7_row1*/ mload(0x3540), /*column7_row1*/ mload(0x3540), PRIME)),\n                PRIME)\n              mstore(0x4a80, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg = 1 - vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit.\n              let val := addmod(\n                1,\n                sub(\n                  PRIME,\n                  /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a80)),\n                PRIME)\n              mstore(0x4aa0, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/prev_authentication/sibling_0 = vaults_state_transition__merkle_update__side_bit_extraction__bit_0 * column3_row0 + (1 - vaults_state_transition__merkle_update__side_bit_extraction__bit_0) * column3_row256.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00),\n                  /*column3_row0*/ mload(0x3300),\n                  PRIME),\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00)),\n                    PRIME),\n                  /*column3_row256*/ mload(0x3340),\n                  PRIME),\n                PRIME)\n              mstore(0x4ac0, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/new_authentication/sibling_0 = vaults_state_transition__merkle_update__side_bit_extraction__bit_0 * column7_row0 + (1 - vaults_state_transition__merkle_update__side_bit_extraction__bit_0) * column7_row256.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00),\n                  /*column7_row0*/ mload(0x3520),\n                  PRIME),\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00)),\n                    PRIME),\n                  /*column7_row256*/ mload(0x3560),\n                  PRIME),\n                PRIME)\n              mstore(0x4ae0, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/prev_authentication/leaf_0 = (1 - vaults_state_transition__merkle_update__side_bit_extraction__bit_0) * column3_row0 + vaults_state_transition__merkle_update__side_bit_extraction__bit_0 * column3_row256.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00)),\n                    PRIME),\n                  /*column3_row0*/ mload(0x3300),\n                  PRIME),\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00),\n                  /*column3_row256*/ mload(0x3340),\n                  PRIME),\n                PRIME)\n              mstore(0x4b00, val)\n              }\n\n\n              {\n              // vaults_state_transition/merkle_update/new_authentication/leaf_0 = (1 - vaults_state_transition__merkle_update__side_bit_extraction__bit_0) * column7_row0 + vaults_state_transition__merkle_update__side_bit_extraction__bit_0 * column7_row256.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00)),\n                    PRIME),\n                  /*column7_row0*/ mload(0x3520),\n                  PRIME),\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00),\n                  /*column7_row256*/ mload(0x3560),\n                  PRIME),\n                PRIME)\n              mstore(0x4b20, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/side_bit_extraction/bit_0 = column14_row511 - (column14_row1023 + column14_row1023).\n              let val := addmod(\n                /*column14_row511*/ mload(0x3ba0),\n                sub(\n                  PRIME,\n                  addmod(/*column14_row1023*/ mload(0x3be0), /*column14_row1023*/ mload(0x3be0), PRIME)),\n                PRIME)\n              mstore(0x4b40, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit = column11_row0 - (column11_row1 + column11_row1).\n              let val := addmod(\n                /*column11_row0*/ mload(0x3960),\n                sub(\n                  PRIME,\n                  addmod(/*column11_row1*/ mload(0x3980), /*column11_row1*/ mload(0x3980), PRIME)),\n                PRIME)\n              mstore(0x4b60, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg = 1 - settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit.\n              let val := addmod(\n                1,\n                sub(\n                  PRIME,\n                  /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4b60)),\n                PRIME)\n              mstore(0x4b80, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/side_bit_extraction/bit_1 = column14_row1023 - (column14_row1535 + column14_row1535).\n              let val := addmod(\n                /*column14_row1023*/ mload(0x3be0),\n                sub(\n                  PRIME,\n                  addmod(/*column14_row1535*/ mload(0x3c20), /*column14_row1535*/ mload(0x3c20), PRIME)),\n                PRIME)\n              mstore(0x4ba0, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit = column15_row0 - (column15_row1 + column15_row1).\n              let val := addmod(\n                /*column15_row0*/ mload(0x3cc0),\n                sub(\n                  PRIME,\n                  addmod(/*column15_row1*/ mload(0x3ce0), /*column15_row1*/ mload(0x3ce0), PRIME)),\n                PRIME)\n              mstore(0x4bc0, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg = 1 - settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit.\n              let val := addmod(\n                1,\n                sub(\n                  PRIME,\n                  /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4bc0)),\n                PRIME)\n              mstore(0x4be0, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/prev_authentication/sibling_0 = settlement_state_transition__merkle_update__side_bit_extraction__bit_0 * column11_row0 + (1 - settlement_state_transition__merkle_update__side_bit_extraction__bit_0) * column11_row256.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40),\n                  /*column11_row0*/ mload(0x3960),\n                  PRIME),\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40)),\n                    PRIME),\n                  /*column11_row256*/ mload(0x39a0),\n                  PRIME),\n                PRIME)\n              mstore(0x4c00, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/new_authentication/sibling_0 = settlement_state_transition__merkle_update__side_bit_extraction__bit_0 * column15_row0 + (1 - settlement_state_transition__merkle_update__side_bit_extraction__bit_0) * column15_row256.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40),\n                  /*column15_row0*/ mload(0x3cc0),\n                  PRIME),\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40)),\n                    PRIME),\n                  /*column15_row256*/ mload(0x3d00),\n                  PRIME),\n                PRIME)\n              mstore(0x4c20, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/prev_authentication/leaf_0 = (1 - settlement_state_transition__merkle_update__side_bit_extraction__bit_0) * column11_row0 + settlement_state_transition__merkle_update__side_bit_extraction__bit_0 * column11_row256.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40)),\n                    PRIME),\n                  /*column11_row0*/ mload(0x3960),\n                  PRIME),\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40),\n                  /*column11_row256*/ mload(0x39a0),\n                  PRIME),\n                PRIME)\n              mstore(0x4c40, val)\n              }\n\n\n              {\n              // settlement_state_transition/merkle_update/new_authentication/leaf_0 = (1 - settlement_state_transition__merkle_update__side_bit_extraction__bit_0) * column15_row0 + settlement_state_transition__merkle_update__side_bit_extraction__bit_0 * column15_row256.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    1,\n                    sub(\n                      PRIME,\n                      /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40)),\n                    PRIME),\n                  /*column15_row0*/ mload(0x3cc0),\n                  PRIME),\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40),\n                  /*column15_row256*/ mload(0x3d00),\n                  PRIME),\n                PRIME)\n              mstore(0x4c60, val)\n              }\n\n\n              {\n              // amounts_range_check/bit_0 = column17_row0 - (column17_row64 + column17_row64).\n              let val := addmod(\n                /*column17_row0*/ mload(0x4200),\n                sub(\n                  PRIME,\n                  addmod(/*column17_row64*/ mload(0x4380), /*column17_row64*/ mload(0x4380), PRIME)),\n                PRIME)\n              mstore(0x4c80, val)\n              }\n\n\n              {\n              // expiration_timestamp_range_check/bit_0 = column10_row255 - (column10_row767 + column10_row767).\n              let val := addmod(\n                /*column10_row255*/ mload(0x3740),\n                sub(\n                  PRIME,\n                  addmod(/*column10_row767*/ mload(0x3780), /*column10_row767*/ mload(0x3780), PRIME)),\n                PRIME)\n              mstore(0x4ca0, val)\n              }\n\n\n              {\n              // nonce_range_check/bit_0 = column16_row1021 - (column16_row2045 + column16_row2045).\n              let val := addmod(\n                /*column16_row1021*/ mload(0x3e60),\n                sub(\n                  PRIME,\n                  addmod(/*column16_row2045*/ mload(0x3f20), /*column16_row2045*/ mload(0x3f20), PRIME)),\n                PRIME)\n              mstore(0x4cc0, val)\n              }\n\n\n              {\n              // sig_verify/doubling_key/x_squared = column17_row32 * column17_row32.\n              let val := mulmod(/*column17_row32*/ mload(0x42c0), /*column17_row32*/ mload(0x42c0), PRIME)\n              mstore(0x4ce0, val)\n              }\n\n\n              {\n              // sig_verify/exponentiate_generator/bit = column17_row84 - (column17_row212 + column17_row212).\n              let val := addmod(\n                /*column17_row84*/ mload(0x43e0),\n                sub(\n                  PRIME,\n                  addmod(/*column17_row212*/ mload(0x44a0), /*column17_row212*/ mload(0x44a0), PRIME)),\n                PRIME)\n              mstore(0x4d00, val)\n              }\n\n\n              {\n              // sig_verify/exponentiate_generator/bit_neg = 1 - sig_verify__exponentiate_generator__bit.\n              let val := addmod(\n                1,\n                sub(PRIME, /*intermediate_value/sig_verify/exponentiate_generator/bit*/ mload(0x4d00)),\n                PRIME)\n              mstore(0x4d20, val)\n              }\n\n\n              {\n              // sig_verify/exponentiate_key/bit = column17_row56 - (column17_row120 + column17_row120).\n              let val := addmod(\n                /*column17_row56*/ mload(0x4360),\n                sub(\n                  PRIME,\n                  addmod(/*column17_row120*/ mload(0x4460), /*column17_row120*/ mload(0x4460), PRIME)),\n                PRIME)\n              mstore(0x4d40, val)\n              }\n\n\n              {\n              // sig_verify/exponentiate_key/bit_neg = 1 - sig_verify__exponentiate_key__bit.\n              let val := addmod(\n                1,\n                sub(PRIME, /*intermediate_value/sig_verify/exponentiate_key/bit*/ mload(0x4d40)),\n                PRIME)\n              mstore(0x4d60, val)\n              }\n\n\n              {\n              // party_a_packed_msg/partial = ((column14_row255 * vault_shift + column14_row49407) * amount_shift + column17_row4096) * amount_shift + column17_row36864.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    mulmod(\n                      addmod(\n                        mulmod(/*column14_row255*/ mload(0x3b80), /*vault_shift*/ mload(0x340), PRIME),\n                        /*column14_row49407*/ mload(0x3ca0),\n                        PRIME),\n                      /*amount_shift*/ mload(0x2c0),\n                      PRIME),\n                    /*column17_row4096*/ mload(0x44e0),\n                    PRIME),\n                  /*amount_shift*/ mload(0x2c0),\n                  PRIME),\n                /*column17_row36864*/ mload(0x4800),\n                PRIME)\n              mstore(0x4d80, val)\n              }\n\n\n              {\n              // party_b_packed_msg/partial = ((column14_row33023 * vault_shift + column14_row16639) * amount_shift + column17_row53248) * amount_shift + column17_row20480.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    mulmod(\n                      addmod(\n                        mulmod(/*column14_row33023*/ mload(0x3c60), /*vault_shift*/ mload(0x340), PRIME),\n                        /*column14_row16639*/ mload(0x3c40),\n                        PRIME),\n                      /*amount_shift*/ mload(0x2c0),\n                      PRIME),\n                    /*column17_row53248*/ mload(0x48c0),\n                    PRIME),\n                  /*amount_shift*/ mload(0x2c0),\n                  PRIME),\n                /*column17_row20480*/ mload(0x4620),\n                PRIME)\n              mstore(0x4da0, val)\n              }\n\n\n              {\n              // party_b_packed_msg_transfer/partial = (((vault_shift + column14_row33023) * vault_shift + column14_row49407) * amount_shift + column17_row53248) * amount_shift + column17_row20480.\n              let val := addmod(\n                mulmod(\n                  addmod(\n                    mulmod(\n                      addmod(\n                        mulmod(\n                          addmod(/*vault_shift*/ mload(0x340), /*column14_row33023*/ mload(0x3c60), PRIME),\n                          /*vault_shift*/ mload(0x340),\n                          PRIME),\n                        /*column14_row49407*/ mload(0x3ca0),\n                        PRIME),\n                      /*amount_shift*/ mload(0x2c0),\n                      PRIME),\n                    /*column17_row53248*/ mload(0x48c0),\n                    PRIME),\n                  /*amount_shift*/ mload(0x2c0),\n                  PRIME),\n                /*column17_row20480*/ mload(0x4620),\n                PRIME)\n              mstore(0x4dc0, val)\n              }\n\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/booleanity_test: hash_pool__hash__ec_subset_sum__bit * (hash_pool__hash__ec_subset_sum__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/hash_pool/hash/ec_subset_sum/bit*/ mload(0x49c0),\n                addmod(\n                  /*intermediate_value/hash_pool/hash/ec_subset_sum/bit*/ mload(0x49c0),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[0].\n              val := mulmod(val, mload(0x57e0), PRIME)\n              // Denominator: point^(trace_length / 4) - 1.\n              // val *= denominator_invs[0].\n              val := mulmod(val, mload(0x50e0), PRIME)\n\n              // res += val * (coefficients[0] + coefficients[1] * adjustments[0]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[0]*/ mload(0x480),\n                                       mulmod(/*coefficients[1]*/ mload(0x4a0),\n                                              /*adjustments[0]*/mload(0x59a0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/bit_extraction_end: column16_row3.\n              let val := /*column16_row3*/ mload(0x3dc0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 1024) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[1].\n              val := mulmod(val, mload(0x5100), PRIME)\n\n              // res += val * (coefficients[2] + coefficients[3] * adjustments[1]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[2]*/ mload(0x4c0),\n                                       mulmod(/*coefficients[3]*/ mload(0x4e0),\n                                              /*adjustments[1]*/mload(0x59c0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/zeros_tail: column16_row3.\n              let val := /*column16_row3*/ mload(0x3dc0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[2].\n              val := mulmod(val, mload(0x5120), PRIME)\n\n              // res += val * (coefficients[4] + coefficients[5] * adjustments[1]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[4]*/ mload(0x500),\n                                       mulmod(/*coefficients[5]*/ mload(0x520),\n                                              /*adjustments[1]*/mload(0x59c0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/add_points/slope: hash_pool__hash__ec_subset_sum__bit * (column16_row2 - hash_pool_points__y) - column16_row1 * (column16_row0 - hash_pool_points__x).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/hash_pool/hash/ec_subset_sum/bit*/ mload(0x49c0),\n                  addmod(\n                    /*column16_row2*/ mload(0x3da0),\n                    sub(PRIME, /*periodic_column/hash_pool_points/y*/ mload(0x20)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column16_row1*/ mload(0x3d80),\n                    addmod(\n                      /*column16_row0*/ mload(0x3d60),\n                      sub(PRIME, /*periodic_column/hash_pool_points/x*/ mload(0x0)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[0].\n              val := mulmod(val, mload(0x57e0), PRIME)\n              // Denominator: point^(trace_length / 4) - 1.\n              // val *= denominator_invs[0].\n              val := mulmod(val, mload(0x50e0), PRIME)\n\n              // res += val * (coefficients[6] + coefficients[7] * adjustments[0]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[6]*/ mload(0x540),\n                                       mulmod(/*coefficients[7]*/ mload(0x560),\n                                              /*adjustments[0]*/mload(0x59a0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/add_points/x: column16_row1 * column16_row1 - hash_pool__hash__ec_subset_sum__bit * (column16_row0 + hash_pool_points__x + column16_row4).\n              let val := addmod(\n                mulmod(/*column16_row1*/ mload(0x3d80), /*column16_row1*/ mload(0x3d80), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/hash_pool/hash/ec_subset_sum/bit*/ mload(0x49c0),\n                    addmod(\n                      addmod(\n                        /*column16_row0*/ mload(0x3d60),\n                        /*periodic_column/hash_pool_points/x*/ mload(0x0),\n                        PRIME),\n                      /*column16_row4*/ mload(0x3de0),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[0].\n              val := mulmod(val, mload(0x57e0), PRIME)\n              // Denominator: point^(trace_length / 4) - 1.\n              // val *= denominator_invs[0].\n              val := mulmod(val, mload(0x50e0), PRIME)\n\n              // res += val * (coefficients[8] + coefficients[9] * adjustments[0]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[8]*/ mload(0x580),\n                                       mulmod(/*coefficients[9]*/ mload(0x5a0),\n                                              /*adjustments[0]*/mload(0x59a0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/add_points/y: hash_pool__hash__ec_subset_sum__bit * (column16_row2 + column16_row6) - column16_row1 * (column16_row0 - column16_row4).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/hash_pool/hash/ec_subset_sum/bit*/ mload(0x49c0),\n                  addmod(/*column16_row2*/ mload(0x3da0), /*column16_row6*/ mload(0x3e00), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column16_row1*/ mload(0x3d80),\n                    addmod(/*column16_row0*/ mload(0x3d60), sub(PRIME, /*column16_row4*/ mload(0x3de0)), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[0].\n              val := mulmod(val, mload(0x57e0), PRIME)\n              // Denominator: point^(trace_length / 4) - 1.\n              // val *= denominator_invs[0].\n              val := mulmod(val, mload(0x50e0), PRIME)\n\n              // res += val * (coefficients[10] + coefficients[11] * adjustments[0]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[10]*/ mload(0x5c0),\n                                       mulmod(/*coefficients[11]*/ mload(0x5e0),\n                                              /*adjustments[0]*/mload(0x59a0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/copy_point/x: hash_pool__hash__ec_subset_sum__bit_neg * (column16_row4 - column16_row0).\n              let val := mulmod(\n                /*intermediate_value/hash_pool/hash/ec_subset_sum/bit_neg*/ mload(0x49e0),\n                addmod(/*column16_row4*/ mload(0x3de0), sub(PRIME, /*column16_row0*/ mload(0x3d60)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[0].\n              val := mulmod(val, mload(0x57e0), PRIME)\n              // Denominator: point^(trace_length / 4) - 1.\n              // val *= denominator_invs[0].\n              val := mulmod(val, mload(0x50e0), PRIME)\n\n              // res += val * (coefficients[12] + coefficients[13] * adjustments[0]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[12]*/ mload(0x600),\n                                       mulmod(/*coefficients[13]*/ mload(0x620),\n                                              /*adjustments[0]*/mload(0x59a0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/ec_subset_sum/copy_point/y: hash_pool__hash__ec_subset_sum__bit_neg * (column16_row6 - column16_row2).\n              let val := mulmod(\n                /*intermediate_value/hash_pool/hash/ec_subset_sum/bit_neg*/ mload(0x49e0),\n                addmod(/*column16_row6*/ mload(0x3e00), sub(PRIME, /*column16_row2*/ mload(0x3da0)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 1024) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[0].\n              val := mulmod(val, mload(0x57e0), PRIME)\n              // Denominator: point^(trace_length / 4) - 1.\n              // val *= denominator_invs[0].\n              val := mulmod(val, mload(0x50e0), PRIME)\n\n              // res += val * (coefficients[14] + coefficients[15] * adjustments[0]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[14]*/ mload(0x640),\n                                       mulmod(/*coefficients[15]*/ mload(0x660),\n                                              /*adjustments[0]*/mload(0x59a0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/copy_point/x: column16_row1024 - column16_row1020.\n              let val := addmod(\n                /*column16_row1024*/ mload(0x3ea0),\n                sub(PRIME, /*column16_row1020*/ mload(0x3e40)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 2048) - trace_generator^(trace_length / 2).\n              // val *= numerators[1].\n              val := mulmod(val, mload(0x5800), PRIME)\n              // Denominator: point^(trace_length / 1024) - 1.\n              // val *= denominator_invs[3].\n              val := mulmod(val, mload(0x5140), PRIME)\n\n              // res += val * (coefficients[16] + coefficients[17] * adjustments[2]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[16]*/ mload(0x680),\n                                       mulmod(/*coefficients[17]*/ mload(0x6a0),\n                                              /*adjustments[2]*/mload(0x59e0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/copy_point/y: column16_row1026 - column16_row1022.\n              let val := addmod(\n                /*column16_row1026*/ mload(0x3ec0),\n                sub(PRIME, /*column16_row1022*/ mload(0x3e80)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 2048) - trace_generator^(trace_length / 2).\n              // val *= numerators[1].\n              val := mulmod(val, mload(0x5800), PRIME)\n              // Denominator: point^(trace_length / 1024) - 1.\n              // val *= denominator_invs[3].\n              val := mulmod(val, mload(0x5140), PRIME)\n\n              // res += val * (coefficients[18] + coefficients[19] * adjustments[2]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[18]*/ mload(0x6c0),\n                                       mulmod(/*coefficients[19]*/ mload(0x6e0),\n                                              /*adjustments[2]*/mload(0x59e0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/init/x: column16_row0 - shift_point.x.\n              let val := addmod(/*column16_row0*/ mload(0x3d60), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 2048) - 1.\n              // val *= denominator_invs[4].\n              val := mulmod(val, mload(0x5160), PRIME)\n\n              // res += val * (coefficients[20] + coefficients[21] * adjustments[3]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[20]*/ mload(0x700),\n                                       mulmod(/*coefficients[21]*/ mload(0x720),\n                                              /*adjustments[3]*/mload(0x5a00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/hash/init/y: column16_row2 - shift_point.y.\n              let val := addmod(/*column16_row2*/ mload(0x3da0), sub(PRIME, /*shift_point.y*/ mload(0x240)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 2048) - 1.\n              // val *= denominator_invs[4].\n              val := mulmod(val, mload(0x5160), PRIME)\n\n              // res += val * (coefficients[22] + coefficients[23] * adjustments[3]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[22]*/ mload(0x740),\n                                       mulmod(/*coefficients[23]*/ mload(0x760),\n                                              /*adjustments[3]*/mload(0x5a00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for hash_pool/output_to_input: column16_row2044 - column16_row2051.\n              let val := addmod(\n                /*column16_row2044*/ mload(0x3f00),\n                sub(PRIME, /*column16_row2051*/ mload(0x3f40)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 4096) - 1.\n              // val *= denominator_invs[5].\n              val := mulmod(val, mload(0x5180), PRIME)\n\n              // res += val * (coefficients[24] + coefficients[25] * adjustments[4]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[24]*/ mload(0x780),\n                                       mulmod(/*coefficients[25]*/ mload(0x7a0),\n                                              /*adjustments[4]*/mload(0x5a20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/side_bit_extraction/bit: vaults_state_transition__merkle_update__side_bit_extraction__bit_0 * vaults_state_transition__merkle_update__side_bit_extraction__bit_0 - vaults_state_transition__merkle_update__side_bit_extraction__bit_0.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00),\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00),\n                  PRIME),\n                sub(\n                  PRIME,\n                  /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4a00)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32).\n              // val *= numerators[2].\n              val := mulmod(val, mload(0x5820), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[26] + coefficients[27] * adjustments[5]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[26]*/ mload(0x7c0),\n                                       mulmod(/*coefficients[27]*/ mload(0x7e0),\n                                              /*adjustments[5]*/mload(0x5a40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/side_bit_extraction/zero: column14_row255.\n              let val := /*column14_row255*/ mload(0x3b80)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - trace_generator^(vaults_path_length * trace_length / 32).\n              // val *= denominator_invs[7].\n              val := mulmod(val, mload(0x51c0), PRIME)\n\n              // res += val * (coefficients[28] + coefficients[29] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[28]*/ mload(0x800),\n                                       mulmod(/*coefficients[29]*/ mload(0x820),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test: vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a20),\n                addmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a20),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[30] + coefficients[31] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[30]*/ mload(0x840),\n                                       mulmod(/*coefficients[31]*/ mload(0x860),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_extraction_end: column3_row0.\n              let val := /*column3_row0*/ mload(0x3300)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[9].\n              val := mulmod(val, mload(0x5200), PRIME)\n\n              // res += val * (coefficients[32] + coefficients[33] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[32]*/ mload(0x880),\n                                       mulmod(/*coefficients[33]*/ mload(0x8a0),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/zeros_tail: column3_row0.\n              let val := /*column3_row0*/ mload(0x3300)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[10].\n              val := mulmod(val, mload(0x5220), PRIME)\n\n              // res += val * (coefficients[34] + coefficients[35] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[34]*/ mload(0x8c0),\n                                       mulmod(/*coefficients[35]*/ mload(0x8e0),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope: vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (column1_row0 - vaults_merkle_hash_points__y) - column2_row0 * (column0_row0 - vaults_merkle_hash_points__x).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a20),\n                  addmod(\n                    /*column1_row0*/ mload(0x3260),\n                    sub(PRIME, /*periodic_column/vaults_merkle_hash_points/y*/ mload(0x60)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column2_row0*/ mload(0x32e0),\n                    addmod(\n                      /*column0_row0*/ mload(0x3180),\n                      sub(PRIME, /*periodic_column/vaults_merkle_hash_points/x*/ mload(0x40)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[36] + coefficients[37] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[36]*/ mload(0x900),\n                                       mulmod(/*coefficients[37]*/ mload(0x920),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x: column2_row0 * column2_row0 - vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (column0_row0 + vaults_merkle_hash_points__x + column0_row1).\n              let val := addmod(\n                mulmod(/*column2_row0*/ mload(0x32e0), /*column2_row0*/ mload(0x32e0), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a20),\n                    addmod(\n                      addmod(\n                        /*column0_row0*/ mload(0x3180),\n                        /*periodic_column/vaults_merkle_hash_points/x*/ mload(0x40),\n                        PRIME),\n                      /*column0_row1*/ mload(0x31a0),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[38] + coefficients[39] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[38]*/ mload(0x940),\n                                       mulmod(/*coefficients[39]*/ mload(0x960),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y: vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (column1_row0 + column1_row1) - column2_row0 * (column0_row0 - column0_row1).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a20),\n                  addmod(/*column1_row0*/ mload(0x3260), /*column1_row1*/ mload(0x3280), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column2_row0*/ mload(0x32e0),\n                    addmod(/*column0_row0*/ mload(0x3180), sub(PRIME, /*column0_row1*/ mload(0x31a0)), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[40] + coefficients[41] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[40]*/ mload(0x980),\n                                       mulmod(/*coefficients[41]*/ mload(0x9a0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x: vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit_neg * (column0_row1 - column0_row0).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4a40),\n                addmod(/*column0_row1*/ mload(0x31a0), sub(PRIME, /*column0_row0*/ mload(0x3180)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[42] + coefficients[43] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[42]*/ mload(0x9c0),\n                                       mulmod(/*coefficients[43]*/ mload(0x9e0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y: vaults_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit_neg * (column1_row1 - column1_row0).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4a40),\n                addmod(/*column1_row1*/ mload(0x3280), sub(PRIME, /*column1_row0*/ mload(0x3260)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[44] + coefficients[45] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[44]*/ mload(0xa00),\n                                       mulmod(/*coefficients[45]*/ mload(0xa20),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/x: column0_row256 - column0_row255.\n              let val := addmod(\n                /*column0_row256*/ mload(0x31e0),\n                sub(PRIME, /*column0_row255*/ mload(0x31c0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[46] + coefficients[47] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[46]*/ mload(0xa40),\n                                       mulmod(/*coefficients[47]*/ mload(0xa60),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/copy_point/y: column1_row256 - column1_row255.\n              let val := addmod(\n                /*column1_row256*/ mload(0x32c0),\n                sub(PRIME, /*column1_row255*/ mload(0x32a0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[48] + coefficients[49] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[48]*/ mload(0xa80),\n                                       mulmod(/*coefficients[49]*/ mload(0xaa0),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/init/x: column0_row0 - shift_point.x.\n              let val := addmod(/*column0_row0*/ mload(0x3180), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[50] + coefficients[51] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[50]*/ mload(0xac0),\n                                       mulmod(/*coefficients[51]*/ mload(0xae0),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/hashes/init/y: column1_row0 - shift_point.y.\n              let val := addmod(/*column1_row0*/ mload(0x3260), sub(PRIME, /*shift_point.y*/ mload(0x240)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[52] + coefficients[53] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[52]*/ mload(0xb00),\n                                       mulmod(/*coefficients[53]*/ mload(0xb20),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_left: (1 - vaults_state_transition__merkle_update__side_bit_extraction__bit_1) * (column0_row511 - column3_row512).\n              let val := mulmod(\n                addmod(\n                  1,\n                  sub(\n                    PRIME,\n                    /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4a60)),\n                  PRIME),\n                addmod(\n                  /*column0_row511*/ mload(0x3200),\n                  sub(PRIME, /*column3_row512*/ mload(0x3360)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32)) * (point^(trace_length / 16384) - trace_generator^(15 * trace_length / 16)).\n              // val *= numerators[5].\n              val := mulmod(val, mload(0x5880), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[54] + coefficients[55] * adjustments[11]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[54]*/ mload(0xb40),\n                                       mulmod(/*coefficients[55]*/ mload(0xb60),\n                                              /*adjustments[11]*/mload(0x5b00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/prev_authentication/copy_prev_to_right: vaults_state_transition__merkle_update__side_bit_extraction__bit_1 * (column0_row511 - column3_row768).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4a60),\n                addmod(\n                  /*column0_row511*/ mload(0x3200),\n                  sub(PRIME, /*column3_row768*/ mload(0x3380)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32)) * (point^(trace_length / 16384) - trace_generator^(15 * trace_length / 16)).\n              // val *= numerators[5].\n              val := mulmod(val, mload(0x5880), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[56] + coefficients[57] * adjustments[11]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[56]*/ mload(0xb80),\n                                       mulmod(/*coefficients[57]*/ mload(0xba0),\n                                              /*adjustments[11]*/mload(0x5b00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test: vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a80),\n                addmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a80),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[58] + coefficients[59] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[58]*/ mload(0xbc0),\n                                       mulmod(/*coefficients[59]*/ mload(0xbe0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_extraction_end: column7_row0.\n              let val := /*column7_row0*/ mload(0x3520)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[9].\n              val := mulmod(val, mload(0x5200), PRIME)\n\n              // res += val * (coefficients[60] + coefficients[61] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[60]*/ mload(0xc00),\n                                       mulmod(/*coefficients[61]*/ mload(0xc20),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/zeros_tail: column7_row0.\n              let val := /*column7_row0*/ mload(0x3520)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[10].\n              val := mulmod(val, mload(0x5220), PRIME)\n\n              // res += val * (coefficients[62] + coefficients[63] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[62]*/ mload(0xc40),\n                                       mulmod(/*coefficients[63]*/ mload(0xc60),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope: vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (column5_row0 - vaults_merkle_hash_points__y) - column6_row0 * (column4_row0 - vaults_merkle_hash_points__x).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a80),\n                  addmod(\n                    /*column5_row0*/ mload(0x3480),\n                    sub(PRIME, /*periodic_column/vaults_merkle_hash_points/y*/ mload(0x60)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column6_row0*/ mload(0x3500),\n                    addmod(\n                      /*column4_row0*/ mload(0x33a0),\n                      sub(PRIME, /*periodic_column/vaults_merkle_hash_points/x*/ mload(0x40)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[64] + coefficients[65] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[64]*/ mload(0xc80),\n                                       mulmod(/*coefficients[65]*/ mload(0xca0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x: column6_row0 * column6_row0 - vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (column4_row0 + vaults_merkle_hash_points__x + column4_row1).\n              let val := addmod(\n                mulmod(/*column6_row0*/ mload(0x3500), /*column6_row0*/ mload(0x3500), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a80),\n                    addmod(\n                      addmod(\n                        /*column4_row0*/ mload(0x33a0),\n                        /*periodic_column/vaults_merkle_hash_points/x*/ mload(0x40),\n                        PRIME),\n                      /*column4_row1*/ mload(0x33c0),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[66] + coefficients[67] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[66]*/ mload(0xcc0),\n                                       mulmod(/*coefficients[67]*/ mload(0xce0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y: vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (column5_row0 + column5_row1) - column6_row0 * (column4_row0 - column4_row1).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4a80),\n                  addmod(/*column5_row0*/ mload(0x3480), /*column5_row1*/ mload(0x34a0), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column6_row0*/ mload(0x3500),\n                    addmod(/*column4_row0*/ mload(0x33a0), sub(PRIME, /*column4_row1*/ mload(0x33c0)), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[68] + coefficients[69] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[68]*/ mload(0xd00),\n                                       mulmod(/*coefficients[69]*/ mload(0xd20),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x: vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit_neg * (column4_row1 - column4_row0).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4aa0),\n                addmod(/*column4_row1*/ mload(0x33c0), sub(PRIME, /*column4_row0*/ mload(0x33a0)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[70] + coefficients[71] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[70]*/ mload(0xd40),\n                                       mulmod(/*coefficients[71]*/ mload(0xd60),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y: vaults_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit_neg * (column5_row1 - column5_row0).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4aa0),\n                addmod(/*column5_row1*/ mload(0x34a0), sub(PRIME, /*column5_row0*/ mload(0x3480)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[72] + coefficients[73] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[72]*/ mload(0xd80),\n                                       mulmod(/*coefficients[73]*/ mload(0xda0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/x: column4_row256 - column4_row255.\n              let val := addmod(\n                /*column4_row256*/ mload(0x3400),\n                sub(PRIME, /*column4_row255*/ mload(0x33e0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[74] + coefficients[75] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[74]*/ mload(0xdc0),\n                                       mulmod(/*coefficients[75]*/ mload(0xde0),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/copy_point/y: column5_row256 - column5_row255.\n              let val := addmod(\n                /*column5_row256*/ mload(0x34e0),\n                sub(PRIME, /*column5_row255*/ mload(0x34c0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[76] + coefficients[77] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[76]*/ mload(0xe00),\n                                       mulmod(/*coefficients[77]*/ mload(0xe20),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/init/x: column4_row0 - shift_point.x.\n              let val := addmod(/*column4_row0*/ mload(0x33a0), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[78] + coefficients[79] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[78]*/ mload(0xe40),\n                                       mulmod(/*coefficients[79]*/ mload(0xe60),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/hashes/init/y: column5_row0 - shift_point.y.\n              let val := addmod(/*column5_row0*/ mload(0x3480), sub(PRIME, /*shift_point.y*/ mload(0x240)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[80] + coefficients[81] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[80]*/ mload(0xe80),\n                                       mulmod(/*coefficients[81]*/ mload(0xea0),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/copy_prev_to_left: (1 - vaults_state_transition__merkle_update__side_bit_extraction__bit_1) * (column4_row511 - column7_row512).\n              let val := mulmod(\n                addmod(\n                  1,\n                  sub(\n                    PRIME,\n                    /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4a60)),\n                  PRIME),\n                addmod(\n                  /*column4_row511*/ mload(0x3420),\n                  sub(PRIME, /*column7_row512*/ mload(0x3580)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32)) * (point^(trace_length / 16384) - trace_generator^(15 * trace_length / 16)).\n              // val *= numerators[5].\n              val := mulmod(val, mload(0x5880), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[82] + coefficients[83] * adjustments[11]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[82]*/ mload(0xec0),\n                                       mulmod(/*coefficients[83]*/ mload(0xee0),\n                                              /*adjustments[11]*/mload(0x5b00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/new_authentication/copy_prev_to_right: vaults_state_transition__merkle_update__side_bit_extraction__bit_1 * (column4_row511 - column7_row768).\n              let val := mulmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4a60),\n                addmod(\n                  /*column4_row511*/ mload(0x3420),\n                  sub(PRIME, /*column7_row768*/ mload(0x35a0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32)) * (point^(trace_length / 16384) - trace_generator^(15 * trace_length / 16)).\n              // val *= numerators[5].\n              val := mulmod(val, mload(0x5880), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[84] + coefficients[85] * adjustments[11]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[84]*/ mload(0xf00),\n                                       mulmod(/*coefficients[85]*/ mload(0xf20),\n                                              /*adjustments[11]*/mload(0x5b00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_update/same_siblings: vaults_state_transition__merkle_update__prev_authentication__sibling_0 - vaults_state_transition__merkle_update__new_authentication__sibling_0.\n              let val := addmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/sibling_0*/ mload(0x4ac0),\n                sub(\n                  PRIME,\n                  /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/sibling_0*/ mload(0x4ae0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32).\n              // val *= numerators[2].\n              val := mulmod(val, mload(0x5820), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[86] + coefficients[87] * adjustments[5]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[86]*/ mload(0xf40),\n                                       mulmod(/*coefficients[87]*/ mload(0xf60),\n                                              /*adjustments[5]*/mload(0x5a40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_set_prev_leaf: vaults_state_transition__merkle_update__prev_authentication__leaf_0 - column16_row4092.\n              let val := addmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/prev_authentication/leaf_0*/ mload(0x4b00),\n                sub(PRIME, /*column16_row4092*/ mload(0x3f80)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[88] + coefficients[89] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[88]*/ mload(0xf80),\n                                       mulmod(/*coefficients[89]*/ mload(0xfa0),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for vaults_state_transition/merkle_set_new_leaf: vaults_state_transition__merkle_update__new_authentication__leaf_0 - column16_row12284.\n              let val := addmod(\n                /*intermediate_value/vaults_state_transition/merkle_update/new_authentication/leaf_0*/ mload(0x4b20),\n                sub(PRIME, /*column16_row12284*/ mload(0x4080)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[90] + coefficients[91] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[90]*/ mload(0xfc0),\n                                       mulmod(/*coefficients[91]*/ mload(0xfe0),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for modification_boundary_key: is_modification * (column17_row16324 * boundary_base - boundary_key).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  mulmod(\n                    /*column17_row16324*/ mload(0x4540),\n                    /*periodic_column/boundary_base*/ mload(0x80),\n                    PRIME),\n                  sub(PRIME, /*periodic_column/boundary_key*/ mload(0xe0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[92] + coefficients[93] * adjustments[13]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[92]*/ mload(0x1000),\n                                       mulmod(/*coefficients[93]*/ mload(0x1020),\n                                              /*adjustments[13]*/mload(0x5b40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for modification_boundary_token: is_modification * (column17_row16344 * boundary_base - boundary_token).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  mulmod(\n                    /*column17_row16344*/ mload(0x4580),\n                    /*periodic_column/boundary_base*/ mload(0x80),\n                    PRIME),\n                  sub(PRIME, /*periodic_column/boundary_token*/ mload(0x100)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[94] + coefficients[95] * adjustments[13]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[94]*/ mload(0x1040),\n                                       mulmod(/*coefficients[95]*/ mload(0x1060),\n                                              /*adjustments[13]*/mload(0x5b40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for modification_boundary_amount0: is_modification * (column16_row3075 * boundary_base - boundary_amount0).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  mulmod(\n                    /*column16_row3075*/ mload(0x3f60),\n                    /*periodic_column/boundary_base*/ mload(0x80),\n                    PRIME),\n                  sub(PRIME, /*periodic_column/boundary_amount0*/ mload(0x120)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[96] + coefficients[97] * adjustments[13]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[96]*/ mload(0x1080),\n                                       mulmod(/*coefficients[97]*/ mload(0x10a0),\n                                              /*adjustments[13]*/mload(0x5b40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for modification_boundary_amount1: is_modification * (column16_row11267 * boundary_base - boundary_amount1).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  mulmod(\n                    /*column16_row11267*/ mload(0x4060),\n                    /*periodic_column/boundary_base*/ mload(0x80),\n                    PRIME),\n                  sub(PRIME, /*periodic_column/boundary_amount1*/ mload(0x140)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[98] + coefficients[99] * adjustments[13]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[98]*/ mload(0x10c0),\n                                       mulmod(/*coefficients[99]*/ mload(0x10e0),\n                                              /*adjustments[13]*/mload(0x5b40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for modification_boundary_vault_id: is_modification * (column14_row255 * boundary_base - boundary_vault_id).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  mulmod(\n                    /*column14_row255*/ mload(0x3b80),\n                    /*periodic_column/boundary_base*/ mload(0x80),\n                    PRIME),\n                  sub(PRIME, /*periodic_column/boundary_vault_id*/ mload(0x160)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[100] + coefficients[101] * adjustments[13]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[100]*/ mload(0x1100),\n                                       mulmod(/*coefficients[101]*/ mload(0x1120),\n                                              /*adjustments[13]*/mload(0x5b40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/side_bit_extraction/bit: settlement_state_transition__merkle_update__side_bit_extraction__bit_0 * settlement_state_transition__merkle_update__side_bit_extraction__bit_0 - settlement_state_transition__merkle_update__side_bit_extraction__bit_0.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40),\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40),\n                  PRIME),\n                sub(\n                  PRIME,\n                  /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_0*/ mload(0x4b40)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64).\n              // val *= numerators[6].\n              val := mulmod(val, mload(0x58a0), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[102] + coefficients[103] * adjustments[14]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[102]*/ mload(0x1140),\n                                       mulmod(/*coefficients[103]*/ mload(0x1160),\n                                              /*adjustments[14]*/mload(0x5b60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/side_bit_extraction/zero: column14_row511.\n              let val := /*column14_row511*/ mload(0x3ba0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[14].\n              val := mulmod(val, mload(0x52a0), PRIME)\n\n              // res += val * (coefficients[104] + coefficients[105] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[104]*/ mload(0x1180),\n                                       mulmod(/*coefficients[105]*/ mload(0x11a0),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/booleanity_test: settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4b60),\n                addmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4b60),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[106] + coefficients[107] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[106]*/ mload(0x11c0),\n                                       mulmod(/*coefficients[107]*/ mload(0x11e0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_extraction_end: column11_row0.\n              let val := /*column11_row0*/ mload(0x3960)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[9].\n              val := mulmod(val, mload(0x5200), PRIME)\n\n              // res += val * (coefficients[108] + coefficients[109] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[108]*/ mload(0x1200),\n                                       mulmod(/*coefficients[109]*/ mload(0x1220),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/zeros_tail: column11_row0.\n              let val := /*column11_row0*/ mload(0x3960)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[10].\n              val := mulmod(val, mload(0x5220), PRIME)\n\n              // res += val * (coefficients[110] + coefficients[111] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[110]*/ mload(0x1240),\n                                       mulmod(/*coefficients[111]*/ mload(0x1260),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/slope: settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (column9_row0 - settlement_merkle_hash_points__y) - column10_row0 * (column8_row0 - settlement_merkle_hash_points__x).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4b60),\n                  addmod(\n                    /*column9_row0*/ mload(0x36a0),\n                    sub(PRIME, /*periodic_column/settlement_merkle_hash_points/y*/ mload(0x1a0)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column10_row0*/ mload(0x3720),\n                    addmod(\n                      /*column8_row0*/ mload(0x35c0),\n                      sub(PRIME, /*periodic_column/settlement_merkle_hash_points/x*/ mload(0x180)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[112] + coefficients[113] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[112]*/ mload(0x1280),\n                                       mulmod(/*coefficients[113]*/ mload(0x12a0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/x: column10_row0 * column10_row0 - settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (column8_row0 + settlement_merkle_hash_points__x + column8_row1).\n              let val := addmod(\n                mulmod(/*column10_row0*/ mload(0x3720), /*column10_row0*/ mload(0x3720), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4b60),\n                    addmod(\n                      addmod(\n                        /*column8_row0*/ mload(0x35c0),\n                        /*periodic_column/settlement_merkle_hash_points/x*/ mload(0x180),\n                        PRIME),\n                      /*column8_row1*/ mload(0x35e0),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[114] + coefficients[115] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[114]*/ mload(0x12c0),\n                                       mulmod(/*coefficients[115]*/ mload(0x12e0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/add_points/y: settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit * (column9_row0 + column9_row1) - column10_row0 * (column8_row0 - column8_row1).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit*/ mload(0x4b60),\n                  addmod(/*column9_row0*/ mload(0x36a0), /*column9_row1*/ mload(0x36c0), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column10_row0*/ mload(0x3720),\n                    addmod(/*column8_row0*/ mload(0x35c0), sub(PRIME, /*column8_row1*/ mload(0x35e0)), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[116] + coefficients[117] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[116]*/ mload(0x1300),\n                                       mulmod(/*coefficients[117]*/ mload(0x1320),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/x: settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit_neg * (column8_row1 - column8_row0).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4b80),\n                addmod(/*column8_row1*/ mload(0x35e0), sub(PRIME, /*column8_row0*/ mload(0x35c0)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[118] + coefficients[119] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[118]*/ mload(0x1340),\n                                       mulmod(/*coefficients[119]*/ mload(0x1360),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/copy_point/y: settlement_state_transition__merkle_update__prev_authentication__hashes__ec_subset_sum__bit_neg * (column9_row1 - column9_row0).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4b80),\n                addmod(/*column9_row1*/ mload(0x36c0), sub(PRIME, /*column9_row0*/ mload(0x36a0)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[120] + coefficients[121] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[120]*/ mload(0x1380),\n                                       mulmod(/*coefficients[121]*/ mload(0x13a0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/x: column8_row256 - column8_row255.\n              let val := addmod(\n                /*column8_row256*/ mload(0x3620),\n                sub(PRIME, /*column8_row255*/ mload(0x3600)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[122] + coefficients[123] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[122]*/ mload(0x13c0),\n                                       mulmod(/*coefficients[123]*/ mload(0x13e0),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/copy_point/y: column9_row256 - column9_row255.\n              let val := addmod(\n                /*column9_row256*/ mload(0x3700),\n                sub(PRIME, /*column9_row255*/ mload(0x36e0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[124] + coefficients[125] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[124]*/ mload(0x1400),\n                                       mulmod(/*coefficients[125]*/ mload(0x1420),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/init/x: column8_row0 - shift_point.x.\n              let val := addmod(/*column8_row0*/ mload(0x35c0), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[126] + coefficients[127] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[126]*/ mload(0x1440),\n                                       mulmod(/*coefficients[127]*/ mload(0x1460),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/hashes/init/y: column9_row0 - shift_point.y.\n              let val := addmod(/*column9_row0*/ mload(0x36a0), sub(PRIME, /*shift_point.y*/ mload(0x240)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[128] + coefficients[129] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[128]*/ mload(0x1480),\n                                       mulmod(/*coefficients[129]*/ mload(0x14a0),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_left: (1 - settlement_state_transition__merkle_update__side_bit_extraction__bit_1) * (column8_row511 - column11_row512).\n              let val := mulmod(\n                addmod(\n                  1,\n                  sub(\n                    PRIME,\n                    /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4ba0)),\n                  PRIME),\n                addmod(\n                  /*column8_row511*/ mload(0x3640),\n                  sub(PRIME, /*column11_row512*/ mload(0x39c0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64)) * (point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32)).\n              // val *= numerators[7].\n              val := mulmod(val, mload(0x58c0), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[130] + coefficients[131] * adjustments[16]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[130]*/ mload(0x14c0),\n                                       mulmod(/*coefficients[131]*/ mload(0x14e0),\n                                              /*adjustments[16]*/mload(0x5ba0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/prev_authentication/copy_prev_to_right: settlement_state_transition__merkle_update__side_bit_extraction__bit_1 * (column8_row511 - column11_row768).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4ba0),\n                addmod(\n                  /*column8_row511*/ mload(0x3640),\n                  sub(PRIME, /*column11_row768*/ mload(0x39e0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64)) * (point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32)).\n              // val *= numerators[7].\n              val := mulmod(val, mload(0x58c0), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[132] + coefficients[133] * adjustments[16]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[132]*/ mload(0x1500),\n                                       mulmod(/*coefficients[133]*/ mload(0x1520),\n                                              /*adjustments[16]*/mload(0x5ba0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/booleanity_test: settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4bc0),\n                addmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4bc0),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[134] + coefficients[135] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[134]*/ mload(0x1540),\n                                       mulmod(/*coefficients[135]*/ mload(0x1560),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_extraction_end: column15_row0.\n              let val := /*column15_row0*/ mload(0x3cc0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[9].\n              val := mulmod(val, mload(0x5200), PRIME)\n\n              // res += val * (coefficients[136] + coefficients[137] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[136]*/ mload(0x1580),\n                                       mulmod(/*coefficients[137]*/ mload(0x15a0),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/zeros_tail: column15_row0.\n              let val := /*column15_row0*/ mload(0x3cc0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[10].\n              val := mulmod(val, mload(0x5220), PRIME)\n\n              // res += val * (coefficients[138] + coefficients[139] * adjustments[8]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[138]*/ mload(0x15c0),\n                                       mulmod(/*coefficients[139]*/ mload(0x15e0),\n                                              /*adjustments[8]*/mload(0x5aa0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/slope: settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (column13_row0 - settlement_merkle_hash_points__y) - column14_row0 * (column12_row0 - settlement_merkle_hash_points__x).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4bc0),\n                  addmod(\n                    /*column13_row0*/ mload(0x3ae0),\n                    sub(PRIME, /*periodic_column/settlement_merkle_hash_points/y*/ mload(0x1a0)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column14_row0*/ mload(0x3b60),\n                    addmod(\n                      /*column12_row0*/ mload(0x3a00),\n                      sub(PRIME, /*periodic_column/settlement_merkle_hash_points/x*/ mload(0x180)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[140] + coefficients[141] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[140]*/ mload(0x1600),\n                                       mulmod(/*coefficients[141]*/ mload(0x1620),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/x: column14_row0 * column14_row0 - settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (column12_row0 + settlement_merkle_hash_points__x + column12_row1).\n              let val := addmod(\n                mulmod(/*column14_row0*/ mload(0x3b60), /*column14_row0*/ mload(0x3b60), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4bc0),\n                    addmod(\n                      addmod(\n                        /*column12_row0*/ mload(0x3a00),\n                        /*periodic_column/settlement_merkle_hash_points/x*/ mload(0x180),\n                        PRIME),\n                      /*column12_row1*/ mload(0x3a20),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[142] + coefficients[143] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[142]*/ mload(0x1640),\n                                       mulmod(/*coefficients[143]*/ mload(0x1660),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/add_points/y: settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit * (column13_row0 + column13_row1) - column14_row0 * (column12_row0 - column12_row1).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit*/ mload(0x4bc0),\n                  addmod(/*column13_row0*/ mload(0x3ae0), /*column13_row1*/ mload(0x3b00), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column14_row0*/ mload(0x3b60),\n                    addmod(/*column12_row0*/ mload(0x3a00), sub(PRIME, /*column12_row1*/ mload(0x3a20)), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[144] + coefficients[145] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[144]*/ mload(0x1680),\n                                       mulmod(/*coefficients[145]*/ mload(0x16a0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/x: settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit_neg * (column12_row1 - column12_row0).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4be0),\n                addmod(/*column12_row1*/ mload(0x3a20), sub(PRIME, /*column12_row0*/ mload(0x3a00)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[146] + coefficients[147] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[146]*/ mload(0x16c0),\n                                       mulmod(/*coefficients[147]*/ mload(0x16e0),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/copy_point/y: settlement_state_transition__merkle_update__new_authentication__hashes__ec_subset_sum__bit_neg * (column13_row1 - column13_row0).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/hashes/ec_subset_sum/bit_neg*/ mload(0x4be0),\n                addmod(/*column13_row1*/ mload(0x3b00), sub(PRIME, /*column13_row0*/ mload(0x3ae0)), PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[3].\n              val := mulmod(val, mload(0x5840), PRIME)\n              // Denominator: point^trace_length - 1.\n              // val *= denominator_invs[8].\n              val := mulmod(val, mload(0x51e0), PRIME)\n\n              // res += val * (coefficients[148] + coefficients[149] * adjustments[7]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[148]*/ mload(0x1700),\n                                       mulmod(/*coefficients[149]*/ mload(0x1720),\n                                              /*adjustments[7]*/mload(0x5a80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/x: column12_row256 - column12_row255.\n              let val := addmod(\n                /*column12_row256*/ mload(0x3a60),\n                sub(PRIME, /*column12_row255*/ mload(0x3a40)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[150] + coefficients[151] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[150]*/ mload(0x1740),\n                                       mulmod(/*coefficients[151]*/ mload(0x1760),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/copy_point/y: column13_row256 - column13_row255.\n              let val := addmod(\n                /*column13_row256*/ mload(0x3b40),\n                sub(PRIME, /*column13_row255*/ mload(0x3b20)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\n              // val *= numerators[4].\n              val := mulmod(val, mload(0x5860), PRIME)\n              // Denominator: point^(trace_length / 256) - 1.\n              // val *= denominator_invs[11].\n              val := mulmod(val, mload(0x5240), PRIME)\n\n              // res += val * (coefficients[152] + coefficients[153] * adjustments[9]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[152]*/ mload(0x1780),\n                                       mulmod(/*coefficients[153]*/ mload(0x17a0),\n                                              /*adjustments[9]*/mload(0x5ac0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/init/x: column12_row0 - shift_point.x.\n              let val := addmod(/*column12_row0*/ mload(0x3a00), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[154] + coefficients[155] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[154]*/ mload(0x17c0),\n                                       mulmod(/*coefficients[155]*/ mload(0x17e0),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/hashes/init/y: column13_row0 - shift_point.y.\n              let val := addmod(/*column13_row0*/ mload(0x3ae0), sub(PRIME, /*shift_point.y*/ mload(0x240)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[156] + coefficients[157] * adjustments[10]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[156]*/ mload(0x1800),\n                                       mulmod(/*coefficients[157]*/ mload(0x1820),\n                                              /*adjustments[10]*/mload(0x5ae0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/copy_prev_to_left: (1 - settlement_state_transition__merkle_update__side_bit_extraction__bit_1) * (column12_row511 - column15_row512).\n              let val := mulmod(\n                addmod(\n                  1,\n                  sub(\n                    PRIME,\n                    /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4ba0)),\n                  PRIME),\n                addmod(\n                  /*column12_row511*/ mload(0x3a80),\n                  sub(PRIME, /*column15_row512*/ mload(0x3d20)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64)) * (point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32)).\n              // val *= numerators[7].\n              val := mulmod(val, mload(0x58c0), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[158] + coefficients[159] * adjustments[16]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[158]*/ mload(0x1840),\n                                       mulmod(/*coefficients[159]*/ mload(0x1860),\n                                              /*adjustments[16]*/mload(0x5ba0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/new_authentication/copy_prev_to_right: settlement_state_transition__merkle_update__side_bit_extraction__bit_1 * (column12_row511 - column15_row768).\n              let val := mulmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/side_bit_extraction/bit_1*/ mload(0x4ba0),\n                addmod(\n                  /*column12_row511*/ mload(0x3a80),\n                  sub(PRIME, /*column15_row768*/ mload(0x3d40)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: (point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64)) * (point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32)).\n              // val *= numerators[7].\n              val := mulmod(val, mload(0x58c0), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[160] + coefficients[161] * adjustments[16]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[160]*/ mload(0x1880),\n                                       mulmod(/*coefficients[161]*/ mload(0x18a0),\n                                              /*adjustments[16]*/mload(0x5ba0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_update/same_siblings: settlement_state_transition__merkle_update__prev_authentication__sibling_0 - settlement_state_transition__merkle_update__new_authentication__sibling_0.\n              let val := addmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/sibling_0*/ mload(0x4c00),\n                sub(\n                  PRIME,\n                  /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/sibling_0*/ mload(0x4c20)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(63 * trace_length / 64).\n              // val *= numerators[6].\n              val := mulmod(val, mload(0x58a0), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[162] + coefficients[163] * adjustments[14]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[162]*/ mload(0x18c0),\n                                       mulmod(/*coefficients[163]*/ mload(0x18e0),\n                                              /*adjustments[14]*/mload(0x5b60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_set_prev_leaf: settlement_state_transition__merkle_update__prev_authentication__leaf_0 - column17_row16368.\n              let val := addmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/prev_authentication/leaf_0*/ mload(0x4c40),\n                sub(PRIME, /*column17_row16368*/ mload(0x45c0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[164] + coefficients[165] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[164]*/ mload(0x1900),\n                                       mulmod(/*coefficients[165]*/ mload(0x1920),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/merkle_set_new_leaf: settlement_state_transition__merkle_update__new_authentication__leaf_0 - column17_row32752.\n              let val := addmod(\n                /*intermediate_value/settlement_state_transition/merkle_update/new_authentication/leaf_0*/ mload(0x4c60),\n                sub(PRIME, /*column17_row32752*/ mload(0x47a0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[166] + coefficients[167] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[166]*/ mload(0x1940),\n                                       mulmod(/*coefficients[167]*/ mload(0x1960),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/set_prev_root: is_settlement * (column8_row32255 - column10_row14847).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column8_row32255*/ mload(0x3660),\n                  sub(PRIME, /*column10_row14847*/ mload(0x3840)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[168] + coefficients[169] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[168]*/ mload(0x1980),\n                                       mulmod(/*coefficients[169]*/ mload(0x19a0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/root_consistency: is_settlement * (column8_row65023 - column12_row32255).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column8_row65023*/ mload(0x3680),\n                  sub(PRIME, /*column12_row32255*/ mload(0x3aa0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[170] + coefficients[171] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[170]*/ mload(0x19c0),\n                                       mulmod(/*coefficients[171]*/ mload(0x19e0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/set_new_root: is_settlement * (column12_row65023 - column10_row47615).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column12_row65023*/ mload(0x3ac0),\n                  sub(PRIME, /*column10_row47615*/ mload(0x3900)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[172] + coefficients[173] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[172]*/ mload(0x1a00),\n                                       mulmod(/*coefficients[173]*/ mload(0x1a20),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for settlement_state_transition/dont_change_if_modification: is_modification * (column10_row14847 - column10_row47615).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  /*column10_row14847*/ mload(0x3840),\n                  sub(PRIME, /*column10_row47615*/ mload(0x3900)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[174] + coefficients[175] * adjustments[19]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[174]*/ mload(0x1a40),\n                                       mulmod(/*coefficients[175]*/ mload(0x1a60),\n                                              /*adjustments[19]*/mload(0x5c00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for amounts_range_check/bit: amounts_range_check__bit_0 * amounts_range_check__bit_0 - amounts_range_check__bit_0.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/amounts_range_check/bit_0*/ mload(0x4c80),\n                  /*intermediate_value/amounts_range_check/bit_0*/ mload(0x4c80),\n                  PRIME),\n                sub(PRIME, /*intermediate_value/amounts_range_check/bit_0*/ mload(0x4c80)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 4096) - trace_generator^(63 * trace_length / 64).\n              // val *= numerators[8].\n              val := mulmod(val, mload(0x58e0), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[176] + coefficients[177] * adjustments[20]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[176]*/ mload(0x1a80),\n                                       mulmod(/*coefficients[177]*/ mload(0x1aa0),\n                                              /*adjustments[20]*/mload(0x5c20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for amounts_range_check/zero: column17_row0.\n              let val := /*column17_row0*/ mload(0x4200)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 4096) - trace_generator^(63 * trace_length / 64).\n              // val *= denominator_invs[17].\n              val := mulmod(val, mload(0x5300), PRIME)\n\n              // res += val * (coefficients[178] + coefficients[179] * adjustments[4]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[178]*/ mload(0x1ac0),\n                                       mulmod(/*coefficients[179]*/ mload(0x1ae0),\n                                              /*adjustments[4]*/mload(0x5a20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for total_token_a_not_changed: is_settlement * (column16_row3075 + column16_row19459 - (column16_row11267 + column16_row27651)).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  addmod(/*column16_row3075*/ mload(0x3f60), /*column16_row19459*/ mload(0x40a0), PRIME),\n                  sub(\n                    PRIME,\n                    addmod(/*column16_row11267*/ mload(0x4060), /*column16_row27651*/ mload(0x40c0), PRIME)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[180] + coefficients[181] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[180]*/ mload(0x1b00),\n                                       mulmod(/*coefficients[181]*/ mload(0x1b20),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for total_token_b_not_changed: is_settlement * (column16_row35843 + column16_row52227 - (column16_row44035 + column16_row60419)).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  addmod(/*column16_row35843*/ mload(0x4100), /*column16_row52227*/ mload(0x41c0), PRIME),\n                  sub(\n                    PRIME,\n                    addmod(/*column16_row44035*/ mload(0x41a0), /*column16_row60419*/ mload(0x41e0), PRIME)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[182] + coefficients[183] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[182]*/ mload(0x1b40),\n                                       mulmod(/*coefficients[183]*/ mload(0x1b60),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for party_a_fulfilled_amount: is_settlement * (column17_row32752 - (column17_row16368 + column17_row8192)).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column17_row32752*/ mload(0x47a0),\n                  sub(\n                    PRIME,\n                    addmod(/*column17_row16368*/ mload(0x45c0), /*column17_row8192*/ mload(0x4500), PRIME)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[184] + coefficients[185] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[184]*/ mload(0x1b80),\n                                       mulmod(/*coefficients[185]*/ mload(0x1ba0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for party_b_fulfilled_amount: is_settlement * (column17_row65520 - (column17_row49136 + column17_row40960)).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column17_row65520*/ mload(0x4980),\n                  sub(\n                    PRIME,\n                    addmod(/*column17_row49136*/ mload(0x48a0), /*column17_row40960*/ mload(0x4820), PRIME)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[186] + coefficients[187] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[186]*/ mload(0x1bc0),\n                                       mulmod(/*coefficients[187]*/ mload(0x1be0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for amount_a_range_check_input: (column17_row8192 + column16_row11267 - column16_row3075) * is_settlement.\n              let val := mulmod(\n                addmod(\n                  addmod(/*column17_row8192*/ mload(0x4500), /*column16_row11267*/ mload(0x4060), PRIME),\n                  sub(PRIME, /*column16_row3075*/ mload(0x3f60)),\n                  PRIME),\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[188] + coefficients[189] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[188]*/ mload(0x1c00),\n                                       mulmod(/*coefficients[189]*/ mload(0x1c20),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for amount_b_range_check_input: (column17_row40960 + column16_row44035 - column16_row35843) * is_settlement.\n              let val := mulmod(\n                addmod(\n                  addmod(/*column17_row40960*/ mload(0x4820), /*column16_row44035*/ mload(0x41a0), PRIME),\n                  sub(PRIME, /*column16_row35843*/ mload(0x4100)),\n                  PRIME),\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[190] + coefficients[191] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[190]*/ mload(0x1c40),\n                                       mulmod(/*coefficients[191]*/ mload(0x1c60),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for amounts_range_check_inputs: column17_row0 - column16_row11267.\n              let val := addmod(\n                /*column17_row0*/ mload(0x4200),\n                sub(PRIME, /*column16_row11267*/ mload(0x4060)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[192] + coefficients[193] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[192]*/ mload(0x1c80),\n                                       mulmod(/*coefficients[193]*/ mload(0x1ca0),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for ratio_party_a: column17_row40960 * column17_row4096 - (column17_row8192 * column17_row36864 + column17_row12288 + column17_row28672 * amount_shift).\n              let val := addmod(\n                mulmod(/*column17_row40960*/ mload(0x4820), /*column17_row4096*/ mload(0x44e0), PRIME),\n                sub(\n                  PRIME,\n                  addmod(\n                    addmod(\n                      mulmod(/*column17_row8192*/ mload(0x4500), /*column17_row36864*/ mload(0x4800), PRIME),\n                      /*column17_row12288*/ mload(0x4520),\n                      PRIME),\n                    mulmod(/*column17_row28672*/ mload(0x4680), /*amount_shift*/ mload(0x2c0), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[194] + coefficients[195] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[194]*/ mload(0x1cc0),\n                                       mulmod(/*coefficients[195]*/ mload(0x1ce0),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for ratio_party_b: column17_row8192 * column17_row53248 - (column17_row40960 * column17_row20480 + column17_row45056 + column17_row61440 * amount_shift).\n              let val := addmod(\n                mulmod(/*column17_row8192*/ mload(0x4500), /*column17_row53248*/ mload(0x48c0), PRIME),\n                sub(\n                  PRIME,\n                  addmod(\n                    addmod(\n                      mulmod(/*column17_row40960*/ mload(0x4820), /*column17_row20480*/ mload(0x4620), PRIME),\n                      /*column17_row45056*/ mload(0x4840),\n                      PRIME),\n                    mulmod(/*column17_row61440*/ mload(0x4920), /*amount_shift*/ mload(0x2c0), PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[196] + coefficients[197] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[196]*/ mload(0x1d00),\n                                       mulmod(/*coefficients[197]*/ mload(0x1d20),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for capacity_party_a: column17_row24576 + column17_row32752 - column17_row4096.\n              let val := addmod(\n                addmod(/*column17_row24576*/ mload(0x4660), /*column17_row32752*/ mload(0x47a0), PRIME),\n                sub(PRIME, /*column17_row4096*/ mload(0x44e0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[198] + coefficients[199] * adjustments[22]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[198]*/ mload(0x1d40),\n                                       mulmod(/*coefficients[199]*/ mload(0x1d60),\n                                              /*adjustments[22]*/mload(0x5c60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for capacity_party_b: column17_row57344 + column17_row65520 - column17_row53248.\n              let val := addmod(\n                addmod(/*column17_row57344*/ mload(0x4900), /*column17_row65520*/ mload(0x4980), PRIME),\n                sub(PRIME, /*column17_row53248*/ mload(0x48c0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[200] + coefficients[201] * adjustments[22]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[200]*/ mload(0x1d80),\n                                       mulmod(/*coefficients[201]*/ mload(0x1da0),\n                                              /*adjustments[22]*/mload(0x5c60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for expiration_timestamp_range_check/bit: expiration_timestamp_range_check__bit_0 * expiration_timestamp_range_check__bit_0 - expiration_timestamp_range_check__bit_0.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/expiration_timestamp_range_check/bit_0*/ mload(0x4ca0),\n                  /*intermediate_value/expiration_timestamp_range_check/bit_0*/ mload(0x4ca0),\n                  PRIME),\n                sub(\n                  PRIME,\n                  /*intermediate_value/expiration_timestamp_range_check/bit_0*/ mload(0x4ca0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(31 * trace_length / 32).\n              // val *= numerators[2].\n              val := mulmod(val, mload(0x5820), PRIME)\n              // Denominator: point^(trace_length / 512) - 1.\n              // val *= denominator_invs[6].\n              val := mulmod(val, mload(0x51a0), PRIME)\n\n              // res += val * (coefficients[202] + coefficients[203] * adjustments[5]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[202]*/ mload(0x1dc0),\n                                       mulmod(/*coefficients[203]*/ mload(0x1de0),\n                                              /*adjustments[5]*/mload(0x5a40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for expiration_timestamp_range_check/zero: column10_row255.\n              let val := /*column10_row255*/ mload(0x3740)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - trace_generator^(11 * trace_length / 16).\n              // val *= denominator_invs[18].\n              val := mulmod(val, mload(0x5320), PRIME)\n\n              // res += val * (coefficients[204] + coefficients[205] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[204]*/ mload(0x1e00),\n                                       mulmod(/*coefficients[205]*/ mload(0x1e20),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for expiration_timestamp_range_check_input: column10_row16639 + global_expiration_timestamp_elm - column10_row255.\n              let val := addmod(\n                addmod(\n                  /*column10_row16639*/ mload(0x3860),\n                  /*global_expiration_timestamp_elm*/ mload(0x2e0),\n                  PRIME),\n                sub(PRIME, /*column10_row255*/ mload(0x3740)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[206] + coefficients[207] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[206]*/ mload(0x1e40),\n                                       mulmod(/*coefficients[207]*/ mload(0x1e60),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for nonce_range_check/bit: nonce_range_check__bit_0 * nonce_range_check__bit_0 - nonce_range_check__bit_0.\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/nonce_range_check/bit_0*/ mload(0x4cc0),\n                  /*intermediate_value/nonce_range_check/bit_0*/ mload(0x4cc0),\n                  PRIME),\n                sub(PRIME, /*intermediate_value/nonce_range_check/bit_0*/ mload(0x4cc0)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32).\n              // val *= numerators[9].\n              val := mulmod(val, mload(0x5900), PRIME)\n              // Denominator: point^(trace_length / 1024) - 1.\n              // val *= denominator_invs[3].\n              val := mulmod(val, mload(0x5140), PRIME)\n\n              // res += val * (coefficients[208] + coefficients[209] * adjustments[23]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[208]*/ mload(0x1e80),\n                                       mulmod(/*coefficients[209]*/ mload(0x1ea0),\n                                              /*adjustments[23]*/mload(0x5c80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for nonce_range_check/zero: column16_row1021.\n              let val := /*column16_row1021*/ mload(0x3e60)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - trace_generator^(31 * trace_length / 32).\n              // val *= denominator_invs[19].\n              val := mulmod(val, mload(0x5340), PRIME)\n\n              // res += val * (coefficients[210] + coefficients[211] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[210]*/ mload(0x1ec0),\n                                       mulmod(/*coefficients[211]*/ mload(0x1ee0),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for is_transfer/bit: column10_row31231 * column10_row31231 - column10_row31231.\n              let val := addmod(\n                mulmod(/*column10_row31231*/ mload(0x38c0), /*column10_row31231*/ mload(0x38c0), PRIME),\n                sub(PRIME, /*column10_row31231*/ mload(0x38c0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[212] + coefficients[213] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[212]*/ mload(0x1f00),\n                                       mulmod(/*coefficients[213]*/ mload(0x1f20),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for is_transfer/modification: is_modification * (1 - column10_row31231).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(1, sub(PRIME, /*column10_row31231*/ mload(0x38c0)), PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[214] + coefficients[215] * adjustments[19]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[214]*/ mload(0x1f40),\n                                       mulmod(/*coefficients[215]*/ mload(0x1f60),\n                                              /*adjustments[19]*/mload(0x5c00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for transfer/party_a_sold: column17_row8192 * column10_row31231.\n              let val := mulmod(/*column17_row8192*/ mload(0x4500), /*column10_row31231*/ mload(0x38c0), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[216] + coefficients[217] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[216]*/ mload(0x1f80),\n                                       mulmod(/*coefficients[217]*/ mload(0x1fa0),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for transfer/party_b_buy: column17_row20480 * column10_row31231.\n              let val := mulmod(/*column17_row20480*/ mload(0x4620), /*column10_row31231*/ mload(0x38c0), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[218] + coefficients[219] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[218]*/ mload(0x1fc0),\n                                       mulmod(/*coefficients[219]*/ mload(0x1fe0),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for transfer/party_a_sell: (column17_row4096 + 1 - amount_shift) * column10_row31231.\n              let val := mulmod(\n                addmod(\n                  addmod(/*column17_row4096*/ mload(0x44e0), 1, PRIME),\n                  sub(PRIME, /*amount_shift*/ mload(0x2c0)),\n                  PRIME),\n                /*column10_row31231*/ mload(0x38c0),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[220] + coefficients[221] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[220]*/ mload(0x2000),\n                                       mulmod(/*coefficients[221]*/ mload(0x2020),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for transfer/party_b_exact_transferred: column10_row31231 * (column17_row40960 - column17_row53248).\n              let val := mulmod(\n                /*column10_row31231*/ mload(0x38c0),\n                addmod(\n                  /*column17_row40960*/ mload(0x4820),\n                  sub(PRIME, /*column17_row53248*/ mload(0x48c0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[222] + coefficients[223] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[222]*/ mload(0x2040),\n                                       mulmod(/*coefficients[223]*/ mload(0x2060),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/doubling_key/slope: sig_verify__doubling_key__x_squared + sig_verify__doubling_key__x_squared + sig_verify__doubling_key__x_squared + sig_config.alpha - (column17_row16 + column17_row16) * column17_row48.\n              let val := addmod(\n                addmod(\n                  addmod(\n                    addmod(\n                      /*intermediate_value/sig_verify/doubling_key/x_squared*/ mload(0x4ce0),\n                      /*intermediate_value/sig_verify/doubling_key/x_squared*/ mload(0x4ce0),\n                      PRIME),\n                    /*intermediate_value/sig_verify/doubling_key/x_squared*/ mload(0x4ce0),\n                    PRIME),\n                  /*sig_config.alpha*/ mload(0x300),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    addmod(/*column17_row16*/ mload(0x4260), /*column17_row16*/ mload(0x4260), PRIME),\n                    /*column17_row48*/ mload(0x4320),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[224] + coefficients[225] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[224]*/ mload(0x2080),\n                                       mulmod(/*coefficients[225]*/ mload(0x20a0),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/doubling_key/x: column17_row48 * column17_row48 - (column17_row32 + column17_row32 + column17_row96).\n              let val := addmod(\n                mulmod(/*column17_row48*/ mload(0x4320), /*column17_row48*/ mload(0x4320), PRIME),\n                sub(\n                  PRIME,\n                  addmod(\n                    addmod(/*column17_row32*/ mload(0x42c0), /*column17_row32*/ mload(0x42c0), PRIME),\n                    /*column17_row96*/ mload(0x4400),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[226] + coefficients[227] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[226]*/ mload(0x20c0),\n                                       mulmod(/*coefficients[227]*/ mload(0x20e0),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/doubling_key/y: column17_row16 + column17_row80 - column17_row48 * (column17_row32 - column17_row96).\n              let val := addmod(\n                addmod(/*column17_row16*/ mload(0x4260), /*column17_row80*/ mload(0x43c0), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column17_row48*/ mload(0x4320),\n                    addmod(\n                      /*column17_row32*/ mload(0x42c0),\n                      sub(PRIME, /*column17_row96*/ mload(0x4400)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[228] + coefficients[229] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[228]*/ mload(0x2100),\n                                       mulmod(/*coefficients[229]*/ mload(0x2120),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/booleanity_test: sig_verify__exponentiate_generator__bit * (sig_verify__exponentiate_generator__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/sig_verify/exponentiate_generator/bit*/ mload(0x4d00),\n                addmod(\n                  /*intermediate_value/sig_verify/exponentiate_generator/bit*/ mload(0x4d00),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[230] + coefficients[231] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[230]*/ mload(0x2140),\n                                       mulmod(/*coefficients[231]*/ mload(0x2160),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/bit_extraction_end: column17_row84.\n              let val := /*column17_row84*/ mload(0x43e0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - trace_generator^(251 * trace_length / 256).\n              // val *= denominator_invs[21].\n              val := mulmod(val, mload(0x5380), PRIME)\n\n              // res += val * (coefficients[232] + coefficients[233] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[232]*/ mload(0x2180),\n                                       mulmod(/*coefficients[233]*/ mload(0x21a0),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/zeros_tail: column17_row84.\n              let val := /*column17_row84*/ mload(0x43e0)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[22].\n              val := mulmod(val, mload(0x53a0), PRIME)\n\n              // res += val * (coefficients[234] + coefficients[235] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[234]*/ mload(0x21c0),\n                                       mulmod(/*coefficients[235]*/ mload(0x21e0),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/add_points/slope: sig_verify__exponentiate_generator__bit * (column17_row100 - ecdsa_points__y) - column17_row20 * (column17_row36 - ecdsa_points__x).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/sig_verify/exponentiate_generator/bit*/ mload(0x4d00),\n                  addmod(\n                    /*column17_row100*/ mload(0x4420),\n                    sub(PRIME, /*periodic_column/ecdsa_points/y*/ mload(0x1e0)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column17_row20*/ mload(0x4280),\n                    addmod(\n                      /*column17_row36*/ mload(0x42e0),\n                      sub(PRIME, /*periodic_column/ecdsa_points/x*/ mload(0x1c0)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[236] + coefficients[237] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[236]*/ mload(0x2200),\n                                       mulmod(/*coefficients[237]*/ mload(0x2220),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/add_points/x: column17_row20 * column17_row20 - sig_verify__exponentiate_generator__bit * (column17_row36 + ecdsa_points__x + column17_row164).\n              let val := addmod(\n                mulmod(/*column17_row20*/ mload(0x4280), /*column17_row20*/ mload(0x4280), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/sig_verify/exponentiate_generator/bit*/ mload(0x4d00),\n                    addmod(\n                      addmod(\n                        /*column17_row36*/ mload(0x42e0),\n                        /*periodic_column/ecdsa_points/x*/ mload(0x1c0),\n                        PRIME),\n                      /*column17_row164*/ mload(0x4480),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[238] + coefficients[239] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[238]*/ mload(0x2240),\n                                       mulmod(/*coefficients[239]*/ mload(0x2260),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/add_points/y: sig_verify__exponentiate_generator__bit * (column17_row100 + column17_row228) - column17_row20 * (column17_row36 - column17_row164).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/sig_verify/exponentiate_generator/bit*/ mload(0x4d00),\n                  addmod(/*column17_row100*/ mload(0x4420), /*column17_row228*/ mload(0x44c0), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column17_row20*/ mload(0x4280),\n                    addmod(\n                      /*column17_row36*/ mload(0x42e0),\n                      sub(PRIME, /*column17_row164*/ mload(0x4480)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[240] + coefficients[241] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[240]*/ mload(0x2280),\n                                       mulmod(/*coefficients[241]*/ mload(0x22a0),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/add_points/x_diff_inv: column17_row52 * (column17_row36 - ecdsa_points__x) - 1.\n              let val := addmod(\n                mulmod(\n                  /*column17_row52*/ mload(0x4340),\n                  addmod(\n                    /*column17_row36*/ mload(0x42e0),\n                    sub(PRIME, /*periodic_column/ecdsa_points/x*/ mload(0x1c0)),\n                    PRIME),\n                  PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[242] + coefficients[243] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[242]*/ mload(0x22c0),\n                                       mulmod(/*coefficients[243]*/ mload(0x22e0),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/copy_point/x: sig_verify__exponentiate_generator__bit_neg * (column17_row164 - column17_row36).\n              let val := mulmod(\n                /*intermediate_value/sig_verify/exponentiate_generator/bit_neg*/ mload(0x4d20),\n                addmod(\n                  /*column17_row164*/ mload(0x4480),\n                  sub(PRIME, /*column17_row36*/ mload(0x42e0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[244] + coefficients[245] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[244]*/ mload(0x2300),\n                                       mulmod(/*coefficients[245]*/ mload(0x2320),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_generator/copy_point/y: sig_verify__exponentiate_generator__bit_neg * (column17_row228 - column17_row100).\n              let val := mulmod(\n                /*intermediate_value/sig_verify/exponentiate_generator/bit_neg*/ mload(0x4d20),\n                addmod(\n                  /*column17_row228*/ mload(0x44c0),\n                  sub(PRIME, /*column17_row100*/ mload(0x4420)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 32768) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[11].\n              val := mulmod(val, mload(0x5940), PRIME)\n              // Denominator: point^(trace_length / 128) - 1.\n              // val *= denominator_invs[20].\n              val := mulmod(val, mload(0x5360), PRIME)\n\n              // res += val * (coefficients[246] + coefficients[247] * adjustments[25]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[246]*/ mload(0x2340),\n                                       mulmod(/*coefficients[247]*/ mload(0x2360),\n                                              /*adjustments[25]*/mload(0x5cc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/booleanity_test: sig_verify__exponentiate_key__bit * (sig_verify__exponentiate_key__bit - 1).\n              let val := mulmod(\n                /*intermediate_value/sig_verify/exponentiate_key/bit*/ mload(0x4d40),\n                addmod(\n                  /*intermediate_value/sig_verify/exponentiate_key/bit*/ mload(0x4d40),\n                  sub(PRIME, 1),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[248] + coefficients[249] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[248]*/ mload(0x2380),\n                                       mulmod(/*coefficients[249]*/ mload(0x23a0),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/bit_extraction_end: column17_row56.\n              let val := /*column17_row56*/ mload(0x4360)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - trace_generator^(251 * trace_length / 256).\n              // val *= denominator_invs[23].\n              val := mulmod(val, mload(0x53c0), PRIME)\n\n              // res += val * (coefficients[250] + coefficients[251] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[250]*/ mload(0x23c0),\n                                       mulmod(/*coefficients[251]*/ mload(0x23e0),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/zeros_tail: column17_row56.\n              let val := /*column17_row56*/ mload(0x4360)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= denominator_invs[24].\n              val := mulmod(val, mload(0x53e0), PRIME)\n\n              // res += val * (coefficients[252] + coefficients[253] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[252]*/ mload(0x2400),\n                                       mulmod(/*coefficients[253]*/ mload(0x2420),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/add_points/slope: sig_verify__exponentiate_key__bit * (column17_row40 - column17_row16) - column17_row24 * (column17_row8 - column17_row32).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/sig_verify/exponentiate_key/bit*/ mload(0x4d40),\n                  addmod(\n                    /*column17_row40*/ mload(0x4300),\n                    sub(PRIME, /*column17_row16*/ mload(0x4260)),\n                    PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column17_row24*/ mload(0x42a0),\n                    addmod(\n                      /*column17_row8*/ mload(0x4240),\n                      sub(PRIME, /*column17_row32*/ mload(0x42c0)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[254] + coefficients[255] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[254]*/ mload(0x2440),\n                                       mulmod(/*coefficients[255]*/ mload(0x2460),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/add_points/x: column17_row24 * column17_row24 - sig_verify__exponentiate_key__bit * (column17_row8 + column17_row32 + column17_row72).\n              let val := addmod(\n                mulmod(/*column17_row24*/ mload(0x42a0), /*column17_row24*/ mload(0x42a0), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*intermediate_value/sig_verify/exponentiate_key/bit*/ mload(0x4d40),\n                    addmod(\n                      addmod(/*column17_row8*/ mload(0x4240), /*column17_row32*/ mload(0x42c0), PRIME),\n                      /*column17_row72*/ mload(0x43a0),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[256] + coefficients[257] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[256]*/ mload(0x2480),\n                                       mulmod(/*coefficients[257]*/ mload(0x24a0),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/add_points/y: sig_verify__exponentiate_key__bit * (column17_row40 + column17_row104) - column17_row24 * (column17_row8 - column17_row72).\n              let val := addmod(\n                mulmod(\n                  /*intermediate_value/sig_verify/exponentiate_key/bit*/ mload(0x4d40),\n                  addmod(/*column17_row40*/ mload(0x4300), /*column17_row104*/ mload(0x4440), PRIME),\n                  PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column17_row24*/ mload(0x42a0),\n                    addmod(\n                      /*column17_row8*/ mload(0x4240),\n                      sub(PRIME, /*column17_row72*/ mload(0x43a0)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[258] + coefficients[259] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[258]*/ mload(0x24c0),\n                                       mulmod(/*coefficients[259]*/ mload(0x24e0),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/add_points/x_diff_inv: column17_row4 * (column17_row8 - column17_row32) - 1.\n              let val := addmod(\n                mulmod(\n                  /*column17_row4*/ mload(0x4220),\n                  addmod(\n                    /*column17_row8*/ mload(0x4240),\n                    sub(PRIME, /*column17_row32*/ mload(0x42c0)),\n                    PRIME),\n                  PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[260] + coefficients[261] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[260]*/ mload(0x2500),\n                                       mulmod(/*coefficients[261]*/ mload(0x2520),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/copy_point/x: sig_verify__exponentiate_key__bit_neg * (column17_row72 - column17_row8).\n              let val := mulmod(\n                /*intermediate_value/sig_verify/exponentiate_key/bit_neg*/ mload(0x4d60),\n                addmod(\n                  /*column17_row72*/ mload(0x43a0),\n                  sub(PRIME, /*column17_row8*/ mload(0x4240)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[262] + coefficients[263] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[262]*/ mload(0x2540),\n                                       mulmod(/*coefficients[263]*/ mload(0x2560),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/exponentiate_key/copy_point/y: sig_verify__exponentiate_key__bit_neg * (column17_row104 - column17_row40).\n              let val := mulmod(\n                /*intermediate_value/sig_verify/exponentiate_key/bit_neg*/ mload(0x4d60),\n                addmod(\n                  /*column17_row104*/ mload(0x4440),\n                  sub(PRIME, /*column17_row40*/ mload(0x4300)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: point^(trace_length / 16384) - trace_generator^(255 * trace_length / 256).\n              // val *= numerators[10].\n              val := mulmod(val, mload(0x5920), PRIME)\n              // Denominator: point^(trace_length / 64) - 1.\n              // val *= denominator_invs[16].\n              val := mulmod(val, mload(0x52e0), PRIME)\n\n              // res += val * (coefficients[264] + coefficients[265] * adjustments[24]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[264]*/ mload(0x2580),\n                                       mulmod(/*coefficients[265]*/ mload(0x25a0),\n                                              /*adjustments[24]*/mload(0x5ca0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/init_gen/x: column17_row36 - sig_config.shift_point.x.\n              let val := addmod(/*column17_row36*/ mload(0x42e0), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[266] + coefficients[267] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[266]*/ mload(0x25c0),\n                                       mulmod(/*coefficients[267]*/ mload(0x25e0),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/init_gen/y: column17_row100 + sig_config.shift_point.y.\n              let val := addmod(/*column17_row100*/ mload(0x4420), /*shift_point.y*/ mload(0x240), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[268] + coefficients[269] * adjustments[15]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[268]*/ mload(0x2600),\n                                       mulmod(/*coefficients[269]*/ mload(0x2620),\n                                              /*adjustments[15]*/mload(0x5b80),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/init_key/x: column17_row8 - sig_config.shift_point.x.\n              let val := addmod(/*column17_row8*/ mload(0x4240), sub(PRIME, /*shift_point.x*/ mload(0x220)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[270] + coefficients[271] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[270]*/ mload(0x2640),\n                                       mulmod(/*coefficients[271]*/ mload(0x2660),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/init_key/y: column17_row40 - sig_config.shift_point.y.\n              let val := addmod(/*column17_row40*/ mload(0x4300), sub(PRIME, /*shift_point.y*/ mload(0x240)), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[272] + coefficients[273] * adjustments[6]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[272]*/ mload(0x2680),\n                                       mulmod(/*coefficients[273]*/ mload(0x26a0),\n                                              /*adjustments[6]*/mload(0x5a60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/add_results/slope: column17_row32740 - (column17_row16360 + column17_row32692 * (column17_row32676 - column17_row16328)).\n              let val := addmod(\n                /*column17_row32740*/ mload(0x4760),\n                sub(\n                  PRIME,\n                  addmod(\n                    /*column17_row16360*/ mload(0x45a0),\n                    mulmod(\n                      /*column17_row32692*/ mload(0x46e0),\n                      addmod(\n                        /*column17_row32676*/ mload(0x46c0),\n                        sub(PRIME, /*column17_row16328*/ mload(0x4560)),\n                        PRIME),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[274] + coefficients[275] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[274]*/ mload(0x26c0),\n                                       mulmod(/*coefficients[275]*/ mload(0x26e0),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/add_results/x: column17_row32692 * column17_row32692 - (column17_row32676 + column17_row16328 + column17_row16416).\n              let val := addmod(\n                mulmod(/*column17_row32692*/ mload(0x46e0), /*column17_row32692*/ mload(0x46e0), PRIME),\n                sub(\n                  PRIME,\n                  addmod(\n                    addmod(/*column17_row32676*/ mload(0x46c0), /*column17_row16328*/ mload(0x4560), PRIME),\n                    /*column17_row16416*/ mload(0x4600),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[276] + coefficients[277] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[276]*/ mload(0x2700),\n                                       mulmod(/*coefficients[277]*/ mload(0x2720),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/add_results/y: column17_row32740 + column17_row16400 - column17_row32692 * (column17_row32676 - column17_row16416).\n              let val := addmod(\n                addmod(/*column17_row32740*/ mload(0x4760), /*column17_row16400*/ mload(0x45e0), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column17_row32692*/ mload(0x46e0),\n                    addmod(\n                      /*column17_row32676*/ mload(0x46c0),\n                      sub(PRIME, /*column17_row16416*/ mload(0x4600)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[278] + coefficients[279] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[278]*/ mload(0x2740),\n                                       mulmod(/*coefficients[279]*/ mload(0x2760),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/add_results/x_diff_inv: column17_row32660 * (column17_row32676 - column17_row16328) - 1.\n              let val := addmod(\n                mulmod(\n                  /*column17_row32660*/ mload(0x46a0),\n                  addmod(\n                    /*column17_row32676*/ mload(0x46c0),\n                    sub(PRIME, /*column17_row16328*/ mload(0x4560)),\n                    PRIME),\n                  PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[280] + coefficients[281] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[280]*/ mload(0x2780),\n                                       mulmod(/*coefficients[281]*/ mload(0x27a0),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/extract_r/slope: column17_row32744 + sig_config.shift_point.y - column10_row10751 * (column17_row32712 - sig_config.shift_point.x).\n              let val := addmod(\n                addmod(/*column17_row32744*/ mload(0x4780), /*shift_point.y*/ mload(0x240), PRIME),\n                sub(\n                  PRIME,\n                  mulmod(\n                    /*column10_row10751*/ mload(0x3820),\n                    addmod(\n                      /*column17_row32712*/ mload(0x4720),\n                      sub(PRIME, /*shift_point.x*/ mload(0x220)),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[282] + coefficients[283] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[282]*/ mload(0x27c0),\n                                       mulmod(/*coefficients[283]*/ mload(0x27e0),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/extract_r/x: column10_row10751 * column10_row10751 - (column17_row32712 + sig_config.shift_point.x + column17_row56).\n              let val := addmod(\n                mulmod(/*column10_row10751*/ mload(0x3820), /*column10_row10751*/ mload(0x3820), PRIME),\n                sub(\n                  PRIME,\n                  addmod(\n                    addmod(/*column17_row32712*/ mload(0x4720), /*shift_point.x*/ mload(0x220), PRIME),\n                    /*column17_row56*/ mload(0x4360),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[284] + coefficients[285] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[284]*/ mload(0x2800),\n                                       mulmod(/*coefficients[285]*/ mload(0x2820),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/extract_r/x_diff_inv: column10_row27135 * (column17_row32712 - sig_config.shift_point.x) - 1.\n              let val := addmod(\n                mulmod(\n                  /*column10_row27135*/ mload(0x38a0),\n                  addmod(\n                    /*column17_row32712*/ mload(0x4720),\n                    sub(PRIME, /*shift_point.x*/ mload(0x220)),\n                    PRIME),\n                  PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[286] + coefficients[287] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[286]*/ mload(0x2840),\n                                       mulmod(/*coefficients[287]*/ mload(0x2860),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/z_nonzero: column17_row84 * column10_row6655 - 1.\n              let val := addmod(\n                mulmod(/*column17_row84*/ mload(0x43e0), /*column10_row6655*/ mload(0x37e0), PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[288] + coefficients[289] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[288]*/ mload(0x2880),\n                                       mulmod(/*coefficients[289]*/ mload(0x28a0),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/r_and_w_nonzero: column17_row56 * column10_row2559 - 1.\n              let val := addmod(\n                mulmod(/*column17_row56*/ mload(0x4360), /*column10_row2559*/ mload(0x37a0), PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[290] + coefficients[291] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[290]*/ mload(0x28c0),\n                                       mulmod(/*coefficients[291]*/ mload(0x28e0),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/q_on_curve/x_squared: column10_row23039 - column17_row32 * column17_row32.\n              let val := addmod(\n                /*column10_row23039*/ mload(0x3880),\n                sub(\n                  PRIME,\n                  mulmod(/*column17_row32*/ mload(0x42c0), /*column17_row32*/ mload(0x42c0), PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[292] + coefficients[293] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[292]*/ mload(0x2900),\n                                       mulmod(/*coefficients[293]*/ mload(0x2920),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for sig_verify/q_on_curve/on_curve: column17_row16 * column17_row16 - (column17_row32 * column10_row23039 + sig_config.alpha * column17_row32 + sig_config.beta).\n              let val := addmod(\n                mulmod(/*column17_row16*/ mload(0x4260), /*column17_row16*/ mload(0x4260), PRIME),\n                sub(\n                  PRIME,\n                  addmod(\n                    addmod(\n                      mulmod(/*column17_row32*/ mload(0x42c0), /*column10_row23039*/ mload(0x3880), PRIME),\n                      mulmod(/*sig_config.alpha*/ mload(0x300), /*column17_row32*/ mload(0x42c0), PRIME),\n                      PRIME),\n                    /*sig_config.beta*/ mload(0x320),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 32768) - 1.\n              // val *= denominator_invs[15].\n              val := mulmod(val, mload(0x52c0), PRIME)\n\n              // res += val * (coefficients[294] + coefficients[295] * adjustments[17]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[294]*/ mload(0x2940),\n                                       mulmod(/*coefficients[295]*/ mload(0x2960),\n                                              /*adjustments[17]*/mload(0x5bc0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for party_a_sig_input_packed: is_settlement * (column16_row7171 - ((party_a_packed_msg__partial * nonce_shift + column16_row1021) * expiration_timestamp_shift + column10_row255)).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column16_row7171*/ mload(0x3fe0),\n                  sub(\n                    PRIME,\n                    addmod(\n                      mulmod(\n                        addmod(\n                          mulmod(\n                            /*intermediate_value/party_a_packed_msg/partial*/ mload(0x4d80),\n                            /*nonce_shift*/ mload(0x360),\n                            PRIME),\n                          /*column16_row1021*/ mload(0x3e60),\n                          PRIME),\n                        /*expiration_timestamp_shift*/ mload(0x380),\n                        PRIME),\n                      /*column10_row255*/ mload(0x3740),\n                      PRIME)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[296] + coefficients[297] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[296]*/ mload(0x2980),\n                                       mulmod(/*coefficients[297]*/ mload(0x29a0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for party_b_sig_input_packed: column16_row39939 - ((1 - column10_row31231) * ((party_b_packed_msg__partial * nonce_shift + column16_row33789) * expiration_timestamp_shift + column10_row33023) + column10_row31231 * ((party_b_packed_msg_transfer__partial * nonce_shift + column16_row33789) * expiration_timestamp_shift + column10_row33023)).\n              let val := addmod(\n                /*column16_row39939*/ mload(0x4160),\n                sub(\n                  PRIME,\n                  addmod(\n                    mulmod(\n                      addmod(1, sub(PRIME, /*column10_row31231*/ mload(0x38c0)), PRIME),\n                      addmod(\n                        mulmod(\n                          addmod(\n                            mulmod(\n                              /*intermediate_value/party_b_packed_msg/partial*/ mload(0x4da0),\n                              /*nonce_shift*/ mload(0x360),\n                              PRIME),\n                            /*column16_row33789*/ mload(0x40e0),\n                            PRIME),\n                          /*expiration_timestamp_shift*/ mload(0x380),\n                          PRIME),\n                        /*column10_row33023*/ mload(0x38e0),\n                        PRIME),\n                      PRIME),\n                    mulmod(\n                      /*column10_row31231*/ mload(0x38c0),\n                      addmod(\n                        mulmod(\n                          addmod(\n                            mulmod(\n                              /*intermediate_value/party_b_packed_msg_transfer/partial*/ mload(0x4dc0),\n                              /*nonce_shift*/ mload(0x360),\n                              PRIME),\n                            /*column16_row33789*/ mload(0x40e0),\n                            PRIME),\n                          /*expiration_timestamp_shift*/ mload(0x380),\n                          PRIME),\n                        /*column10_row33023*/ mload(0x38e0),\n                        PRIME),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[298] + coefficients[299] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[298]*/ mload(0x29c0),\n                                       mulmod(/*coefficients[299]*/ mload(0x29e0),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for signatures/party_b_hash_sec_msg: column16_row37891 - (column10_row31231 * column10_row63999 + (1 - column10_row31231) * column16_row4099).\n              let val := addmod(\n                /*column16_row37891*/ mload(0x4140),\n                sub(\n                  PRIME,\n                  addmod(\n                    mulmod(/*column10_row31231*/ mload(0x38c0), /*column10_row63999*/ mload(0x3920), PRIME),\n                    mulmod(\n                      addmod(1, sub(PRIME, /*column10_row31231*/ mload(0x38c0)), PRIME),\n                      /*column16_row4099*/ mload(0x3fa0),\n                      PRIME),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[300] + coefficients[301] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[300]*/ mload(0x2a00),\n                                       mulmod(/*coefficients[301]*/ mload(0x2a20),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for signatures/copy_token_b: column16_row5123 - column16_row36867.\n              let val := addmod(\n                /*column16_row5123*/ mload(0x3fc0),\n                sub(PRIME, /*column16_row36867*/ mload(0x4120)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[302] + coefficients[303] * adjustments[22]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[302]*/ mload(0x2a40),\n                                       mulmod(/*coefficients[303]*/ mload(0x2a60),\n                                              /*adjustments[22]*/mload(0x5c60),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for copy_signature_input_party_a: (1 - column10_row31231) * (column16_row8188 - column17_row84).\n              let val := mulmod(\n                addmod(1, sub(PRIME, /*column10_row31231*/ mload(0x38c0)), PRIME),\n                addmod(\n                  /*column16_row8188*/ mload(0x4000),\n                  sub(PRIME, /*column17_row84*/ mload(0x43e0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[304] + coefficients[305] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[304]*/ mload(0x2a80),\n                                       mulmod(/*coefficients[305]*/ mload(0x2aa0),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for copy_signature_input_party_b: is_settlement * (column16_row40956 - column17_row32852).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column16_row40956*/ mload(0x4180),\n                  sub(PRIME, /*column17_row32852*/ mload(0x47e0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[306] + coefficients[307] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[306]*/ mload(0x2ac0),\n                                       mulmod(/*coefficients[307]*/ mload(0x2ae0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for message_hash_determines_order_id_party_a: column14_row511 - (1 - column10_row31231) * column17_row24148.\n              let val := addmod(\n                /*column14_row511*/ mload(0x3ba0),\n                sub(\n                  PRIME,\n                  mulmod(\n                    addmod(1, sub(PRIME, /*column10_row31231*/ mload(0x38c0)), PRIME),\n                    /*column17_row24148*/ mload(0x4640),\n                    PRIME)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[308] + coefficients[309] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[308]*/ mload(0x2b00),\n                                       mulmod(/*coefficients[309]*/ mload(0x2b20),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for message_hash_determines_order_id_party_b: is_settlement * (column14_row33279 - column17_row56916).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column14_row33279*/ mload(0x3c80),\n                  sub(PRIME, /*column17_row56916*/ mload(0x48e0)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[310] + coefficients[311] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[310]*/ mload(0x2b40),\n                                       mulmod(/*coefficients[311]*/ mload(0x2b60),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for party_a_public_key_copy: (1 - column10_row31231) * (column17_row32 - column10_row63999).\n              let val := mulmod(\n                addmod(1, sub(PRIME, /*column10_row31231*/ mload(0x38c0)), PRIME),\n                addmod(\n                  /*column17_row32*/ mload(0x42c0),\n                  sub(PRIME, /*column10_row63999*/ mload(0x3920)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[312] + coefficients[313] * adjustments[21]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[312]*/ mload(0x2b80),\n                                       mulmod(/*coefficients[313]*/ mload(0x2ba0),\n                                              /*adjustments[21]*/mload(0x5c40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_key_change0: is_settlement * (column10_row63999 - column17_row16324).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column10_row63999*/ mload(0x3920),\n                  sub(PRIME, /*column17_row16324*/ mload(0x4540)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[314] + coefficients[315] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[314]*/ mload(0x2bc0),\n                                       mulmod(/*coefficients[315]*/ mload(0x2be0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_token_change0: is_settlement * (column16_row4099 - column17_row16344).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column16_row4099*/ mload(0x3fa0),\n                  sub(PRIME, /*column17_row16344*/ mload(0x4580)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[316] + coefficients[317] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[316]*/ mload(0x2c00),\n                                       mulmod(/*coefficients[317]*/ mload(0x2c20),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_key_change3: is_settlement * (column10_row63999 - column17_row65476).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column10_row63999*/ mload(0x3920),\n                  sub(PRIME, /*column17_row65476*/ mload(0x4940)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[318] + coefficients[319] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[318]*/ mload(0x2c40),\n                                       mulmod(/*coefficients[319]*/ mload(0x2c60),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_token_change3: is_settlement * (column16_row5123 - column17_row65496).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column16_row5123*/ mload(0x3fc0),\n                  sub(PRIME, /*column17_row65496*/ mload(0x4960)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[320] + coefficients[321] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[320]*/ mload(0x2c80),\n                                       mulmod(/*coefficients[321]*/ mload(0x2ca0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_key_change1: is_settlement * (column17_row32800 - column17_row32708).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column17_row32800*/ mload(0x47c0),\n                  sub(PRIME, /*column17_row32708*/ mload(0x4700)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[322] + coefficients[323] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[322]*/ mload(0x2cc0),\n                                       mulmod(/*coefficients[323]*/ mload(0x2ce0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_token_change1: is_settlement * (column16_row4099 - column17_row32728).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column16_row4099*/ mload(0x3fa0),\n                  sub(PRIME, /*column17_row32728*/ mload(0x4740)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[324] + coefficients[325] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[324]*/ mload(0x2d00),\n                                       mulmod(/*coefficients[325]*/ mload(0x2d20),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_key_change2: is_settlement * (column17_row32800 - column17_row49092).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column17_row32800*/ mload(0x47c0),\n                  sub(PRIME, /*column17_row49092*/ mload(0x4860)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[326] + coefficients[327] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[326]*/ mload(0x2d40),\n                                       mulmod(/*coefficients[327]*/ mload(0x2d60),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_token_change2: is_settlement * (column16_row5123 - column17_row49112).\n              let val := mulmod(\n                /*periodic_column/is_settlement*/ mload(0xc0),\n                addmod(\n                  /*column16_row5123*/ mload(0x3fc0),\n                  sub(PRIME, /*column17_row49112*/ mload(0x4880)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[328] + coefficients[329] * adjustments[18]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[328]*/ mload(0x2d80),\n                                       mulmod(/*coefficients[329]*/ mload(0x2da0),\n                                              /*adjustments[18]*/mload(0x5be0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/vault_empty/empty_vault_booleanity: column10_row511 * (1 - column10_row511).\n              let val := mulmod(\n                /*column10_row511*/ mload(0x3760),\n                addmod(1, sub(PRIME, /*column10_row511*/ mload(0x3760)), PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 8192) - 1.\n              // val *= denominator_invs[25].\n              val := mulmod(val, mload(0x5400), PRIME)\n\n              // res += val * (coefficients[330] + coefficients[331] * adjustments[26]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[330]*/ mload(0x2dc0),\n                                       mulmod(/*coefficients[331]*/ mload(0x2de0),\n                                              /*adjustments[26]*/mload(0x5ce0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/vault_empty/amount_zero_when_empty: column10_row511 * column16_row3075.\n              let val := mulmod(/*column10_row511*/ mload(0x3760), /*column16_row3075*/ mload(0x3f60), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 8192) - 1.\n              // val *= denominator_invs[25].\n              val := mulmod(val, mload(0x5400), PRIME)\n\n              // res += val * (coefficients[332] + coefficients[333] * adjustments[26]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[332]*/ mload(0x2e00),\n                                       mulmod(/*coefficients[333]*/ mload(0x2e20),\n                                              /*adjustments[26]*/mload(0x5ce0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/vault_empty/amount_inv_zero_when_empty: column10_row511 * column10_row4607.\n              let val := mulmod(/*column10_row511*/ mload(0x3760), /*column10_row4607*/ mload(0x37c0), PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 8192) - 1.\n              // val *= denominator_invs[25].\n              val := mulmod(val, mload(0x5400), PRIME)\n\n              // res += val * (coefficients[334] + coefficients[335] * adjustments[26]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[334]*/ mload(0x2e40),\n                                       mulmod(/*coefficients[335]*/ mload(0x2e60),\n                                              /*adjustments[26]*/mload(0x5ce0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/vault_empty/empty_when_amount_zero: column16_row3075 * column10_row4607 + column10_row511 - 1.\n              let val := addmod(\n                addmod(\n                  mulmod(/*column16_row3075*/ mload(0x3f60), /*column10_row4607*/ mload(0x37c0), PRIME),\n                  /*column10_row511*/ mload(0x3760),\n                  PRIME),\n                sub(PRIME, 1),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 8192) - 1.\n              // val *= denominator_invs[25].\n              val := mulmod(val, mload(0x5400), PRIME)\n\n              // res += val * (coefficients[336] + coefficients[337] * adjustments[26]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[336]*/ mload(0x2e80),\n                                       mulmod(/*coefficients[337]*/ mload(0x2ea0),\n                                              /*adjustments[26]*/mload(0x5ce0),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_key_stage0: (1 - column10_row511) * column17_row16324 - column16_row3.\n              let val := addmod(\n                mulmod(\n                  addmod(1, sub(PRIME, /*column10_row511*/ mload(0x3760)), PRIME),\n                  /*column17_row16324*/ mload(0x4540),\n                  PRIME),\n                sub(PRIME, /*column16_row3*/ mload(0x3dc0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[338] + coefficients[339] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[338]*/ mload(0x2ec0),\n                                       mulmod(/*coefficients[339]*/ mload(0x2ee0),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_token_stage0: (1 - column10_row511) * column17_row16344 - column16_row1027.\n              let val := addmod(\n                mulmod(\n                  addmod(1, sub(PRIME, /*column10_row511*/ mload(0x3760)), PRIME),\n                  /*column17_row16344*/ mload(0x4580),\n                  PRIME),\n                sub(PRIME, /*column16_row1027*/ mload(0x3ee0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[340] + coefficients[341] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[340]*/ mload(0x2f00),\n                                       mulmod(/*coefficients[341]*/ mload(0x2f20),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_key_stage1: (1 - column10_row8703) * column17_row16324 - column16_row8195.\n              let val := addmod(\n                mulmod(\n                  addmod(1, sub(PRIME, /*column10_row8703*/ mload(0x3800)), PRIME),\n                  /*column17_row16324*/ mload(0x4540),\n                  PRIME),\n                sub(PRIME, /*column16_row8195*/ mload(0x4020)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[342] + coefficients[343] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[342]*/ mload(0x2f40),\n                                       mulmod(/*coefficients[343]*/ mload(0x2f60),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for handle_empty_vault/consistency_token_stage1: (1 - column10_row8703) * column17_row16344 - column16_row9219.\n              let val := addmod(\n                mulmod(\n                  addmod(1, sub(PRIME, /*column10_row8703*/ mload(0x3800)), PRIME),\n                  /*column17_row16344*/ mload(0x4580),\n                  PRIME),\n                sub(PRIME, /*column16_row9219*/ mload(0x4040)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[344] + coefficients[345] * adjustments[12]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[344]*/ mload(0x2f80),\n                                       mulmod(/*coefficients[345]*/ mload(0x2fa0),\n                                              /*adjustments[12]*/mload(0x5b20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for initial_vaults_root: column0_row_expr0 - initial_vaults_root.\n              let val := addmod(\n                /*column0_row_expr0*/ mload(0x3220),\n                sub(PRIME, /*initial_vaults_root*/ mload(0x3a0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point - 1.\n              // val *= denominator_invs[26].\n              val := mulmod(val, mload(0x5420), PRIME)\n\n              // res += val * (coefficients[346] + coefficients[347] * adjustments[27]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[346]*/ mload(0x2fc0),\n                                       mulmod(/*coefficients[347]*/ mload(0x2fe0),\n                                              /*adjustments[27]*/mload(0x5d00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for initial_settlement_root: column10_row14847 - initial_settlement_root.\n              let val := addmod(\n                /*column10_row14847*/ mload(0x3840),\n                sub(PRIME, /*initial_settlement_root*/ mload(0x3c0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point - 1.\n              // val *= denominator_invs[26].\n              val := mulmod(val, mload(0x5420), PRIME)\n\n              // res += val * (coefficients[348] + coefficients[349] * adjustments[27]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[348]*/ mload(0x3000),\n                                       mulmod(/*coefficients[349]*/ mload(0x3020),\n                                              /*adjustments[27]*/mload(0x5d00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for final_vaults_root: column4_row_expr1 - final_vaults_root.\n              let val := addmod(\n                /*column4_row_expr1*/ mload(0x3440),\n                sub(PRIME, /*final_vaults_root*/ mload(0x3e0)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point - trace_generator^(65536 * (n_transactions - 1)).\n              // val *= denominator_invs[27].\n              val := mulmod(val, mload(0x5440), PRIME)\n\n              // res += val * (coefficients[350] + coefficients[351] * adjustments[27]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[350]*/ mload(0x3040),\n                                       mulmod(/*coefficients[351]*/ mload(0x3060),\n                                              /*adjustments[27]*/mload(0x5d00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for final_settlement_root: column10_row47615 - final_settlement_root.\n              let val := addmod(\n                /*column10_row47615*/ mload(0x3900),\n                sub(PRIME, /*final_settlement_root*/ mload(0x420)),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point - trace_generator^(65536 * (n_transactions - 1)).\n              // val *= denominator_invs[27].\n              val := mulmod(val, mload(0x5440), PRIME)\n\n              // res += val * (coefficients[352] + coefficients[353] * adjustments[27]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[352]*/ mload(0x3080),\n                                       mulmod(/*coefficients[353]*/ mload(0x30a0),\n                                              /*adjustments[27]*/mload(0x5d00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for copy_merkle_roots: column4_row_expr0 - column0_row_expr2.\n              let val := addmod(\n                /*column4_row_expr0*/ mload(0x3460),\n                sub(PRIME, /*column0_row_expr2*/ mload(0x3240)),\n                PRIME)\n\n              // Numerator: point - trace_generator^(65536 * (trace_length / 65536 - 1) + 49152).\n              // val *= numerators[12].\n              val := mulmod(val, mload(0x5960), PRIME)\n              // Denominator: point^(trace_length / 16384) - 1.\n              // val *= denominator_invs[12].\n              val := mulmod(val, mload(0x5260), PRIME)\n\n              // res += val * (coefficients[354] + coefficients[355] * adjustments[28]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[354]*/ mload(0x30c0),\n                                       mulmod(/*coefficients[355]*/ mload(0x30e0),\n                                              /*adjustments[28]*/mload(0x5d20),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for copy_settlement_merkle_roots: column10_row47615 - column10_row80383.\n              let val := addmod(\n                /*column10_row47615*/ mload(0x3900),\n                sub(PRIME, /*column10_row80383*/ mload(0x3940)),\n                PRIME)\n\n              // Numerator: point - trace_generator^(65536 * (trace_length / 65536 - 1)).\n              // val *= numerators[13].\n              val := mulmod(val, mload(0x5980), PRIME)\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[356] + coefficients[357] * adjustments[29]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[356]*/ mload(0x3100),\n                                       mulmod(/*coefficients[357]*/ mload(0x3120),\n                                              /*adjustments[29]*/mload(0x5d40),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n              {\n              // Constraint expression for copy_merkle_roots_modification: is_modification * (column4_row_expr0 - column4_row_expr1).\n              let val := mulmod(\n                /*periodic_column/is_modification*/ mload(0xa0),\n                addmod(\n                  /*column4_row_expr0*/ mload(0x3460),\n                  sub(PRIME, /*column4_row_expr1*/ mload(0x3440)),\n                  PRIME),\n                PRIME)\n\n              // Numerator: 1.\n              // val *= 1.\n              // val := mulmod(val, 1, PRIME).\n              // Denominator: point^(trace_length / 65536) - 1.\n              // val *= denominator_invs[13].\n              val := mulmod(val, mload(0x5280), PRIME)\n\n              // res += val * (coefficients[358] + coefficients[359] * adjustments[19]).\n              res := addmod(res,\n                            mulmod(val,\n                                   add(/*coefficients[358]*/ mload(0x3140),\n                                       mulmod(/*coefficients[359]*/ mload(0x3160),\n                                              /*adjustments[19]*/mload(0x5c00),\n                      PRIME)),\n                      PRIME),\n                      PRIME)\n              }\n\n            mstore(0, res)\n            return(0, 0x20)\n            }\n        }\n    }\n}\n// ---------- End of auto-generated code. ----------\n"},"DexFrilessStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"DexStatementVerifier.sol\";\nimport \"MerkleStatementVerifier.sol\";\nimport \"FriStatementVerifier.sol\";\n\ncontract DexFrilessStatementVerifier is DexStatementVerifier,\n    MerkleStatementVerifier, FriStatementVerifier {\n\n    constructor(address[] memory auxPolynomials, address oodsContract,\n        address merkleStatementContractAddress, address friStatementContractAddress,\n        uint256 numSecurityBits_, uint256 minProofOfWorkBits_) public\n        MerkleStatementVerifier(merkleStatementContractAddress)\n        FriStatementVerifier(friStatementContractAddress)\n        DexStatementVerifier(auxPolynomials, oodsContract, numSecurityBits_, minProofOfWorkBits_) {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    function identify()\n        external pure\n        returns(string memory)\n    {\n        return \"StarkWare_DexFrilessStatementVerifier_2019_1\";\n    }\n\n}\n"},"DexStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"DexVerifier.sol\";\nimport \"IDexStatementVerifier.sol\";\nimport \"FactRegistry.sol\";\nimport \"Identity.sol\";\n\ncontract DexStatementVerifier is IDexStatementVerifier, DexVerifier, FactRegistry, Identity {\n\n    // auxPolynomials contains constraintPolynomial and periodic columns.\n    constructor(address[] memory auxPolynomials, address oodsContract,\n        uint256 numSecurityBits_, uint256 minProofOfWorkBits_) public\n        DexVerifier(auxPolynomials, oodsContract, numSecurityBits_, minProofOfWorkBits_) {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    function identify()\n        external pure\n        returns(string memory)\n    {\n        return \"StarkWare_DexStatementVerifier_2019_1\";\n    }\n\n    function verifyProofAndRegister(\n        uint256[] calldata proofParams,\n        uint256[] calldata proof,\n        uint256[] calldata publicInput\n    )\n        external\n    {\n        verifyProof(proofParams, proof, publicInput);\n        registerFact(keccak256(abi.encodePacked(publicInput)));\n    }\n}\n"},"DexVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"StarkVerifier.sol\";\nimport \"StarkParameters.sol\";\nimport \"PublicInputOffsets.sol\";\nimport \"DexConstraintPoly.sol\";\n\ncontract PeriodicColumnContract {\n    function compute(uint256 x) external pure returns(uint256 result);\n}\n\ncontract DexVerifier is StarkParameters, StarkVerifier, PublicInputOffsets {\n    DexConstraintPoly constraintPoly;\n    PeriodicColumnContract hashPointsX;\n    PeriodicColumnContract hashPointsY;\n    PeriodicColumnContract ecdsaPointsX;\n    PeriodicColumnContract ecdsaPointsY;\n\n    constructor(\n        address[] memory auxPolynomials,\n        address oodsContract,\n        uint256 numSecurityBits_,\n        uint256 minProofOfWorkBits_)\n        StarkVerifier(\n            numSecurityBits_,\n            minProofOfWorkBits_\n        )\n        public {\n        constraintPoly = DexConstraintPoly(auxPolynomials[0]);\n        hashPointsX = PeriodicColumnContract(auxPolynomials[1]);\n        hashPointsY = PeriodicColumnContract(auxPolynomials[2]);\n        ecdsaPointsX = PeriodicColumnContract(auxPolynomials[3]);\n        ecdsaPointsY = PeriodicColumnContract(auxPolynomials[4]);\n        oodsContractAddress = oodsContract;\n    }\n\n    function getNColumnsInTrace() internal pure returns(uint256) {\n        return N_COLUMNS_IN_MASK;\n    }\n\n    function getNColumnsInComposition() internal pure returns(uint256) {\n        return CONSTRAINTS_DEGREE_BOUND;\n    }\n\n    function getMmCoefficients() internal pure returns(uint256) {\n        return MM_COEFFICIENTS;\n    }\n\n    function getMmOodsValues() internal pure returns(uint256) {\n        return MM_OODS_VALUES;\n    }\n\n    function getMmOodsCoefficients() internal pure returns(uint256) {\n        return MM_OODS_COEFFICIENTS;\n    }\n\n    function getNCoefficients() internal pure returns(uint256) {\n        return N_COEFFICIENTS;\n    }\n\n    function getNOodsValues() internal pure returns(uint256) {\n        return N_OODS_VALUES;\n    }\n\n    function getNOodsCoefficients() internal pure returns(uint256) {\n        return N_OODS_COEFFICIENTS;\n    }\n\n    function getModificationRow(uint256[] memory publicInput, uint256 modificationId)\n        internal pure returns (uint256) {\n        return (\n            publicInput[OFFSET_MODIFICATION_DATA + N_WORDS_PER_MODIFICATION *\n            modificationId + 2] \u003e\u003e 80) \u0026 ((1 \u003c\u003c 16) - 1);\n    }\n\n    function airSpecificInit(uint256[] memory publicInput)\n        internal returns (uint256[] memory ctx, uint256 logTraceLength)\n    {\n        ctx = new uint256[](MM_CONTEXT_SIZE);\n\n        require(\n            publicInput.length \u003e= OFFSET_MODIFICATION_DATA,\n            \"Missing public input parameters.\");\n\n        uint256 logBatchSize = publicInput[OFFSET_LOG_BATCH_SIZE];\n        require(logBatchSize \u003c 15, \"Only support up to 16K transactions per proof\");\n        uint256 batchSize = 2**logBatchSize;\n        publicInput[OFFSET_LOG_BATCH_SIZE] = batchSize;\n\n        {\n        // Check validity of global timestamp value.\n        uint256 globalExpirationTimestamp = publicInput[OFFSET_GLOBAL_EXPIRATION_TIMESTAMP];\n        require(\n            0 \u003c= globalExpirationTimestamp \u0026\u0026 globalExpirationTimestamp \u003c\n            2**EXPIRATION_TIMESTAMP_RANGE_CHECK_BITS,\n            \"Global expiration timestamp is out of range.\");\n        ctx[MM_GLOBAL_EXPIRATION_TIMESTAMP_ELM] = globalExpirationTimestamp;\n\n        // Make sure globalExpirationTimestamp \u003e timestamp of the current block.\n        require(\n            // solium-disable-next-line security/no-block-members\n            globalExpirationTimestamp \u003e now / 3600,\n            \"Timestamp of the current block passed the threshold for the transaction batch.\");\n        }\n\n        uint256 nTransactions = publicInput[OFFSET_N_TRANSACTIONS];\n        require(\n            0 \u003c nTransactions \u0026\u0026 nTransactions \u003c= batchSize,\n            \"nTransaction should be between 1 and batchSize.\");\n\n        require(\n            (publicInput.length - OFFSET_MODIFICATION_DATA) % N_WORDS_PER_MODIFICATION == 0,\n            \"Invalid public input length.\");\n        uint256 nModifications = (\n            (publicInput.length - OFFSET_MODIFICATION_DATA) / N_WORDS_PER_MODIFICATION\n        );\n        require(\n            getModificationRow(publicInput, nModifications - 1) \u003c nTransactions,\n            \"There is a Modification after the final transaction in the batch.\");\n        ctx[MM_N_TRANSACTIONS] = nTransactions;\n        require(nModifications \u003c= nTransactions, \"More modifications than nTransactions.\");\n        ctx[MM_N_MODIFICATIONS] = nModifications;\n        ctx[MM_N_SETTLEMENTS] = batchSize - nModifications;\n\n        uint256 initialVaultsRoot = publicInput[OFFSET_VAULT_INITIAL_ROOT];\n        require(initialVaultsRoot \u003c K_MODULUS, \"Invalid initial vaults root\");\n        ctx[MM_INITIAL_VAULTS_ROOT] = initialVaultsRoot;\n        uint256 finalVaultsRoot = publicInput[OFFSET_VAULT_FINAL_ROOT];\n        require(finalVaultsRoot \u003c K_MODULUS, \"Invalid final vaults root\");\n        ctx[MM_FINAL_VAULTS_ROOT] = finalVaultsRoot;\n        uint256 vaultsPathLength = publicInput[OFFSET_VAULT_TREE_HEIGHT];\n        require(\n            vaultsPathLength \u003e 0 \u0026\u0026 vaultsPathLength \u003c VAULTS_PATH_HEIGHT,\n            \"Vaults path length is wrong\");\n        ctx[MM_VAULTS_PATH_LENGTH] = vaultsPathLength;\n\n        uint256 initialSettlementRoot = publicInput[OFFSET_ORDER_INITIAL_ROOT];\n        require(initialSettlementRoot \u003c K_MODULUS, \"Invalid initial settlement root\");\n        ctx[MM_INITIAL_SETTLEMENT_ROOT] = initialSettlementRoot;\n        uint256 finalSettlementRoot = publicInput[OFFSET_ORDER_FINAL_ROOT];\n        require(finalSettlementRoot \u003c K_MODULUS, \"Invalid final settlement root\");\n        ctx[MM_FINAL_SETTLEMENT_ROOT] = finalSettlementRoot;\n        uint256 settlementPathLength = publicInput[OFFSET_ORDER_TREE_HEIGHT];\n        require(\n            settlementPathLength == SETTLEMENT_PATH_LENGTH,\n            \"Settlement path length is wrong\");\n\n        uint256 lmmPublicInputPtr = MM_PUBLIC_INPUT_PTR;\n        assembly {\n            // Set public input pointer to point at the first word of the public input\n            // (skipping length word).\n            mstore(add(ctx, mul(add(lmmPublicInputPtr, 1), 0x20)), add(publicInput, 0x20))\n        }\n\n        // shiftPoint.x\n        ctx[MM_SHIFT_POINT_X] = 0x49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804;\n        // shiftPoint.y\n        ctx[MM_SHIFT_POINT_Y] = 0x3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a;\n\n        ctx[MM_SIG_CONFIG_ALPHA] = 1;\n        ctx[MM_SIG_CONFIG_BETA] = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\n\n        ctx[MM_VAULT_SHIFT] = 2**(VAULTS_PATH_HEIGHT-1);\n        ctx[MM_AMOUNT_SHIFT] = 2**RANGE_CHECK_BITS; // 2**kRangeCheckBits\n        ctx[MM_NONCE_SHIFT] = 2**NONCE_RANGE_CHECK_BITS;\n        ctx[MM_EXPIRATION_TIMESTAMP_SHIFT] = 2**EXPIRATION_TIMESTAMP_RANGE_CHECK_BITS;\n\n        logTraceLength = (\n            logBatchSize +\n            1 /* maker and taker */ +\n            1 /* token A and token B */ +\n            5 /* Merkle tree depth */ +\n            8 /* num steps per hash */ +\n            1 /* two to one hash per step */\n        );\n    }\n\n    function getPublicInputHash(uint256[] memory publicInput)\n        internal pure\n        returns (bytes32 publicInputHash) {\n        uint256 publicInputLength = publicInput.length;\n\n        assembly {\n            let length := mul(publicInputLength, 0x20)\n            publicInputHash := keccak256(add(publicInput, 0x20), length)\n        }\n    }\n\n    /*\n      Computes the value of the boundary periodic columns at the given point.\n\n      Modification action format:\n        prevAmount (64b) + newAmount (64b) + vaultId (32b) + row (16b) + reserved (80b).\n    */\n    function computeBoundaryPeriodicColumn(\n        uint256 modificationsPtr, uint256 nModifications, uint256 nTransactions, uint256 point,\n        uint256 prime, uint256 gen, uint256 resultArrayPtr)\n        internal view {\n        require(nTransactions \u003c 0x1000000, \"Overflow protection failed.\");\n        require(nModifications \u003c= nTransactions, \"nModifications \u003e nTransactions.\");\n        bool sorted = true;\n        assembly {\n            function expmod(base, exponent, modulus) -\u003e res {\n                let p := mload(0x40)\n                mstore(p, 0x20)                 // Length of Base.\n                mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n                mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n                mstore(add(p, 0x60), base)      // Base.\n                mstore(add(p, 0x80), exponent)  // Exponent.\n                mstore(add(p, 0xa0), modulus)   // Modulus.\n                // Call modexp precompile.\n                if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n                    revert(0, 0)\n                }\n                res := mload(p)\n            }\n\n            let lastOffset := mul(nModifications, 0x20)\n\n            // pointMinusXValues = freePtr;\n            let pointMinusXValues := mload(0x40)\n            let cumulativeProduct := add(pointMinusXValues, lastOffset)\n\n            // Bump free pointer as it is used in expmod.\n            mstore(0x40, add(cumulativeProduct, lastOffset))\n\n            {\n            // Initialize prevRow to (nTransactions + 1) to avoid special casing the first row.\n                let prevRow := nTransactions\n                let prod := 1\n                // Skip first 2 words of first update.\n                let rowsPtr := add(modificationsPtr, 0x40)\n                for { let offset := lastOffset } gt(offset, 0) { } {\n                    offset := sub(offset, 0x20)\n\n                    mstore(add(cumulativeProduct, offset), prod)\n\n                    // Extract the row represented by the 16 bits at offset 95:80 in the word.\n                    let currentRow := and(div(mload(add(rowsPtr,\n                                                      mul(offset, /*itemsPerUpdate*/ 3))),\n                                               0x100000000000000000000),\n                                           0xFFFF)\n\n                    // We go over the rows in reverse order so we expect them to be\n                    // strictly decreasing (!(currentRow \u003c prevRow) \u003c=\u003e currentRow \u003e= prevRow).\n                    if iszero(lt(currentRow, prevRow)) {\n                        // If currentRow \u003e= prevRow the rows are not sorted.\n                        // Set sorted to False.\n                        sorted := 0\n                    }\n                    prevRow := currentRow\n\n                    let pointMinusXValue := add(point, sub(prime, expmod(gen, currentRow, prime)))\n                    mstore(add(pointMinusXValues, offset), pointMinusXValue)\n\n                    prod := mulmod(prod, pointMinusXValue, prime)\n                }\n\n                mstore(add(resultArrayPtr, 0x40), prod)\n                let prodInv := expmod(prod, sub(prime, 2), prime)\n                let numerator := sub(expmod(point, nTransactions, prime), 1)\n                mstore(add(resultArrayPtr, 0x20), mulmod(numerator, prodInv, prime))\n            }\n\n            let boundaryBase := 0\n            let values := modificationsPtr\n            let prod := 1\n            for { let offset := 0 } lt(offset, lastOffset) { offset := add(offset, 0x20) } {\n                let pointMinusXValue := mload(add(pointMinusXValues, offset))\n                let othersProd := mulmod(prod, mload(add(cumulativeProduct, offset)), prime)\n                boundaryBase := addmod(boundaryBase, othersProd, prime)\n                let modificationAction := mload(add(values, 0x40))\n                // Handle key.\n                mstore(add(resultArrayPtr, 0x60), addmod(\n                    mload(add(resultArrayPtr, 0x60)),\n                    mulmod(othersProd, mload(values), prime),\n                    prime))\n                // Handle token.\n                mstore(add(resultArrayPtr, 0x80), addmod(\n                    mload(add(resultArrayPtr, 0x80)),\n                    mulmod(othersProd, mload(add(values, 0x20)), prime),\n                    prime))\n                // Handle prevAmount.\n                mstore(add(resultArrayPtr, 0xa0), addmod(\n                    mload(add(resultArrayPtr, 0xa0)),\n                    mulmod(othersProd,\n                // Extract the prev amount represented by the 63 bits at offset 254:192 in the word.\n                           and(div(modificationAction,\n                                   0x1000000000000000000000000000000000000000000000000),\n                               0x7FFFFFFFFFFFFFFF),\n                           prime),\n                    prime))\n                // Handle newAmount.\n                mstore(add(resultArrayPtr, 0xc0), addmod(\n                    mload(add(resultArrayPtr, 0xc0)),\n                    mulmod(othersProd,\n                // Extract the new amount represented by the 63 bits at offset 190:128 in the word.\n                           and(div(modificationAction,\n                                   0x100000000000000000000000000000000),\n                               0x7FFFFFFFFFFFFFFF),\n                           prime),\n                    prime))\n                // Handle vaultId.\n                mstore(add(resultArrayPtr, 0xe0), addmod(\n                    mload(add(resultArrayPtr, 0xe0)),\n                    mulmod(othersProd,\n                // Extract the vaultId represented by the 31 bits at offset 126:96 in the word.\n                           and(div(mload(add(values, 0x40)),\n                                   0x1000000000000000000000000),\n                               0x7FFFFFFF),\n                           prime),\n                    prime))\n                prod := mulmod(prod, pointMinusXValue, prime)\n\n                // Skip 8 values: 7 x update items + 1 x row number encoded in 3 words.\n                values := add(values, /*(3*0x20)*/ 0x60)\n            }\n\n            mstore(resultArrayPtr, boundaryBase)\n            // Deallocate pointMinusXValues and cumulativeProduct, and restore freePtr.\n            mstore(0x40, pointMinusXValues)\n        }\n\n        require(\n            sorted,\n            \"The list of rows is not sorted or not unique or row is greater than nTransactions.\"\n        );\n    }\n\n    function getNTransactions(uint256[] memory ctx)\n        internal pure returns (uint256 nTransactions) {\n        uint256 publicInputPtr = ctx[MM_PUBLIC_INPUT_PTR];\n        assembly {\n            nTransactions := /*nTransactions*/ mload(publicInputPtr)\n        }\n    }\n\n    /*\n      Checks that the trace and the composition agree on the Out of Domain Sampling point,\n      assuming the prover provided us with the proper evaluations.\n\n      Later, we use boundary constraints to check that those evaluations\n      are actually consistent with the committed trace and composition polynomials.\n    */\n    function oodsConsistencyCheck(uint256[] memory ctx)\n    internal {\n        uint256 oodsPoint = ctx[MM_OODS_POINT];\n        uint256 subGroupGenerator = fpow(\n            ctx[MM_TRACE_GENERATOR], ctx[MM_TRACE_LENGTH] / getNTransactions(ctx));\n\n        computeBoundaryPeriodicColumn(\n            ctx[MM_PUBLIC_INPUT_PTR] + 0x20 * OFFSET_MODIFICATION_DATA, ctx[MM_N_MODIFICATIONS],\n            getNTransactions(ctx), oodsPoint, K_MODULUS, subGroupGenerator,\n            getPtr(ctx, MM_PERIODIC_COLUMN__BOUNDARY_BASE));\n\n        // emit LogGas(\"Boundry periodic column\", gasleft());\n\n        // The ecdsaPoints columns have 256 values and a step of ECDSA_POINTS_STEP\n        // =\u003e nCopies = traceLength / (256 * ECDSA_POINTS_STEP).\n        uint256 zPointPow = fpow(oodsPoint, ctx[MM_TRACE_LENGTH] / (256 * ECDSA_POINTS_STEP));\n\n        ctx[MM_PERIODIC_COLUMN__ECDSA_POINTS__X] = ecdsaPointsX.compute(zPointPow);\n        ctx[MM_PERIODIC_COLUMN__ECDSA_POINTS__Y] = ecdsaPointsY.compute(zPointPow);\n\n        // The hashPoolPoints columns have 512 values with a step of PERIODIC_HASH_POOL_STEP\n        // =\u003e nCopies = traceLength / (512 * PERIODIC_HASH_POOL_STEP).\n        zPointPow = fpow(oodsPoint, ctx[MM_TRACE_LENGTH] / (512 * PERIODIC_HASH_POOL_STEP));\n\n        ctx[MM_PERIODIC_COLUMN__HASH_POOL_POINTS__X] = hashPointsX.compute(zPointPow);\n        ctx[MM_PERIODIC_COLUMN__HASH_POOL_POINTS__Y] = hashPointsY.compute(zPointPow);\n\n        // The vaultsMerkleHashPoints columns have 512 values\n        // and a step of VAULTS_PERIODIC_MERKLE_HASH_STEP\n        // =\u003e nCopies = traceLength / (512 * VAULTS_PERIODIC_MERKLE_HASH_STEP).\n        zPointPow = (\n            fpow(oodsPoint, ctx[MM_TRACE_LENGTH] / (512 * VAULTS_PERIODIC_MERKLE_HASH_STEP))\n        );\n        ctx[MM_PERIODIC_COLUMN__VAULTS_MERKLE_HASH_POINTS__X] = hashPointsX.compute(zPointPow);\n        ctx[MM_PERIODIC_COLUMN__VAULTS_MERKLE_HASH_POINTS__Y] = hashPointsY.compute(zPointPow);\n\n        // The settlmentMerkleHashPoints columns have 512 values\n        // and a step of SETTLEMENT_PERIODIC_MERKLE_HASH_STEP\n        // =\u003e nCopies = trace_length / (512 * SETTLEMENT_PERIODIC_MERKLE_HASH_STEP).\n        zPointPow = (\n            fpow(oodsPoint, ctx[MM_TRACE_LENGTH] / (512 * SETTLEMENT_PERIODIC_MERKLE_HASH_STEP))\n        );\n        ctx[MM_PERIODIC_COLUMN__SETTLEMENT_MERKLE_HASH_POINTS__X] = (\n            hashPointsX.compute(zPointPow)\n        );\n        ctx[MM_PERIODIC_COLUMN__SETTLEMENT_MERKLE_HASH_POINTS__Y] = (\n            hashPointsY.compute(zPointPow)\n        );\n\n        // emit LogGas(\"Other periodic columns\", gasleft());\n\n        // emit log_debug(oods_point);\n        // emit log_debug(ctx[mm_periodic_column__hash_pool_points__x]);\n        // emit log_debug(ctx[mm_periodic_column__hash_pool_points__y]);\n        // emit log_debug(ctx[mm_periodic_column__vaults_merkle_hash_points__x]);\n        // emit log_debug(ctx[mm_periodic_column__vaults_merkle_hash_points__y]);\n        // emit log_debug(ctx[mm_periodic_column__boundary_base]);\n        // emit log_debug(ctx[mm_periodic_column__is_modification]);\n        // emit log_debug(ctx[mm_periodic_column__is_settlement]);\n        // emit log_debug(ctx[mm_periodic_column__boundary_key]);\n        // emit log_debug(ctx[mm_periodic_column__boundary_token]);\n        // emit log_debug(ctx[mm_periodic_column__boundary_amount0]);\n        // emit log_debug(ctx[mm_periodic_column__boundary_amount1]);\n        // emit log_debug(ctx[mm_periodic_column__boundary_vault_id]);\n        // emit log_debug(ctx[mm_periodic_column__settlement_merkle_hash_points__x]);\n        // emit log_debug(ctx[mm_periodic_column__settlement_merkle_hash_points__y]);\n        // emit log_debug(ctx[mm_periodic_column__ecdsa_points__x]);\n        // emit log_debug(ctx[mm_periodic_column__ecdsa_points__y]);\n\n        uint256 compositionFromTraceValue;\n        address lconstraintPoly = address(constraintPoly);\n        uint256 offset = 0x20 * (1 + MM_CONSTRAINT_POLY_ARGS_START);\n        uint256 size = 0x20 * (MM_CONSTRAINT_POLY_ARGS_END - MM_CONSTRAINT_POLY_ARGS_START);\n        assembly {\n            // Call DexConstraintPoly contract.\n            let p := mload(0x40)\n            if iszero(staticcall(not(0), lconstraintPoly, add(ctx, offset), size, p, 0x20)) {\n                returndatacopy(0, 0, returndatasize)\n                revert(0, returndatasize)\n            }\n            compositionFromTraceValue := mload(p)\n        }\n\n        uint256 claimedComposition = fadd(\n            ctx[MM_OODS_VALUES + MASK_SIZE],\n            fmul(oodsPoint, ctx[MM_OODS_VALUES + MASK_SIZE + 1]));\n\n        require(\n            compositionFromTraceValue == claimedComposition,\n            \"claimedComposition does not match trace\");\n    }\n}\n"},"FactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IQueryableFactRegistry.sol\";\n\ncontract FactRegistry is IQueryableFactRegistry {\n    // Mapping: fact hash -\u003e true.\n    mapping (bytes32 =\u003e bool) private verifiedFact;\n\n    // Indicates whether the Fact Registry has at least one fact registered.\n    bool anyFactRegistered;\n\n    /*\n      Checks if a fact has been verified.\n    */\n    function isValid(bytes32 fact)\n        external view\n        returns(bool)\n    {\n        return verifiedFact[fact];\n    }\n\n    function registerFact(\n        bytes32 factHash\n        )\n        internal\n    {\n        // This function stores the testiment hash in the mapping.\n        verifiedFact[factHash] = true;\n\n        // Mark first time off.\n        if (!anyFactRegistered) {\n            anyFactRegistered = true;\n        }\n    }\n\n    /*\n      Indicates whether at least one fact was registered.\n    */\n    function hasRegisteredFact()\n        external view\n        returns(bool)\n    {\n        return anyFactRegistered;\n    }\n\n}\n"},"Fri.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MemoryMap.sol\";\nimport \"MemoryAccessUtils.sol\";\nimport \"FriLayer.sol\";\nimport \"HornerEvaluator.sol\";\n\n/*\n  This contract computes and verifies all the FRI layer, one by one. The final layer is verified\n  by evaluating the fully committed polynomial, and requires specific handling.\n*/\ncontract Fri is MemoryMap, MemoryAccessUtils, HornerEvaluator, FriLayer {\n    event LogGas(string name, uint256 val);\n\n    function verifyLastLayer(uint256[] memory ctx, uint256 nPoints)\n        internal {\n        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];\n        uint256 groupOrderMinusOne = friLastLayerDegBound * ctx[MM_BLOW_UP_FACTOR] - 1;\n        uint256 coefsStart = ctx[MM_FRI_LAST_LAYER_PTR];\n\n        for (uint256 i = 0; i \u003c nPoints; i++) {\n            uint256 point = ctx[MM_FRI_QUEUE + 3*i + 2];\n            // Invert point using inverse(point) == fpow(point, ord(point) - 1).\n\n            point = fpow(point, groupOrderMinusOne);\n            require(\n                hornerEval(coefsStart, point, friLastLayerDegBound) == ctx[MM_FRI_QUEUE + 3*i + 1],\n                \"Bad Last layer value.\");\n        }\n    }\n\n    /*\n      Verifies FRI layers.\n\n      Upon entry and every time we pass through the \"if (index \u003c layerSize)\" condition,\n      ctx[mmFriQueue:] holds an array of triplets (query index, FRI value, FRI inversed point), i.e.\n          ctx[mmFriQueue::3] holds query indices.\n          ctx[mmFriQueue + 1::3] holds the input for the next layer.\n          ctx[mmFriQueue + 2::3] holds the inverses of the evaluation points:\n            ctx[mmFriQueue + 3*i + 2] = inverse(\n                fpow(layerGenerator,  bitReverse(ctx[mmFriQueue + 3*i], logLayerSize)).\n    */\n    function friVerifyLayers(\n        uint256[] memory ctx)\n        internal\n    {\n\n        uint256 friCtx = getPtr(ctx, MM_FRI_CTX);\n        require(\n            MAX_SUPPORTED_MAX_FRI_STEP == FRI_MAX_FRI_STEP,\n            \"Incosistent MAX_FRI_STEP between MemoryMap.sol and FriLayer.sol\");\n        initFriGroups(friCtx);\n        // emit LogGas(\"FRI offset precomputation\", gasleft());\n        uint256 channelPtr = getChannelPtr(ctx);\n        uint256 merkleQueuePtr = getMerkleQueuePtr(ctx);\n\n        uint256 friStep = 1;\n        uint256 nLiveQueries = ctx[MM_N_UNIQUE_QUERIES];\n\n        // Add 0 at the end of the queries array to avoid empty array check in readNextElment.\n        ctx[MM_FRI_QUERIES_DELIMITER] = 0;\n\n        // Rather than converting all the values from Montgomery to standard form,\n        // we can just pretend that the values are in standard form but all\n        // the committed polynomials are multiplied by MontgomeryR.\n        //\n        // The values in the proof are already multiplied by MontgomeryR,\n        // but the inputs from the OODS oracle need to be fixed.\n        for (uint256 i = 0; i \u003c nLiveQueries; i++ ) {\n            ctx[MM_FRI_QUEUE + 3*i + 1] = fmul(ctx[MM_FRI_QUEUE + 3*i + 1], K_MONTGOMERY_R);\n        }\n\n        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);\n\n        uint256[] memory friSteps = getFriSteps(ctx);\n        uint256 nFriSteps = friSteps.length;\n        while (friStep \u003c nFriSteps) {\n            uint256 friCosetSize = 2**friSteps[friStep];\n\n            nLiveQueries = computeNextLayer(\n                channelPtr, friQueue, merkleQueuePtr, nLiveQueries,\n                ctx[MM_FRI_EVAL_POINTS + friStep], friCosetSize, friCtx);\n\n            // emit LogGas(\n            //     string(abi.encodePacked(\"FRI layer \", bytes1(uint8(48 + friStep)))), gasleft());\n\n            // Layer is done, verify the current layer and move to next layer.\n            // ctx[mmMerkleQueue: merkleQueueIdx) holds the indices\n            // and values of the merkle leaves that need verification.\n            verify(\n                channelPtr, merkleQueuePtr, bytes32(ctx[MM_FRI_COMMITMENTS + friStep - 1]),\n                nLiveQueries);\n\n            // emit LogGas(\n            //     string(abi.encodePacked(\"Merkle of FRI layer \", bytes1(uint8(48 + friStep)))),\n            //     gasleft());\n            friStep++;\n        }\n\n        verifyLastLayer(ctx, nLiveQueries);\n        // emit LogGas(\"last FRI layer\", gasleft());\n    }\n}\n"},"FriLayer.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MerkleVerifier.sol\";\nimport \"PrimeFieldElement0.sol\";\n\n/*\n  The main component of FRI is the FRI step which takes\n  the i-th layer evaluations on a coset c*\u003cg\u003e and produces a single evaluation in layer i+1.\n\n  To this end we have a friCtx that holds the following data:\n  evaluations:    holds the evaluations on the coset we are currently working on.\n  group:          holds the group \u003cg\u003e in bit reversed order.\n  halfInvGroup:   holds the group \u003cg^-1\u003e/\u003c-1\u003e in bit reversed order.\n                  (We only need half of the inverse group)\n\n  Note that due to the bit reversed order, a prefix of size 2^k of either group\n  or halfInvGroup has the same structure (but for a smaller group).\n*/\ncontract FriLayer is MerkleVerifier, PrimeFieldElement0 {\n    event LogGas(string name, uint256 val);\n\n    uint256 constant internal FRI_MAX_FRI_STEP = 4;\n    uint256 constant internal MAX_COSET_SIZE = 2**FRI_MAX_FRI_STEP;\n    // Generator of the group of size MAX_COSET_SIZE: GENERATOR_VAL**((PRIME - 1)/MAX_COSET_SIZE).\n    uint256 constant internal FRI_GROUP_GEN =\n    0x5ec467b88826aba4537602d514425f3b0bdf467bbf302458337c45f6021e539;\n\n    uint256 constant internal FRI_GROUP_SIZE = 0x20 * MAX_COSET_SIZE;\n    uint256 constant internal FRI_CTX_TO_COSET_EVALUATIONS_OFFSET = 0;\n    uint256 constant internal FRI_CTX_TO_FRI_GROUP_OFFSET = FRI_GROUP_SIZE;\n    uint256 constant internal FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET =\n    FRI_CTX_TO_FRI_GROUP_OFFSET + FRI_GROUP_SIZE;\n\n    uint256 constant internal FRI_CTX_SIZE =\n    FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET + (FRI_GROUP_SIZE / 2);\n\n    function nextLayerElementFromTwoPreviousLayerElements(\n        uint256 fX, uint256 fMinusX, uint256 evalPoint, uint256 xInv)\n        internal pure\n        returns (uint256 res)\n    {\n        // Folding formula:\n        // f(x)  = g(x^2) + xh(x^2)\n        // f(-x) = g((-x)^2) - xh((-x)^2) = g(x^2) - xh(x^2)\n        // =\u003e\n        // 2g(x^2) = f(x) + f(-x)\n        // 2h(x^2) = (f(x) - f(-x))/x\n        // =\u003e The 2*interpolation at evalPoint is:\n        // 2*(g(x^2) + evalPoint*h(x^2)) = f(x) + f(-x) + evalPoint*(f(x) - f(-x))*xInv.\n        //\n        // Note that multiplying by 2 doesn\u0027t affect the degree,\n        // so we can just agree to do that on both the prover and verifier.\n        assembly {\n            // PRIME is PrimeFieldElement0.K_MODULUS.\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            // Note that whenever we call add(), the result is always less than 2*PRIME,\n            // so there are no overflows.\n            res := addmod(add(fX, fMinusX),\n                   mulmod(mulmod(evalPoint, xInv, PRIME),\n                   add(fX, /*-fMinusX*/sub(PRIME, fMinusX)), PRIME), PRIME)\n        }\n    }\n\n    /*\n      Reads 4 elements, and applies 2 + 1 FRI transformations to obtain a single element.\n\n      FRI layer n:                              f0 f1  f2 f3\n      -----------------------------------------  \\ / -- \\ / -----------\n      FRI layer n+1:                              f0    f2\n      -------------------------------------------- \\ ---/ -------------\n      FRI layer n+2:                                 f0\n\n      The basic FRI transformation is described in nextLayerElementFromTwoPreviousLayerElements().\n    */\n    function do2FriSteps(\n        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,\n        uint256 friEvalPoint)\n    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {\n        assembly {\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)\n\n            let f0 := mload(evaluationsOnCosetPtr)\n            {\n                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))\n\n                // f0 \u003c 3P ( = 1 + 1 + 1).\n                f0 := add(add(f0, f1),\n                             mulmod(friEvalPointDivByX,\n                                    add(f0, /*-fMinusX*/sub(PRIME, f1)),\n                                    PRIME))\n            }\n\n            let f2 := mload(add(evaluationsOnCosetPtr, 0x40))\n            {\n                let f3 := mload(add(evaluationsOnCosetPtr, 0x60))\n                f2 := addmod(add(f2, f3),\n                             mulmod(add(f2, /*-fMinusX*/sub(PRIME, f3)),\n                                    mulmod(mload(add(friHalfInvGroupPtr, 0x20)),\n                                           friEvalPointDivByX,\n                                           PRIME),\n                                    PRIME),\n                             PRIME)\n            }\n\n            {\n                let newXInv := mulmod(cosetOffset_, cosetOffset_, PRIME)\n                nextXInv := mulmod(newXInv, newXInv, PRIME)\n            }\n\n            // f0 + f2 \u003c 4P ( = 3 + 1).\n            nextLayerValue := addmod(add(f0, f2),\n                          mulmod(mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME),\n                                 add(f0, /*-fMinusX*/sub(PRIME, f2)),\n                                 PRIME),\n                          PRIME)\n        }\n    }\n\n    /*\n      Reads 8 elements, and applies 4 + 2 + 1 FRI transformation to obtain a single element.\n\n      See do2FriSteps for more detailed explanation.\n    */\n    function do3FriSteps(\n        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,\n        uint256 friEvalPoint)\n    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {\n        assembly {\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010\n            let f0 := mload(evaluationsOnCosetPtr)\n\n            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)\n            let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)\n            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))\n\n            {\n                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))\n\n                // f0 \u003c 3P ( = 1 + 1 + 1).\n                f0 := add(add(f0, f1),\n                          mulmod(friEvalPointDivByX,\n                                 add(f0, /*-fMinusX*/sub(PRIME, f1)),\n                                 PRIME))\n            }\n            {\n                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))\n                {\n                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))\n\n                    // f2 \u003c 3P ( = 1 + 1 + 1).\n                    f2 := add(add(f2, f3),\n                              mulmod(add(f2, /*-fMinusX*/sub(PRIME, f3)),\n                                     mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),\n                                     PRIME))\n                }\n\n                // f0 \u003c 7P ( = 3 + 3 + 1).\n                f0 := add(add(f0, f2),\n                          mulmod(friEvalPointDivByXSquared,\n                                 add(f0, /*-fMinusX*/sub(MPRIME, f2)),\n                                 PRIME))\n            }\n            {\n                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))\n                {\n                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,\n                                                    mload(add(friHalfInvGroupPtr, 0x40)), PRIME)\n                    {\n                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))\n\n                        // f4 \u003c 3P ( = 1 + 1 + 1).\n                        f4 := add(add(f4, f5),\n                                  mulmod(friEvalPointDivByX2,\n                                         add(f4, /*-fMinusX*/sub(PRIME, f5)),\n                                         PRIME))\n                    }\n\n                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))\n                    {\n                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))\n\n                        // f6 \u003c 3P ( = 1 + 1 + 1).\n                        f6 := add(add(f6, f7),\n                                  mulmod(add(f6, /*-fMinusX*/sub(PRIME, f7)),\n                                         // friEvalPointDivByX2 * imaginaryUnit ==\n                                         // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0x60)).\n                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),\n                                         PRIME))\n                    }\n\n                    // f4 \u003c 7P ( = 3 + 3 + 1).\n                    f4 := add(add(f4, f6),\n                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),\n                                     add(f4, /*-fMinusX*/sub(MPRIME, f6)),\n                                     PRIME))\n                }\n\n                // f0, f4 \u003c 7P -\u003e f0 + f4 \u003c 14P \u0026\u0026 9P \u003c f0 + (MPRIME - f4) \u003c 23P.\n                nextLayerValue :=\n                   addmod(add(f0, f4),\n                          mulmod(mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME),\n                                 add(f0, /*-fMinusX*/sub(MPRIME, f4)),\n                                 PRIME),\n                          PRIME)\n            }\n\n            {\n                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)\n                let xInv4 := mulmod(xInv2, xInv2, PRIME)\n                nextXInv := mulmod(xInv4, xInv4, PRIME)\n            }\n\n\n        }\n    }\n\n    /*\n      This function reads 16 elements, and applies 8 + 4 + 2 + 1 fri transformation\n      to obtain a single element.\n\n      See do2FriSteps for more detailed explanation.\n    */\n    function do4FriSteps(\n        uint256 friHalfInvGroupPtr, uint256 evaluationsOnCosetPtr, uint256 cosetOffset_,\n        uint256 friEvalPoint)\n    internal pure returns (uint256 nextLayerValue, uint256 nextXInv) {\n        assembly {\n            let friEvalPointDivByXTessed\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let MPRIME := 0x8000000000000110000000000000000000000000000000000000000000000010\n            let f0 := mload(evaluationsOnCosetPtr)\n\n            let friEvalPointDivByX := mulmod(friEvalPoint, cosetOffset_, PRIME)\n            let imaginaryUnit := mload(add(friHalfInvGroupPtr, 0x20))\n\n            {\n                let f1 := mload(add(evaluationsOnCosetPtr, 0x20))\n\n                // f0 \u003c 3P ( = 1 + 1 + 1).\n                f0 := add(add(f0, f1),\n                          mulmod(friEvalPointDivByX,\n                                 add(f0, /*-fMinusX*/sub(PRIME, f1)),\n                                 PRIME))\n            }\n            {\n                let f2 := mload(add(evaluationsOnCosetPtr, 0x40))\n                {\n                    let f3 := mload(add(evaluationsOnCosetPtr, 0x60))\n\n                    // f2 \u003c 3P ( = 1 + 1 + 1).\n                    f2 := add(add(f2, f3),\n                                mulmod(add(f2, /*-fMinusX*/sub(PRIME, f3)),\n                                       mulmod(friEvalPointDivByX, imaginaryUnit, PRIME),\n                                       PRIME))\n                }\n                {\n                    let friEvalPointDivByXSquared := mulmod(friEvalPointDivByX, friEvalPointDivByX, PRIME)\n                    friEvalPointDivByXTessed := mulmod(friEvalPointDivByXSquared, friEvalPointDivByXSquared, PRIME)\n\n                    // f0 \u003c 7P ( = 3 + 3 + 1).\n                    f0 := add(add(f0, f2),\n                              mulmod(friEvalPointDivByXSquared,\n                                     add(f0, /*-fMinusX*/sub(MPRIME, f2)),\n                                     PRIME))\n                }\n            }\n            {\n                let f4 := mload(add(evaluationsOnCosetPtr, 0x80))\n                {\n                    let friEvalPointDivByX2 := mulmod(friEvalPointDivByX,\n                                                      mload(add(friHalfInvGroupPtr, 0x40)), PRIME)\n                    {\n                        let f5 := mload(add(evaluationsOnCosetPtr, 0xa0))\n\n                        // f4 \u003c 3P ( = 1 + 1 + 1).\n                        f4 := add(add(f4, f5),\n                                  mulmod(friEvalPointDivByX2,\n                                         add(f4, /*-fMinusX*/sub(PRIME, f5)),\n                                         PRIME))\n                    }\n\n                    let f6 := mload(add(evaluationsOnCosetPtr, 0xc0))\n                    {\n                        let f7 := mload(add(evaluationsOnCosetPtr, 0xe0))\n\n                        // f6 \u003c 3P ( = 1 + 1 + 1).\n                        f6 := add(add(f6, f7),\n                                  mulmod(add(f6, /*-fMinusX*/sub(PRIME, f7)),\n                                         // friEvalPointDivByX2 * imaginaryUnit ==\n                                         // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0x60)).\n                                         mulmod(friEvalPointDivByX2, imaginaryUnit, PRIME),\n                                         PRIME))\n                    }\n\n                    // f4 \u003c 7P ( = 3 + 3 + 1).\n                    f4 := add(add(f4, f6),\n                              mulmod(mulmod(friEvalPointDivByX2, friEvalPointDivByX2, PRIME),\n                                     add(f4, /*-fMinusX*/sub(MPRIME, f6)),\n                                     PRIME))\n                }\n\n                // f0 \u003c 15P ( = 7 + 7 + 1).\n                f0 := add(add(f0, f4),\n                          mulmod(friEvalPointDivByXTessed,\n                                 add(f0, /*-fMinusX*/sub(MPRIME, f4)),\n                                 PRIME))\n            }\n            {\n                let f8 := mload(add(evaluationsOnCosetPtr, 0x100))\n                {\n                    let friEvalPointDivByX4 := mulmod(friEvalPointDivByX,\n                                                      mload(add(friHalfInvGroupPtr, 0x80)), PRIME)\n                    {\n                        let f9 := mload(add(evaluationsOnCosetPtr, 0x120))\n\n                        // f8 \u003c 3P ( = 1 + 1 + 1).\n                        f8 := add(add(f8, f9),\n                                  mulmod(friEvalPointDivByX4,\n                                         add(f8, /*-fMinusX*/sub(PRIME, f9)),\n                                         PRIME))\n                    }\n\n                    let f10 := mload(add(evaluationsOnCosetPtr, 0x140))\n                    {\n                        let f11 := mload(add(evaluationsOnCosetPtr, 0x160))\n                        // f10 \u003c 3P ( = 1 + 1 + 1).\n                        f10 := add(add(f10, f11),\n                                   mulmod(add(f10, /*-fMinusX*/sub(PRIME, f11)),\n                                          // friEvalPointDivByX4 * imaginaryUnit ==\n                                          // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0xa0)).\n                                          mulmod(friEvalPointDivByX4, imaginaryUnit, PRIME),\n                                          PRIME))\n                    }\n\n                    // f8 \u003c 7P ( = 3 + 3 + 1).\n                    f8 := add(add(f8, f10),\n                              mulmod(mulmod(friEvalPointDivByX4, friEvalPointDivByX4, PRIME),\n                                     add(f8, /*-fMinusX*/sub(MPRIME, f10)),\n                                     PRIME))\n                }\n                {\n                    let f12 := mload(add(evaluationsOnCosetPtr, 0x180))\n                    {\n                        let friEvalPointDivByX6 := mulmod(friEvalPointDivByX,\n                                                          mload(add(friHalfInvGroupPtr, 0xc0)), PRIME)\n                        {\n                            let f13 := mload(add(evaluationsOnCosetPtr, 0x1a0))\n\n                            // f12 \u003c 3P ( = 1 + 1 + 1).\n                            f12 := add(add(f12, f13),\n                                       mulmod(friEvalPointDivByX6,\n                                              add(f12, /*-fMinusX*/sub(PRIME, f13)),\n                                              PRIME))\n                        }\n\n                        let f14 := mload(add(evaluationsOnCosetPtr, 0x1c0))\n                        {\n                            let f15 := mload(add(evaluationsOnCosetPtr, 0x1e0))\n\n                            // f14 \u003c 3P ( = 1 + 1 + 1).\n                            f14 := add(add(f14, f15),\n                                       mulmod(add(f14, /*-fMinusX*/sub(PRIME, f15)),\n                                              // friEvalPointDivByX6 * imaginaryUnit ==\n                                              // friEvalPointDivByX * mload(add(friHalfInvGroupPtr, 0xe0)).\n                                              mulmod(friEvalPointDivByX6, imaginaryUnit, PRIME),\n                                              PRIME))\n                        }\n\n                        // f12 \u003c 7P ( = 3 + 3 + 1).\n                        f12 := add(add(f12, f14),\n                                   mulmod(mulmod(friEvalPointDivByX6, friEvalPointDivByX6, PRIME),\n                                          add(f12, /*-fMinusX*/sub(MPRIME, f14)),\n                                          PRIME))\n                    }\n\n                    // f8 \u003c 15P ( = 7 + 7 + 1).\n                    f8 := add(add(f8, f12),\n                              mulmod(mulmod(friEvalPointDivByXTessed, imaginaryUnit, PRIME),\n                                     add(f8, /*-fMinusX*/sub(MPRIME, f12)),\n                                     PRIME))\n                }\n\n                // f0, f8 \u003c 15P -\u003e f0 + f8 \u003c 30P \u0026\u0026 16P \u003c f0 + (MPRIME - f8) \u003c 31P.\n                nextLayerValue :=\n                    addmod(add(f0, f8),\n                           mulmod(mulmod(friEvalPointDivByXTessed, friEvalPointDivByXTessed, PRIME),\n                                  add(f0, /*-fMinusX*/sub(MPRIME, f8)),\n                                  PRIME),\n                           PRIME)\n            }\n\n            {\n                let xInv2 := mulmod(cosetOffset_, cosetOffset_, PRIME)\n                let xInv4 := mulmod(xInv2, xInv2, PRIME)\n                let xInv8 := mulmod(xInv4, xInv4, PRIME)\n                nextXInv := mulmod(xInv8, xInv8, PRIME)\n            }\n        }\n    }\n\n    /*\n      Gathers the \"cosetSize\" elements that belong to the same coset\n      as the item at the top of the FRI queue and stores them in ctx[MM_FRI_STEP_VALUES:].\n\n      Returns\n        friQueueHead - friQueueHead_ + 0x60  * (# elements that were taken from the queue).\n        cosetIdx - the start index of the coset that was gathered.\n        cosetOffset_ - the xInv field element that corresponds to cosetIdx.\n    */\n    function gatherCosetInputs(\n        uint256 channelPtr, uint256 friCtx, uint256 friQueueHead_, uint256 cosetSize)\n        internal pure returns (uint256 friQueueHead, uint256 cosetIdx, uint256 cosetOffset_) {\n\n        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;\n        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;\n\n        friQueueHead = friQueueHead_;\n        assembly {\n            let queueItemIdx := mload(friQueueHead)\n            // The coset index is represented by the most significant bits of the queue item index.\n            cosetIdx := and(queueItemIdx, not(sub(cosetSize, 1)))\n            let nextCosetIdx := add(cosetIdx, cosetSize)\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n            // Get the algebraic coset offset:\n            // I.e. given c*g^(-k) compute c, where\n            //      g is the generator of the coset group.\n            //      k is bitReverse(offsetWithinCoset, log2(cosetSize)).\n            //\n            // To do this we multiply the algebraic coset offset at the top of the queue (c*g^(-k))\n            // by the group element that corresponds to the index inside the coset (g^k).\n            cosetOffset_ := mulmod(\n                /*(c*g^(-k)*/ mload(add(friQueueHead, 0x40)),\n                /*(g^k)*/     mload(add(friGroupPtr,\n                                        mul(/*offsetWithinCoset*/sub(queueItemIdx, cosetIdx),\n                                            0x20))),\n                PRIME)\n\n            let proofPtr := mload(channelPtr)\n\n            for { let index := cosetIdx } lt(index, nextCosetIdx) { index := add(index, 1) } {\n                // Inline channel operation:\n                // Assume we are going to read the next element from the proof.\n                // If this is not the case add(proofPtr, 0x20) will be reverted.\n                let fieldElementPtr := proofPtr\n                proofPtr := add(proofPtr, 0x20)\n\n                // Load the next index from the queue and check if it is our sibling.\n                if eq(index, queueItemIdx) {\n                    // Take element from the queue rather than from the proof\n                    // and convert it back to Montgomery form for Merkle verification.\n                    fieldElementPtr := add(friQueueHead, 0x20)\n\n                    // Revert the read from proof.\n                    proofPtr := sub(proofPtr, 0x20)\n\n                    // Reading the next index here is safe due to the\n                    // delimiter after the queries.\n                    friQueueHead := add(friQueueHead, 0x60)\n                    queueItemIdx := mload(friQueueHead)\n                }\n\n                // Note that we apply the modulo operation to convert the field elements we read\n                // from the proof to canonical representation (in the range [0, PRIME - 1]).\n                mstore(evaluationsOnCosetPtr, mod(mload(fieldElementPtr), PRIME))\n                evaluationsOnCosetPtr := add(evaluationsOnCosetPtr, 0x20)\n            }\n\n            mstore(channelPtr, proofPtr)\n        }\n    }\n\n    /*\n      Returns the bit reversal of num assuming it has the given number of bits.\n      For example, if we have numberOfBits = 6 and num = (0b)1101 == (0b)001101,\n      the function will return (0b)101100.\n    */\n    function bitReverse(uint256 num, uint256 numberOfBits)\n    internal pure\n        returns(uint256 numReversed)\n    {\n        assert((numberOfBits == 256) || (num \u003c 2 ** numberOfBits));\n        uint256 n = num;\n        uint256 r = 0;\n        for (uint256 k = 0; k \u003c numberOfBits; k++) {\n            r = (r * 2) | (n % 2);\n            n = n / 2;\n        }\n        return r;\n    }\n\n    /*\n      Initializes the FRI group and half inv group in the FRI context.\n    */\n    function initFriGroups(uint256 friCtx) internal {\n        uint256 friGroupPtr = friCtx + FRI_CTX_TO_FRI_GROUP_OFFSET;\n        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;\n\n        // FRI_GROUP_GEN is the coset generator.\n        // Raising it to the (MAX_COSET_SIZE - 1) power gives us the inverse.\n        uint256 genFriGroup = FRI_GROUP_GEN;\n\n        uint256 genFriGroupInv = fpow(genFriGroup, (MAX_COSET_SIZE - 1));\n\n        uint256 lastVal = ONE_VAL;\n        uint256 lastValInv = ONE_VAL;\n        uint256 prime = PrimeFieldElement0.K_MODULUS;\n        assembly {\n            // ctx[mmHalfFriInvGroup + 0] = ONE_VAL;\n            mstore(friHalfInvGroupPtr, lastValInv)\n            // ctx[mmFriGroup + 0] = ONE_VAL;\n            mstore(friGroupPtr, lastVal)\n            // ctx[mmFriGroup + 1] = fsub(0, ONE_VAL);\n            mstore(add(friGroupPtr, 0x20), sub(prime, lastVal))\n        }\n\n        // To compute [1, -1 (== g^n/2), g^n/4, -g^n/4, ...]\n        // we compute half the elements and derive the rest using negation.\n        uint256 halfCosetSize = MAX_COSET_SIZE / 2;\n        for (uint256 i = 1; i \u003c halfCosetSize; i++) {\n            lastVal = fmul(lastVal, genFriGroup);\n            lastValInv = fmul(lastValInv, genFriGroupInv);\n            uint256 idx = bitReverse(i, FRI_MAX_FRI_STEP-1);\n\n            assembly {\n                // ctx[mmHalfFriInvGroup + idx] = lastValInv;\n                mstore(add(friHalfInvGroupPtr, mul(idx, 0x20)), lastValInv)\n                // ctx[mmFriGroup + 2*idx] = lastVal;\n                mstore(add(friGroupPtr, mul(idx, 0x40)), lastVal)\n                // ctx[mmFriGroup + 2*idx + 1] = fsub(0, lastVal);\n                mstore(add(friGroupPtr, add(mul(idx, 0x40), 0x20)), sub(prime, lastVal))\n            }\n        }\n    }\n\n    /*\n      Operates on the coset of size friFoldedCosetSize that start at index.\n\n      It produces 3 outputs:\n        1. The field elements that result from doing FRI reductions on the coset.\n        2. The pointInv elements for the location that corresponds to the first output.\n        3. The root of a Merkle tree for the input layer.\n\n      The input is read either from the queue or from the proof depending on data availability.\n      Since the function reads from the queue it returns an updated head pointer.\n    */\n    function doFriSteps(\n        uint256 friCtx, uint256 friQueueTail, uint256 cosetOffset_, uint256 friEvalPoint,\n        uint256 friCosetSize, uint256 index, uint256 merkleQueuePtr)\n        internal pure {\n        uint256 friValue;\n\n        uint256 evaluationsOnCosetPtr = friCtx + FRI_CTX_TO_COSET_EVALUATIONS_OFFSET;\n        uint256 friHalfInvGroupPtr = friCtx + FRI_CTX_TO_FRI_HALF_INV_GROUP_OFFSET;\n\n        // Compare to expected FRI step sizes in order of likelihood, step size 3 being most common.\n        if (friCosetSize == 8) {\n            (friValue, cosetOffset_) = do3FriSteps(\n                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);\n        } else if (friCosetSize == 4) {\n            (friValue, cosetOffset_) = do2FriSteps(\n                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);\n        } else if (friCosetSize == 16) {\n            (friValue, cosetOffset_) = do4FriSteps(\n                friHalfInvGroupPtr, evaluationsOnCosetPtr, cosetOffset_, friEvalPoint);\n        } else {\n            require(false, \"Only step sizes of 2, 3 or 4 are supported.\");\n        }\n\n        uint256 lhashMask = getHashMask();\n        assembly {\n            let indexInNextStep := div(index, friCosetSize)\n            mstore(merkleQueuePtr, indexInNextStep)\n            mstore(add(merkleQueuePtr, 0x20), and(lhashMask, keccak256(evaluationsOnCosetPtr,\n                                                                          mul(0x20,friCosetSize))))\n\n            mstore(friQueueTail, indexInNextStep)\n            mstore(add(friQueueTail, 0x20), friValue)\n            mstore(add(friQueueTail, 0x40), cosetOffset_)\n        }\n    }\n\n    /*\n      Computes the FRI step with eta = log2(friCosetSize) for all the live queries.\n      The input and output data is given in array of triplets:\n          (query index, FRI value, FRI inversed point)\n      in the address friQueuePtr (which is \u0026ctx[mmFriQueue:]).\n\n      The function returns the number of live queries remaining after computing the FRI step.\n\n      The number of live queries decreases whenever multiple query points in the same\n      coset are reduced to a single query in the next FRI layer.\n\n      As the function computes the next layer it also collects that data from\n      the previous layer for Merkle verification.\n    */\n    function computeNextLayer(\n        uint256 channelPtr, uint256 friQueuePtr, uint256 merkleQueuePtr, uint256 nQueries,\n        uint256 friEvalPoint, uint256 friCosetSize, uint256 friCtx)\n        internal pure returns (uint256 nLiveQueries) {\n        uint256 merkleQueueTail = merkleQueuePtr;\n        uint256 friQueueHead = friQueuePtr;\n        uint256 friQueueTail = friQueuePtr;\n        uint256 friQueueEnd = friQueueHead + (0x60 * nQueries);\n\n        do {\n            uint256 cosetOffset;\n            uint256 index;\n            (friQueueHead, index, cosetOffset) = gatherCosetInputs(\n                channelPtr, friCtx, friQueueHead, friCosetSize);\n\n            doFriSteps(\n                friCtx, friQueueTail, cosetOffset, friEvalPoint, friCosetSize, index,\n                merkleQueueTail);\n\n            merkleQueueTail += 0x40;\n            friQueueTail += 0x60;\n        } while (friQueueHead \u003c friQueueEnd);\n        return (friQueueTail - friQueuePtr) / 0x60;\n    }\n\n}\n"},"FriStatementContract.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"FactRegistry.sol\";\nimport \"FriLayer.sol\";\n\ncontract FriStatementContract is FriLayer, FactRegistry {\n    /*\n      Compute a single FRI layer of size friStepSize at evaluationPoint starting from input\n      friQueue, and the extra witnesses in the \"proof\" channel. Also check that the input and\n      witnesses belong to a Merkle tree with root expectedRoot, again using witnesses from \"proof\".\n      After verification, register the FRI fact hash, which is:\n      keccak256(\n          evaluationPoint,\n          friStepSize,\n          keccak256(friQueue_input),\n          keccak256(friQueue_output),  // The FRI queue after proccessing the FRI layer\n          expectedRoot\n      )\n\n      Note that this function is used as external, but declared public to avoid copying the arrays.\n    */\n    function verifyFRI(\n        uint256[] memory proof,\n        uint256[] memory friQueue,\n        uint256 evaluationPoint,\n        uint256 friStepSize,\n        uint256 expectedRoot) public {\n\n        require (friStepSize \u003c= FRI_MAX_FRI_STEP, \"FRI step size too large\");\n        /*\n          The friQueue should have of 3*nQueries + 1 elements, beginning with nQueries triplets\n          of the form (query_index, FRI_value, FRI_inverse_point), and ending with a single buffer\n          cell set to 0, which is accessed and read during the computation of the FRI layer.\n        */\n        require (\n            friQueue.length % 3 == 1,\n            \"FRI Queue must be composed of triplets plus one delimiter cell\");\n        require (friQueue.length \u003e= 4, \"No query to process\");\n\n        uint256 mmFriCtxSize = FRI_CTX_SIZE;\n        uint256 nQueries = friQueue.length / 3;\n        friQueue[3*nQueries] = 0;\n        uint256 merkleQueuePtr;\n        uint256 friQueuePtr;\n        uint256 channelPtr;\n        uint256 friCtx;\n        uint256 dataToHash;\n\n        // Verify evaluation point within valid range.\n        require(evaluationPoint \u003c K_MODULUS, \"INVALID_EVAL_POINT\");\n\n        // Queries need to be in the range [2**height .. 2**(height+1)-1] strictly incrementing.\n        // i.e. we need to check that Qi+1 \u003e Qi for each i,\n        // but regarding the height range - it\u0027s sufficient to check that\n        // (Q1 ^ Qn) \u003c Q1 Which affirms that all queries are within the same logarithmic step.\n\n        // Verify FRI values and inverses are within valid range.\n        // and verify that queries are strictly incrementing.\n        uint256 prevQuery = 0; // If we pass height, change to: prevQuery = 1 \u003c\u003c height - 1;\n        for (uint256 i = 0; i \u003c nQueries; i++) {\n            require(friQueue[3*i] \u003e prevQuery, \"INVALID_QUERY_VALUE\");\n            require(friQueue[3*i+1] \u003c K_MODULUS, \"INVALID_FRI_VALUE\");\n            require(friQueue[3*i+2] \u003c K_MODULUS, \"INVALID_FRI_INVERSE_POINT\");\n            prevQuery = friQueue[3*i];\n        }\n\n        // Verify all queries are on the same logarithmic step.\n        require((friQueue[0] ^ friQueue[3*nQueries-3]) \u003c friQueue[0], \"INVALID_QUERIES_RANGE\");\n\n        // Allocate memory queues: channelPtr, merkleQueue, friCtx, dataToHash.\n        assembly {\n            friQueuePtr := add(friQueue, 0x20)\n            channelPtr := mload(0x40) // Free pointer location.\n            mstore(channelPtr, add(proof, 0x20))\n            merkleQueuePtr := add(channelPtr, 0x20)\n            friCtx := add(merkleQueuePtr, mul(0x40, nQueries))\n            dataToHash := add(friCtx, mmFriCtxSize)\n            mstore(0x40, add(dataToHash, 0xa0)) // Advance free pointer.\n\n            mstore(dataToHash, evaluationPoint)\n            mstore(add(dataToHash, 0x20), friStepSize)\n            mstore(add(dataToHash, 0x80), expectedRoot)\n\n            // Hash FRI inputs and add to dataToHash.\n            mstore(add(dataToHash, 0x40), keccak256(friQueuePtr, mul(0x60, nQueries)))\n        }\n\n        initFriGroups(friCtx);\n\n        nQueries = computeNextLayer(\n            channelPtr, friQueuePtr, merkleQueuePtr, nQueries, evaluationPoint,\n            2**friStepSize, /* friCosetSize = 2**friStepSize */\n            friCtx);\n\n        verify(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);\n\n        bytes32 factHash;\n        assembly {\n            // Hash FRI outputs and add to dataToHash.\n            mstore(add(dataToHash, 0x60), keccak256(friQueuePtr, mul(0x60, nQueries)))\n            factHash := keccak256(dataToHash, 0xa0)\n        }\n\n        registerFact(factHash);\n    }\n}\n"},"FriStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MemoryMap.sol\";\nimport \"MemoryAccessUtils.sol\";\nimport \"FriStatementContract.sol\";\nimport \"HornerEvaluator.sol\";\nimport \"VerifierChannel.sol\";\n\n/*\n  This contract verifies all the FRI layer, one by one, using the FriStatementContract.\n  The first layer is computed from decommitments, the last layer is computed by evaluating the\n  fully committed polynomial, and the mid-layers are provided in the proof only as hashed data.\n*/\ncontract FriStatementVerifier is MemoryMap, MemoryAccessUtils, VerifierChannel, HornerEvaluator {\n    event LogGas(string name, uint256 val);\n\n    FriStatementContract friStatementContract;\n\n    constructor(address friStatementContractAddress) internal {\n        friStatementContract = FriStatementContract(friStatementContractAddress);\n    }\n\n    /*\n      Fast-forwards the queries and invPoints of the friQueue from before the first layer to after\n      the last layer, computes the last FRI layer using horner evalations, then returns the hash\n      of the final FriQueue.\n    */\n    function computerLastLayerHash(uint256[] memory ctx, uint256 nPoints, uint256 numLayers)\n        internal returns (bytes32 lastLayerHash) {\n        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];\n        uint256 groupOrderMinusOne = friLastLayerDegBound * ctx[MM_BLOW_UP_FACTOR] - 1;\n        uint256 exponent = 1 \u003c\u003c numLayers;\n        uint256 curPointIndex = 0;\n        uint256 prevQuery = 0;\n        uint256 coefsStart = ctx[MM_FRI_LAST_LAYER_PTR];\n\n        for (uint256 i = 0; i \u003c nPoints; i++) {\n            uint256 query = ctx[MM_FRI_QUEUE + 3*i] \u003e\u003e numLayers;\n            if (query == prevQuery) {\n                continue;\n            }\n            ctx[MM_FRI_QUEUE + 3*curPointIndex] = query;\n            prevQuery = query;\n\n            uint256 point = fpow(ctx[MM_FRI_QUEUE + 3*i + 2], exponent);\n            ctx[MM_FRI_QUEUE + 3*curPointIndex + 2] = point;\n            // Invert point using inverse(point) == fpow(point, ord(point) - 1).\n\n            point = fpow(point, groupOrderMinusOne);\n            ctx[MM_FRI_QUEUE + 3*curPointIndex + 1] = hornerEval(\n                coefsStart, point, friLastLayerDegBound);\n\n            curPointIndex++;\n        }\n\n        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);\n        assembly {\n            lastLayerHash := keccak256(friQueue, mul(curPointIndex, 0x60))\n        }\n    }\n\n    /*\n      Verifies that FRI layers consistent with the computed first and last FRI layers\n      have been registered in the FriStatementContract.\n    */\n    function friVerifyLayers(\n        uint256[] memory ctx)\n        internal\n    {\n        uint256 channelPtr = getChannelPtr(ctx);\n        uint256 nQueries = ctx[MM_N_UNIQUE_QUERIES];\n\n        // Rather than converting all the values from Montgomery to standard form,\n        // we can just pretend that the values are in standard form but all\n        // the committed polynomials are multiplied by MontgomeryR.\n        //\n        // The values in the proof are already multiplied by MontgomeryR,\n        // but the inputs from the OODS oracle need to be fixed.\n        for (uint256 i = 0; i \u003c nQueries; i++ ) {\n            ctx[MM_FRI_QUEUE + 3*i + 1] = fmul(ctx[MM_FRI_QUEUE + 3*i + 1], K_MONTGOMERY_R);\n        }\n\n        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);\n        uint256 inputLayerHash;\n        assembly {\n            inputLayerHash := keccak256(friQueue, mul(nQueries, 0x60))\n        }\n\n\n        uint256[] memory friSteps = getFriSteps(ctx);\n        uint256 nFriStepsLessOne = friSteps.length - 1;\n        uint256 friStep = 1;\n        uint256 sumSteps = friSteps[1];\n        uint256[5] memory dataToHash;\n        while (friStep \u003c nFriStepsLessOne) {\n            uint256 outputLayerHash = uint256(readBytes(channelPtr, true));\n            dataToHash[0] = ctx[MM_FRI_EVAL_POINTS + friStep];\n            dataToHash[1] = friSteps[friStep];\n            dataToHash[2] = inputLayerHash;\n            dataToHash[3] = outputLayerHash;\n            dataToHash[4] = ctx[MM_FRI_COMMITMENTS + friStep - 1];\n\n            // Verify statement is registered.\n            require(\n                friStatementContract.isValid(keccak256(abi.encodePacked(dataToHash))),\n                \"INVALIDATED_FRI_STATEMENT\");\n\n            inputLayerHash = outputLayerHash;\n\n            friStep++;\n            sumSteps += friSteps[friStep];\n        }\n\n        dataToHash[0] = ctx[MM_FRI_EVAL_POINTS + friStep];\n        dataToHash[1] = friSteps[friStep];\n        dataToHash[2] = inputLayerHash;\n        dataToHash[3] = uint256(computerLastLayerHash(ctx, nQueries, sumSteps));\n        dataToHash[4] = ctx[MM_FRI_COMMITMENTS + friStep - 1];\n\n        require(\n            friStatementContract.isValid(keccak256(abi.encodePacked(dataToHash))),\n            \"INVALIDATED_FRI_STATEMENT\");\n    }\n}\n"},"HornerEvaluator.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"PrimeFieldElement0.sol\";\n\ncontract HornerEvaluator is PrimeFieldElement0 {\n    /*\n      Computes the evaluation of a polynomial f(x) = sum(a_i * x^i) on the given point.\n      The coefficients of the polynomial are given in\n        a_0 = coefsStart[0], ..., a_{n-1} = coefsStart[n - 1]\n      where n = nCoefs = friLastLayerDegBound. Note that coefsStart is not actually an array but\n      a direct pointer.\n      The function requires that n is divisible by 8.\n    */\n    function hornerEval(uint256 coefsStart, uint256 point, uint256 nCoefs)\n        internal pure\n        returns (uint256) {\n        uint256 result = 0;\n        uint256 prime = PrimeFieldElement0.K_MODULUS;\n\n        require(nCoefs % 8 == 0, \"Number of polynomial coefficients must be divisible by 8\");\n        require(nCoefs \u003c 4096, \"No more than 4096 coefficients are supported\");\n\n        assembly {\n            let coefsPtr := add(coefsStart, mul(nCoefs, 0x20))\n            for { } gt(coefsPtr, coefsStart) { } {\n                // Reduce coefsPtr by 8 field elements.\n                coefsPtr := sub(coefsPtr, 0x100)\n\n                // Apply 4 Horner steps (result := result * point + coef).\n                result :=\n                    add(mload(add(coefsPtr, 0x80)), mulmod(\n                    add(mload(add(coefsPtr, 0xa0)), mulmod(\n                    add(mload(add(coefsPtr, 0xc0)), mulmod(\n                    add(mload(add(coefsPtr, 0xe0)), mulmod(\n                        result,\n                    point, prime)),\n                    point, prime)),\n                    point, prime)),\n                    point, prime))\n\n                // Apply 4 additional Horner steps.\n                result :=\n                    add(mload(coefsPtr), mulmod(\n                    add(mload(add(coefsPtr, 0x20)), mulmod(\n                    add(mload(add(coefsPtr, 0x40)), mulmod(\n                    add(mload(add(coefsPtr, 0x60)), mulmod(\n                        result,\n                    point, prime)),\n                    point, prime)),\n                    point, prime)),\n                    point, prime))\n            }\n        }\n\n        // Since the last operation was \"add\" (instead of \"addmod\"), we need to take result % prime.\n        return result % prime;\n    }\n}\n"},"Identity.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract Identity {\n\n    /*\n      Allows a caller, typically another contract,\n      to ensure that the provided address is of the expected type and version.\n    */\n    function identify()\n        external pure\n        returns(string memory);\n}\n"},"IDexStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n\ncontract IDexStatementVerifier {\n\n    function verifyProofAndRegister(\n        uint256[] calldata proofParams,\n        uint256[] calldata proof,\n        uint256[] calldata publicInput\n    )\n        external;\n\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"IFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post \u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\u003e`_.\n*/\ncontract IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"IMerkleVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract IMerkleVerifier {\n    uint256 constant internal MAX_N_MERKLE_VERIFIER_QUERIES =  128;\n\n    function verify(\n        uint256 channelPtr,\n        uint256 queuePtr,\n        bytes32 root,\n        uint256 n)\n        internal view\n        returns (bytes32 hash);\n}\n"},"IQueryableFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IFactRegistry.sol\";\n\n/*\n  Extends the IFactRegistry interface with a query method that indicates\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\n*/\ncontract IQueryableFactRegistry is IFactRegistry {\n\n    /*\n      Returns true if at least one fact has been registered.\n    */\n    function hasRegisteredFact()\n        external view\n        returns(bool);\n\n}\n"},"IStarkVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract IStarkVerifier {\n\n    function verifyProof(\n        uint256[] memory proofParams,\n        uint256[] memory proof,\n        uint256[] memory publicInput\n    )\n        internal;\n}\n"},"MemoryAccessUtils.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MemoryMap.sol\";\n\ncontract MemoryAccessUtils is MemoryMap {\n    function getPtr(uint256[] memory ctx, uint256 offset)\n        internal pure\n        returns (uint256) {\n        uint256 ctxPtr;\n        require(offset \u003c MM_CONTEXT_SIZE, \"Overflow protection failed\");\n        assembly {\n            ctxPtr := add(ctx, 0x20)\n        }\n        return ctxPtr + offset * 0x20;\n    }\n\n    function getProofPtr(uint256[] memory proof)\n        internal pure\n        returns (uint256)\n    {\n        uint256 proofPtr;\n        assembly {\n            proofPtr := proof\n        }\n        return proofPtr;\n    }\n\n    function getChannelPtr(uint256[] memory ctx)\n        internal pure\n        returns (uint256) {\n        uint256 ctxPtr;\n        assembly {\n            ctxPtr := add(ctx, 0x20)\n        }\n        return ctxPtr + MM_CHANNEL * 0x20;\n    }\n\n    function getQueries(uint256[] memory ctx)\n        internal pure\n        returns (uint256[] memory)\n    {\n        uint256[] memory queries;\n        // Dynamic array holds length followed by values.\n        uint256 offset = 0x20 + 0x20*MM_N_UNIQUE_QUERIES;\n        assembly {\n            queries := add(ctx, offset)\n        }\n        return queries;\n    }\n\n    function getMerkleQueuePtr(uint256[] memory ctx)\n        internal pure\n        returns (uint256)\n    {\n        return getPtr(ctx, MM_MERKLE_QUEUE);\n    }\n\n    function getFriSteps(uint256[] memory ctx)\n        internal pure\n        returns (uint256[] memory friSteps)\n    {\n        uint256 friStepsPtr = getPtr(ctx, MM_FRI_STEPS_PTR);\n        assembly {\n            friSteps := mload(friStepsPtr)\n        }\n    }\n}\n"},"MemoryMap.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MemoryMap {\n    /*\n      We store the state of the verifer in a contiguous chunk of memory.\n      The offsets of the different fields are listed below.\n      E.g. The offset of the i\u0027th hash is [mm_hashes + i].\n    */\n    uint256 constant internal CHANNEL_STATE_SIZE = 3;\n    uint256 constant internal MAX_N_QUERIES =  48;\n    uint256 constant internal FRI_QUEUE_SIZE = MAX_N_QUERIES;\n\n    uint256 constant internal MAX_SUPPORTED_MAX_FRI_STEP = 4;\n\n    uint256 constant internal MM_EVAL_DOMAIN_SIZE =                          0x0;\n    uint256 constant internal MM_BLOW_UP_FACTOR =                            0x1;\n    uint256 constant internal MM_LOG_EVAL_DOMAIN_SIZE =                      0x2;\n    uint256 constant internal MM_PROOF_OF_WORK_BITS =                        0x3;\n    uint256 constant internal MM_EVAL_DOMAIN_GENERATOR =                     0x4;\n    uint256 constant internal MM_PUBLIC_INPUT_PTR =                          0x5;\n    uint256 constant internal MM_TRACE_COMMITMENT =                          0x6;\n    uint256 constant internal MM_OODS_COMMITMENT =                           0x7;\n    uint256 constant internal MM_N_UNIQUE_QUERIES =                          0x8;\n    uint256 constant internal MM_CHANNEL =                                   0x9; // uint256[3]\n    uint256 constant internal MM_MERKLE_QUEUE =                              0xc; // uint256[96]\n    uint256 constant internal MM_FRI_QUEUE =                                0x6c; // uint256[144]\n    uint256 constant internal MM_FRI_QUERIES_DELIMITER =                    0xfc;\n    uint256 constant internal MM_FRI_CTX =                                  0xfd; // uint256[40]\n    uint256 constant internal MM_FRI_STEPS_PTR =                           0x125;\n    uint256 constant internal MM_FRI_EVAL_POINTS =                         0x126; // uint256[10]\n    uint256 constant internal MM_FRI_COMMITMENTS =                         0x130; // uint256[10]\n    uint256 constant internal MM_FRI_LAST_LAYER_DEG_BOUND =                0x13a;\n    uint256 constant internal MM_FRI_LAST_LAYER_PTR =                      0x13b;\n    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_START =              0x13c;\n    uint256 constant internal MM_PERIODIC_COLUMN__HASH_POOL_POINTS__X =    0x13c;\n    uint256 constant internal MM_PERIODIC_COLUMN__HASH_POOL_POINTS__Y =    0x13d;\n    uint256 constant internal MM_PERIODIC_COLUMN__VAULTS_MERKLE_HASH_POINTS__X = 0x13e;\n    uint256 constant internal MM_PERIODIC_COLUMN__VAULTS_MERKLE_HASH_POINTS__Y = 0x13f;\n    uint256 constant internal MM_PERIODIC_COLUMN__BOUNDARY_BASE =          0x140;\n    uint256 constant internal MM_PERIODIC_COLUMN__IS_MODIFICATION =        0x141;\n    uint256 constant internal MM_PERIODIC_COLUMN__IS_SETTLEMENT =          0x142;\n    uint256 constant internal MM_PERIODIC_COLUMN__BOUNDARY_KEY =           0x143;\n    uint256 constant internal MM_PERIODIC_COLUMN__BOUNDARY_TOKEN =         0x144;\n    uint256 constant internal MM_PERIODIC_COLUMN__BOUNDARY_AMOUNT0 =       0x145;\n    uint256 constant internal MM_PERIODIC_COLUMN__BOUNDARY_AMOUNT1 =       0x146;\n    uint256 constant internal MM_PERIODIC_COLUMN__BOUNDARY_VAULT_ID =      0x147;\n    uint256 constant internal MM_PERIODIC_COLUMN__SETTLEMENT_MERKLE_HASH_POINTS__X = 0x148;\n    uint256 constant internal MM_PERIODIC_COLUMN__SETTLEMENT_MERKLE_HASH_POINTS__Y = 0x149;\n    uint256 constant internal MM_PERIODIC_COLUMN__ECDSA_POINTS__X =        0x14a;\n    uint256 constant internal MM_PERIODIC_COLUMN__ECDSA_POINTS__Y =        0x14b;\n    uint256 constant internal MM_TRACE_LENGTH =                            0x14c;\n    uint256 constant internal MM_SHIFT_POINT_X =                           0x14d;\n    uint256 constant internal MM_SHIFT_POINT_Y =                           0x14e;\n    uint256 constant internal MM_VAULTS_PATH_LENGTH =                      0x14f;\n    uint256 constant internal MM_N_MODIFICATIONS =                         0x150;\n    uint256 constant internal MM_N_SETTLEMENTS =                           0x151;\n    uint256 constant internal MM_AMOUNT_SHIFT =                            0x152;\n    uint256 constant internal MM_GLOBAL_EXPIRATION_TIMESTAMP_ELM =         0x153;\n    uint256 constant internal MM_SIG_CONFIG_ALPHA =                        0x154;\n    uint256 constant internal MM_SIG_CONFIG_BETA =                         0x155;\n    uint256 constant internal MM_VAULT_SHIFT =                             0x156;\n    uint256 constant internal MM_NONCE_SHIFT =                             0x157;\n    uint256 constant internal MM_EXPIRATION_TIMESTAMP_SHIFT =              0x158;\n    uint256 constant internal MM_INITIAL_VAULTS_ROOT =                     0x159;\n    uint256 constant internal MM_INITIAL_SETTLEMENT_ROOT =                 0x15a;\n    uint256 constant internal MM_FINAL_VAULTS_ROOT =                       0x15b;\n    uint256 constant internal MM_N_TRANSACTIONS =                          0x15c;\n    uint256 constant internal MM_FINAL_SETTLEMENT_ROOT =                   0x15d;\n    uint256 constant internal MM_TRACE_GENERATOR =                         0x15e;\n    uint256 constant internal MM_OODS_POINT =                              0x15f;\n    uint256 constant internal MM_COEFFICIENTS =                            0x160; // uint256[360]\n    uint256 constant internal MM_OODS_VALUES =                             0x2c8; // uint256[193]\n    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_END =                0x389;\n    uint256 constant internal MM_COMPOSITION_OODS_VALUES =                 0x389; // uint256[2]\n    uint256 constant internal MM_OODS_EVAL_POINTS =                        0x38b; // uint256[48]\n    uint256 constant internal MM_OODS_COEFFICIENTS =                       0x3bb; // uint256[195]\n    uint256 constant internal MM_TRACE_QUERY_RESPONSES =                   0x47e; // uint256[864]\n    uint256 constant internal MM_COMPOSITION_QUERY_RESPONSES =             0x7de; // uint256[96]\n    uint256 constant internal MM_CONTEXT_SIZE =                            0x83e;\n}\n"},"MerkleStatementContract.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"FactRegistry.sol\";\nimport \"MerkleVerifier.sol\";\n\ncontract MerkleStatementContract is MerkleVerifier, FactRegistry {\n    /*\n      This function recieves an initial merkle queue (consists of indices of leaves in the merkle\n      in addition to their values) and a merkle view (contains the values of all the nodes\n      required to be able to validate the queue). In case of success it registers the Merkle fact,\n      which is the hash of the queue together with the resulting root.\n    */\n    function verifyMerkle(\n        uint256[] memory merkleView,\n        uint256[] memory initialMerkleQueue,\n        uint256 height,\n        uint256 expectedRoot\n        )\n        public\n    {\n        require(height \u003c 200, \"Height must be \u003c 200.\");\n        require(\n            initialMerkleQueue.length \u003c= MAX_N_MERKLE_VERIFIER_QUERIES * 2,\n            \"TOO_MANY_MERKLE_QUERIES\");\n\n        uint256 merkleQueuePtr;\n        uint256 channelPtr;\n        uint256 nQueries;\n        uint256 dataToHashPtr;\n        uint256 badInput = 0;\n\n        assembly {\n            // Skip 0x20 bytes length at the beginning of the merkleView.\n            let merkleViewPtr := add(merkleView, 0x20)\n            // Let channelPtr point to a free space.\n            channelPtr := mload(0x40) // freePtr.\n            // channelPtr will point to the merkleViewPtr because the \u0027verify\u0027 function expects\n            // a pointer to the proofPtr.\n            mstore(channelPtr, merkleViewPtr)\n            // Skip 0x20 bytes length at the beginning of the initialMerkleQueue.\n            merkleQueuePtr := add(initialMerkleQueue, 0x20)\n            // Get number of queries.\n            nQueries := div(mload(initialMerkleQueue), 0x2)\n            // Get a pointer to the end of initialMerkleQueue.\n            let initialMerkleQueueEndPtr := add(merkleQueuePtr, mul(nQueries, 0x40))\n            // Let dataToHashPtr point to a free memory.\n            dataToHashPtr := add(channelPtr, 0x20) // Next freePtr.\n\n            // Copy initialMerkleQueue to dataToHashPtr and validaite the indices.\n            // The indices need to be in the range [2**height..2*(height+1)-1] and\n            // strictly incrementing.\n\n            // First index needs to be \u003e= 2**height.\n            let idxLowerLimit := shl(height, 1)\n            for { } lt(merkleQueuePtr, initialMerkleQueueEndPtr) { } {\n                let curIdx := mload(merkleQueuePtr)\n                // badInput |= curIdx \u003c IdxLowerLimit.\n                badInput := or(badInput, lt(curIdx, idxLowerLimit))\n\n                // The next idx must be at least curIdx + 1.\n                idxLowerLimit := add(curIdx, 1)\n\n                // Copy the pair (idx, hash) to the dataToHash array.\n                mstore(dataToHashPtr, curIdx)\n                mstore(add(dataToHashPtr, 0x20), mload(add(merkleQueuePtr, 0x20)))\n\n                dataToHashPtr := add(dataToHashPtr, 0x40)\n                merkleQueuePtr := add(merkleQueuePtr, 0x40)\n            }\n\n            // We need to enforce that lastIdx \u003c 2**(height+1)\n            // =\u003e fail if lastIdx \u003e= 2**(height+1)\n            // =\u003e fail if (lastIdx + 1) \u003e 2**(height+1)\n            // =\u003e fail if idxLowerLimit \u003e 2**(height+1).\n            badInput := or(badInput, gt(idxLowerLimit, shl(height, 2)))\n\n            // Reset merkleQueuePtr.\n            merkleQueuePtr := add(initialMerkleQueue, 0x20)\n            // Let freePtr point to a free memory (one word after the copied queries - reserved\n            // for the root).\n            mstore(0x40, add(dataToHashPtr, 0x20))\n        }\n        require(badInput == 0, \"INVALID_MERKLE_INDICES\");\n        bytes32 resRoot = verify(channelPtr, merkleQueuePtr, bytes32(expectedRoot), nQueries);\n        bytes32 factHash;\n        assembly {\n            // Append the resulted root (should be the return value of verify) to dataToHashPtr.\n            mstore(dataToHashPtr, resRoot)\n            // Reset dataToHashPtr.\n            dataToHashPtr := add(channelPtr, 0x20)\n            factHash := keccak256(dataToHashPtr, add(mul(nQueries, 0x40), 0x20))\n        }\n\n        registerFact(factHash);\n    }\n}\n"},"MerkleStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MerkleStatementContract.sol\";\n\ncontract MerkleStatementVerifier is IMerkleVerifier {\n    MerkleStatementContract merkleStatementContract;\n\n    constructor(address merkleStatementContractAddress) internal {\n        merkleStatementContract = MerkleStatementContract(merkleStatementContractAddress);\n    }\n\n    // Computes the hash of the Merkle statement, and verifies that it is registered in the\n    // Merkle Fact Registry. Receives as input the queuePtr (as address), its length\n    // the numbers of queries n, and the root. The channelPtr is is ignored.\n    function verify(uint256 /*channelPtr*/, uint256 queuePtr, bytes32 root, uint256 n) internal view\n        returns(bytes32) {\n        bytes32 statement;\n        require(n \u003c= MAX_N_MERKLE_VERIFIER_QUERIES, \"TOO_MANY_MERKLE_QUERIES\");\n\n        assembly {\n            let dataToHashPtrStart := mload(0x40) // freePtr.\n            let dataToHashPtrCur := dataToHashPtrStart\n\n            let queEndPtr := add(queuePtr, mul(n, 0x40))\n\n            for { } lt(queuePtr, queEndPtr) { } {\n                mstore(dataToHashPtrCur, mload(queuePtr))\n                dataToHashPtrCur := add(dataToHashPtrCur, 0x20)\n                queuePtr := add(queuePtr, 0x20)\n            }\n\n            mstore(dataToHashPtrCur, root)\n            dataToHashPtrCur := add(dataToHashPtrCur, 0x20)\n            mstore(0x40, dataToHashPtrCur)\n\n            statement := keccak256(dataToHashPtrStart, sub(dataToHashPtrCur, dataToHashPtrStart))\n        }\n        require(merkleStatementContract.isValid(statement), \"INVALIDATED_MERKLE_STATEMENT\");\n        return root;\n    }\n\n}\n"},"MerkleVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IMerkleVerifier.sol\";\n\ncontract MerkleVerifier is IMerkleVerifier {\n\n    function getHashMask() internal pure returns(uint256) {\n        // Default implementation.\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\n    }\n\n    /*\n      Verifies a Merkle tree decommitment for n leaves in a Merkle tree with N leaves.\n\n      The inputs data sits in the queue at queuePtr.\n      Each slot in the queue contains a 32 bytes leaf index and a 32 byte leaf value.\n      The indices need to be in the range [N..2*N-1] and strictly incrementing.\n      Decommitments are read from the channel in the ctx.\n\n      The input data is destroyed during verification.\n    */\n    function verify(\n        uint256 channelPtr,\n        uint256 queuePtr,\n        bytes32 root,\n        uint256 n)\n        internal view\n        returns (bytes32 hash)\n    {\n        uint256 lhashMask = getHashMask();\n        require(n \u003c= MAX_N_MERKLE_VERIFIER_QUERIES, \"TOO_MANY_MERKLE_QUERIES\");\n\n        assembly {\n            // queuePtr + i * 0x40 gives the i\u0027th index in the queue.\n            // hashesPtr + i * 0x40 gives the i\u0027th hash in the queue.\n            let hashesPtr := add(queuePtr, 0x20)\n            let queueSize := mul(n, 0x40)\n            let slotSize := 0x40\n\n            // The items are in slots [0, n-1].\n            let rdIdx := 0\n            let wrIdx := 0 // = n % n.\n\n            // Iterate the queue until we hit the root.\n            let index := mload(add(rdIdx, queuePtr))\n            let proofPtr := mload(channelPtr)\n\n            // while(index \u003e 1).\n            for { } gt(index, 1) { } {\n                let siblingIndex := xor(index, 1)\n                // sibblingOffset := 0x20 * lsb(siblingIndex).\n                let sibblingOffset := mulmod(siblingIndex, 0x20, 0x40)\n\n                // Store the hash corresponding to index in the correct slot.\n                // 0 if index is even and 0x20 if index is odd.\n                // The hash of the sibling will be written to the other slot.\n                mstore(xor(0x20, sibblingOffset), mload(add(rdIdx, hashesPtr)))\n                rdIdx := addmod(rdIdx, slotSize, queueSize)\n\n                // Inline channel operation:\n                // Assume we are going to read a new hash from the proof.\n                // If this is not the case add(proofPtr, 0x20) will be reverted.\n                let newHashPtr := proofPtr\n                proofPtr := add(proofPtr, 0x20)\n\n                // Push index/2 into the queue, before reading the next index.\n                // The order is important, as otherwise we may try to read from an empty queue (in\n                // the case where we are working on one item).\n                // wrIdx will be updated after writing the relevant hash to the queue.\n                mstore(add(wrIdx, queuePtr), div(index, 2))\n\n                // Load the next index from the queue and check if it is our sibling.\n                index := mload(add(rdIdx, queuePtr))\n                if eq(index, siblingIndex) {\n                    // Take sibling from queue rather than from proof.\n                    newHashPtr := add(rdIdx, hashesPtr)\n                    // Revert reading from proof.\n                    proofPtr := sub(proofPtr, 0x20)\n                    rdIdx := addmod(rdIdx, slotSize, queueSize)\n\n                    // Index was consumed, read the next one.\n                    // Note that the queue can\u0027t be empty at this point.\n                    // The index of the parent of the current node was already pushed into the\n                    // queue, and the parent is never the sibling.\n                    index := mload(add(rdIdx, queuePtr))\n                }\n\n                mstore(sibblingOffset, mload(newHashPtr))\n\n                // Push the new hash to the end of the queue.\n                mstore(add(wrIdx, hashesPtr), and(lhashMask, keccak256(0x00, 0x40)))\n                wrIdx := addmod(wrIdx, slotSize, queueSize)\n            }\n            hash := mload(add(rdIdx, hashesPtr))\n\n            // Update the proof pointer in the context.\n            mstore(channelPtr, proofPtr)\n        }\n        // emit LogBool(hash == root);\n        require(hash == root, \"INVALID_MERKLE_PROOF\");\n    }\n}\n"},"PrimeFieldElement0.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract PrimeFieldElement0 {\n    uint256 constant internal K_MODULUS =\n    0x800000000000011000000000000000000000000000000000000000000000001;\n    uint256 constant internal K_MODULUS_MASK =\n    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 constant internal K_MONTGOMERY_R =\n    0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1;\n    uint256 constant internal K_MONTGOMERY_R_INV =\n    0x40000000000001100000000000012100000000000000000000000000000000;\n    uint256 constant internal GENERATOR_VAL = 3;\n    uint256 constant internal ONE_VAL = 1;\n    uint256 constant internal GEN1024_VAL =\n    0x659d83946a03edd72406af6711825f5653d9e35dc125289a206c054ec89c4f1;\n\n    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {\n        // uint256 res = fmul(val, kMontgomeryRInv);\n        assembly {\n            res := mulmod(val,\n                          0x40000000000001100000000000012100000000000000000000000000000000,\n                          0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {\n        // Assuming bs is a 256bit bytes object, in Montgomery form, it is read into a field\n        // element.\n        uint256 res = uint256(bs);\n        return fromMontgomery(res);\n    }\n\n    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {\n        //uint256 res = fmul(val, kMontgomeryR);\n        assembly {\n            res := mulmod(val,\n                          0x7fffffffffffdf0ffffffffffffffffffffffffffffffffffffffffffffffe1,\n                          0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        //uint256 res = mulmod(a, b, kModulus);\n        assembly {\n            res := mulmod(a, b,\n                0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, b, kModulus);\n        assembly {\n            res := addmod(a, b,\n                0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, kModulus - b, kModulus);\n        assembly {\n            res := addmod(a, sub(0x800000000000011000000000000000000000000000000000000000000000001, b),\n                0x800000000000011000000000000000000000000000000000000000000000001)\n        }\n        return res;\n    }\n\n    function fpow(uint256 val, uint256 exp) internal returns (uint256) {\n        return expmod(val, exp, K_MODULUS);\n    }\n\n    function fpow2(uint256 val, uint256 exp) internal pure returns (uint256) {\n        uint256 curPow = val;\n        uint n = exp;\n        uint256 res = 1;\n        while (n \u003e 0) {\n            if ((n % 2) != 0) {\n                res = fmul(res, curPow);\n            }\n            n = n / 2;\n            curPow = fmul(curPow, curPow);\n        }\n        return res;\n    }\n\n    function expmod(uint256 base, uint256 exponent, uint256 modulus) internal returns (uint256 res)\n    {\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20)                  // Length of Base.\n            mstore(add(p, 0x20), 0x20)       // Length of Exponent.\n            mstore(add(p, 0x40), 0x20)       // Length of Modulus.\n            mstore(add(p, 0x60), base)       // Base.\n            mstore(add(p, 0x80), exponent)   // Exponent.\n            mstore(add(p, 0xa0), modulus)    // Modulus.\n            // Call modexp precompile.\n            if iszero(call(not(0), 0x05, 0, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function inverse(uint256 val) internal returns (uint256) {\n        return expmod(val, K_MODULUS - 2, K_MODULUS);\n    }\n}\n"},"Prng.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"PrimeFieldElement0.sol\";\n\ncontract Prng is PrimeFieldElement0 {\n    function storePrng(uint256 statePtr, bytes32 digest, uint256 counter)\n        internal pure {\n        assembly {\n            mstore(statePtr, digest)\n            mstore(add(statePtr, 0x20), counter)\n        }\n    }\n\n    function loadPrng(uint256 statePtr)\n        internal pure\n        returns (bytes32, uint256) {\n        bytes32 digest;\n        uint256 counter;\n\n        assembly {\n            digest := mload(statePtr)\n            counter := mload(add(statePtr, 0x20))\n        }\n\n        return (digest, counter);\n    }\n\n    function initPrng(uint256 prngPtr, bytes32 publicInputHash)\n        internal pure\n    {\n        storePrng(prngPtr, /*keccak256(publicInput)*/ publicInputHash, 0);\n    }\n\n    /*\n      Auxiliary function for getRandomBytes.\n    */\n    function getRandomBytesInner(bytes32 digest, uint256 counter)\n        internal pure\n        returns (bytes32, uint256, bytes32)\n    {\n        // returns 32 bytes (for random field elements or four queries at a time).\n        bytes32 randomBytes = keccak256(abi.encodePacked(digest, counter));\n\n        return (digest, counter + 1, randomBytes);\n    }\n\n    /*\n      Returns 32 bytes. Used for a random field element, or for 4 query indices.\n    */\n    function getRandomBytes(uint256 prngPtr)\n        internal pure\n        returns (bytes32 randomBytes)\n    {\n        bytes32 digest;\n        uint256 counter;\n        (digest, counter) = loadPrng(prngPtr);\n\n        // returns 32 bytes (for random field elements or four queries at a time).\n        (digest, counter, randomBytes) = getRandomBytesInner(digest, counter);\n\n        storePrng(prngPtr, digest, counter);\n        return randomBytes;\n    }\n\n    function mixSeedWithBytes(uint256 prngPtr, bytes memory dataBytes)\n        internal pure\n    {\n        bytes32 digest;\n\n        assembly {\n            digest := mload(prngPtr)\n        }\n        initPrng(prngPtr, keccak256(abi.encodePacked(digest, dataBytes)));\n    }\n\n    function getPrngDigest(uint256 prngPtr)\n        internal pure\n        returns (bytes32 digest)\n    {\n        assembly {\n           digest := mload(prngPtr)\n        }\n    }\n}\n"},"PublicInputOffsets.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract PublicInputOffsets {\n    // The following constants are offsets of data expected in the public input.\n    uint256 internal constant OFFSET_LOG_BATCH_SIZE = 0;\n    uint256 internal constant OFFSET_N_TRANSACTIONS = 1;\n    uint256 internal constant OFFSET_GLOBAL_EXPIRATION_TIMESTAMP = 2;\n    uint256 internal constant OFFSET_VAULT_INITIAL_ROOT = 3;\n    uint256 internal constant OFFSET_VAULT_FINAL_ROOT = 4;\n    uint256 internal constant OFFSET_ORDER_INITIAL_ROOT = 5;\n    uint256 internal constant OFFSET_ORDER_FINAL_ROOT = 6;\n    uint256 internal constant OFFSET_VAULT_TREE_HEIGHT = 7;\n    uint256 internal constant OFFSET_ORDER_TREE_HEIGHT = 8;\n    uint256 internal constant OFFSET_MODIFICATION_DATA = 9;\n    uint256 internal constant APPLICATION_DATA_BATCH_ID_OFFSET = 0;\n    uint256 internal constant APPLICATION_DATA_PREVIOUS_BATCH_ID_OFFSET = 1;\n    uint256 internal constant APPLICATION_DATA_N_MODIFICATIONS_OFFSET = 2;\n    uint256 internal constant APPLICATION_DATA_MODIFICATIONS_OFFSET = 3;\n\n    uint256 internal constant N_WORDS_PER_MODIFICATION = 3;\n}\n"},"StarkParameters.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\npragma solidity ^0.5.2;\n\nimport \"PrimeFieldElement0.sol\";\n\ncontract StarkParameters is PrimeFieldElement0 {\n    uint256 constant internal N_COEFFICIENTS = 360;\n    uint256 constant internal MASK_SIZE = 193;\n    uint256 constant internal N_ROWS_IN_MASK = 126;\n    uint256 constant internal N_COLUMNS_IN_MASK = 18;\n    uint256 constant internal CONSTRAINTS_DEGREE_BOUND = 2;\n    uint256 constant internal N_OODS_VALUES = MASK_SIZE + CONSTRAINTS_DEGREE_BOUND;\n    uint256 constant internal N_OODS_COEFFICIENTS = N_OODS_VALUES;\n    uint256 constant internal MAX_FRI_STEP = 3;\n\n    // ---------- // Air specific constants. ----------\n    uint256 constant internal PERIODIC_HASH_POOL_STEP = 4;\n    uint256 constant internal VAULTS_PERIODIC_MERKLE_HASH_STEP = 1;\n    uint256 constant internal SETTLEMENT_PERIODIC_MERKLE_HASH_STEP = 1;\n    uint256 constant internal ECDSA_POINTS_STEP = 128;\n    uint256 constant internal VAULTS_PATH_HEIGHT = 32;\n    uint256 constant internal SETTLEMENT_PATH_HEIGHT = 64;\n    uint256 constant internal SETTLEMENT_PATH_LENGTH = 63;\n    uint256 constant internal RANGE_CHECK_BITS = 63;\n    uint256 constant internal EXPIRATION_TIMESTAMP_RANGE_CHECK_BITS = 22;\n    uint256 constant internal NONCE_RANGE_CHECK_BITS = 31;\n}\n// ---------- End of auto-generated code. ----------\n"},"StarkVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"Fri.sol\";\nimport \"MemoryMap.sol\";\nimport \"MemoryAccessUtils.sol\";\nimport \"IStarkVerifier.sol\";\nimport \"VerifierChannel.sol\";\n\n\ncontract StarkVerifier is MemoryMap, MemoryAccessUtils, VerifierChannel, IStarkVerifier, Fri {\n    /*\n      The work required to generate an invalid proof is 2^numSecurityBits.\n      Typical values: 80-128.\n    */\n    uint256 numSecurityBits;\n\n    /*\n      The secuirty of a proof is a composition of bits obtained by PoW and bits obtained by FRI\n      queries. The verifier requires at least minProofOfWorkBits to be obtained by PoW.\n      Typical values: 20-30.\n    */\n    uint256 minProofOfWorkBits;\n\n    constructor(uint256 numSecurityBits_, uint256 minProofOfWorkBits_) public {\n        numSecurityBits = numSecurityBits_;\n        minProofOfWorkBits = minProofOfWorkBits_;\n    }\n\n    /*\n      To print LogDebug messages from assembly use code like the following:\n\n      assembly {\n            let val := 0x1234\n            mstore(0, val) // uint256 val\n            // log to the LogDebug(uint256) topic\n            log1(0, 0x20, 0x2feb477e5c8c82cfb95c787ed434e820b1a28fa84d68bbf5aba5367382f5581c)\n      }\n\n      Note that you can\u0027t use log in a contract that was called with staticcall\n      (ContraintPoly, Oods,...)\n\n      If logging is needed replace the staticcall to call and add a third argument of 0.\n    */\n    event LogBool(bool val);\n    event LogDebug(uint256 val);\n    address oodsContractAddress;\n\n    function airSpecificInit(uint256[] memory publicInput)\n        internal returns (uint256[] memory ctx, uint256 logTraceLength);\n\n    uint256 constant internal PROOF_PARAMS_N_QUERIES_OFFSET = 0;\n    uint256 constant internal PROOF_PARAMS_LOG_BLOWUP_FACTOR_OFFSET = 1;\n    uint256 constant internal PROOF_PARAMS_PROOF_OF_WORK_BITS_OFFSET = 2;\n    uint256 constant internal PROOF_PARAMS_FRI_LAST_LAYER_DEG_BOUND_OFFSET = 3;\n    uint256 constant internal PROOF_PARAMS_N_FRI_STEPS_OFFSET = 4;\n    uint256 constant internal PROOF_PARAMS_FRI_STEPS_OFFSET = 5;\n\n    function validateFriParams(\n        uint256[] memory friSteps, uint256 logTraceLength, uint256 logFriLastLayerDegBound)\n        internal pure {\n        require (friSteps[0] == 0, \"Only eta0 == 0 is currently supported\");\n\n        uint256 expectedLogDegBound = logFriLastLayerDegBound;\n        uint256 nFriSteps = friSteps.length;\n        for (uint256 i = 1; i \u003c nFriSteps; i++) {\n            uint256 friStep = friSteps[i];\n            require(friStep \u003e 0, \"Only the first fri step can be 0\");\n            require(friStep \u003c= 4, \"Max supported fri step is 4.\");\n            expectedLogDegBound += friStep;\n        }\n\n        // FRI starts with a polynomial of degree \u0027traceLength\u0027.\n        // After applying all the FRI steps we expect to get a polynomial of degree less\n        // than friLastLayerDegBound.\n        require (\n            expectedLogDegBound == logTraceLength, \"Fri params do not match trace length\");\n    }\n\n    function initVerifierParams(uint256[] memory publicInput, uint256[] memory proofParams)\n        internal returns (uint256[] memory ctx) {\n        require (proofParams.length \u003e PROOF_PARAMS_FRI_STEPS_OFFSET, \"Invalid proofParams.\");\n        require (\n            proofParams.length == (\n                PROOF_PARAMS_FRI_STEPS_OFFSET + proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET]),\n            \"Invalid proofParams.\");\n        uint256 logBlowupFactor = proofParams[PROOF_PARAMS_LOG_BLOWUP_FACTOR_OFFSET];\n        require (logBlowupFactor \u003c= 16, \"logBlowupFactor must be at most 16\");\n        require (logBlowupFactor \u003e= 1, \"logBlowupFactor must be at least 1\");\n\n        uint256 proofOfWorkBits = proofParams[PROOF_PARAMS_PROOF_OF_WORK_BITS_OFFSET];\n        require (proofOfWorkBits \u003c= 50, \"proofOfWorkBits must be at most 50\");\n        require (proofOfWorkBits \u003e= minProofOfWorkBits, \"minimum proofOfWorkBits not satisfied\");\n        require (proofOfWorkBits \u003c numSecurityBits, \"Proofs may not be purely based on PoW.\");\n\n        uint256 logFriLastLayerDegBound = (\n            proofParams[PROOF_PARAMS_FRI_LAST_LAYER_DEG_BOUND_OFFSET]\n        );\n        require (\n            logFriLastLayerDegBound \u003c= 10, \"logFriLastLayerDegBound must be at most 10.\");\n\n        uint256 nFriSteps = proofParams[PROOF_PARAMS_N_FRI_STEPS_OFFSET];\n        require (nFriSteps \u003c= 10, \"Too many fri steps.\");\n        require (nFriSteps \u003e 1, \"Not enough fri steps.\");\n\n        uint256[] memory friSteps = new uint256[](nFriSteps);\n        for (uint256 i = 0; i \u003c nFriSteps; i++) {\n            friSteps[i] = proofParams[PROOF_PARAMS_FRI_STEPS_OFFSET + i];\n        }\n\n        uint256 logTraceLength;\n        (ctx, logTraceLength) = airSpecificInit(publicInput);\n\n        validateFriParams(friSteps, logTraceLength, logFriLastLayerDegBound);\n\n        uint256 friStepsPtr = getPtr(ctx, MM_FRI_STEPS_PTR);\n        assembly {\n            mstore(friStepsPtr, friSteps)\n        }\n        ctx[MM_FRI_LAST_LAYER_DEG_BOUND] = 2**logFriLastLayerDegBound;\n        ctx[MM_TRACE_LENGTH] = 2 ** logTraceLength;\n\n        ctx[MM_BLOW_UP_FACTOR] = 2**logBlowupFactor;\n        ctx[MM_PROOF_OF_WORK_BITS] = proofOfWorkBits;\n\n        uint256 nQueries = proofParams[PROOF_PARAMS_N_QUERIES_OFFSET];\n        require (nQueries \u003e 0, \"Number of queries must be at least one\");\n        require (nQueries \u003c= MAX_N_QUERIES, \"Too many queries.\");\n        require (\n            nQueries * logBlowupFactor + proofOfWorkBits \u003e= numSecurityBits,\n            \"Proof params do not satisfy security requirements.\");\n\n        ctx[MM_N_UNIQUE_QUERIES] = nQueries;\n\n        // We start with log_evalDomainSize = logTraceSize and update it here.\n        ctx[MM_LOG_EVAL_DOMAIN_SIZE] = logTraceLength + logBlowupFactor;\n        ctx[MM_EVAL_DOMAIN_SIZE] = 2**ctx[MM_LOG_EVAL_DOMAIN_SIZE];\n\n        uint256 gen_evalDomain = fpow(GENERATOR_VAL, (K_MODULUS - 1) / ctx[MM_EVAL_DOMAIN_SIZE]);\n        ctx[MM_EVAL_DOMAIN_GENERATOR] = gen_evalDomain;\n        uint256 genTraceDomain = fpow(gen_evalDomain, ctx[MM_BLOW_UP_FACTOR]);\n        ctx[MM_TRACE_GENERATOR] = genTraceDomain;\n    }\n\n    function getPublicInputHash(uint256[] memory publicInput) internal pure returns (bytes32);\n\n    function oodsConsistencyCheck(uint256[] memory ctx) internal;\n\n    function getNColumnsInTrace() internal pure returns(uint256);\n\n    function getNColumnsInComposition() internal pure returns(uint256);\n\n    function getMmCoefficients() internal pure returns(uint256);\n\n    function getMmOodsValues() internal pure returns(uint256);\n\n    function getMmOodsCoefficients() internal pure returns(uint256);\n\n    function getNCoefficients() internal pure returns(uint256);\n\n    function getNOodsValues() internal pure returns(uint256);\n\n    function getNOodsCoefficients() internal pure returns(uint256);\n\n    function hashRow(uint256[] memory ctx, uint256 offset, uint256 length)\n    internal pure returns (uint256 res) {\n        assembly {\n            res := keccak256(add(add(ctx, 0x20), offset), length)\n        }\n        res \u0026= getHashMask();\n    }\n\n    /*\n      Adjusts the query indices and generates evaluation points for each query index.\n      The operations above are independent but we can save gas by combining them as both\n      operations require us to iterate the queries array.\n\n      Indices adjustment:\n          The query indices adjustment is needed because both the Merkle verification and FRI\n          expect queries \"full binary tree in array\" indices.\n          The adjustment is simply adding evalDomainSize to each query.\n          Note that evalDomainSize == 2^(#FRI layers) == 2^(Merkle tree hight).\n\n      evalPoints generation:\n          for each query index \"idx\" we compute the corresponding evaluation point:\n              g^(bitReverse(idx, log_evalDomainSize).\n    */\n    function adjustQueryIndicesAndPrepareEvalPoints(uint256[] memory ctx) internal {\n        uint256 nUniqueQueries = ctx[MM_N_UNIQUE_QUERIES];\n        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);\n        uint256 friQueueEnd = friQueue + nUniqueQueries * 0x60;\n        uint256 evalPointsPtr = getPtr(ctx, MM_OODS_EVAL_POINTS);\n        uint256 log_evalDomainSize = ctx[MM_LOG_EVAL_DOMAIN_SIZE];\n        uint256 evalDomainSize = ctx[MM_EVAL_DOMAIN_SIZE];\n        uint256 evalDomainGenerator = ctx[MM_EVAL_DOMAIN_GENERATOR];\n\n        assembly {\n            /*\n              Returns the bit reversal of value assuming it has the given number of bits.\n              numberOfBits must be \u003c= 64.\n            */\n            function bitReverse(value, numberOfBits) -\u003e res {\n                // Bit reverse value by swapping 1 bit chunks then 2 bit chunks and so forth.\n                // Each swap is done by masking out and shifting one of the chunks by twice its size.\n                // Finally, we use div to align the result to the right.\n                res := value\n                // Swap 1 bit chunks.\n                res := or(mul(and(res, 0x5555555555555555), 0x4),\n                        and(res, 0xaaaaaaaaaaaaaaaa))\n                // Swap 2 bit chunks.\n                res := or(mul(and(res, 0x6666666666666666), 0x10),\n                        and(res, 0x19999999999999998))\n                // Swap 4 bit chunks.\n                res := or(mul(and(res, 0x7878787878787878), 0x100),\n                        and(res, 0x78787878787878780))\n                // Swap 8 bit chunks.\n                res := or(mul(and(res, 0x7f807f807f807f80), 0x10000),\n                        and(res, 0x7f807f807f807f8000))\n                // Swap 16 bit chunks.\n                res := or(mul(and(res, 0x7fff80007fff8000), 0x100000000),\n                        and(res, 0x7fff80007fff80000000))\n                // Swap 32 bit chunks.\n                res := or(mul(and(res, 0x7fffffff80000000), 0x10000000000000000),\n                        and(res, 0x7fffffff8000000000000000))\n                // Right align the result.\n                res := div(res, exp(2, sub(127, numberOfBits)))\n            }\n\n            function expmod(base, exponent, modulus) -\u003e res {\n                let p := mload(0x40)\n                mstore(p, 0x20)                 // Length of Base.\n                mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n                mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n                mstore(add(p, 0x60), base)      // Base.\n                mstore(add(p, 0x80), exponent)  // Exponent.\n                mstore(add(p, 0xa0), modulus)   // Modulus.\n                // Call modexp precompile.\n                if iszero(call(not(0), 0x05, 0, p, 0xc0, p, 0x20)) {\n                    revert(0, 0)\n                }\n                res := mload(p)\n            }\n\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {\n                let queryIdx := mload(friQueue)\n                // Adjust queryIdx, see comment in function description.\n                let adjustedQueryIdx := add(queryIdx, evalDomainSize)\n                mstore(friQueue, adjustedQueryIdx)\n\n                // Compute the evaluation point corresponding to the current queryIdx.\n                mstore(evalPointsPtr, expmod(evalDomainGenerator,\n                                             bitReverse(queryIdx, log_evalDomainSize),\n                                             PRIME))\n                evalPointsPtr := add(evalPointsPtr, 0x20)\n            }\n        }\n    }\n\n    function readQueryResponsesAndDecommit(\n        uint256[] memory ctx, uint256 nColumns, uint256 proofDataPtr, bytes32 merkleRoot)\n         internal view {\n        require(nColumns \u003c= getNColumnsInTrace() + getNColumnsInComposition(), \"Too many columns.\");\n\n        uint256 nUniqueQueries = ctx[MM_N_UNIQUE_QUERIES];\n        uint256 channelPtr = getPtr(ctx, MM_CHANNEL);\n        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);\n        uint256 friQueueEnd = friQueue + nUniqueQueries * 0x60;\n        uint256 merkleQueuePtr = getPtr(ctx, MM_MERKLE_QUEUE);\n        uint256 rowSize = 0x20 * nColumns;\n        uint256 lhashMask = getHashMask();\n\n        assembly {\n            let proofPtr := mload(channelPtr)\n            let merklePtr := merkleQueuePtr\n\n            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {\n                let merkleLeaf := and(keccak256(proofPtr, rowSize), lhashMask)\n                if eq(rowSize, 0x20) {\n                    // If a leaf contains only 1 field element we don\u0027t hash it.\n                    merkleLeaf := mload(proofPtr)\n                }\n\n                // push(queryIdx, hash(row)) to merkleQueue.\n                mstore(merklePtr, mload(friQueue))\n                mstore(add(merklePtr, 0x20), merkleLeaf)\n                merklePtr := add(merklePtr, 0x40)\n\n                // Copy query responses to proofData array.\n                // This array will be sent to the OODS contract.\n                for {let proofDataChunk_end := add(proofPtr, rowSize)}\n                        lt(proofPtr, proofDataChunk_end)\n                        {proofPtr := add(proofPtr, 0x20)} {\n                    mstore(proofDataPtr, mload(proofPtr))\n                    proofDataPtr := add(proofDataPtr, 0x20)\n                }\n            }\n\n            mstore(channelPtr, proofPtr)\n        }\n\n        verify(channelPtr, merkleQueuePtr, merkleRoot, nUniqueQueries);\n    }\n\n    /*\n      Computes the first FRI layer by reading the query responses and calling\n      the OODS contract.\n\n      The OODS contract will build and sum boundary constraints that check that\n      the prover provided the proper evaluations for the Out of Domain Sampling.\n\n      I.e. if the prover said that f(z) = c, the first FRI layer will include\n      the term (f(x) - c)/(x-z).\n    */\n    function computeFirstFriLayer(uint256[] memory ctx) internal {\n        adjustQueryIndicesAndPrepareEvalPoints(ctx);\n        // emit LogGas(\"Prepare evaluation points\", gasleft());\n        readQueryResponsesAndDecommit(\n            ctx, getNColumnsInTrace(), getPtr(ctx, MM_TRACE_QUERY_RESPONSES),\n            bytes32(ctx[MM_TRACE_COMMITMENT]));\n        // emit LogGas(\"Read and decommit trace\", gasleft());\n\n        readQueryResponsesAndDecommit(\n            ctx, getNColumnsInComposition(), getPtr(ctx, MM_COMPOSITION_QUERY_RESPONSES),\n            bytes32(ctx[MM_OODS_COMMITMENT]));\n\n        // emit LogGas(\"Read and decommit composition\", gasleft());\n\n        address oodsAddress = oodsContractAddress;\n        uint256 friQueue = getPtr(ctx, MM_FRI_QUEUE);\n        uint256 returnDataSize = MAX_N_QUERIES * 0x60;\n        assembly {\n            // Call the OODS contract.\n            if iszero(staticcall(not(0), oodsAddress, ctx,\n                                 /*sizeof(ctx)*/ mul(add(mload(ctx), 1), 0x20),\n                                 friQueue, returnDataSize)) {\n              returndatacopy(0, 0, returndatasize)\n              revert(0, returndatasize)\n            }\n        }\n        // emit LogGas(\"OODS virtual oracle\", gasleft());\n    }\n\n    /*\n      Reads the last FRI layer (i.e. the polynomial\u0027s coefficients) from the channel.\n      This differs from standard reading of channel field elements in several ways:\n      -- The digest is updated by hashing it once with all coefficients simultaneously, rather than\n         iteratively one by one.\n      -- The coefficients are kept in Montgomery form, as is the case throughout the FRI\n         computation.\n      -- The coefficients are not actually read and copied elsewhere, but rather only a pointer to\n         their location in the channel is stored.\n    */\n    function readLastFriLayer(uint256[] memory ctx)\n        internal pure\n    {\n        uint256 lmmChannel = MM_CHANNEL;\n        uint256 friLastLayerDegBound = ctx[MM_FRI_LAST_LAYER_DEG_BOUND];\n        uint256 lastLayerPtr;\n        uint256 badInput = 0;\n\n        assembly {\n            let primeMinusOne := 0x800000000000011000000000000000000000000000000000000000000000000\n            let channelPtr := add(add(ctx, 0x20), mul(lmmChannel, 0x20))\n            lastLayerPtr := mload(channelPtr)\n\n            // Make sure all the values are valid field elements.\n            let length := mul(friLastLayerDegBound, 0x20)\n            let lastLayerEnd := add(lastLayerPtr, length)\n            for { let coefsPtr := lastLayerPtr } lt(coefsPtr, lastLayerEnd)\n                { coefsPtr := add(coefsPtr, 0x20) } {\n                badInput := or(badInput, gt(mload(coefsPtr), primeMinusOne))\n            }\n\n            // Copy the digest to the proof area\n            // (store it before the coefficients - this is done because\n            // keccak256 needs all data to be consecutive),\n            // then hash and place back in digestPtr.\n            let newDigestPtr := sub(lastLayerPtr, 0x20)\n            let digestPtr := add(channelPtr, 0x20)\n            // Overwriting the proof to minimize copying of data.\n            mstore(newDigestPtr, mload(digestPtr))\n\n            // prng.digest := keccak256(digest||lastLayerCoefs).\n            mstore(digestPtr, keccak256(newDigestPtr, add(length, 0x20)))\n            // prng.counter := 0.\n            mstore(add(channelPtr, 0x40), 0)\n\n            // Note: proof pointer is not incremented until this point.\n            mstore(channelPtr, lastLayerEnd)\n        }\n\n        require(badInput == 0, \"Invalid field element.\");\n        ctx[MM_FRI_LAST_LAYER_PTR] = lastLayerPtr;\n    }\n\n    function verifyProof(\n        uint256[] memory proofParams, uint256[] memory proof, uint256[] memory publicInput)\n        internal {\n        // emit LogGas(\"Transmission\", gasleft());\n        uint256[] memory ctx = initVerifierParams(publicInput, proofParams);\n        uint256 channelPtr = getChannelPtr(ctx);\n\n        initChannel(channelPtr,  getProofPtr(proof), getPublicInputHash(publicInput));\n        // emit LogGas(\"Initializations\", gasleft());\n\n        // Read trace commitment.\n        ctx[MM_TRACE_COMMITMENT] = uint256(readHash(channelPtr, true));\n        VerifierChannel.sendFieldElements(\n            channelPtr, getNCoefficients(), getPtr(ctx, getMmCoefficients()));\n        // emit LogGas(\"Generate coefficients\", gasleft());\n\n        ctx[MM_OODS_COMMITMENT] = uint256(readHash(channelPtr, true));\n\n        // Send Out of Domain Sampling point.\n        VerifierChannel.sendFieldElements(channelPtr, 1, getPtr(ctx, MM_OODS_POINT));\n\n        // Read the answers to the Out of Domain Sampling.\n        uint256 lmmOodsValues = getMmOodsValues();\n        for (uint256 i = lmmOodsValues; i \u003c lmmOodsValues+getNOodsValues(); i++) {\n            ctx[i] = VerifierChannel.readFieldElement(channelPtr, true);\n        }\n        // emit LogGas(\"Read OODS commitments\", gasleft());\n        oodsConsistencyCheck(ctx);\n        // emit LogGas(\"OODS consistency check\", gasleft());\n        VerifierChannel.sendFieldElements(\n            channelPtr, getNOodsCoefficients(), getPtr(ctx, getMmOodsCoefficients()));\n        // emit LogGas(\"Generate OODS coefficients\", gasleft());\n        ctx[MM_FRI_COMMITMENTS] = uint256(VerifierChannel.readHash(channelPtr, true));\n\n        uint256 nFriSteps = getFriSteps(ctx).length;\n        uint256 fri_evalPointPtr = getPtr(ctx, MM_FRI_EVAL_POINTS);\n        for (uint256 i = 1; i \u003c nFriSteps - 1; i++) {\n            VerifierChannel.sendFieldElements(channelPtr, 1, fri_evalPointPtr + i * 0x20);\n            ctx[MM_FRI_COMMITMENTS + i] = uint256(VerifierChannel.readHash(channelPtr, true));\n        }\n\n        // Send last random FRI evaluation point.\n        VerifierChannel.sendFieldElements(\n            channelPtr, 1, getPtr(ctx, MM_FRI_EVAL_POINTS + nFriSteps - 1));\n\n        // Read FRI last layer commitment.\n        readLastFriLayer(ctx);\n\n        // Generate queries.\n        // emit LogGas(\"Read FRI commitments\", gasleft());\n        VerifierChannel.verifyProofOfWork(channelPtr, ctx[MM_PROOF_OF_WORK_BITS]);\n        ctx[MM_N_UNIQUE_QUERIES] = VerifierChannel.sendRandomQueries(\n            channelPtr, ctx[MM_N_UNIQUE_QUERIES], ctx[MM_EVAL_DOMAIN_SIZE] - 1,\n            getPtr(ctx, MM_FRI_QUEUE), 0x60);\n        // emit LogGas(\"Send queries\", gasleft());\n\n        computeFirstFriLayer(ctx);\n\n        friVerifyLayers(ctx);\n    }\n}\n"},"VerifierChannel.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"Prng.sol\";\n\ncontract VerifierChannel is Prng {\n\n    /*\n      We store the state of the channel in uint256[3] as follows:\n        [0] proof pointer.\n        [1] prng digest.\n        [2] prng counter.\n    */\n    uint256 constant internal CHANNEL_STATE_SIZE = 3;\n\n    event LogValue(bytes32 val);\n\n    event SendRandomnessEvent(uint256 val);\n\n    event ReadFieldElementEvent(uint256 val);\n\n    event ReadHashEvent(bytes32 val);\n\n    function getPrngPtr(uint256 channelPtr)\n        internal pure\n        returns (uint256)\n    {\n        return channelPtr + 0x20;\n    }\n\n    function initChannel(uint256 channelPtr, uint256 proofPtr, bytes32 publicInputHash)\n        internal pure\n    {\n        assembly {\n            // Skip 0x20 bytes length at the beginning of the proof.\n            mstore(channelPtr, add(proofPtr, 0x20))\n        }\n\n        initPrng(getPrngPtr(channelPtr), publicInputHash);\n    }\n\n    function sendFieldElements(uint256 channelPtr, uint256 nElements, uint256 targetPtr)\n        internal pure\n    {\n        require(nElements \u003c 0x1000000, \"Overflow protection failed.\");\n        assembly {\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n            let PRIME_MON_R_INV := 0x40000000000001100000000000012100000000000000000000000000000000\n            let PRIME_MASK := 0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n            let digestPtr := add(channelPtr, 0x20)\n            let counterPtr := add(channelPtr, 0x40)\n\n            let endPtr := add(targetPtr, mul(nElements, 0x20))\n            for { } lt(targetPtr, endPtr) { targetPtr := add(targetPtr, 0x20) } {\n                // *targetPtr = getRandomFieldElement(getPrngPtr(channelPtr));\n\n                let fieldElement := PRIME\n                // while (fieldElement \u003e= PRIME).\n                for { } iszero(lt(fieldElement, PRIME)) { } {\n                    // keccak256(abi.encodePacked(digest, counter));\n                    fieldElement := and(keccak256(digestPtr, 0x40), PRIME_MASK)\n                    // *counterPtr += 1;\n                    mstore(counterPtr, add(mload(counterPtr), 1))\n                }\n                // *targetPtr = fromMontgomery(fieldElement);\n                mstore(targetPtr, mulmod(fieldElement, PRIME_MON_R_INV, PRIME))\n                // emit ReadFieldElementEvent(fieldElement);\n                // log1(targetPtr, 0x20, 0x4bfcc54f35095697be2d635fb0706801e13637312eff0cedcdfc254b3b8c385e);\n            }\n        }\n    }\n\n    /*\n      Sends random queries and returns an array of queries sorted in ascending order.\n      Generates count queries in the range [0, mask] and returns the number of unique queries.\n      Note that mask is of the form 2^k-1 (for some k).\n\n      Note that queriesOutPtr may be (and is) inteleaved with other arrays. The stride parameter\n      is passed to indicate the distance between every two entries to the queries array, i.e.\n      stride = 0x20*(number of interleaved arrays).\n    */\n    function sendRandomQueries(\n        uint256 channelPtr, uint256 count, uint256 mask, uint256 queriesOutPtr, uint256 stride)\n        internal pure returns (uint256)\n    {\n        uint256 val;\n        uint256 shift = 0;\n        uint256 endPtr = queriesOutPtr;\n        for (uint256 i = 0; i \u003c count; i++) {\n            if (shift == 0) {\n                val = uint256(getRandomBytes(getPrngPtr(channelPtr)));\n                shift = 0x100;\n            }\n            shift -= 0x40;\n            uint256 queryIdx = (val \u003e\u003e shift) \u0026 mask;\n            // emit sendRandomnessEvent(queryIdx);\n\n            uint256 ptr = endPtr;\n            uint256 curr;\n            // Insert new queryIdx in the correct place like insertion sort.\n\n            while (ptr \u003e queriesOutPtr) {\n                assembly {\n                    curr := mload(sub(ptr, stride))\n                }\n\n                if (queryIdx \u003e= curr) {\n                    break;\n                }\n\n                assembly {\n                    mstore(ptr, curr)\n                }\n                ptr -= stride;\n            }\n\n            if (queryIdx != curr) {\n                assembly {\n                    mstore(ptr, queryIdx)\n                }\n                endPtr += stride;\n            } else {\n                // Revert right shuffling.\n                while (ptr \u003c endPtr) {\n                    assembly {\n                        mstore(ptr, mload(add(ptr, stride)))\n                        ptr := add(ptr, stride)\n                    }\n                }\n            }\n        }\n\n        return (endPtr - queriesOutPtr) / stride;\n    }\n\n    function readBytes(uint256 channelPtr, bool mix)\n        internal pure\n        returns (bytes32)\n    {\n        uint256 proofPtr;\n        bytes32 val;\n\n        assembly {\n            proofPtr := mload(channelPtr)\n            val := mload(proofPtr)\n            mstore(channelPtr, add(proofPtr, 0x20))\n        }\n        if (mix) {\n            // inline: Prng.mixSeedWithBytes(getPrngPtr(channelPtr), abi.encodePacked(val));\n            assembly {\n                let digestPtr := add(channelPtr, 0x20)\n                let counterPtr := add(digestPtr, 0x20)\n                mstore(counterPtr, val)\n                // prng.digest := keccak256(digest||val), nonce was written earlier.\n                mstore(digestPtr, keccak256(digestPtr, 0x40))\n                // prng.counter := 0.\n                mstore(counterPtr, 0)\n            }\n        }\n\n        return val;\n    }\n\n    function readHash(uint256 channelPtr, bool mix)\n        internal pure\n        returns (bytes32)\n    {\n        bytes32 val = readBytes(channelPtr, mix);\n        // emit ReadHashEvent(val);\n\n        return val;\n    }\n\n    function readFieldElement(uint256 channelPtr, bool mix)\n        internal pure returns (uint256) {\n        uint256 val = fromMontgomery(uint256(readBytes(channelPtr, mix)));\n        // emit ReadFieldElementEvent(val);\n\n        return val;\n    }\n\n    function verifyProofOfWork(uint256 channelPtr, uint256 proofOfWorkBits) internal pure {\n        if (proofOfWorkBits == 0) {\n            return;\n        }\n\n        uint256 proofOfWorkDigest;\n        assembly {\n            // [0:29] := 0123456789abcded || digest || workBits.\n            mstore(0, 0x0123456789abcded000000000000000000000000000000000000000000000000)\n            let digest := mload(add(channelPtr, 0x20))\n            mstore(0x8, digest)\n            mstore8(0x28, proofOfWorkBits)\n            mstore(0, keccak256(0, 0x29))\n\n            let proofPtr := mload(channelPtr)\n            mstore(0x20, mload(proofPtr))\n            // proofOfWorkDigest:= keccak256(keccak256(0123456789abcded || digest || workBits) || nonce).\n            proofOfWorkDigest := keccak256(0, 0x28)\n\n            mstore(0, digest)\n            // prng.digest := keccak256(digest||nonce), nonce was written earlier.\n            mstore(add(channelPtr, 0x20), keccak256(0, 0x28))\n            // prng.counter := 0.\n            mstore(add(channelPtr, 0x40), 0)\n\n            mstore(channelPtr, add(proofPtr, 0x8))\n        }\n\n        uint256 proofOfWorkThreshold = uint256(1) \u003c\u003c (256 - proofOfWorkBits);\n        require(proofOfWorkDigest \u003c proofOfWorkThreshold, \"Proof of work check failed.\");\n    }\n}\n"}}