{"ERC20Interface.sol":{"content":"pragma solidity ^0.5.8;\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n"},"ERC20Swap.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./Swap.sol\";\nimport \"./ERC20Interface.sol\";\n\ncontract ERC20Swap is Swap {\n    enum OrderState { HasFundingBalance, Claimed, Refunded }\n\n    struct SwapOrder {\n        address user;\n        address tokenContractAddress;\n        bytes32 paymentHash;\n        bytes32 preimage;\n        uint onchainAmount;\n        uint refundBlockHeight;\n        OrderState state;\n        bool exist;\n    }\n\n    mapping(bytes16 =\u003e SwapOrder) orders;\n\n    event OrderErc20FundingReceived(\n        bytes16 orderUUID,\n        uint onchainAmount,\n        bytes32 paymentHash,\n        uint refundBlockHeight,\n        address tokenContractAddress\n    );\n    event OrderErc20Claimed(bytes16 orderUUID);\n    event OrderErc20Refunded(bytes16 orderUUID);\n\n    /**\n     * Allow the sender to fund a swap in one or more transactions.\n     */\n    function fund(bytes16 orderUUID, bytes32 paymentHash, address tokenContractAddress, uint tokenAmount) external {\n        SwapOrder storage order = orders[orderUUID];\n\n        if (!order.exist) {\n            order.user = msg.sender;\n            order.tokenContractAddress = tokenContractAddress;\n            order.exist = true;\n            order.paymentHash = paymentHash;\n            order.refundBlockHeight = block.number + refundDelay;\n            order.state = OrderState.HasFundingBalance;\n            order.onchainAmount = 0;\n        } else {\n            require(order.state == OrderState.HasFundingBalance, \"Order already claimed or refunded.\");\n        }\n\n        // one token type per order\n        require(order.tokenContractAddress == tokenContractAddress, \"Incorrect token.\");\n        // fund token to this contract\n        require(ERC20Interface(tokenContractAddress).transferFrom(msg.sender, address(this), tokenAmount), \"Unable to transfer token.\");\n\n        order.onchainAmount += tokenAmount;\n\n        emit OrderErc20FundingReceived(\n            orderUUID,\n            order.onchainAmount,\n            order.paymentHash,\n            order.refundBlockHeight,\n            order.tokenContractAddress\n        );\n    }\n\n    /**\n     * Allow the recipient to claim the funds once they know the preimage of the hashlock.\n     * Anyone can claim but tokens only send to owner.\n     */\n    function claim(bytes16 orderUUID, address tokenContractAddress, bytes32 preimage) external {\n        SwapOrder storage order = orders[orderUUID];\n\n        require(order.exist == true, \"Order does not exist.\");\n        require(order.state == OrderState.HasFundingBalance, \"Order cannot be claimed.\");\n        require(sha256(abi.encodePacked(preimage)) == order.paymentHash, \"Incorrect payment preimage.\");\n        require(block.number \u003c= order.refundBlockHeight, \"Too late to claim.\");\n\n        order.preimage = preimage;\n        // transfer token to owner\n        ERC20Interface(tokenContractAddress).transfer(owner, order.onchainAmount);\n        order.state = OrderState.Claimed;\n\n        emit OrderErc20Claimed(orderUUID);\n    }\n\n    /**\n     * Refund the sent token amount back to the funder if the timelock has expired.\n     */\n    function refund(bytes16 orderUUID, address tokenContractAddress) external {\n        SwapOrder storage order = orders[orderUUID];\n\n        require(order.exist == true, \"Order does not exist.\");\n        require(order.state == OrderState.HasFundingBalance, \"Order cannot be refunded.\");\n        require(block.number \u003e order.refundBlockHeight, \"Too early to refund.\");\n\n        // transfer token to recepient\n        ERC20Interface(tokenContractAddress).transfer(order.user, order.onchainAmount);\n        order.state = OrderState.Refunded;\n\n        emit OrderErc20Refunded(orderUUID);\n    }\n}\n"},"Owned.sol":{"content":"pragma solidity ^0.5.8;\n\ncontract Owned {\n    constructor() public { owner = msg.sender; }\n    address payable public owner;\n\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n}\n"},"Swap.sol":{"content":"pragma solidity ^0.5.8;\n\nimport \"./Owned.sol\";\n\ncontract Swap is Owned {\n    // Refund delay. Default: 4 hours\n    uint public refundDelay = 4 * 60 * 4;\n\n    // Max possible refund delay: 5 days\n    uint constant MAX_REFUND_DELAY = 60 * 60 * 2 * 4;\n\n    /**\n     * Set the block height at which a refund will successfully process.\n     */\n    function setRefundDelay(uint delay) external onlyOwner {\n        require(delay \u003c= MAX_REFUND_DELAY, \"Delay is too large.\");\n        refundDelay = delay;\n    }\n}\n"}}