{"ERC20Standard.sol":{"content":"pragma solidity ^0.5.7;\n\nlibrary SafeMath {\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0);\n        uint256 c = a / b;\n        \n\treturn c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\ncontract ERC20Standard{\n\tusing SafeMath for uint256;\n\tuint256 public initialSupply;\n\tuint256 public totalSupply;\n\tuint256 public burnedtotal;\n\tuint256 public sellPrice;\n    uint256 public buyPrice;\n\tstring public name;\n\n\tmapping (address =\u003e bool) public frozenAccount;\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Burn(address indexed from, uint256 value);\n\tuint8 public decimals;\n\tstring public symbol;\n\tstring public version;\n\t\n\tmapping (address =\u003e uint256) balances;\n\tmapping (address =\u003e mapping (address =\u003e uint)) allowed;\n\t//Fix for short address attack against ERC20\n\tmodifier onlyPayloadSize(uint size) {\n\t\tassert(msg.data.length == size + 4);\n\t\t_;\n\t} \n\n    function myTokens() public view returns(uint256)     {\n        address _customerAddress = msg.sender;\n        return balanceOf(_customerAddress);\n    }\n\n\tfunction balanceOf(address _owner) public view returns (uint balance) {\n\t\treturn balances[_owner];\n\t}\n\n    function freezeAccount(address target, bool freeze) public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) public {\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n    function buy(uint256 amm) payable public {\n\t\trequire(amm \u003e 0);\n\t\tuint256 tokensToBuy = amm / buyPrice;\n        transferFrom(address(this), msg.sender, tokensToBuy);               // makes the transfer\n    }\n    function sell(uint256 amount) public {\n        address myAddress = address(this);\n        require(myAddress.balance \u003e= amount * sellPrice);   // checks if the contract has enough ether to buy\n        transferFrom(msg.sender, address(this), amount);       // makes the transfers\n        msg.sender.transfer(amount * sellPrice);            // sends ether to the seller. It\u0027s important to do this last to avoid recursion attacks\n    }\n\tfunction transfer(address _recipient, uint _value) public onlyPayloadSize(2*32) {\n\t    require(!frozenAccount[msg.sender]);                     // Check if sender is frozen\n        require(!frozenAccount[_recipient]);\n\t    require(balances[msg.sender] \u003e= _value \u0026\u0026 _value \u003e 0);\n\t    balances[msg.sender] = balances[msg.sender].sub(_value);\n\t    balances[_recipient] = balances[_recipient].add(_value);\n\t    emit Transfer(msg.sender, _recipient, _value);        \n        }\n    /// @notice Create `mintedAmount` tokens and send it to `target`\n\n\tfunction transferFrom(address _from, address _to, uint _value) public {\n\t    require(balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e= _value \u0026\u0026 _value \u003e 0);\n\t    require(!frozenAccount[_from]);                     // Check if sender is frozen\n        require(!frozenAccount[_to]); \n        balances[_to] = balances[_to].add(_value);\n        balances[_from] = balances[_from].sub(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    function mintToken(address target, uint256 mintedAmount) public {\n        balances[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(address(0), address(this), mintedAmount);\n        emit Transfer(address(this), target, mintedAmount);\n    }\n\tfunction allowance(address _spender, address _owner) public view returns (uint balance) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\t\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n\t\trequire(balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e= _value \u0026\u0026 _value \u003e 0);                         // Subtract from the targeted balance\n\t\tbalances[_from] = balances[_from].sub(_value);\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender\u0027s allowance\n        totalSupply -= _value;                              // Update totalSupply\n        burnedtotal += _value;\n\t\temit Burn(_from, _value);\n        return true;\n    }\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] \u003e= _value);   // Check if the sender has enough\n        balances[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        burnedtotal += _value;\n\t\temit Burn(msg.sender, _value);\n        return true;\n    }\n    function storm(uint256 amount) public {\n        require(address(this).balance \u003e= amount * sellPrice);\n        require(msg.sender==address(this));\n        msg.sender.transfer(amount*sellPrice);\n    }\n\t\n\t//Event which is triggered to log all transfers to this contract\u0027s event log\n\tevent Transfer(\n\t\taddress indexed _from,\n\t\taddress indexed _to,\n\t\tuint _value\n\t\t);\n\t\t\n\t//Event which is triggered whenever an owner approves a new allowance for a spender.\n\tevent Approval(\n\t\taddress indexed _owner,\n\t\taddress indexed _spender,\n\t\tuint _value\n\t\t);\n}\n"},"ZeldaCoin.sol":{"content":"pragma solidity ^0.5.7;\n\nimport \"./ERC20Standard.sol\";\n\ncontract ZeldaCoin is ERC20Standard, Owned {\n\tconstructor() public {\n\t\tinitialSupply = 1000;\n\t\ttotalSupply = initialSupply * 1000 ** uint256(decimals);\n\t\tname = \"ZeldaCoin\";\n\t\tdecimals = 0;  \n\t\tsymbol = \"ZLD\";\n\t\tversion = \"3.5\";\n\t\tbalances[msg.sender] = initialSupply;\n\t}\n}\n"}}