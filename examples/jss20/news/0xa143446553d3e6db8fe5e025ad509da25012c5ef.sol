{"ERC20Token.sol":{"content":"pragma solidity ^0.4.26;\n\nimport \"./SafeMath.sol\";\nimport \"./Owned.sol\";\nimport \"./IERC20.sol\";\n\ncontract ERC20Token is IERC20, Owned {\n    using SafeMath for uint256;\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) balances;\n    mapping(address =\u003e mapping (address =\u003e uint256)) allowed;\n\n\n    // True if transfers are allowed\n    bool public transferable = true;\n\n    modifier canTransfer() {\n        require(transferable == true);\n        _;\n    }\n\n    function setTransferable(bool _transferable) onlyOwner public {\n        transferable = _transferable;\n    }\n\n    /**\n     * @dev transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) canTransfer public returns (bool) {\n        require(_to != address(0));\n        require(_value \u003c= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address _from, address _to, uint256 _value) canTransfer public returns (bool) {\n        require(_to != address(0));\n        require(_value \u003c= balances[_from]);\n        require(_value \u003c= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    // Allow `_spender` to withdraw from your account, multiple times.\n    function approve(address _spender, uint _value) public returns (bool success) {\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        if ((_value != 0) \u0026\u0026 (allowed[msg.sender][_spender] != 0)) {\n            revert();\n        }\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    function () external payable {\n        revert();\n    }\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.4.26;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface  IERC20 {\n    function balanceOf(address who) external view returns (uint256);\n    function transfer(address to, uint256 value) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function approve(address spender, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Owned.sol":{"content":"pragma solidity ^0.4.26;\n\ncontract Owned {\n    address public owner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _owner) onlyOwner public {\n        require(_owner != address(0));\n        owner = _owner;\n\n        emit OwnershipTransferred(owner, _owner);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.26;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003e 0);\n    uint256 c = a / b;\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}\n"},"SNSSynth.sol":{"content":"pragma solidity ^0.4.26;\n\nimport \"./Owned.sol\";\nimport \"./SNSToken.sol\";\n\ncontract SNSSynth is ERC20Token {\n    using SafeMath for uint256;\n\n    //mint \u0026 burn event\n    event Mint(address indexed to, uint256 indexed amount, uint256 indexed locked);\n    event Burn(address indexed from, uint256 indexed amount, uint256 indexed unlocked);\n    event ChangeRate(uint256 indexed oldRate, uint256 indexed newRate);\n\n    uint256 public mintingRate;\n    uint256 public rateDecimals;\n\n    SNS private _snsToken;\n\n    //locked SNS amount\n    mapping(address =\u003e uint256) public lockedSNS;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    constructor(address _issuer, address snsToken, string _name, string _symbol, uint8 _decimals, uint256 _rateDecimals) public Owned(_issuer){\n        _snsToken = SNS(snsToken);\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        totalSupply = uint256(0);\n        balances[_issuer] = uint256(0);\n\n        mintingRate = 0;\n        rateDecimals = 10 ** _rateDecimals;\n    }\n\n    /**\n     * @dev synthetic assets minting rate setting up\n     * @param newRate The minting rate.\n     */\n    function setMintingRate(uint256 newRate) onlyOwner public {\n        require(newRate != 0);\n        require(mintingRate != newRate);\n\n        emit ChangeRate(mintingRate, newRate);\n\n        mintingRate = newRate;\n    }\n\n    /**\n     * @dev This method will lock SNS token to mint synthetic assets\n     * @param _amount The amount of synthetic assets you want to mint.\n     */\n    function mint(uint256 _amount) public {\n        address user = msg.sender;\n\n        //check rate\n        require(mintingRate != 0);\n\n        //check user balance\n        uint256 userSNSBalance = _snsToken.balanceOf(user);\n        uint256 snsCost = _amount.mul(mintingRate);\n        snsCost = snsCost.div(rateDecimals);\n\n        require(snsCost \u003c= userSNSBalance);\n\n        //transfer from user balance to this contract\n        _snsToken.transferFrom(user, address(this), snsCost);\n\n        //record user sns cost to balance map\n        lockedSNS[user] = lockedSNS[user].add(snsCost);\n\n        //mint synthetic assets to user\n        _mintAssets(user, _amount, snsCost);\n    }\n\n\n    /**\n     * @dev This method will burn synthetic assets to redeem SNS token\n     * @param _snsAmount The amount of SNS tokens you want to redeem.\n     */\n    function redeem(uint256 _snsAmount) public {\n        address user = msg.sender;\n\n        //check rate\n        require(mintingRate != 0);\n\n        //check sns internal balance\n        uint256 snsBalance = lockedSNS[user];\n        require(snsBalance \u003e= _snsAmount, \"too greed\");\n\n        //check synthetic assets balance\n        uint256 synBalance = balanceOf(user);\n        uint256 synBurnAmount = _snsAmount.div(mintingRate);\n        synBurnAmount = synBurnAmount.mul(rateDecimals);\n\n        require(synBalance \u003e= synBurnAmount, \"insufficient synthetic assets balance\");\n\n        //burn and unlock the balance\n        _burnAssets(user, synBurnAmount, _snsAmount);\n\n        _snsToken.transfer(user, _snsAmount);\n        lockedSNS[user] = lockedSNS[user].sub(_snsAmount);\n    }\n\n\n    /**\n     * @dev mint synthetic token.\n     * @param _to The address which assets mint to.\n     * @param _amount The synthetic token mint amount.\n     */\n    function _mintAssets(address _to, uint256 _amount, uint256 _locked) private returns (bool) {\n        totalSupply = totalSupply.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Mint(_to, _amount, _locked);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n    /**\n     * @dev Burn synthetic token when address redeem SNS token.\n     * @param _from The address which assets mint to.\n     * @param _amount The synthetic token mint amount.\n     */\n    function _burnAssets(address _from, uint256 _amount, uint256 _unlocked) private returns (bool) {\n        balances[_from] = balances[_from].sub(_amount);\n        totalSupply = totalSupply.sub(_amount);\n\n        emit Burn(_from, _amount, _unlocked);\n        emit Transfer(_from, address(0), _amount);\n\n        return true;\n    }\n}\n"},"SNSToken.sol":{"content":"pragma solidity ^0.4.26;\n\nimport \"./ERC20Token.sol\";\n\ncontract SNS is ERC20Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 private constant DECIMALS = 18;\n    uint256 private constant TOTAL_SUPPLY = 499 * 10 ** 8 * 10**DECIMALS;\n\n    /**\n     * @param _issuer The address of the owner.\n     */\n    constructor(address _issuer) public Owned(_issuer){\n        name = \"Skyrim Network\";\n        symbol = \"SNS\";\n        decimals = uint8(DECIMALS);\n        totalSupply = TOTAL_SUPPLY;\n        balances[_issuer] = TOTAL_SUPPLY;\n        emit Transfer(address(0), _issuer, TOTAL_SUPPLY);\n    }\n}\n"}}