{"auth.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\npragma solidity \u003e=0.4.23;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n        public\n        auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n        public\n        auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"},"TokenAuthority.sol":{"content":"/*\n  This file is part of The Colony Network.\n\n  The Colony Network is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  The Colony Network is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with The Colony Network. If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n*/\n\npragma solidity 0.5.8;\n\nimport \"./auth.sol\";\n\n\ncontract TokenAuthority is DSAuthority {\n  address public token;\n  mapping(address =\u003e mapping(bytes4 =\u003e bool)) authorizations;\n\n  bytes4 constant BURN_FUNC_SIG = bytes4(keccak256(\"burn(uint256)\"));\n  bytes4 constant BURN_OVERLOAD_FUNC_SIG = bytes4(keccak256(\"burn(address,uint256)\"));\n\n  constructor(address _token, address _colony, address[] memory allowedToTransfer) public {\n    token = _token;\n    bytes4 transferSig = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 transferFromSig = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n    bytes4 mintSig = bytes4(keccak256(\"mint(uint256)\"));\n    bytes4 mintSigOverload = bytes4(keccak256(\"mint(address,uint256)\"));\n\n    authorizations[_colony][transferSig] = true;\n    authorizations[_colony][mintSig] = true;\n    authorizations[_colony][mintSigOverload] = true;\n\n    for (uint i = 0; i \u003c allowedToTransfer.length; i++) {\n      authorizations[allowedToTransfer[i]][transferSig] = true;\n      authorizations[allowedToTransfer[i]][transferFromSig] = true;\n    }\n  }\n\n  function canCall(address src, address dst, bytes4 sig) public view returns (bool) {\n    if (sig == BURN_FUNC_SIG || sig == BURN_OVERLOAD_FUNC_SIG) {\n      // We allow anyone to burn their own tokens even when the token is still locked\n      return true;\n    }\n\n    if (dst != token) {\n      return false;\n    }\n\n    return authorizations[src][sig];\n  }\n}\n"}}