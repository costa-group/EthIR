{"interfaces.sol":{"content":"pragma solidity ^0.6.4;\n\ninterface DaiErc20 {\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address,address,uint256) external returns (bool);\n    function approve(address,uint256) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n    function allowance(address, address) external view returns (uint);\n}\n\n"},"mathlib.sol":{"content":"pragma solidity ^0.6.4;\n\nlibrary mathlib\n{\n     \n     // --- Math functions as implemented in DAI ERC20 Token---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) \u003e= x);\n    }\n    \n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) \u003c= x);\n    }\n    \n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n   function calculatereservationdays(uint rstart,uint rend) internal pure returns(uint)\n    {\n        /*\n            Dates are rounded, so 5.6 days becomes 6 days. 0.5 days become 1 day.\n        */\n        \n\t    require(rend \u003e rstart,\"Reservation End has to be greater than Reservation Start\");\n\n        uint diff = sub(rend,rstart);\n        \n        uint dlen = diff / 86400; //div is Math.floor()\n        \n        uint md = diff % 86400;\n        \n        return md \u003e= 43200 ? add(dlen,1) : dlen;\n        \n    }\n    \n}\n\n"},"owned.sol":{"content":"pragma solidity ^0.6.4;\n\ncontract owned\n{\n    /*\n        1) Allows the manager to pause the main Factory contract\n        2) [Very Important]) The new contract that is created by the Factory is NOT owned, and therefore can not in any way be modified by the manager\n        3) Only the Factory contract is owned.\n    */\n    \n    address public manager;\n    \n    constructor() public \n\t{\n\t    manager = msg.sender;\n\t}\n\n\n    modifier onlyManager()\n    {\n        require(msg.sender == manager);\n        _;\n    }\n    \n\n    function setManager(address newmanager) external onlyManager\n    {\n        /*\n            Allows the current manager to set a new manager\n        */\n        \n        require(newmanager.balance \u003e 0);\n        manager = newmanager;\n    }\n    \n}\n\n\n\n\n"},"stayusb.sol":{"content":"pragma solidity ^0.6.4;\n\nimport \"./interfaces.sol\";\nimport \"./owned.sol\";\nimport \"./mathlib.sol\";\n\n\nenum reservationstatus {CANCELLED, NOTACTIVATED, ACTIVATED, COMPLETED}\n\n\ncontract ReservationFactory is owned\n{\n    /*\n        This contract will create new Reservation Contract between Guest and Host\n    */\n    \n    address constant private dai_ = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    DaiErc20 private daiToken;\n\n    //Reservation Fee in wad\n    uint public reservationfee;\n    \n    uint constant private secondsin21hrs = 75600;\n    \n    //Switch that controls whether the factory is active\n    bool public factorycontractactive;\n    \n    \n    //Event for new Reservation Contract\n    event NewReservationContractEvent(address indexed reservationcontractaddress, address indexed guest, address indexed host, uint rstart, uint rend, uint dprice, uint advpay, bytes8 rstartformat, bytes8 rendformat, uint eventtime);\n    \n\n    \n    constructor() public \n\t{\n\t    reservationfee = 1000000000000000000; //1 DAI\n\t\tfactorycontractactive = true;\n\t\tdaiToken = DaiErc20(dai_);\n\t}\n\n\n    function setReservationFee(uint newfee) external onlyManager\n    {\n        /*\n            Changes the Registration fee that is paid to the manager\n            If new fee is set, it can never be greater than 10 DAI\n        */\n        \n        require(newfee \u003e 0 \u0026\u0026 newfee \u003c=10000000000000000000);\n        \n        reservationfee = newfee;\n    }\n    \n\n    function setFactoryContractSwitch() external onlyManager\n    {\n        /*\n            Switch that controls whether the contract is active\n        */\n        \n        factorycontractactive = factorycontractactive == true ? false : true;\n    }\n    \n    function createnewReservationContract(address host, uint reservationstart, uint reservationend, uint dailyprice, uint advancepayment, bytes8 rstartformat, bytes8 rendformat) external \n    {\n        /*\n            Will Create a new reservation contract between guest and host\n        */\n        \n        require(factorycontractactive, \"Factory Contract should be Active\");\n        require(msg.sender != host,\"Host and Guest can not be same\");\n        require(dailyprice \u003e 0, \"Daily Price should be \u003e 0\");\n        require(now \u003c mathlib.add(reservationstart,secondsin21hrs),\"Too late to start this reservation\");\n        \n        uint lengthofstay = mathlib.calculatereservationdays(reservationstart,reservationend);\n        \n        require(lengthofstay \u003e 0,\"Length of Stay should be \u003e 0\");\n        \n        uint totalreservationamount = mathlib.mul(dailyprice,lengthofstay);\n        \n        uint minadvpayment = lengthofstay \u003e 5 ? mathlib.mul(dailyprice,2) : dailyprice;\n        \n        require(advancepayment \u003e= minadvpayment \u0026\u0026 advancepayment \u003c= totalreservationamount ,\"Advance Payment should be \u003e= minadvpayment and \u003c= reservation amount \");\n        \n        //Check daitoken allowance for Factory contract\n        require(daiToken.allowance(msg.sender,address(this)) \u003e= mathlib.add(advancepayment, reservationfee), \"daiToken allowance exceeded\");\n        \n        Reservation ReservationContract = (new Reservation) (msg.sender, host, reservationstart, reservationend, dailyprice, advancepayment, lengthofstay, minadvpayment);\n        \n        //Transfer the advance payment to reservation contract\n        daiToken.transferFrom(msg.sender, address(ReservationContract), advancepayment);\n        \n        //Transfer the reservation fee to factory manager\n        daiToken.transferFrom(msg.sender, manager, reservationfee);\n\n        emit NewReservationContractEvent(address(ReservationContract), msg.sender, host, reservationstart, reservationend, dailyprice, advancepayment, rstartformat, rendformat, now);\n        \n    }\n    \n}\n\ncontract Reservation\n{\n    reservationstatus public contractstatus;\n    \n    uint constant private secondsinday = 86400;\n    uint constant private secondsin21hrs = 75600;\n    \n    //This value will hold the time 21 Hrs after reservation start\n    uint immutable private reservationstart21Hrs;\n\n    address constant private dai_ = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    DaiErc20 private daiToken;\n    \n    address immutable  public factory;\n    \n    address immutable public guest;\n    address immutable public host;\n    \n    uint immutable public reservationstart;\n    uint immutable public reservationend;\n    uint immutable public dailyprice;\n    uint immutable public lengthofstay;\n    \n    /*\n        The cancellation fee will only be charged if the guest cancels after the valid cancellation period.\n    */\n    uint immutable public cancellationfee;\n    \n    uint immutable public advancepayment;\n    \n    //Reservation Status Change Event\n    event ContractStatusEvent(reservationstatus cstatus, uint eventtime);\n\n    constructor(address guestin,address hostin, uint rstart, uint rend, uint dprice, uint advpay, uint lstay, uint minadvpay) public\n    {\n        daiToken = DaiErc20(dai_);\n        \n        contractstatus = reservationstatus.NOTACTIVATED;\n        \n        guest = guestin;\n        host = hostin;\n        \n        factory = msg.sender;\n        \n        reservationstart = rstart;\n        reservationend = rend;\n        \n        reservationstart21Hrs = mathlib.add(rstart,secondsin21hrs);\n        \n        dailyprice = dprice;\n        advancepayment = advpay;\n        \n        lengthofstay = lstay;\n        \n        cancellationfee = minadvpay;\n        \n    }\n    \n\n    modifier onlyGuest()\n    {\n        require(msg.sender == guest, \"Only Guest\");\n        _;\n    }\n    \n    modifier onlyHost()\n    {\n        require(msg.sender == host, \"Only Host\");\n        _;\n    }\n    \n    \n    function getContractAddress() external view returns (address)\n    {\n        //This reservation Contract address\n        \n        return address(this);\n    }\n    \n    function getContractBalance() public view returns(uint)\n    {\n        //The contract balance in DAI\n        \n        return daiToken.balanceOf(address(this));\n    }\n    \n    \n    function setHostAcceptsReservation() external onlyHost\n    {\n        /*\n            1) Host has to activate the reservation for it to be valid\n            2) Host can activate the reservation upto 21 Hrs after reservation start\n        */\n        \n        require(contractstatus == reservationstatus.NOTACTIVATED,\"Reservation should be NOTACTIVATED\");\n        \n        require(now \u003c reservationstart21Hrs,\"Reservation Can be ACTIVATED upto 21 Hrs after reservation start\");\n        \n        contractstatus = reservationstatus.ACTIVATED;\n        emit ContractStatusEvent(contractstatus,now);\n    }\n    \n   function setHostCancelsReservation() external onlyHost\n    {\n        /*\n            1) Allows the host to cancel the reservation anytime if NOTACTIVATED\n            2) Allows the host to cancel the reservation upto 21 Hrs after reservation start if ACTIVATED\n            3) Guest gets a Full Refund Instantly, since the Host is cancelling\n        */\n        \n        require(contractstatus == reservationstatus.NOTACTIVATED || contractstatus == reservationstatus.ACTIVATED,\"Reservation must be ACTIVATED or NOTACTIVATED\");\n        \n        uint fullbalance = getContractBalance();\n         \n        if (contractstatus == reservationstatus.NOTACTIVATED)\n        {\n            \n             daiToken.transfer(guest,fullbalance);\n        }\n        else if (contractstatus == reservationstatus.ACTIVATED)\n        {\n    \n            require(now \u003c reservationstart21Hrs,\"Reservation Can be CANCELLED upto 21 Hrs after reservation start\");\n            \n            daiToken.transfer(guest, fullbalance);\n        }\n         \n        contractstatus = reservationstatus.CANCELLED;\n        emit ContractStatusEvent(contractstatus,now);\n    }\n    \n    function setGuestCancelReservation() external onlyGuest\n    {\n        /*\n            1) Guest can cancel the reservation anytime if NOTACTIVATED\n            2) Guest can cancel the reservation upto 21 Hrs after reservation start if ACTIVATED\n            3) If length of stay is 5 days or less, cancel upto 3 days before reservation start, otherwise a cancellation fee of dailyprice is applied\n            4) If length of stay is greater than 5 days, cancel upto 5 days before reservation start, otherwise a cancellation fee of 2*dailyprice is applied\n        */\n        \n        require(contractstatus == reservationstatus.NOTACTIVATED || contractstatus == reservationstatus.ACTIVATED,\"Reservation must be ACTIVATED or NOTACTIVATED\");\n        \n        uint fullbalance = getContractBalance();\n        \n        if (contractstatus == reservationstatus.NOTACTIVATED)\n        {\n           \n            daiToken.transfer(guest,fullbalance);\n        }\n        else if (contractstatus == reservationstatus.ACTIVATED)\n        {\n            \n            require(now \u003c reservationstart21Hrs,\"Guest can only cancel upto 21 Hrs after reservation start\");\n            \n            uint cancellationperiod = lengthofstay \u003e 5 ? 5 : 3;\n            \n            if (now \u003c mathlib.sub(reservationstart,mathlib.mul(cancellationperiod,secondsinday)))\n            {\n                daiToken.transfer(guest,fullbalance);\n            }\n            else\n            {\n                \n                uint guestdue = mathlib.sub(fullbalance,cancellationfee);\n                \n                //Host gets compensated for cancellation    \n                 daiToken.transfer(host,cancellationfee);\n                 \n                 //Guest gets refunded the remaining balance\n                 if (guestdue \u003e 0)\n                 {\n                    daiToken.transfer(guest,guestdue);\n                 }\n            }\n        }\n        \n        contractstatus = reservationstatus.CANCELLED;\n        emit ContractStatusEvent(contractstatus,now);\n    }\n    \n   function setHostClaimsRent() external onlyHost\n    {\n        /*\n            Host can claim the rent 21 Hrs after reservation start\n        */\n        \n        require(contractstatus == reservationstatus.ACTIVATED, \"Reservation has to be ACTIVATED\");\n        \n        require(now \u003e= reservationstart21Hrs,\"Host can only claim the rent 21 Hrs after reservation start\");\n        \n        //Host claims the entire contract balance\n         daiToken.transfer(host,getContractBalance());\n         \n        contractstatus = reservationstatus.COMPLETED;\n        emit ContractStatusEvent(contractstatus,now);\n    }\n    \n     function setHostRefundsPartRent(uint refundamount) external onlyHost\n    {\n        /*\n            1) Host can refund the Guest a part of or full contract balance amount 21 Hrs after reservation start\n            2) The remaining balance if any will be transferred to the Host. \n        */\n        \n        require(contractstatus == reservationstatus.ACTIVATED, \"Reservation has to be ACTIVATED\");\n        \n        require(now \u003e= reservationstart21Hrs, \"Host can refund part of contract balance 21 Hrs after Reservation Start\");\n        \n        uint fullbalance = getContractBalance();\n        \n        require(refundamount \u003e 0 \u0026\u0026 refundamount \u003c= fullbalance, \"Refund amount should be \u003e 0 \u0026\u0026 \u003c= contractbalance\");\n        \n        uint hostdue = mathlib.sub(fullbalance,refundamount);\n        \n        //The refund amount is transferred to the guest\n        daiToken.transfer(guest,refundamount);\n        \n        //The remaining amount is transffered to the Host\n        if (hostdue \u003e 0)\n        {\n            daiToken.transfer(host,hostdue);\n        }\n        \n        contractstatus = reservationstatus.COMPLETED;\n        emit ContractStatusEvent(contractstatus,now);\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}}