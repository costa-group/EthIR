{"PIXBY.sol":{"content":"pragma solidity 0.5.11;\nimport \"./SafeMath.sol\";\n\ncontract PXB   {\n    using SafeMath for uint256;\n\n   \n    event PassiveDeposit(\n        address indexed _investor2,\n        uint256 _investmentValue2,\n        uint256 _ID2,\n        uint256 _unlocktime2,\n        uint256 _dailyIncome,\n        uint256 _investmentTime\n    );\n   \n    event PassiveSpent(\n        address indexed _acclaimer2,\n        uint256 indexed _amout2\n    );\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    string constant public name = \"PIXBY\";\n    string constant public symbol = \"PXB\";\n    string constant public standard = \"PXB Token\";\n    uint256 constant public decimals = 18 ;\n    uint256 private _totalSupply;\n    uint256 public totalInvestmentAfterInterest;\n    uint256 public passiveInvestorIndex = 1;\n    uint256 constant public interestRate = 23;\n    uint256 public minForPassive = 35000 * (10 ** uint256(decimals));\n    uint256 public maxForPassive = 2500000 * (10 ** uint256(decimals));\n    uint256 constant public Percent = 1000000000;\n    uint256 constant internal daysInYear = 365;\n    uint256 constant internal secondsInDay = 86400;\n    uint256 internal _startSupply = 450000000 * (10 ** uint256(decimals));\n    address payable public fundsWallet;\n    enum TermData {DEFAULT, ONE, TWO, THREE}\n\n    mapping(uint256 =\u003e PassiveIncome) private passiveInvestors;\n    mapping (address =\u003e uint256) private _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n    \n    struct PassiveIncome {\n        address investorAddress2;\n        uint256 investedAmount2;\n        uint256 dailyPassiveIncome;\n        uint256 investmentTimeStamp;\n        uint256 investmentUnlocktime2;\n        uint256 day;\n        bool spent2;\n        uint256 Days;\n    }\n    constructor (address payable _fundsWallet)  public {\n        _totalSupply = _startSupply;\n        fundsWallet = _fundsWallet;\n        _balances[msg.sender] = _startSupply;\n        _balances[address(1)] = 0;\n        emit Transfer(\n            address(1),\n            msg.sender,\n            _startSupply\n        );\n    \n    }\n    function () external payable{\n        \n    }\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        require(recipient != address(this));\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(_msgSender(), spender, value);\n        return true;\n    }\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));\n        return true;\n    }\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue));\n        return true;\n    }\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n    /**\n    * @dev Destroys `amount` tokens from the caller.\n    *\n    * See {ERC20-_burn}.\n    */\n    function burn(uint256 amount) public {\n        _burn(_msgSender(), amount);\n    }\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount);\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n    \n    \n    function makePassiveIncomeInvestment(uint256 _amount,uint256 _unlockTime) external returns (uint256) {\n        require(_balances[_msgSender()] \u003e= _amount, \"You  have insufficent amount of tokens\");\n        require(_amount \u003e= minForPassive, \"Investment amount should be greater than 35,000 PXB\");\n        require(_amount \u003c= maxForPassive, \"Investment amount should be smaller than 2,500,000 PXB\");\n        require(_unlockTime \u003c= secondsInDay.mul(365), \"Investment term should be smaller than 365 days\");\n        require(_unlockTime \u003e= (secondsInDay.mul(2)) \u0026\u0026 (_unlockTime.mod(secondsInDay)) == 0, \"Wrong investment time\");\n\n        // Term time is currently in days\n        uint256 passiveDays = (_unlockTime.div(secondsInDay));\n\n        uint256 interestOnInvestment = getInterestRate(_amount, passiveDays);\n        uint256 currentInvestor = passiveInvestorIndex;\n        passiveInvestorIndex++;\n        passiveInvestors[currentInvestor] = PassiveIncome(\n            _msgSender(),\n            _amount,\n            interestOnInvestment,\n            block.timestamp,\n            block.timestamp.add(secondsInDay.mul(passiveDays)),\n            1,\n            false,\n            passiveDays\n        );\n        emit Transfer(\n            _msgSender(),\n            address(1),\n            _amount\n        );\n        emit Transfer(\n            address(1),\n            address(1),\n            interestOnInvestment.mul(passiveDays)\n        );\n        emit PassiveDeposit(\n            _msgSender(),\n            _amount,\n            currentInvestor,\n            block.timestamp.add((secondsInDay * passiveDays)),\n            passiveInvestors[currentInvestor].dailyPassiveIncome,\n            passiveInvestors[currentInvestor].investmentTimeStamp\n        );\n        _balances[_msgSender()] = _balances[_msgSender()].sub(_amount);\n        _balances[address(1)] = _balances[address(1)].add((interestOnInvestment.mul(passiveDays)).add(_amount));\n        _totalSupply = _totalSupply.sub(_amount);\n        return (currentInvestor);\n    }\n\n\n    function releasePassiveIncome(uint256 _passiveIncomeID) external returns (bool success) {\n        require(passiveInvestors[_passiveIncomeID].investorAddress2 == _msgSender(), \"Only the investor can claim the investment\");\n        require(passiveInvestors[_passiveIncomeID].spent2 == false, \"The investment is already claimed\");\n\n        require(passiveInvestors[_passiveIncomeID].investmentTimeStamp.add(120) \u003c block.timestamp,\n        \"Unlock time for the investment did not mature\");\n        require(passiveInvestors[_passiveIncomeID].investmentTimeStamp.add((\n        secondsInDay.mul(passiveInvestors[_passiveIncomeID].day))) \u003c block.timestamp,\n        \"Unlock time for the investment did not pass\");\n        require(passiveInvestors[_passiveIncomeID].day \u003c= passiveInvestors[_passiveIncomeID].Days.add(1), \"The investment is already claimed\");\n        uint256 totalReward = 0;\n        uint256 numberOfDaysHeld = (block.timestamp.sub(passiveInvestors[_passiveIncomeID].investmentTimeStamp)).div(secondsInDay);\n        if(numberOfDaysHeld \u003e= passiveInvestors[_passiveIncomeID].Days){\n            passiveInvestors[_passiveIncomeID].spent2 = true;\n            numberOfDaysHeld = passiveInvestors[_passiveIncomeID].Days;\n            totalReward = passiveInvestors[_passiveIncomeID].investedAmount2;\n        }\n        uint numberOfDaysOwed = numberOfDaysHeld.sub((passiveInvestors[_passiveIncomeID].day.sub(1)));\n        uint totalDailyPassiveIncome = passiveInvestors[_passiveIncomeID].dailyPassiveIncome.mul(numberOfDaysOwed);\n        passiveInvestors[_passiveIncomeID].day = numberOfDaysHeld.add(1);\n        totalReward = totalReward.add(totalDailyPassiveIncome);\n        if(totalReward \u003e 0){\n            _totalSupply = _totalSupply.add(totalReward);\n            _balances[address(1)] = _balances[address(1)].sub(totalReward);\n            _balances[_msgSender()] = _balances[_msgSender()].add(totalReward);\n            emit Transfer(\n                address(1),\n                _msgSender(),\n                totalReward\n            );\n            emit PassiveSpent(\n                _msgSender(),\n                totalReward\n            );\n            return true;\n        }\n        else{\n            revert(\n                \"There is no total reward earned.\"\n            );\n        }\n    }\n   \n   \n    \n    function getPassiveDetails (uint _passiveIncomeID) external view returns (\n        address investorAddress2,\n        uint256 investedAmount2,\n        uint256 dailyPassiveIncome,\n        uint256 investmentTimeStamp,\n        uint256 investmentUnlocktime2,\n        uint256 day,\n        bool spent2\n    ){\n        return(\n            passiveInvestors[_passiveIncomeID].investorAddress2,\n            passiveInvestors[_passiveIncomeID].investedAmount2,\n            passiveInvestors[_passiveIncomeID].dailyPassiveIncome,\n            passiveInvestors[_passiveIncomeID].investmentTimeStamp,\n            passiveInvestors[_passiveIncomeID].investmentUnlocktime2,\n            passiveInvestors[_passiveIncomeID].day,\n            passiveInvestors[_passiveIncomeID].spent2\n        );\n    }\n    function getPassiveIncomeDay(uint256 _passiveIncomeID) external view returns (uint256) {\n        return(passiveInvestors[_passiveIncomeID].day);\n    }\n    function getPassiveIncomeStatus(uint256 _passiveIncomeID) external view returns (bool) {\n        return (passiveInvestors[_passiveIncomeID].spent2);\n    }\n    function getPassiveInvestmentTerm(uint256 _passiveIncomeID) external view returns (uint256){\n        return (passiveInvestors[_passiveIncomeID].investmentUnlocktime2);\n    }\n    function getPassiveNumberOfDays (uint _passiveIncomeID) external view returns (uint256){\n        return (block.timestamp.sub(passiveInvestors[_passiveIncomeID].investmentTimeStamp)).div(secondsInDay);\n    }\n    function getPassiveInvestmentTimeStamp(uint256 _passiveIncomeID) external view returns (uint256){\n        return (passiveInvestors[_passiveIncomeID].investmentTimeStamp);\n    }\n   \n  \n    function getBlockTimestamp () external view returns (uint blockTimestamp){\n        return block.timestamp;\n    }\n    function getInterestRate(uint256 _investment, uint _term) public view returns (uint256 rate) {\n        require(_investment \u003c _totalSupply, \"The investment is too large\");\n\n\n        uint256 Precentege = _term.mul(23).mul(Percent).div(365);\n        uint256 interestoninvestment = Precentege.div(100).mul(_investment).div(_term);\n\n        return (interestoninvestment.div(Percent));\n\n    }\n   \n    function getSimulatedDailyIncome (uint _passiveIncomeID) external view returns (\n        uint _numberOfDaysHeld,\n        uint _numberOfDaysOwed,\n        uint _totalDailyPassiveIncome,\n        uint _dailyPassiveIncome,\n        uint _totalReward,\n        uint _day,\n        bool _spent\n    ){\n        _spent = false;\n        _numberOfDaysHeld = (block.timestamp - passiveInvestors[_passiveIncomeID].investmentTimeStamp) / secondsInDay;\n        if(_numberOfDaysHeld \u003e passiveInvestors[_passiveIncomeID].day){\n            _numberOfDaysHeld = passiveInvestors[_passiveIncomeID].day;\n            _totalReward = passiveInvestors[_passiveIncomeID].investedAmount2;\n            _spent = true;\n        }\n        _numberOfDaysOwed = _numberOfDaysHeld - (passiveInvestors[_passiveIncomeID].day - 1);\n        _totalDailyPassiveIncome = passiveInvestors[_passiveIncomeID].dailyPassiveIncome * _numberOfDaysOwed;\n        _day = _numberOfDaysHeld.add(1);\n        _totalReward = _totalReward.add(_totalDailyPassiveIncome);\n        _dailyPassiveIncome = passiveInvestors[_passiveIncomeID].dailyPassiveIncome;\n        return (\n            _numberOfDaysHeld,\n            _numberOfDaysOwed,\n            _totalDailyPassiveIncome,\n            _dailyPassiveIncome,\n            _totalReward,\n            _day,\n            _spent\n        );\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}