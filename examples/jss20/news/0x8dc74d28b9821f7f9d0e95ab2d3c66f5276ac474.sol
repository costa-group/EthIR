{"DeliverFunds.sol":{"content":"pragma solidity 0.5.16;\r\n\r\ncontract DeliverFunds {\r\n    constructor(address payable target) public payable {\r\n        selfdestruct(target);\r\n    }\r\n}\r\n"},"EthexJackpot.sol":{"content":"pragma solidity 0.5.16;\r\n\r\n/**\r\n * (E)t)h)e)x) Jackpot Contract \r\n *  This smart-contract is the part of Ethex Lottery fair game.\r\n *  See latest version at https://github.com/ethex-bet/ethex-contracts \r\n *  http://ethex.bet\r\n */\r\n\r\nimport \"./DeliverFunds.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\ncontract EthexJackpot is Ownable {\r\n    mapping(uint256 =\u003e address payable) public tickets;\r\n    mapping(uint256 =\u003e Segment[4]) public prevJackpots;\r\n    uint256[4] public amounts;\r\n    uint256[4] public starts;\r\n    uint256[4] public ends;\r\n    uint256[4] public numberStarts;\r\n    uint256 public numberEnd;\r\n    uint256 public firstNumber;\r\n    address public lotoAddress;\r\n    address payable public newVersionAddress;\r\n    EthexJackpot public previousContract;\r\n    \r\n    struct Segment {\r\n        uint256 start;\r\n        uint256 end;\r\n        bool processed;\r\n    }\r\n    \r\n    event Jackpot (\r\n        uint256 number,\r\n        uint256 count,\r\n        uint256 amount,\r\n        byte jackpotType\r\n    );\r\n    \r\n    event Ticket (\r\n        uint256 number\r\n    );\r\n    \r\n    event Superprize (\r\n        uint256 amount,\r\n        address winner\r\n    );\r\n    \r\n    uint256 internal constant PRECISION = 1 ether;\r\n    \r\n    modifier onlyLoto {\r\n        require(msg.sender == lotoAddress, \"Loto only\");\r\n        _;\r\n    }\r\n    \r\n    function() external payable { }\r\n    \r\n    function migrate() external {\r\n        require(msg.sender == owner || msg.sender == newVersionAddress);\r\n        require(newVersionAddress != address(0), \"NewVersionAddress required\");\r\n        newVersionAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function registerTicket(address payable gamer) external payable onlyLoto {\r\n        distribute();\r\n        uint8 i;\r\n        if (gamer == address(0x0)) {\r\n            for (; i \u003c 4; i++)\r\n                if (block.number \u003e= ends[i])\r\n                    setJackpot(i);\r\n        }\r\n        else {\r\n            uint256 number = numberEnd + 1;\r\n            for (; i \u003c 4; i++) {\r\n                if (block.number \u003e= ends[i]) {\r\n                    setJackpot(i);\r\n                    numberStarts[i] = number;\r\n                }\r\n                else\r\n                    if (numberStarts[i] == prevJackpots[starts[i]][i].start)\r\n                        numberStarts[i] = number;\r\n            }\r\n            numberEnd = number;\r\n            tickets[number] = gamer;\r\n            emit Ticket(number);\r\n        }\r\n    }\r\n    \r\n    function setLoto(address loto) external onlyOwner {\r\n        lotoAddress = loto;\r\n    }\r\n    \r\n    function setNewVersion(address payable newVersion) external onlyOwner {\r\n        newVersionAddress = newVersion;\r\n    }\r\n    \r\n    function payIn() external payable { distribute(); }\r\n    \r\n    function settleJackpot() external {\r\n        for (uint8 i = 0; i \u003c 4; i++)\r\n            if (block.number \u003e= ends[i])\r\n                setJackpot(i);\r\n\r\n        uint256[4] memory payAmounts;\r\n        uint256[4] memory wins;\r\n        uint8[4] memory PARTS = [84, 12, 3, 1];\r\n        for (uint8 i = 0; i \u003c 4; i++) {\r\n            uint256 start = starts[i];\r\n            if (block.number == start || (start \u003c block.number - 256))\r\n                continue;\r\n            if (prevJackpots[start][i].processed == false \u0026\u0026 prevJackpots[start][i].start != 0) {\r\n                payAmounts[i] = amounts[i] * PRECISION / PARTS[i] / PRECISION;\r\n                amounts[i] -= payAmounts[i];\r\n                prevJackpots[start][i].processed = true;\r\n                uint48 modulo = uint48(bytes6(blockhash(start) \u003c\u003c 29));\r\n                wins[i] = getNumber(prevJackpots[start][i].start, prevJackpots[start][i].end, modulo);\r\n                emit Jackpot(wins[i], prevJackpots[start][i].end - prevJackpots[start][i].start + 1, payAmounts[i], byte(uint8(1) \u003c\u003c i));\r\n            }\r\n        }\r\n        \r\n        for (uint8 i = 0; i \u003c 4; i++)\r\n            if (payAmounts[i] \u003e 0 \u0026\u0026 !getAddress(wins[i]).send(payAmounts[i]))\r\n                (new DeliverFunds).value(payAmounts[i])(getAddress(wins[i]));\r\n    }\r\n\r\n    function settleMissedJackpot(bytes32 hash, uint256 blockHeight) external onlyOwner {\r\n        for (uint8 i = 0; i \u003c 4; i++)\r\n            if (block.number \u003e= ends[i])\r\n                setJackpot(i);\r\n        \r\n        if (blockHeight \u003c block.number - 256) {\r\n            uint48 modulo = uint48(bytes6(hash \u003c\u003c 29));\r\n        \r\n            uint256[4] memory payAmounts;\r\n            uint256[4] memory wins;\r\n            uint8[4] memory PARTS = [84, 12, 3, 1];\r\n            for (uint8 i = 0; i \u003c 4; i++) {\r\n                if (prevJackpots[blockHeight][i].processed == false \u0026\u0026 prevJackpots[blockHeight][i].start != 0) {\r\n                    payAmounts[i] = amounts[i] * PRECISION / PARTS[i] / PRECISION;\r\n                    amounts[i] -= payAmounts[i];\r\n                    prevJackpots[blockHeight][i].processed = true;\r\n                    wins[i] = getNumber(prevJackpots[blockHeight][i].start, prevJackpots[blockHeight][i].end, modulo);\r\n                    emit Jackpot(wins[i], prevJackpots[blockHeight][i].end - prevJackpots[blockHeight][i].start + 1, payAmounts[i], byte(uint8(1) \u003c\u003c i));\r\n                }\r\n            }\r\n        \r\n            for (uint8 i = 0; i \u003c 4; i++)\r\n                if (payAmounts[i] \u003e 0 \u0026\u0026 !getAddress(wins[i]).send(payAmounts[i]))\r\n                    (new DeliverFunds).value(payAmounts[i])(getAddress(wins[i]));\r\n        }\r\n    }\r\n    \r\n    function paySuperprize(address payable winner) external onlyLoto {\r\n        uint256 superprizeAmount = amounts[0] + amounts[1] + amounts[2] + amounts[3];\r\n        amounts[0] = 0;\r\n        amounts[1] = 0;\r\n        amounts[2] = 0;\r\n        amounts[3] = 0;\r\n        emit Superprize(superprizeAmount, winner);\r\n        if (superprizeAmount \u003e 0 \u0026\u0026 !winner.send(superprizeAmount))\r\n            (new DeliverFunds).value(superprizeAmount)(winner);\r\n    }\r\n    \r\n    function setOldVersion(address payable oldAddress) external onlyOwner {\r\n        previousContract = EthexJackpot(oldAddress);\r\n        for (uint8 i = 0; i \u003c 4; i++) {\r\n            starts[i] = previousContract.starts(i);\r\n            ends[i] = previousContract.ends(i);\r\n            numberStarts[i] = previousContract.numberStarts(i);\r\n            uint256 start;\r\n            uint256 end;\r\n            bool processed;\r\n            (start, end, processed) = previousContract.prevJackpots(starts[i], i);\r\n            prevJackpots[starts[i]][i] = Segment(start, end, processed);\r\n            amounts[i] = previousContract.amounts(i);\r\n        }\r\n        numberEnd = previousContract.numberEnd();\r\n        firstNumber = numberEnd;\r\n        previousContract.migrate();\r\n    }\r\n    \r\n    function getAddress(uint256 number) public returns (address payable) {\r\n        if (number \u003c= firstNumber)\r\n            return previousContract.getAddress(number);\r\n        return tickets[number];\r\n    }\r\n    \r\n    function setJackpot(uint8 jackpotType) private {\r\n        uint24[4] memory LENGTH = [5000, 35000, 150000, 450000];\r\n        prevJackpots[ends[jackpotType]][jackpotType].processed = prevJackpots[starts[jackpotType]][jackpotType].end == numberEnd;\r\n        starts[jackpotType] = ends[jackpotType];\r\n        ends[jackpotType] = starts[jackpotType] + LENGTH[jackpotType];\r\n        prevJackpots[starts[jackpotType]][jackpotType].start = numberStarts[jackpotType];\r\n        prevJackpots[starts[jackpotType]][jackpotType].end = numberEnd;\r\n    }\r\n    \r\n    function distribute() private {\r\n        uint256 distributedAmount = amounts[0] + amounts[1] + amounts[2] + amounts[3];\r\n        if (distributedAmount \u003c address(this).balance) {\r\n            uint256 amount = (address(this).balance - distributedAmount) / 4;\r\n            amounts[0] += amount;\r\n            amounts[1] += amount;\r\n            amounts[2] += amount;\r\n            amounts[3] += amount;\r\n        }\r\n    }\r\n    \r\n    function getNumber(uint256 startNumber, uint256 endNumber, uint48 modulo) private pure returns (uint256) {\r\n        return startNumber + modulo % (endNumber - startNumber + 1);\r\n    }\r\n}\r\n"},"Ownable.sol":{"content":"pragma solidity 0.5.16;\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n"}}