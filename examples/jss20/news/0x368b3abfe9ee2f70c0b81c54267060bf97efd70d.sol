{"EGToken.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\nimport \"../SafeMath.sol\";\nimport \"./ERC223ReceivingContract.sol\";\n\n\ncontract EGToken is ERC20 {\n    string public constant _name = \"EGT\";\n\n    string public constant _symbol = \"g\";\n\n    uint8 public constant _decimal = 12;\n\n    address private _superAdmin;\n\n    address private _egNetwork;\n\n    address private _blacklistController;\n\n    mapping(address =\u003e bool) private _blacklist;\n\n    bool public _initialized = false;\n\n\n\n    function initialize(address superAdmin, address blacklist) public {\n        require(!_initialized);\n        _superAdmin = superAdmin;\n        _blacklistController = blacklist;\n        _initialized = true;\n    }\n\n\n\n    /**\n    *@event\n    */\n    event NewSuperAdmin(address indexed account);\n\n    event NewEGNetwork(address indexed EGNetwork);\n\n    event NewBlackListController(address indexed BlackListController);\n\n    event BlacklistAddress(address indexed blacklistAccount);\n\n    event DeBlacklistAddress(address indexed unblacklistAccount);\n\n    event BurnBlacklistToken(address indexed blacklistAddress, uint256 burnAmount);\n\n\n\n    /**\n    *@modifier\n    */\n\n    modifier onlySuperAdmin() {\n        require(msg.sender == _superAdmin, \"Sender is not a super secrete admin\");\n        _;\n    }\n\n    modifier onlyBlackListController(){\n        require(msg.sender == _blacklistController, \"Sender is not a blacklist controller\");\n        _;\n    }\n\n    modifier onlyEGNetwork() {\n        require(msg.sender == _egNetwork, \"Sender is not a EG network\");\n        _;\n    }\n\n    modifier onlyNotBlacklist(address account) {\n        require(! isBlacklist(account), \"Account is in the blacklist\");\n        _;\n    }\n\n\n    /**\n    *@dev check whether it\u0027s a blacklist account\n    *@params address - account\n    */\n    function isBlacklist(address account) public view returns(bool) {\n        return _blacklist[account];\n    }\n\n\n    function superAdmin() public view returns (address) {\n        return _superAdmin;\n    }\n\n\n    function updateSuperAdmin(address newSuperAdmin) public onlySuperAdmin {\n        _superAdmin = newSuperAdmin;\n        emit NewSuperAdmin(_superAdmin);\n    }\n\n\n    function getEGNetwork() public view returns (address) {\n        return _egNetwork;\n    }\n\n    function updateEGNetwork(address newEGNetwork) public onlySuperAdmin {\n        _egNetwork = newEGNetwork;\n        emit NewEGNetwork(newEGNetwork);\n    }\n\n\n    function blacklistController() public view returns (address) {\n        return address(_blacklistController);\n    }\n\n    /**\n    *@dev to update the blackListController and only BlacklistController can update it\n    *@param blackListController address\n    */\n    function updateBlacklist(address blackListController) public onlyBlackListController {\n        _blacklistController = blackListController;\n        emit NewBlackListController(blackListController);\n    }\n\n\n\n    /**\n    *@dev add an account into the blacklist and only EG network can add it\n    *       in the EG network contract, only operation admin can add it\n    *@params address - account\n    */\n    function blacklistAddress(address account) public onlyEGNetwork {\n        require(! isBlacklist(account),\"Account is already in a blacklist\");\n        _blacklist[account] = true;\n        emit BlacklistAddress(account);\n    }\n\n    /**\n    *@dev only BlacklistController is able to deblacklist account\n    *@param address - unblacklist account\n    */\n    function deBlacklistAddress(address account) public onlyBlackListController {\n        require(isBlacklist(account),\"Account is not in a blacklist\");\n        _blacklist[account] = false;\n        emit DeBlacklistAddress(account);\n    }\n\n    /**\n    *@dev    ERC223 features https://github.com/Dexaran/ERC223-token-standard\n    *       only unblacklist account and recipient can transfer or receive token\n    *        Invokes the \"tokenFallback\u0027 function if the recipient is a contract.\n    *           The token transfer fails if the recipient is a contract but does not implement the \"tokenFallback\" function\n    *           or the fallback function to receive fund.\n    *@params    address of recipient and amount\n    */\n    function transfer(address recipient, uint256 amount)\n    public\n    onlyNotBlacklist(msg.sender)\n    onlyNotBlacklist(recipient)\n    returns (bool) {\n        uint codeLength;\n        bytes memory empty;\n\n        assembly {\n            // Retrieve the size of the code on target address, this needs assembly\n            codeLength := extcodesize(recipient)\n        }\n\n        super.transfer(recipient, amount);\n\n        if(codeLength \u003e 0) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(recipient);\n            receiver.tokenFallback(msg.sender, amount, empty);\n        }\n\n        return true;\n    }\n\n\n    /**\n    *@dev   only unblacklist account and recipient can transfer and  receive token\n    *@params    address of sender, recipient, amount\n    */\n    function transferFrom(address sender, address recipient, uint256 amount)\n    public\n    onlyNotBlacklist(sender)\n    onlyNotBlacklist(recipient)\n    returns (bool) {\n        return super.transferFrom(sender, recipient,amount);\n    }\n\n    /**\n    *@dev onlyNotBlacklist can approve for other doing transfer\n    *@params address spender, amount\n    */\n    function approve(address spender, uint256 value) public onlyNotBlacklist(spender) returns (bool) {\n        return super.approve(spender, value);\n    }\n\n\n    /**\n    *@dev onlyNotBlacklist can increase allowances\n    *@params address spender, addedValue\n    */\n    function increaseAllowance(address spender, uint256 addedValue) public onlyNotBlacklist(spender) returns (bool) {\n        return super.increaseAllowance(spender, addedValue);\n    }\n\n    /**\n    *@dev onlyNotBlacklist can decrease allowances\n    *@params address spender, subtractedValue\n    */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public onlyNotBlacklist(spender) returns (bool) {\n        return super.decreaseAllowance(spender, subtractedValue);\n    }\n\n\n    /**\n    * @dev any can destroy token, even the blacklist guys.\n    *\n    * See `ERC20._burn`.\n    */\n    function burn(uint256 amount) public {\n        _burn(msg.sender, amount);\n    }\n\n    /**\n     * @dev See `ERC20._burnFrom`.\n     */\n    function burnFrom(address account, uint256 amount) public {\n        _burnFrom(account, amount);\n    }\n\n\n    /**\n    *@dev only blacklist controller is able to burn the blacklist token\n    *@param blacklist address\n    *@param amount of EG token will be burnt from the blacklist\n    */\n    function burnBlacklistToken(address blacklistAccount, uint256 burnAmount) public onlyBlackListController {\n        require(isBlacklist(blacklistAccount),\"Account is not in blacklist\");\n        require(burnAmount \u003c= balanceOf(blacklistAccount),\"Burn amount is over the black balance\");\n        _burn(blacklistAccount, burnAmount);\n        emit BurnBlacklistToken(blacklistAccount, burnAmount);\n    }\n\n\n\n    /**\n    *@dev only EGT generator listed on EGT network is able to minted token\n    *     implete ERC223 features for minted wallet who has the features ERC223\n    *@params targeted account received token - usually a multi-sign wallet\n    *@param amount of EG token is minted\n    */\n    function mint(address account, uint256 amount) public onlyEGNetwork returns (bool) {\n        uint codeLength;\n        // add empty data to backwards compatibility with ERC20\n        bytes memory empty;\n\n        assembly {\n            // Retrieve the size of the code on target address, this needs assembly\n            codeLength := extcodesize(account)\n        }\n\n        _mint(account, amount);\n\n        if(codeLength \u003e 0) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(account);\n            receiver.tokenFallback(msg.sender, amount, empty);\n        }\n\n        return true;\n    }\n\n\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./IERC20.sol\";\nimport \"../SafeMath.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in `IERC20.approve`.\n     *\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destoys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller\u0027s allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\n"},"ERC223FullReceivingContract.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n*@dev Contract that is working with ERC223 tokens\n*/\ncontract ERC223FullReceivingContract {\n    struct TKN {\n        address sender;\n        uint value;\n        bytes data;\n        bytes4 sig;\n    }\n\n\n    function tokenFallback(address _from, uint _value, bytes memory _data) public pure {\n        TKN memory tkn;\n        tkn.sender = _from;\n        tkn.value = _value;\n        tkn.data = _data;\n       // uint32 u = uint32(_data[3]) + (uint32(_data[2]) \u003c\u003c 8) + (uint32(_data[1]) \u003c\u003c 16) + (uint32(_data[0]) \u003c\u003c 24);\n       // tkn.sig = bytes4(u);\n\n        /* tkn variable is analogue of msg variable of Ether transaction\n        *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender)\n        *  tkn.value the number of tokens that were sent   (analogue of msg.value)\n        *  tkn.data is data of token transaction   (analogue of msg.data)\n        *  tkn.sig is 4 bytes signature of function\n        *  if data of token transaction is a function execution\n        */\n    }\n}\n"},"ERC223ReceivingContract.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n*@title Contract that will work with ERC223 tokens\n*/\ncontract ERC223ReceivingContract {\n\n    /**\n    *@dev Standard ERC223 function that will handle incoming token transfers\n    *\n    *@param from Token sender address\n    *@param value Amount of tokens\n    *@param data    Transaction metadata.\n    */\n    function tokenFallback(address from, uint value, bytes memory data) public;\n}\n"},"IEGToken.sol":{"content":"pragma solidity ^0.5.0;\n\ninterface IEGToken {\n\n    function mint(address account, uint256 amount) external returns (bool);\n\n    function deBlacklistAddress(address account) external;\n\n    function burnBlacklistToken(address blacklistAddress, uint256 burnAmount) external;\n\n    function updateSuperAdmin(address newSuperAdmin) external;\n\n    function burn(uint256 amount) external;\n\n    function balanceOf(address account) external returns(uint256);\n\n\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * \u003e Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"Math.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n"}}