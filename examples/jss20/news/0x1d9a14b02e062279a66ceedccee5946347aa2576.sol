{"Address.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract\u0027s constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * \u003e It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size \u003e 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` into `address payable`. Note that this is\r\n     * simply a type cast: the actual underlying value is not changed.\r\n     */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n}\r\n"},"CryptoHarborExchangeGameToken.sol":{"content":"pragma solidity ^0.5.1;\r\n\r\n\r\nimport \"./ERC223Token.sol\";\r\n\r\ncontract  CryptoHarborExchangeGameToken is ERC223Token {\r\n\r\n    string public name = \"CryptoHarborExchangeGameToken\";\r\n\r\n    string public symbol = \"CHEG\";\r\n\r\n    uint public decimals = 8;\r\n\r\n    uint256 public initialSupply = 1e8 * 1e8;\r\n\r\n    uint256 public _totalSupply;\r\n    \r\n    address public owner;\r\n    \r\n    bool public mintingFinished;\r\n\r\n    mapping (address =\u003e bool) public frozenAccount;\r\n    mapping (address =\u003e uint256) public unlockUnixTime;\r\n    event FrozenFunds(address indexed target, bool frozen);\r\n    event LockedFunds(address indexed target, uint256 locked);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Burn(address indexed from, uint256 amount);\r\n    event Mint(address indexed _to, uint256 _unitAmount);\r\n    event MintFinished();\r\n\r\n    constructor() public {\r\n        _totalSupply = initialSupply;\r\n        balances[msg.sender] = initialSupply;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _from The address that will burn the tokens.\r\n     * @param _unitAmount The amount of token to be burned.\r\n     */\r\n    function burn(address _from, uint256 _unitAmount) onlyOwner public {\r\n        require(_unitAmount \u003e 0\r\n                \u0026\u0026 balances[_from] \u003e= _unitAmount);\r\n\r\n        balances[_from] = balances[_from].sub(_unitAmount);\r\n        _totalSupply = _totalSupply.sub(_unitAmount);\r\n        emit Burn(_from, _unitAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to mint tokens\r\n     * @param _to The address that will receive the minted tokens.\r\n     * @param _unitAmount The amount of tokens to mint.\r\n     */\r\n    \r\n    function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {\r\n        require(_unitAmount \u003e 0);\r\n        \r\n        _totalSupply = _totalSupply.add(_unitAmount);\r\n        balances[_to] = balances[_to].add(_unitAmount);\r\n        emit Mint(_to, _unitAmount);\r\n        emit Transfer(address(0), _to, _unitAmount);\r\n        return true;\r\n    }\r\n    \r\n        modifier canMint() {\r\n        require(!mintingFinished);\r\n        _;\r\n    }\r\n   \r\n       /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    } \r\n    \r\n        /**\r\n     * @dev Function to stop minting new tokens.\r\n     */\r\n    function finishMinting() onlyOwner canMint public returns (bool) {\r\n        mintingFinished = true;\r\n        emit MintFinished();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent targets from sending or receiving tokens\r\n     * @param targets Addresses to be frozen\r\n     * @param isFrozen either to freeze it or not\r\n     */\r\n    function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length \u003e 0);\r\n\r\n        for (uint j = 0; j \u003c targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Prevent targets from sending or receiving tokens by setting Unix times\r\n     * @param targets Addresses to be locked funds\r\n     * @param unixTimes Unix times when locking up will be finished\r\n     */\r\n    function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length \u003e 0\r\n                \u0026\u0026 targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j \u003c targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] \u003c unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value \u003e 0\r\n                \u0026\u0026 frozenAccount[msg.sender] == false \r\n                \u0026\u0026 frozenAccount[_to] == false\r\n                \u0026\u0026 now \u003e unlockUnixTime[msg.sender] \r\n                \u0026\u0026 now \u003e unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Standard function transfer similar to ERC20 transfer with no _data\r\n     *      Added due to backwards compatibility reasons\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(_value \u003e 0\r\n                \u0026\u0026 frozenAccount[msg.sender] == false \r\n                \u0026\u0026 frozenAccount[_to] == false\r\n                \u0026\u0026 now \u003e unlockUnixTime[msg.sender] \r\n                \u0026\u0026 now \u003e unlockUnixTime[_to]);\r\n\r\n        bytes memory empty;\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, empty);\r\n        }\r\n    }\r\n\r\n    // assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length \u003e 0);\r\n    }\r\n\r\n    // function that is called when transaction target is an address\r\n    function transferToAddress(address _to, uint _value, bytes memory  _data) private returns (bool success) {\r\n        require(balances[msg.sender] \u003e= _value);\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n}"},"ERC223Token.sol":{"content":"pragma solidity ^0.5.1;\r\n\r\nimport \"./IERC223.sol\";\r\nimport \"./IERC223Recipient.sol\";\r\nimport \"./safeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title Reference implementation of the ERC223 standard token.\r\n */\r\ncontract ERC223Token is IERC223 {\r\n    using SafeMath for uint;\r\n\r\n    /**\r\n     * @dev See `IERC223.totalSupply`.\r\n     */\r\n     /*\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    */\r\n\r\n    mapping(address =\u003e uint) balances; // List of user balances.\r\n    \r\n    /**\r\n     * @dev Transfer the specified amount of tokens to the specified address.\r\n     *      Invokes the `tokenFallback` function if the recipient is a contract.\r\n     *      The token transfer fails if the recipient is a contract\r\n     *      but does not implement the `tokenFallback` function\r\n     *      or the fallback function to receive funds.\r\n     *\r\n     * @param _to    Receiver address.\r\n     * @param _value Amount of tokens that will be transferred.\r\n     * @param _data  Transaction metadata.\r\n     */\r\n    function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer the specified amount of tokens to the specified address.\r\n     *      This function works the same with the previous one\r\n     *      but doesn\u0027t contain `_data` param.\r\n     *      Added due to backwards compatibility reasons.\r\n     *\r\n     * @param _to    Receiver address.\r\n     * @param _value Amount of tokens that will be transferred.\r\n     */\r\n    function transfer(address _to, uint _value) public returns (bool success){\r\n        bytes memory empty = hex\"00000000\";\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, empty);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, empty);\r\n        return true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Returns balance of the `_owner`.\r\n     *\r\n     * @param _owner   The address whose balance will be returned.\r\n     * @return balance Balance of the `_owner`.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n}\r\n"},"IERC223.sol":{"content":"    \r\npragma solidity ^0.5.1;\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * [ERC1820 registry standard](https://eips.ethereum.org/EIPS/eip-1820) to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See `IERC1820Registry` and\r\n * `ERC1820Implementer`.\r\n */\r\n\r\ncontract IERC223 {\r\n    /**\r\n     * @dev Returns the total supply of the token.\r\n     */\r\n    uint public _totalSupply;\r\n    \r\n    /**\r\n     * @dev Returns the balance of the `who` address.\r\n     */\r\n    function balanceOf(address who) public view returns (uint);\r\n        \r\n    /**\r\n     * @dev Transfers `value` tokens from `msg.sender` to `to` address\r\n     * and returns `true` on success.\r\n     */\r\n    function transfer(address to, uint value) public returns (bool success);\r\n        \r\n    /**\r\n     * @dev Transfers `value` tokens from `msg.sender` to `to` address with `data` parameter\r\n     * and returns `true` on success.\r\n     */\r\n    function transfer(address to, uint value, bytes memory data) public returns (bool success);\r\n     \r\n     /**\r\n     * @dev Event that is fired on successful transfer.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n"},"IERC223Recipient.sol":{"content":"pragma solidity ^0.5.1;\r\n\r\n /**\r\n * @title Contract that will work with ERC223 tokens.\r\n */\r\n \r\ncontract IERC223Recipient { \r\n/**\r\n * @dev Standard ERC223 function that will handle incoming token transfers.\r\n *\r\n * @param _from  Token sender address.\r\n * @param _value Amount of tokens.\r\n * @param _data  Transaction metadata.\r\n */\r\n    function tokenFallback(address _from, uint _value, bytes memory _data) public;\r\n}\r\n"},"safeMath.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n"}}