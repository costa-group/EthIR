{"ForkDelta.sol":{"content":"pragma solidity 0.4.19;\n\nimport \"./IToken.sol\";\nimport \"./LSafeMath.sol\";\n\n/**\n * @title ForkDelta\n * @dev This is the main contract for the ForkDelta exchange.\n */\ncontract ForkDelta {\n  \n  using LSafeMath for uint;\n\n  /// Variables\n  address public admin; // the admin address\n  address public feeAccount; // the account that will receive fees\n  uint public feeTake; // percentage times (1 ether)\n  uint public freeUntilDate; // date in UNIX timestamp that trades will be free until\n  bool private depositingTokenFlag; // True when Token.transferFrom is being called from depositToken\n  mapping (address =\u003e mapping (address =\u003e uint)) public tokens; // mapping of token addresses to mapping of account balances (token=0 means Ether)\n  mapping (address =\u003e mapping (bytes32 =\u003e bool)) public orders; // mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\n  mapping (address =\u003e mapping (bytes32 =\u003e uint)) public orderFills; // mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\n  address public predecessor; // Address of the previous version of this contract. If address(0), this is the first version\n  address public successor; // Address of the next version of this contract. If address(0), this is the most up to date version.\n  uint16 public version; // This is the version # of the contract\n\n  /// Logging Events\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n  event Deposit(address token, address user, uint amount, uint balance);\n  event Withdraw(address token, address user, uint amount, uint balance);\n  event FundsMigrated(address user, address newContract);\n\n  /// This is a modifier for functions to check if the sending user address is the same as the admin user address.\n  modifier isAdmin() {\n      require(msg.sender == admin);\n      _;\n  }\n\n  /// Constructor function. This is only called on contract creation.\n  function ForkDelta(address admin_, address feeAccount_, uint feeTake_, uint freeUntilDate_, address predecessor_) public {\n    admin = admin_;\n    feeAccount = feeAccount_;\n    feeTake = feeTake_;\n    freeUntilDate = freeUntilDate_;\n    depositingTokenFlag = false;\n    predecessor = predecessor_;\n    \n    if (predecessor != address(0)) {\n      version = ForkDelta(predecessor).version() + 1;\n    } else {\n      version = 1;\n    }\n  }\n\n  /// The fallback function. Ether transfered into the contract is not accepted.\n  function() public {\n    revert();\n  }\n\n  /// Changes the official admin user address. Accepts Ethereum address.\n  function changeAdmin(address admin_) public isAdmin {\n    require(admin_ != address(0));\n    admin = admin_;\n  }\n\n  /// Changes the account address that receives trading fees. Accepts Ethereum address.\n  function changeFeeAccount(address feeAccount_) public isAdmin {\n    feeAccount = feeAccount_;\n  }\n\n  /// Changes the fee on takes. Can only be changed to a value less than it is currently set at.\n  function changeFeeTake(uint feeTake_) public isAdmin {\n    require(feeTake_ \u003c= feeTake);\n    feeTake = feeTake_;\n  }\n\n  /// Changes the date that trades are free until. Accepts UNIX timestamp.\n  function changeFreeUntilDate(uint freeUntilDate_) public isAdmin {\n    freeUntilDate = freeUntilDate_;\n  }\n  \n  /// Changes the successor. Used in updating the contract.\n  function setSuccessor(address successor_) public isAdmin {\n    require(successor_ != address(0));\n    successor = successor_;\n  }\n  \n  ////////////////////////////////////////////////////////////////////////////////\n  // Deposits, Withdrawals, Balances\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n  * This function handles deposits of Ether into the contract.\n  * Emits a Deposit event.\n  * Note: With the payable modifier, this function accepts Ether.\n  */\n  function deposit() public payable {\n    tokens[0][msg.sender] = tokens[0][msg.sender].add(msg.value);\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n  }\n\n  /**\n  * This function handles withdrawals of Ether from the contract.\n  * Verifies that the user has enough funds to cover the withdrawal.\n  * Emits a Withdraw event.\n  * @param amount uint of the amount of Ether the user wishes to withdraw\n  */\n  function withdraw(uint amount) public {\n    require(tokens[0][msg.sender] \u003e= amount);\n    tokens[0][msg.sender] = tokens[0][msg.sender].sub(amount);\n    msg.sender.transfer(amount);\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n  }\n\n  /**\n  * This function handles deposits of Ethereum based tokens to the contract.\n  * Does not allow Ether.\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n  * Emits a Deposit event.\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n  * @param token Ethereum contract address of the token or 0 for Ether\n  * @param amount uint of the amount of the token the user wishes to deposit\n  */\n  function depositToken(address token, uint amount) public {\n    require(token != 0);\n    depositingTokenFlag = true;\n    require(IToken(token).transferFrom(msg.sender, this, amount));\n    depositingTokenFlag = false;\n    tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n\n  /**\n  * This function provides a fallback solution as outlined in ERC223.\n  * If tokens are deposited through depositToken(), the transaction will continue.\n  * If tokens are sent directly to this contract, the transaction is reverted.\n  * @param sender Ethereum address of the sender of the token\n  * @param amount amount of the incoming tokens\n  * @param data attached data similar to msg.data of Ether transactions\n  */\n  function tokenFallback( address sender, uint amount, bytes data) public returns (bool ok) {\n      if (depositingTokenFlag) {\n        // Transfer was initiated from depositToken(). User token balance will be updated there.\n        return true;\n      } else {\n        // Direct ECR223 Token.transfer into this contract not allowed, to keep it consistent\n        // with direct transfers of ECR20 and ETH.\n        revert();\n      }\n  }\n  \n  /**\n  * This function handles withdrawals of Ethereum based tokens from the contract.\n  * Does not allow Ether.\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n  * Emits a Withdraw event.\n  * @param token Ethereum contract address of the token or 0 for Ether\n  * @param amount uint of the amount of the token the user wishes to withdraw\n  */\n  function withdrawToken(address token, uint amount) public {\n    require(token != 0);\n    require(tokens[token][msg.sender] \u003e= amount);\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\n    require(IToken(token).transfer(msg.sender, amount));\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  /**\n  * Retrieves the balance of a token based on a user address and token address.\n  * @param token Ethereum contract address of the token or 0 for Ether\n  * @param user Ethereum address of the user\n  * @return the amount of tokens on the exchange for a given user address\n  */\n  function balanceOf(address token, address user) public constant returns (uint) {\n    return tokens[token][user];\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Trading\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n  * Stores the active order inside of the contract.\n  * Emits an Order event.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param expires uint of block number when this order should expire\n  * @param nonce arbitrary random number\n  */\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    orders[msg.sender][hash] = true;\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n  }\n\n  /**\n  * Facilitates a trade from one user to another.\n  * Requires that the transaction is signed properly, the trade isn\u0027t past its expiration, and all funds are present to fill the trade.\n  * Calls tradeBalances().\n  * Updates orderFills with the amount traded.\n  * Emits a Trade event.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * Note: amount is in amountGet / tokenGet terms.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param expires uint of block number when this order should expire\n  * @param nonce arbitrary random number\n  * @param user Ethereum address of the user who placed the order\n  * @param v part of signature for the order hash as signed by user\n  * @param r part of signature for the order hash as signed by user\n  * @param s part of signature for the order hash as signed by user\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\n  */\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    require((\n      (orders[user][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) \u0026\u0026\n      block.number \u003c= expires \u0026\u0026\n      orderFills[user][hash].add(amount) \u003c= amountGet\n    ));\n    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n    orderFills[user][hash] = orderFills[user][hash].add(amount);\n    Trade(tokenGet, amount, tokenGive, amountGive.mul(amount) / amountGet, user, msg.sender);\n  }\n\n  /**\n  * This is a private function and is only being called from trade().\n  * Handles the movement of funds when a trade occurs.\n  * Takes fees.\n  * Updates token balances for both buyer and seller.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * Note: amount is in amountGet / tokenGet terms.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param user Ethereum address of the user who placed the order\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\n  */\n  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n    \n    uint feeTakeXfer = 0;\n    \n    if (now \u003e= freeUntilDate) {\n      feeTakeXfer = amount.mul(feeTake).div(1 ether);\n    }\n    \n    tokens[tokenGet][msg.sender] = tokens[tokenGet][msg.sender].sub(amount.add(feeTakeXfer));\n    tokens[tokenGet][user] = tokens[tokenGet][user].add(amount);\n    tokens[tokenGet][feeAccount] = tokens[tokenGet][feeAccount].add(feeTakeXfer);\n    tokens[tokenGive][user] = tokens[tokenGive][user].sub(amountGive.mul(amount).div(amountGet));\n    tokens[tokenGive][msg.sender] = tokens[tokenGive][msg.sender].add(amountGive.mul(amount).div(amountGet));\n  }\n\n  /**\n  * This function is to test if a trade would go through.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * Note: amount is in amountGet / tokenGet terms.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param expires uint of block number when this order should expire\n  * @param nonce arbitrary random number\n  * @param user Ethereum address of the user who placed the order\n  * @param v part of signature for the order hash as signed by user\n  * @param r part of signature for the order hash as signed by user\n  * @param s part of signature for the order hash as signed by user\n  * @param amount uint amount in terms of tokenGet that will be \"buy\" in the trade\n  * @param sender Ethereum address of the user taking the order\n  * @return bool: true if the trade would be successful, false otherwise\n  */\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) public constant returns(bool) {\n    if (!(\n      tokens[tokenGet][sender] \u003e= amount \u0026\u0026\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) \u003e= amount\n      )) { \n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n  * This function checks the available volume for a given order.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param expires uint of block number when this order should expire\n  * @param nonce arbitrary random number\n  * @param user Ethereum address of the user who placed the order\n  * @param v part of signature for the order hash as signed by user\n  * @param r part of signature for the order hash as signed by user\n  * @param s part of signature for the order hash as signed by user\n  * @return uint: amount of volume available for the given order in terms of amountGet / tokenGet\n  */\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      (orders[user][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user) \u0026\u0026\n      block.number \u003c= expires\n      )) {\n      return 0;\n    }\n    uint[2] memory available;\n    available[0] = amountGet.sub(orderFills[user][hash]);\n    available[1] = tokens[tokenGive][user].mul(amountGet) / amountGive;\n    if (available[0] \u003c available[1]) {\n      return available[0];\n    } else {\n      return available[1];\n    }\n  }\n\n  /**\n  * This function checks the amount of an order that has already been filled.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param expires uint of block number when this order should expire\n  * @param nonce arbitrary random number\n  * @param user Ethereum address of the user who placed the order\n  * @param v part of signature for the order hash as signed by user\n  * @param r part of signature for the order hash as signed by user\n  * @param s part of signature for the order hash as signed by user\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n  */\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) public constant returns(uint) {\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    return orderFills[user][hash];\n  }\n\n  /**\n  * This function cancels a given order by editing its fill data to the full amount.\n  * Requires that the transaction is signed properly.\n  * Updates orderFills to the full amountGet\n  * Emits a Cancel event.\n  * Note: tokenGet \u0026 tokenGive can be the Ethereum contract address.\n  * @param tokenGet Ethereum contract address of the token to receive\n  * @param amountGet uint amount of tokens being received\n  * @param tokenGive Ethereum contract address of the token to give\n  * @param amountGive uint amount of tokens being given\n  * @param expires uint of block number when this order should expire\n  * @param nonce arbitrary random number\n  * @param v part of signature for the order hash as signed by user\n  * @param r part of signature for the order hash as signed by user\n  * @param s part of signature for the order hash as signed by user\n  * @return uint: amount of the given order that has already been filled in terms of amountGet / tokenGet\n  */\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    require ((orders[msg.sender][hash] || ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == msg.sender));\n    orderFills[msg.sender][hash] = amountGet;\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n\n\n  \n  ////////////////////////////////////////////////////////////////////////////////\n  // Contract Versioning / Migration\n  ////////////////////////////////////////////////////////////////////////////////\n  \n  /**\n  * User triggered function to migrate funds into a new contract to ease updates.\n  * Emits a FundsMigrated event.\n  * @param newContract Contract address of the new contract we are migrating funds to\n  * @param tokens_ Array of token addresses that we will be migrating to the new contract\n  */\n  function migrateFunds(address newContract, address[] tokens_) public {\n  \n    require(newContract != address(0));\n    \n    ForkDelta newExchange = ForkDelta(newContract);\n\n    // Move Ether into new exchange.\n    uint etherAmount = tokens[0][msg.sender];\n    if (etherAmount \u003e 0) {\n      tokens[0][msg.sender] = 0;\n      newExchange.depositForUser.value(etherAmount)(msg.sender);\n    }\n\n    // Move Tokens into new exchange.\n    for (uint16 n = 0; n \u003c tokens_.length; n++) {\n      address token = tokens_[n];\n      require(token != address(0)); // Ether is handled above.\n      uint tokenAmount = tokens[token][msg.sender];\n      \n      if (tokenAmount != 0) {      \n      \trequire(IToken(token).approve(newExchange, tokenAmount));\n      \ttokens[token][msg.sender] = 0;\n      \tnewExchange.depositTokenForUser(token, tokenAmount, msg.sender);\n      }\n    }\n\n    FundsMigrated(msg.sender, newContract);\n  }\n  \n  /**\n  * This function handles deposits of Ether into the contract, but allows specification of a user.\n  * Note: This is generally used in migration of funds.\n  * Note: With the payable modifier, this function accepts Ether.\n  */\n  function depositForUser(address user) public payable {\n    require(user != address(0));\n    require(msg.value \u003e 0);\n    tokens[0][user] = tokens[0][user].add(msg.value);\n  }\n  \n  /**\n  * This function handles deposits of Ethereum based tokens into the contract, but allows specification of a user.\n  * Does not allow Ether.\n  * If token transfer fails, transaction is reverted and remaining gas is refunded.\n  * Note: This is generally used in migration of funds.\n  * Note: Remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n  * @param token Ethereum contract address of the token\n  * @param amount uint of the amount of the token the user wishes to deposit\n  */\n  function depositTokenForUser(address token, uint amount, address user) public {\n    require(token != address(0));\n    require(user != address(0));\n    require(amount \u003e 0);\n    depositingTokenFlag = true;\n    require(IToken(token).transferFrom(msg.sender, this, amount));\n    depositingTokenFlag = false;\n    tokens[token][user] = tokens[token][user].add(amount);\n  }\n  \n}"},"IToken.sol":{"content":"pragma solidity 0.4.19;\n\n/**\n * @title Token\n * @dev Token interface necessary for working with tokens within the exchange contract.\n */\ncontract IToken {\n  /// @return total amount of tokens\n  function totalSupply() public constant returns (uint256 supply) {}\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) public constant returns (uint256 balance) {}\n\n  /// @notice send `_value` token to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of token to be transferred\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) public returns (bool success) {}\n\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of token to be transferred\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of wei to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens allowed to spent\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n  uint public decimals;\n  string public name;\n}"},"LSafeMath.sol":{"content":"pragma solidity 0.4.19;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary LSafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    require(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003e 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003c= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a);\n    return c;\n  }\n}"},"Migrations.sol":{"content":"pragma solidity 0.4.19;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"}}