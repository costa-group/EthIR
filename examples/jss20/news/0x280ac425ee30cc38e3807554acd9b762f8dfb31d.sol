{"Distribute.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity \u003e=0.4.23 \u003c0.7.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\npragma solidity \u003e=0.4.23 \u003c0.7.0;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b \u003c= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c \u003e= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\npragma solidity \u003e=0.4.23 \u003c0.7.0;\r\n\r\n\r\n/*\r\n--------------------------------------------------------------------------\r\n-        Distribution Contract for the Analys-X (XYS) Token              -\r\n-                   Written by: Admirral                                 -\r\n-                     ~~~~~~~~~~~~~~~~                                   -\r\n-    This contract will track XYS stakers and distribute payments        -\r\n-    received from users who purchase Analys-X products. All payments    -\r\n-    will be received in XYS tokens.                                     -\r\n-                                                                        -\r\n-    Only 100 stakers will be allowed at any one time.                   -\r\n-    When a new user stakes, the oldest on the list is removed and       -\r\n-    they receive their stake back. The price to stake                   -\r\n-    increases by 1% after each new stake.                               -\r\n-                                                                        -\r\n-    When product fees are collected, 90% of that fee is redistributed   -\r\n-    to the 100 addresses on the list.                                   -\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\ncontract Distribute is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    // EVENTS\r\n    event Stake(address indexed user);\r\n    event Purchase(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user);\r\n\r\n    //basic identifiers - ERC20 Standard\r\n    string public name = \"ANALYSX\";\r\n    string public symbol = \"XYS\";\r\n    uint256 public decimals = 6;\r\n\r\n    //total Supply - currently 40\u0027000\u0027000\r\n    uint256 private _totalSupply = 40000000 * (10 ** decimals);\r\n\r\n    // balances and allowance - ERC20 Standard\r\n    mapping (address =\u003e uint256) private _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    // Staked Token Tracking\r\n    mapping (address =\u003e uint256) public _staked;\r\n\r\n    // Users earnings from staking\r\n    mapping (address =\u003e uint256) private _earned;\r\n\r\n    // Is user on staking list? \r\n    mapping (address =\u003e bool) public _isStaked;\r\n\r\n    // Stake List\r\n    address[100] private _stakeList;\r\n\r\n    // initial staking fee\r\n    uint256 public _initialFee = 100000 * (10 ** decimals);\r\n\r\n    // Current Staking Fee\r\n    uint256 public _stakeFee;\r\n\r\n    // Total Amount Staked;\r\n    uint256 public _totalStaked;\r\n\r\n    // Time of Previous Staker\r\n    uint256 public _lastStakerTime;\r\n\r\n    // Contract owner Address\r\n    address payable _owner;\r\n\r\n\r\n    // Constructor\r\n    constructor(address payable owner) public {\r\n\r\n        // mints tokens\r\n        _mint(owner, _totalSupply);\r\n\r\n        // Sets owner of contract\r\n        _owner = owner;  \r\n\r\n        // Sets staking fee to initial amount             \r\n        _stakeFee = _initialFee;\r\n\r\n        // initiates time of most recent staker\r\n        _lastStakerTime = block.timestamp;\r\n\r\n        // fills stakeList with owner.\r\n        for (uint i = 0; i \u003c= 99; i++) {\r\n            _stakeList[i] = _owner;\r\n        }\r\n\r\n    }\r\n\r\n    // ---------------------------------\r\n    // --       ERC20 Functions       --\r\n    // --        Open Zeppelin        --\r\n    // ---------------------------------\r\n\r\n    function totalSupply() override public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) override public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) override public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n\r\n    // --------------------------------------\r\n    // --       Custom Functions           --\r\n    // --------------------------------------\r\n\r\n    // Owner modifier. Functions with this modifier can only be called by contract owner\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    } \r\n\r\n    // checks if the sending user is owner. Returns true or false\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    // change owner\r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n\r\n    // Returns users stake earnings\r\n    function checkReward() public view returns (uint256) {\r\n        return _earned[msg.sender];\r\n    }\r\n\r\n    // returns staker list\r\n    function showStakers() public view returns (address[100] memory) {\r\n        return _stakeList;\r\n    }\r\n\r\n    // Stake Function\r\n    function stake() public {\r\n        require(msg.sender != _owner, \"Owner cannot stake\");\r\n        require(_balances[msg.sender] \u003e= _stakeFee, \"Insufficient Tokens\");\r\n        require(_isStaked[msg.sender] == false, \"You are already staking\");\r\n        require(_staked[msg.sender] == 0, \"You have stake\"); // Maybe redundant?\r\n\r\n        // updates new stakers balances and records stake\r\n        _balances[msg.sender] = _balances[msg.sender].sub(_stakeFee);\r\n        _staked[msg.sender] = _stakeFee;\r\n        _totalStaked = _totalStaked.add(_stakeFee);\r\n\r\n        // updates staking fee\r\n        uint256 stakeIncrease = _stakeFee.div(100);\r\n        _stakeFee = _stakeFee.add(stakeIncrease);\r\n        _lastStakerTime = block.timestamp;\r\n\r\n        // updates stake list\r\n        updateStaking();\r\n\r\n        emit Stake(msg.sender);\r\n\r\n    }\r\n    \r\n    // Remove a user from staking, and replace slot with _owner address\r\n    function exitStake() public returns(bool) {\r\n        require(msg.sender != _owner, \"owner cannot exit\");\r\n        require(_isStaked[msg.sender] == true, \"You are not staking\");\r\n        require(_staked[msg.sender] != 0, \"You don\u0027t have stake\"); // Maybe redundant?\r\n        \r\n        for (uint i = 0; i \u003c 99; i++) {\r\n            if (_stakeList[i] == msg.sender) {\r\n                _balances[msg.sender] = _balances[msg.sender].add(_earned[msg.sender]).add(_staked[msg.sender]);\r\n                _staked[msg.sender] = 0;\r\n                _earned[msg.sender] = 0;\r\n                _stakeList[i] = _owner;\r\n                _isStaked[msg.sender] = false;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //Adds new user to staking list, removes oldest user, returns their stake\r\n    function updateStaking() internal {\r\n\r\n        // Refunds the user at the end of the list\r\n        address lastUser = _stakeList[99];\r\n        _balances[lastUser] = _balances[lastUser].add(_staked[lastUser]);\r\n        _staked[lastUser] = 0;\r\n        _isStaked[lastUser] = false;\r\n        \r\n        // Gives the final user their collected rewards\r\n        _balances[lastUser] = _balances[lastUser].add(_earned[lastUser]);\r\n        _earned[lastUser] = 0;\r\n\r\n        // Updates positions on list\r\n        for (uint i = 99; i \u003e 0; i--) {\r\n            uint previous = i.sub(1);\r\n            address previousUser = _stakeList[previous];\r\n            _stakeList[i] = previousUser;\r\n        }\r\n\r\n        // Inserts new staker to top of list\r\n        _stakeList[0] = msg.sender;\r\n        _isStaked[msg.sender] = true;\r\n    }\r\n\r\n    // Function to purchase service (any price is possible, product is offerred off-chain)\r\n    function purchaseService(uint256 price, address purchaser) public {\r\n        \r\n        // Check if user has required balance\r\n        require (_balances[purchaser] \u003e= price, \"Insufficient funds\");\r\n        \r\n        // token value must be \u003e 0.001 to avoid computation errors)\r\n        require (price \u003e 1000, \"Value too Small\");\r\n\r\n        // 10% goes to owner (this can be adjusted)\r\n        uint256 ownerShare = price.div(10);\r\n        uint256 toSplit = price.sub(ownerShare);\r\n        uint256 stakeShare = toSplit.div(100);\r\n        _earned[_owner] = _earned[_owner].add(ownerShare);\r\n\r\n        // distributes funds to each staker, except the last one. \r\n        for (uint i = 0; i \u003c 99; i++) {\r\n            \r\n            // adds stakeShare to each user\r\n            _earned[_stakeList[i]] = _earned[_stakeList[i]].add(stakeShare);\r\n            \r\n            // We subtract from toSplit to produce a final amount for the final staker\r\n            toSplit = toSplit.sub(stakeShare);\r\n        }\r\n        \r\n        // toSplit should be equal or slightly higher than stakeShare. This is to avoid accidental burning.\r\n        _earned[_stakeList[99]] = _earned[_stakeList[99]].add(toSplit);\r\n        \r\n        // Remove the price from sender.\r\n        _balances[purchaser] = _balances[purchaser].sub(price);\r\n\r\n        emit Purchase(purchaser, price);\r\n    }\r\n\r\n    // Stakers can call this function to claim their funds without leaving the pool. \r\n    function withdraw() public {\r\n        require(_earned[msg.sender] \u003e 0, \"Stake some more\");\r\n        _balances[msg.sender] = _balances[msg.sender].add(_earned[msg.sender]);\r\n        _earned[msg.sender] = 0;\r\n\r\n        emit Withdraw(msg.sender);\r\n    }\r\n\r\n    // Resets staking price. Can only be usable if no new staker has entered the pool in 1 month (2592000 seconds)\r\n    function stakeReset() public  onlyOwner {\r\n        require(block.timestamp.sub(_lastStakerTime) \u003e= 2592000, \"not enough time has passed\");\r\n        _stakeFee = _initialFee;\r\n    }\r\n}"},"Monitoring.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED\"\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \u0027./Distribute.sol\u0027;\r\nimport \u0027./Owned.sol\u0027;\r\n\r\ncontract Monitoring is Owned{\r\n    \r\n    struct Register{\r\n        address _addressToMonitor;\r\n        uint256 _hours;\r\n        uint256 _startTime;\r\n    }\r\n    \r\n    mapping(address =\u003e Register[]) public userMonitoringAddresses;\r\n    mapping(address =\u003e uint256) public totalAddressMonitoring;\r\n    \r\n    Distribute public dst;\r\n    \r\n    uint256 _perHour = 500; // multiplied by 10 already\r\n    \r\n    constructor(address _distributAddress, address payable _owner) public{\r\n        dst = Distribute(_distributAddress);\r\n        owner = _owner;\r\n    }\r\n\r\n    function startMonitoring(address _addressToMonitor, uint256 _hours) public {\r\n        require(_addressToMonitor != address(0));\r\n        require(_hours != 0);\r\n        \r\n        // Register\r\n        userMonitoringAddresses[msg.sender].push(Register({\r\n             _addressToMonitor: _addressToMonitor,\r\n             _hours: _hours,\r\n             _startTime: now\r\n        }));\r\n        \r\n        // make a purchase\r\n        dst.purchaseService(_calculatePrice(_hours), msg.sender);\r\n        \r\n        // increase total addresses monitoring by an address count\r\n        totalAddressMonitoring[msg.sender] = totalAddressMonitoring[msg.sender] + 1;\r\n    }\r\n    \r\n    function _calculatePrice(uint256 _hours) public view returns(uint256 _price){\r\n        return ((((_hours) * (_perHour))/10) * 10 ** (dst.decimals()));\r\n    }\r\n    \r\n    function changeHourlyRate(uint256 _rate) public onlyOwner{\r\n        _perHour = _rate;\r\n    }\r\n}"},"Owned.sol":{"content":"// \"SPDX-License-Identifier: UNLICENSED \"\r\npragma solidity ^0.6.0;\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n    }\r\n}"}}