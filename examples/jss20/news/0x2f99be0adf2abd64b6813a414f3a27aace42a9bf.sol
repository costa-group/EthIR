{"BytesLib.sol":{"content":"pragma solidity ^0.4.18;\n// from\n// https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n\n\nlibrary BytesLib {\n  function toAddress(bytes _bytes, uint _start) internal pure returns (address) {\n    require(_bytes.length \u003e= (_start + 20));\n    address tempAddress;\n\n    assembly {\n      tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n    }\n\n    return tempAddress;\n  }\n\n  function toUint(bytes _bytes, uint _start) internal pure returns (uint256) {\n    require(_bytes.length \u003e= (_start + 32));\n    uint256 tempUint;\n\n    assembly {\n      tempUint := mload(add(add(_bytes, 0x20), _start))\n    }\n\n    return tempUint;\n  }\n}\n"},"ERC223.sol":{"content":"pragma solidity ^0.4.11;\n\nimport \"./SafeMath.sol\";\n\ncontract ERC223 {\n  uint public totalSupply;\n  function balanceOf(address who) constant public returns (uint);\n\n  function name() constant public returns (string _name);\n  function symbol() constant public returns (string _symbol);\n  function decimals() constant public returns (uint8 _decimals);\n  function totalSupply() constant public returns (uint256 _supply);\n\n  function transfer(address to, uint value) public returns (bool ok);\n  function transfer(address to, uint value, bytes data) public returns (bool ok);\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event ERC223Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\n}\n\ncontract ContractReceiver {\n  function tokenFallback(address _from, uint _value, bytes _data) public;\n}\n\ncontract ERC223I is ERC223 {\n  using SafeMath for uint;\n\n  mapping(address =\u003e uint) balances;\n\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n  uint256 public totalSupply;\n\n\n  function name() constant public returns (string _name) {\n    return name;\n  }\n  function symbol() constant public returns (string _symbol) {\n    return symbol;\n  }\n  function decimals() constant public returns (uint8 _decimals) {\n    return decimals;\n  }\n  function totalSupply() constant public returns (uint256 _totalSupply) {\n    return totalSupply;\n  }\n\n  function transfer(address _to, uint _value, bytes _data) public returns (bool success) {\n    if (isContract(_to)) {\n      return transferToContract(_to, _value, _data);\n    } else {\n      return transferToAddress(_to, _value, _data);\n    }\n  }\n\n  function transfer(address _to, uint _value) public returns (bool success) {\n    bytes memory empty;\n    if (isContract(_to)) {\n      return transferToContract(_to, _value, empty);\n    } else {\n      return transferToAddress(_to, _value, empty);\n    }\n  }\n\n  function isContract(address _addr) private view returns (bool is_contract) {\n    uint length;\n    assembly {\n      length := extcodesize(_addr)\n    }\n    return (length \u003e 0);\n  }\n\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) \u003c _value) revert();\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    balances[_to] = balanceOf(_to).add(_value);\n    Transfer(msg.sender, _to, _value);\n    ERC223Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) \u003c _value) revert();\n    balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    balances[_to] = balanceOf(_to).add(_value);\n    ContractReceiver reciever = ContractReceiver(_to);\n    reciever.tokenFallback(msg.sender, _value, _data);\n    Transfer(msg.sender, _to, _value);\n    ERC223Transfer(msg.sender, _to, _value, _data);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant public returns (uint balance) {\n    return balances[_owner];\n  }\n}\n"},"Exchange.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./SafeMath.sol\";\nimport \"./BytesLib.sol\";\nimport \"./ERC223.sol\";\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address holder) public view returns (uint);\n    function allowance(address holder, address other) public view returns (uint);\n\n    function approve(address other, uint amount) public returns (bool);\n    function transfer(address to, uint amount) public returns (bool);\n    function transferFrom(\n        address from, address to, uint amount\n    ) public returns (bool);\n}\n\ncontract Exchange is ContractReceiver {\n  using SafeMath for uint256;\n  using BytesLib for bytes;\n\n  bool private rentrancy_lock = false;\n  modifier nonReentrant() {\n    require(!rentrancy_lock);\n    rentrancy_lock = true;\n    _;\n    rentrancy_lock = false;\n  }\n\n  struct Order {\n    address owner;\n    bool    active;\n    address sellToken;\n    address buyToken;\n    address ring;\n    uint256 amount;\n    uint256 priceMul;\n    uint256 priceDiv;\n  }\n\n  // person =\u003e token =\u003e balance\n  mapping(address =\u003e mapping(address =\u003e uint256)) private balances;\n  mapping(uint256 =\u003e Order) private orderBook;\n  uint256 public orderCount;\n  address private etherAddress = 0x0;\n\n  address private saturnToken;\n  address private admin;\n  uint256 public tradeMiningBalance;\n  address public treasury;\n\n  uint256 public feeMul;\n  uint256 public feeDiv;\n  uint256 public tradeMiningMul;\n  uint256 public tradeMiningDiv;\n\n  event NewOrder(\n    uint256 id,\n    address owner,\n    address sellToken,\n    address buyToken,\n    address ring,\n    uint256 amount,\n    uint256 priceMul,\n    uint256 priceDiv,\n    uint256 time\n  );\n\n  event OrderCancelled(\n    uint256 id,\n    uint256 time\n  );\n\n  event OrderFulfilled(\n    uint256 id,\n    uint256 time\n  );\n\n  event Trade(\n    address from,\n    address to,\n    uint256 orderId,\n    uint256 soldTokens,\n    uint256 boughtTokens,\n    uint256 feePaid,\n    uint256 time\n  );\n\n  event Mined(\n    address trader,\n    uint256 amount,\n    uint256 time\n  );\n\n  function Exchange(\n    address _saturnToken,\n    address _treasury,\n    uint256 _feeMul,\n    uint256 _feeDiv,\n    uint256 _tradeMiningMul,\n    uint256 _tradeMiningDiv\n  ) public {\n    saturnToken    = _saturnToken;\n    treasury       = _treasury;\n    feeMul         = _feeMul;\n    feeDiv         = _feeDiv;\n    tradeMiningMul = _tradeMiningMul;\n    tradeMiningDiv = _tradeMiningDiv;\n    admin          = msg.sender;\n  }\n\n  function() payable public { revert(); }\n\n  //////////////////\n  // public views //\n  //////////////////\n  // add views for prices too\n  // and for order owner too\n\n  function getBalance(address token, address user) view public returns(uint256) {\n    return balances[user][token];\n  }\n\n  function isOrderActive(uint256 orderId) view public returns(bool) {\n    return orderBook[orderId].active;\n  }\n\n  function remainingAmount(uint256 orderId) view public returns(uint256) {\n    return orderBook[orderId].amount;\n  }\n\n  function getBuyTokenAmount(uint256 desiredSellTokenAmount, uint256 orderId) public view returns(uint256 amount) {\n    require(desiredSellTokenAmount \u003e 0);\n    Order storage order = orderBook[orderId];\n\n    if (order.sellToken == etherAddress || order.buyToken == etherAddress) {\n      uint256 feediff = feeDiv.sub(feeMul);\n      amount = desiredSellTokenAmount.mul(order.priceDiv).mul(feeDiv).div(order.priceMul).div(feediff);\n    } else {\n      amount = desiredSellTokenAmount.mul(order.priceDiv).div(order.priceMul);\n    }\n    require(amount \u003e 0);\n  }\n\n  function calcFees(uint256 amount, uint256 orderId) public view returns(uint256 fees) {\n    Order storage order = orderBook[orderId];\n\n    if (order.sellToken == etherAddress) {\n      uint256 sellTokenAmount = amount.mul(order.priceMul).div(order.priceDiv);\n      fees = sellTokenAmount.mul(feeMul).div(feeDiv);\n    } else if (order.buyToken == etherAddress) {\n      fees = amount.mul(feeMul).div(feeDiv);\n    } else {\n      fees = 0;\n    }\n    return fees;\n  }\n\n  function tradeMiningAmount(uint256 fees, uint256 orderId) public view returns(uint256) {\n    if (fees == 0) { return 0; }\n    Order storage order = orderBook[orderId];\n    if (!order.active) { return 0; }\n    uint256 tokenAmount = fees.mul(tradeMiningMul).div(tradeMiningDiv);\n\n    if (tradeMiningBalance \u003c tokenAmount) {\n      return tradeMiningBalance;\n    } else {\n      return tokenAmount;\n    }\n  }\n\n  ////////////////////\n  // public methods //\n  ////////////////////\n\n  function withdrawTradeMining() public {\n    if (msg.sender != admin) { revert(); }\n    require(tradeMiningBalance \u003e 0);\n\n    uint toSend = tradeMiningBalance;\n    tradeMiningBalance = 0;\n    require(sendTokensTo(admin, toSend, saturnToken));\n  }\n\n  function changeTradeMiningPrice(uint256 newMul, uint256 newDiv) public {\n    if (msg.sender != admin) { revert(); }\n    require(newDiv != 0);\n    tradeMiningMul = newMul;\n    tradeMiningDiv = newDiv;\n  }\n\n  // handle incoming ERC223 tokens\n  function tokenFallback(address from, uint value, bytes data) public {\n    // depending on length of data\n    // this should be either an order creating transaction\n    // or an order taking transaction\n    // or a transaction allocating tokens for trade mining\n    if (data.length == 0 \u0026\u0026 msg.sender == saturnToken) {\n      _topUpTradeMining(value);\n    } else if (data.length == 84) {\n      _newOrder(from, msg.sender, data.toAddress(64), value, data.toUint(0), data.toUint(32), etherAddress);\n    } else if (data.length == 104) {\n      _newOrder(from, msg.sender, data.toAddress(64), value, data.toUint(0), data.toUint(32), data.toAddress(84));\n    } else if (data.length == 32) {\n      _executeOrder(from, data.toUint(0), msg.sender, value);\n    } else {\n      // unknown payload!\n      revert();\n    }\n  }\n\n  function sellEther(\n    address buyToken,\n    uint256 priceMul,\n    uint256 priceDiv\n  ) public payable returns(uint256 orderId) {\n    require(msg.value \u003e 0);\n    return _newOrder(msg.sender, etherAddress, buyToken, msg.value, priceMul, priceDiv, etherAddress);\n  }\n\n  function sellEtherWithRing(\n    address buyToken,\n    uint256 priceMul,\n    uint256 priceDiv,\n    address ring\n  ) public payable returns(uint256 orderId) {\n    require(msg.value \u003e 0);\n    return _newOrder(msg.sender, etherAddress, buyToken, msg.value, priceMul, priceDiv, ring);\n  }\n\n  function buyOrderWithEth(uint256 orderId) public payable {\n    require(msg.value \u003e 0);\n    _executeOrder(msg.sender, orderId, etherAddress, msg.value);\n  }\n\n  function sellERC20Token(\n    address sellToken,\n    address buyToken,\n    uint256 amount,\n    uint256 priceMul,\n    uint256 priceDiv\n  ) public returns(uint256 orderId) {\n    require(amount \u003e 0);\n    require(pullTokens(sellToken, amount));\n    return _newOrder(msg.sender, sellToken, buyToken, amount, priceMul, priceDiv, etherAddress);\n  }\n\n  function sellERC20TokenWithRing(\n    address sellToken,\n    address buyToken,\n    uint256 amount,\n    uint256 priceMul,\n    uint256 priceDiv,\n    address ring\n  ) public returns(uint256 orderId) {\n    require(amount \u003e 0);\n    require(pullTokens(sellToken, amount));\n    return _newOrder(msg.sender, sellToken, buyToken, amount, priceMul, priceDiv, ring);\n  }\n\n  function buyOrderWithERC20Token(\n    uint256 orderId,\n    address token,\n    uint256 amount\n  ) public {\n    require(amount \u003e 0);\n    require(pullTokens(token, amount));\n    _executeOrder(msg.sender, orderId, token, amount);\n  }\n\n  function cancelOrder(uint256 orderId) public nonReentrant {\n    Order storage order = orderBook[orderId];\n    require(order.amount \u003e 0);\n    require(order.active);\n    require(msg.sender == order.owner);\n\n    balances[msg.sender][order.sellToken] = balances[msg.sender][order.sellToken].sub(order.amount);\n    require(sendTokensTo(order.owner, order.amount, order.sellToken));\n\n    // deleting the order refunds the caller some gas\n    // this also sets order.active to false\n    delete orderBook[orderId];\n    emit OrderCancelled(orderId, now);\n  }\n\n  /////////////////////\n  // private methods //\n  /////////////////////\n\n  function _newOrder(\n    address owner,\n    address sellToken,\n    address buyToken,\n    uint256 amount,\n    uint256 priceMul,\n    uint256 priceDiv,\n    address ring\n  ) private nonReentrant returns(uint256 orderId) {\n    /////////////////////////\n    // step 1. validations //\n    /////////////////////////\n    require(amount \u003e 0);\n    require(priceMul \u003e 0);\n    require(priceDiv \u003e 0);\n    require(sellToken != buyToken);\n    ///////////////////////////////\n    // step 2. Update order book //\n    ///////////////////////////////\n    orderId = orderCount++;\n    orderBook[orderId] = Order(owner, true, sellToken, buyToken, ring, amount, priceMul, priceDiv);\n    balances[owner][sellToken] = balances[owner][sellToken].add(amount);\n\n    emit NewOrder(orderId, owner, sellToken, buyToken, ring, amount, priceMul, priceDiv, now);\n  }\n\n  function _executeBuyOrder(address trader, uint256 orderId, uint256 buyTokenAmount) private returns(uint256) {\n    // buytoken: tkn\n    // selltoken: ether\n    Order storage order = orderBook[orderId];\n    uint256 sellTokenAmount = buyTokenAmount.mul(order.priceMul).div(order.priceDiv);\n    uint256 fees = sellTokenAmount.mul(feeMul).div(feeDiv);\n\n    require(sellTokenAmount \u003e 0);\n    require(sellTokenAmount \u003c= order.amount);\n    order.amount = order.amount.sub(sellTokenAmount);\n    // send tokens to order owner\n    require(sendTokensTo(order.owner, buyTokenAmount, order.buyToken));\n    // send ether to trader\n    require(sendTokensTo(trader, sellTokenAmount.sub(fees), order.sellToken));\n\n    emit Trade(trader, order.owner, orderId, sellTokenAmount.sub(fees), buyTokenAmount, fees, now);\n    return fees;\n  }\n\n  function _executeSellOrder(address trader, uint256 orderId, uint256 buyTokenAmount) private returns(uint256) {\n    // buytoken: ether\n    // selltoken: tkn\n    Order storage order = orderBook[orderId];\n    uint256 fees = buyTokenAmount.mul(feeMul).div(feeDiv);\n    uint256 sellTokenAmount = buyTokenAmount.sub(fees).mul(order.priceMul).div(order.priceDiv);\n\n\n    require(sellTokenAmount \u003e 0);\n    require(sellTokenAmount \u003c= order.amount);\n    order.amount = order.amount.sub(sellTokenAmount);\n    // send ether to order owner\n    require(sendTokensTo(order.owner, buyTokenAmount.sub(fees), order.buyToken));\n    // send token to trader\n    require(sendTokensTo(trader, sellTokenAmount, order.sellToken));\n\n    emit Trade(trader, order.owner, orderId, sellTokenAmount, buyTokenAmount.sub(fees), fees, now);\n    return fees;\n  }\n\n  function _executeTokenSwap(address trader, uint256 orderId, uint256 buyTokenAmount) private returns(uint256) {\n    // no ether was exchanged\n    Order storage order = orderBook[orderId];\n    uint256 sellTokenAmount = buyTokenAmount.mul(order.priceMul).div(order.priceDiv);\n\n    require(sellTokenAmount \u003e 0);\n    require(sellTokenAmount \u003c= order.amount);\n    order.amount = order.amount.sub(sellTokenAmount);\n\n    require(sendTokensTo(order.owner, buyTokenAmount, order.buyToken));\n    require(order.active);\n    require(sendTokensTo(trader, sellTokenAmount, order.sellToken));\n\n    emit Trade(trader, order.owner, orderId, sellTokenAmount, buyTokenAmount, 0, now);\n    return 0;\n  }\n\n  function _executeOrder(address trader, uint256 orderId, address buyToken, uint256 buyTokenAmount) private nonReentrant {\n    /////////////////////////\n    // step 0. validations //\n    /////////////////////////\n    require(orderId \u003c orderCount);\n    require(buyTokenAmount \u003e 0);\n    Order storage order = orderBook[orderId];\n    require(order.active);\n    require(trader != order.owner);\n    require(buyToken == order.buyToken);\n\n    // enforce exclusivity\n    if (order.ring != etherAddress) { require(order.ring == tx.origin); }\n\n    ////////////////////////////\n    // step 1. token exchange //\n    ////////////////////////////\n    uint256 fees;\n    if (order.sellToken == etherAddress) {\n      // buy order: taker sends ether, gets tokens\n      fees = _executeBuyOrder(trader, orderId, buyTokenAmount);\n    } else if (order.buyToken == etherAddress) {\n      // sell order: taker sends tokens, gets ether\n      fees = _executeSellOrder(trader, orderId, buyTokenAmount);\n    } else {\n      fees = _executeTokenSwap(trader, orderId, buyTokenAmount);\n    }\n\n    ////////////////////////////\n    // step 2. fees \u0026 wrap up //\n    ////////////////////////////\n    // collect fees and issue trade mining\n    require(_tradeMiningAndFees(fees, trader));\n    // deleting the order refunds the caller some gas\n    if (orderBook[orderId].amount == 0) {\n      delete orderBook[orderId];\n      emit OrderFulfilled(orderId, now);\n    }\n  }\n\n  function _tradeMiningAndFees(uint256 fees, address trader) private returns(bool) {\n    if (fees == 0) { return true; }\n    // step one: send fees to the treasury\n    require(sendTokensTo(treasury, fees, etherAddress));\n    if (tradeMiningBalance == 0) { return true; }\n\n    // step two: calculate reward\n    uint256 tokenAmount = fees.mul(tradeMiningMul).div(tradeMiningDiv);\n    if (tokenAmount == 0) { return true; }\n    if (tokenAmount \u003e tradeMiningBalance) { tokenAmount = tradeMiningBalance; }\n\n    // account for sent tokens\n    tradeMiningBalance = tradeMiningBalance.sub(tokenAmount);\n    // step three: send the reward to the trader\n    require(sendTokensTo(trader, tokenAmount, saturnToken));\n    emit Mined(trader, tokenAmount, now);\n    return true;\n  }\n\n  function sendTokensTo(address destination, uint256 amount, address tkn) private returns(bool) {\n    if (tkn == etherAddress) {\n      destination.transfer(amount);\n    } else {\n      // works with both ERC223 and ERC20\n      require(ERC20(tkn).transfer(destination, amount));\n    }\n    return true;\n  }\n\n  // ERC20 fixture\n  function pullTokens(address token, uint256 amount) private returns(bool) {\n    return ERC20(token).transferFrom(msg.sender, address(this), amount);\n  }\n\n  function _topUpTradeMining(uint256 amount) private returns(bool) {\n    tradeMiningBalance = tradeMiningBalance.add(amount);\n    return true;\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.18;\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}\n"}}