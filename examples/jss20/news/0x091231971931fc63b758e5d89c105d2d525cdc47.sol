{"AlumniStore.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\ncontract AlumniStore {\n    function getAlumniAddress(bytes32 _blockchainCertificateHash) public view returns (address payable _address){}\n}"},"OpenCertsStore.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\ncontract OpenCertsStore {\n    function isIssued(bytes32 document) public view returns (bool){}\n}"},"ScholarshipContract_V2.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\nimport \"./AlumniStore.sol\";\nimport \"./OpenCertsStore.sol\";\nimport \"./TokenContract.sol\";\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n}\n\ncontract ScholarshipContract_V2 {\n    using SafeMath for uint256;\n    OpenCertsStore openCertsStore;\n    AlumniStore alumniStore;\n    TokenContract tokenContract;\n\n    address payable owner;\n    uint256 bitDegreeFee = 3; //percent\n\n    constructor(address _openCertsStoreAddress, address _alumniStoreAddress, address _tokenContractAddress) public {\n        owner = msg.sender;\n        openCertsStore = OpenCertsStore(_openCertsStoreAddress);\n        alumniStore = AlumniStore(_alumniStoreAddress);\n        tokenContract = TokenContract(_tokenContractAddress);\n    }\n\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n\n    function() external payable {}\n\n    function changeOwner(address payable _newOwnerAddress) public onlyOwner returns (bool) {\n        owner = _newOwnerAddress;\n        return true;\n    }\n\n    function isCertificateIssued(bytes32 _blockchainCertificateHash) private view returns (address payable _address) {\n        if (openCertsStore.isIssued(_blockchainCertificateHash)) {\n            return alumniStore.getAlumniAddress(_blockchainCertificateHash);\n        } else {\n            return 0x0000000000000000000000000000000000000000;\n        }\n    }\n\n    function unlockScholarship(bytes32 _blockchainCertificateHash) public returns (bool){\n        uint256 toBitDegree = tokenContract.balanceOf(address(this)).mul(bitDegreeFee).div(100);\n        uint256 toStudent = tokenContract.balanceOf(address(this)).sub(toBitDegree);\n        address payable studentAddress = isCertificateIssued(_blockchainCertificateHash);\n        if (studentAddress != address(0x0)) {\n            tokenContract.transfer(studentAddress, toStudent);\n            tokenContract.transfer(owner, toBitDegree);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function refund() public onlyOwner returns (bool) {\n        tokenContract.transfer(owner,tokenContract.balanceOf(address(this)));\n        return true;\n    }\n\n    function selfDestruct() public onlyOwner {\n        selfdestruct(owner);\n    }\n}"},"TokenContract.sol":{"content":"pragma solidity \u003e=0.4.21 \u003c0.6.0;\n\ncontract TokenContract {\n    function balanceOf(address ownerAddress) public view returns (uint);\n    function transfer(address to, uint tokens) public returns (bool success);\n}"}}