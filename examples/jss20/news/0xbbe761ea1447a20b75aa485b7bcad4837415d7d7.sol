{"CALL.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./ERC777ERC20Compat.sol\";\nimport \"./SafeGuard.sol\";\nimport { CStore } from \"./CStore.sol\"; //TODO: Convert all imports like this\n\ncontract CALL is ERC777ERC20Compat, SafeGuard {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _granularity,\n        uint256 _totalSupply,\n        address _initialOwner,\n        address[] memory _defaultOperators\n    )\n    public ERC777ERC20Compat(_name, _symbol, _granularity, _totalSupply, _initialOwner, _defaultOperators)\n    {\n        requireMultiple(_totalSupply);\n        require(balancesDB.setModule(address(this), true), \"Cannot enable access to the database.\");\n        balancesDB.transferOwnership(_initialOwner);\n\n        callRecipient(msg.sender, address(0), _initialOwner, _totalSupply, \"\", \"\", true);\n\n        emit Minted(msg.sender, _initialOwner, _totalSupply, \"\", \"\");\n        if (mErc20compatible) { emit Transfer(address(0), _initialOwner, _totalSupply); }\n    }\n\n    /**\n     * @notice change the balances database to `_newDB`\n     * @param _newDB The new balances database address\n     */\n    function changeBalancesDB(address _newDB) public onlyOwner {\n        balancesDB = CStore(_newDB);\n    }\n\n    /**\n     * @notice Disables the ERC20 interface. This function can only be called\n     * by the owner.\n     */\n    function disableERC20() public onlyOwner {\n        mErc20compatible = false;\n        setInterfaceImplementation(\"ERC20Token\", address(0));\n    }\n\n    /**\n     * @notice Re enables the ERC20 interface. This function can only be called\n     *  by the owner.\n     */\n    function enableERC20() public onlyOwner {\n        mErc20compatible = true;\n        setInterfaceImplementation(\"ERC20Token\", address(this));\n    }\n\n    /**\n     * @dev Transfer the specified amounts of tokens to the specified addresses.\n     * @dev Be aware that there is no check for duplicate recipients.\n     * @param _toAddresses Receiver addresses.\n     * @param _amounts Amounts of tokens that will be transferred.\n     */\n    function multiPartyTransfer(address[] calldata _toAddresses, uint256[] calldata _amounts) external erc20 {\n        /* Ensures _toAddresses array is less than or equal to 255 */\n        require(_toAddresses.length \u003c= 255, \"Unsupported number of addresses.\");\n        /* Ensures _toAddress and _amounts have the same number of entries. */\n        require(_toAddresses.length == _amounts.length, \"Provided addresses does not equal to provided sums.\");\n\n        for (uint8 i = 0; i \u003c _toAddresses.length; i++) {\n            transfer(_toAddresses[i], _amounts[i]);\n        }\n    }\n\n    /**\n    * @dev Transfer the specified amounts of tokens to the specified addresses from authorized balance of sender.\n    * @dev Be aware that there is no check for duplicate recipients.\n    * @param _from The address of the sender\n    * @param _toAddresses The addresses of the recipients (MAX 255)\n    * @param _amounts The amounts of tokens to be transferred\n    */\n    function multiPartyTransferFrom(address _from, address[] calldata _toAddresses, uint256[] calldata _amounts) external erc20 {\n        /* Ensures _toAddresses array is less than or equal to 255 */\n        require(_toAddresses.length \u003c= 255, \"Unsupported number of addresses.\");\n        /* Ensures _toAddress and _amounts have the same number of entries. */\n        require(_toAddresses.length == _amounts.length, \"Provided addresses does not equal to provided sums.\");\n\n        for (uint8 i = 0; i \u003c _toAddresses.length; i++) {\n            transferFrom(_from, _toAddresses[i], _amounts[i]);\n        }\n    }\n\n    /**\n     * @dev Transfer the specified amounts of tokens to the specified addresses.\n     * @dev Be aware that there is no check for duplicate recipients.\n     * @param _toAddresses Receiver addresses.\n     * @param _amounts Amounts of tokens that will be transferred.\n     * @param _userData User supplied data\n     */\n    function multiPartySend(address[] memory _toAddresses, uint256[] memory _amounts, bytes memory _userData) public {\n        /* Ensures _toAddresses array is less than or equal to 255 */\n        require(_toAddresses.length \u003c= 255, \"Unsupported number of addresses.\");\n        /* Ensures _toAddress and _amounts have the same number of entries. */\n        require(_toAddresses.length == _amounts.length, \"Provided addresses does not equal to provided sums.\");\n\n        for (uint8 i = 0; i \u003c _toAddresses.length; i++) {\n            doSend(msg.sender,  msg.sender, _toAddresses[i], _amounts[i], _userData, \"\", true);\n        }\n    }\n\n    /**\n    * @dev Transfer the specified amounts of tokens to the specified addresses as `_from`.\n    * @dev Be aware that there is no check for duplicate recipients.\n    * @param _from Address to use as sender\n    * @param _to Receiver addresses.\n    * @param _amounts Amounts of tokens that will be transferred.\n    * @param _userData User supplied data\n    * @param _operatorData Operator supplied data\n    */\n    function multiOperatorSend(address _from, address[] calldata _to, uint256[] calldata _amounts, bytes calldata _userData, bytes calldata _operatorData)\n    external {\n        /* Ensures _toAddresses array is less than or equal to 255 */\n        require(_to.length \u003c= 255, \"Unsupported number of addresses.\");\n        /* Ensures _toAddress and _amounts have the same number of entries. */\n        require(_to.length == _amounts.length, \"Provided addresses does not equal to provided sums.\");\n\n        for (uint8 i = 0; i \u003c _to.length; i++) {\n            require(isOperatorFor(msg.sender, _from), \"Not an operator\"); //TODO check for denial of service\n            doSend(msg.sender, _from, _to[i], _amounts[i], _userData, _operatorData, true);\n        }\n    }\n}\n\n"},"Context.sol":{"content":"pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"CStore.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./ERC644Balances.sol\";\nimport { ERC1820Client } from \"./ERC1820Client.sol\";\n\n\n/**\n * @title ERC644 Database Contract\n * @author Panos\n */\ncontract CStore is ERC644Balances, ERC1820Client {\n\n    address[] internal mDefaultOperators;\n    mapping(address =\u003e bool) internal mIsDefaultOperator;\n    mapping(address =\u003e mapping(address =\u003e bool)) internal mRevokedDefaultOperator;\n    mapping(address =\u003e mapping(address =\u003e bool)) internal mAuthorizedOperators;\n\n    /**\n     * @notice Database construction\n     * @param _totalSupply The total supply of the token\n     */\n    constructor(uint256 _totalSupply, address _initialOwner, address[] memory _defaultOperators) public\n    {\n        balances[_initialOwner] = _totalSupply;\n        totalSupply = _totalSupply;\n        mDefaultOperators = _defaultOperators;\n        for (uint256 i = 0; i \u003c mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }\n\n        setInterfaceImplementation(\"ERC644Balances\", address(this));\n    }\n\n    /**\n     * @notice Increase total supply by `_val`\n     * @param _val Value to increase\n     * @return Operation status\n     */\n    // solhint-disable-next-line no-unused-vars\n    function incTotalSupply(uint _val) external onlyModule returns (bool) {\n        return false;\n    }\n\n    /**\n     * @notice Decrease total supply by `_val`\n     * @param _val Value to decrease\n     * @return Operation status\n     */\n     // solhint-disable-next-line no-unused-vars\n     function decTotalSupply(uint _val) external onlyModule returns (bool) {\n         return false;\n     }\n\n    /**\n     * @notice moving `_amount` from `_from` to `_to`\n     * @param _from The sender address\n     * @param _to The receiving address\n     * @param _amount The moving amount\n     * @return bool The move result\n     */\n    function move(address _from, address _to, uint256 _amount) external\n    onlyModule\n    returns (bool) {\n        balances[_from] = balances[_from].sub(_amount);\n        emit BalanceAdj(msg.sender, _from, _amount, \"-\");\n        balances[_to] = balances[_to].add(_amount);\n        emit BalanceAdj(msg.sender, _to, _amount, \"+\");\n        return true;\n    }\n\n    /**\n     * @notice Setting operator `_operator` for `_tokenHolder`\n     * @param _operator The operator to set status\n     * @param _tokenHolder The token holder to set operator\n     * @param _status The operator status\n     * @return bool Status of operation\n     */\n    function setAuthorizedOperator(address _operator, address _tokenHolder, bool _status) external\n    onlyModule\n    returns (bool) {\n        mAuthorizedOperators[_operator][_tokenHolder] = _status;\n        return true;\n    }\n\n    /**\n     * @notice Set revoke status for default operator `_operator` for `_tokenHolder`\n     * @param _operator The default operator to set status\n     * @param _tokenHolder The token holder to set operator\n     * @param _status The operator status\n     * @return bool Status of operation\n     */\n    function setRevokedDefaultOperator(address _operator, address _tokenHolder, bool _status) external\n    onlyModule\n    returns (bool) {\n    mRevokedDefaultOperator[_operator][_tokenHolder] = _status;\n        return true;\n    }\n\n    /**\n     * @notice Getting operator `_operator` for `_tokenHolder`\n     * @param _operator The operator address to get status\n     * @param _tokenHolder The token holder address\n     * @return bool Operator status\n     */\n    function getAuthorizedOperator(address _operator, address _tokenHolder) external\n    view\n    returns (bool) {\n        return mAuthorizedOperators[_operator][_tokenHolder];\n    }\n\n    /**\n     * @notice Getting default operator `_operator`\n     * @param _operator The default operator address to get status\n     * @return bool Default operator status\n     */\n    function getDefaultOperator(address _operator) external view returns (bool) {\n        return mIsDefaultOperator[_operator];\n    }\n\n    /**\n     * @notice Getting default operators\n     * @return address[] Default operator addresses\n     */\n    function getDefaultOperators() external view returns (address[] memory) {\n        return mDefaultOperators;\n    }\n\n    function getRevokedDefaultOperator(address _operator, address _tokenHolder) external view returns (bool) {\n        return mRevokedDefaultOperator[_operator][_tokenHolder];\n    }\n\n    /**\n     * @notice Increment `_acct` balance by `_val`\n     * @param _acct Target account to increment balance.\n     * @param _val Value to increment\n     * @return Operation status\n     */\n    // solhint-disable-next-line no-unused-vars\n    function incBalance(address _acct, uint _val) public onlyModule returns (bool) {\n        return false;\n    }\n\n    /**\n     * @notice Decrement `_acct` balance by `_val`\n     * @param _acct Target account to decrement balance.\n     * @param _val Value to decrement\n     * @return Operation status\n     */\n     // solhint-disable-next-line no-unused-vars\n     function decBalance(address _acct, uint _val) public onlyModule returns (bool) {\n         return false;\n     }\n}\n\n"},"ERC1820Client.sol":{"content":"pragma solidity ^0.5.3;\n\n\ncontract ERC1820Registry {\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external;\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address);\n    function setManager(address _addr, address _newManager) external;\n    function getManager(address _addr) public view returns (address);\n}\n\n\n/// Base client to interact with the registry.\ncontract ERC1820Client {\n    ERC1820Registry constant ERC1820REGISTRY = ERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\n    }\n\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\n    }\n\n    function delegateManagement(address _newManager) internal {\n        ERC1820REGISTRY.setManager(address(this), _newManager);\n    }\n}\n"},"ERC644Balances.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./SafeMath.sol\";\nimport \"./SafeGuard.sol\";\nimport \"./IERC644.sol\";\n\n\n/**\n * @title ERC644 Standard Balances Contract\n * @author chrisfranko\n */\ncontract ERC644Balances is IERC644, SafeGuard {\n    using SafeMath for uint256;\n\n    uint256 public totalSupply;\n\n    event BalanceAdj(address indexed module, address indexed account, uint amount, string polarity);\n    event ModuleSet(address indexed module, bool indexed set);\n\n    mapping(address =\u003e bool) public modules;\n    mapping(address =\u003e uint256) public balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowed;\n\n    modifier onlyModule() {\n        require(modules[msg.sender], \"ERC644Balances: caller is not a module\");\n        _;\n    }\n\n    /**\n     * @notice Set allowance of `_spender` in behalf of `_sender` at `_value`\n     * @param _sender Owner account\n     * @param _spender Spender account\n     * @param _value Value to approve\n     * @return Operation status\n     */\n    function setApprove(address _sender, address _spender, uint256 _value) external onlyModule returns (bool) {\n        allowed[_sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * @notice Decrease allowance of `_spender` in behalf of `_from` at `_value`\n     * @param _from Owner account\n     * @param _spender Spender account\n     * @param _value Value to decrease\n     * @return Operation status\n     */\n    function decApprove(address _from, address _spender, uint _value) external onlyModule returns (bool) {\n        allowed[_from][_spender] = allowed[_from][_spender].sub(_value);\n        return true;\n    }\n\n    /**\n    * @notice Increase total supply by `_val`\n    * @param _val Value to increase\n    * @return Operation status\n    */\n    function incTotalSupply(uint _val) external onlyModule returns (bool) {\n        totalSupply = totalSupply.add(_val);\n        return true;\n    }\n\n    /**\n     * @notice Decrease total supply by `_val`\n     * @param _val Value to decrease\n     * @return Operation status\n     */\n    function decTotalSupply(uint _val) external onlyModule returns (bool) {\n        totalSupply = totalSupply.sub(_val);\n        return true;\n    }\n\n    /**\n     * @notice Set/Unset `_acct` as an authorized module\n     * @param _acct Module address\n     * @param _set Module set status\n     * @return Operation status\n     */\n    function setModule(address _acct, bool _set) external onlyOwner returns (bool) {\n        modules[_acct] = _set;\n        emit ModuleSet(_acct, _set);\n        return true;\n    }\n\n    /**\n     * @notice Get `_acct` balance\n     * @param _acct Target account to get balance.\n     * @return The account balance\n     */\n    function getBalance(address _acct) external view returns (uint256) {\n        return balances[_acct];\n    }\n\n    /**\n     * @notice Get allowance of `_spender` in behalf of `_owner`\n     * @param _owner Owner account\n     * @param _spender Spender account\n     * @return Allowance\n     */\n    function getAllowance(address _owner, address _spender) external view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @notice Get if `_acct` is an authorized module\n     * @param _acct Module address\n     * @return Operation status\n     */\n    function getModule(address _acct) external view returns (bool) {\n        return modules[_acct];\n    }\n\n    /**\n     * @notice Get total supply\n     * @return Total supply\n     */\n    function getTotalSupply() external view returns (uint256) {\n        return totalSupply;\n    }\n\n    /**\n     * @notice Increment `_acct` balance by `_val`\n     * @param _acct Target account to increment balance.\n     * @param _val Value to increment\n     * @return Operation status\n     */\n    function incBalance(address _acct, uint _val) public onlyModule returns (bool) {\n        balances[_acct] = balances[_acct].add(_val);\n        emit BalanceAdj(msg.sender, _acct, _val, \"+\");\n        return true;\n    }\n\n    /**\n     * @notice Decrement `_acct` balance by `_val`\n     * @param _acct Target account to decrement balance.\n     * @param _val Value to decrement\n     * @return Operation status\n     */\n    function decBalance(address _acct, uint _val) public onlyModule returns (bool) {\n        balances[_acct] = balances[_acct].sub(_val);\n        emit BalanceAdj(msg.sender, _acct, _val, \"-\");\n        return true;\n    }\n\n    function transferRoot(address _new) external returns (bool) {\n        return false;\n    }\n}\n\n"},"ERC777.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n* License, v. 2.0. If a copy of the MPL was not distributed with this\n* file, You can obtain one at http://mozilla.org/MPL/2.0/. */\npragma solidity 0.5.8;\n\nimport { ERC1820Client } from \"./ERC1820Client.sol\";\nimport { SafeMath } from \"./SafeMath.sol\";\nimport { IERC777 } from \"./IERC777.sol\";\nimport { IERC777TokensSender } from \"./IERC777TokensSender.sol\";\nimport { IERC777TokensRecipient } from \"./IERC777TokensRecipient.sol\";\n\n\ncontract ERC777 is IERC777, ERC1820Client {\n    using SafeMath for uint256;\n\n    string internal mName;\n    string internal mSymbol;\n    uint256 internal mGranularity;\n    uint256 internal mTotalSupply;\n\n\n    mapping(address =\u003e uint) internal mBalances;\n\n    address[] internal mDefaultOperators;\n    mapping(address =\u003e bool) internal mIsDefaultOperator;\n    mapping(address =\u003e mapping(address =\u003e bool)) internal mRevokedDefaultOperator;\n    mapping(address =\u003e mapping(address =\u003e bool)) internal mAuthorizedOperators;\n\n    /* -- Constructor -- */\n    //\n    /// @notice Constructor to create a ReferenceToken\n    /// @param _name Name of the new token\n    /// @param _symbol Symbol of the new token.\n    /// @param _granularity Minimum transferable chunk.\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _granularity,\n        address[] memory _defaultOperators\n    ) internal {\n        mName = _name;\n        mSymbol = _symbol;\n        mTotalSupply = 0;\n        require(_granularity \u003e= 1, \"Granularity must be \u003e 1\");\n        mGranularity = _granularity;\n\n        mDefaultOperators = _defaultOperators;\n        for (uint256 i = 0; i \u003c mDefaultOperators.length; i++) { mIsDefaultOperator[mDefaultOperators[i]] = true; }\n\n        setInterfaceImplementation(\"ERC777Token\", address(this));\n    }\n\n    /* -- ERC777 Interface Implementation -- */\n    //\n    /// @return the name of the token\n    function name() public view returns (string memory) { return mName; }\n\n    /// @return the symbol of the token\n    function symbol() public view returns (string memory) { return mSymbol; }\n\n    /// @return the granularity of the token\n    function granularity() public view returns (uint256) { return mGranularity; }\n\n    /// @return the total supply of the token\n    function totalSupply() public view returns (uint256) { return mTotalSupply; }\n\n    /// @notice Return the account balance of some account\n    /// @param _tokenHolder Address for which the balance is returned\n    /// @return the balance of `_tokenAddress`.\n    function balanceOf(address _tokenHolder) public view returns (uint256) { return mBalances[_tokenHolder]; }\n\n    /// @notice Return the list of default operators\n    /// @return the list of all the default operators\n    function defaultOperators() public view returns (address[] memory) { return mDefaultOperators; }\n\n    /// @notice Send `_amount` of tokens to address `_to` passing `_data` to the recipient\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    function send(address _to, uint256 _amount, bytes calldata _data) external {\n        doSend(msg.sender, msg.sender, _to, _amount, _data, \"\", true);\n    }\n\n    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`\u0027s tokens.\n    /// @param _operator The operator that wants to be Authorized\n    function authorizeOperator(address _operator) external {\n        require(_operator != msg.sender, \"Cannot authorize yourself as an operator\");\n        if (mIsDefaultOperator[_operator]) {\n            mRevokedDefaultOperator[_operator][msg.sender] = false;\n        } else {\n            mAuthorizedOperators[_operator][msg.sender] = true;\n        }\n        emit AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Revoke a third party `_operator`\u0027s rights to manage (send) `msg.sender`\u0027s tokens.\n    /// @param _operator The operator that wants to be Revoked\n    function revokeOperator(address _operator) external {\n        require(_operator != msg.sender, \"Cannot revoke yourself as an operator\");\n        if (mIsDefaultOperator[_operator]) {\n            mRevokedDefaultOperator[_operator][msg.sender] = true;\n        } else {\n            mAuthorizedOperators[_operator][msg.sender] = false;\n        }\n        emit RevokedOperator(_operator, msg.sender);\n    }\n\n    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.\n    /// @param _operator address to check if it has the right to manage the tokens\n    /// @param _tokenHolder address which holds the tokens to be managed\n    /// @return `true` if `_operator` is authorized for `_tokenHolder`\n    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\n        return (_operator == _tokenHolder // solium-disable-line operator-whitespace\n        || mAuthorizedOperators[_operator][_tokenHolder]\n        || (mIsDefaultOperator[_operator] \u0026\u0026 !mRevokedDefaultOperator[_operator][_tokenHolder]));\n    }\n\n    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _data Data generated by the user to be sent to the recipient\n    /// @param _operatorData Data generated by the operator to be sent to the recipient\n    function operatorSend(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n    external\n    {\n        require(isOperatorFor(msg.sender, _from), \"Not an operator.\");\n        doSend(msg.sender, _from, _to, _amount, _data, _operatorData, true);\n    }\n\n    function burn(uint256 _amount, bytes calldata _data) external {\n        doBurn(msg.sender, msg.sender, _amount, _data, \"\");\n    }\n\n    function operatorBurn(\n        address _tokenHolder,\n        uint256 _amount,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    )\n    external\n    {\n        require(isOperatorFor(msg.sender, _tokenHolder), \"Not an operator\");\n        doBurn(msg.sender, _tokenHolder, _amount, _data, _operatorData);\n    }\n\n    /* -- Helper Functions -- */\n    //\n    /// @notice Internal function that ensures `_amount` is multiple of the granularity\n    /// @param _amount The quantity that want\u0027s to be checked\n    function requireMultiple(uint256 _amount) internal view {\n        require(_amount % mGranularity == 0, \"Amount is not a multiple of granularity\");\n    }\n\n    /// @notice Check whether an address is a regular address or not.\n    /// @param _addr Address of the contract that has to be checked\n    /// @return `true` if `_addr` is a regular address (not a contract)\n    function isRegularAddress(address _addr) internal view returns(bool) {\n        if (_addr == address(0)) { return false; }\n        uint size;\n        assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\n        return size == 0;\n    }\n\n    /// @notice Helper function actually performing the sending of tokens.\n    /// @param _operator The address performing the send\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _data Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777tokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n    internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _data, _operatorData);\n\n        require(_to != address(0), \"Cannot send to 0x0\");\n        require(mBalances[_from] \u003e= _amount, \"Not enough funds\");\n\n        mBalances[_from] = mBalances[_from].sub(_amount);\n        mBalances[_to] = mBalances[_to].add(_amount);\n\n        callRecipient(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\n\n        emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n    }\n\n    /// @notice Helper function actually performing the burning of tokens.\n    /// @param _operator The address performing the burn\n    /// @param _tokenHolder The address holding the tokens being burn\n    /// @param _amount The number of tokens to be burnt\n    /// @param _data Data generated by the token holder\n    /// @param _operatorData Data generated by the operator\n    function doBurn(\n        address _operator,\n        address _tokenHolder,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData\n    )\n    internal\n    {\n        callSender(_operator, _tokenHolder, address(0), _amount, _data, _operatorData);\n\n        requireMultiple(_amount);\n        require(balanceOf(_tokenHolder) \u003e= _amount, \"Not enough funds\");\n\n        mBalances[_tokenHolder] = mBalances[_tokenHolder].sub(_amount);\n        mTotalSupply = mTotalSupply.sub(_amount);\n\n        emit Burned(_operator, _tokenHolder, _amount, _data, _operatorData);\n    }\n\n    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _operator The address performing the send or mint\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be sent\n    /// @param _data Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n    ///  implementing `ERC777TokensRecipient`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callRecipient(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n    internal\n    {\n        address recipientImplementation = interfaceAddr(_to, \"ERC777TokensRecipient\");\n        if (recipientImplementation != address(0)) {\n            IERC777TokensRecipient(recipientImplementation).tokensReceived(\n                _operator, _from, _to, _amount, _data, _operatorData);\n        } else if (_preventLocking) {\n            require(isRegularAddress(_to), \"Cannot send to contract without ERC777TokensRecipient\");\n        }\n    }\n\n    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.\n    ///  May throw according to `_preventLocking`\n    /// @param _from The address holding the tokens being sent\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be sent\n    /// @param _data Data generated by the user to be passed to the recipient\n    /// @param _operatorData Data generated by the operator to be passed to the recipient\n    ///  implementing `ERC777TokensSender`.\n    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n    ///  functions SHOULD set this parameter to `false`.\n    function callSender(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData\n    )\n    internal\n    {\n        address senderImplementation = interfaceAddr(_from, \"ERC777TokensSender\");\n        if (senderImplementation == address(0)) { return; }\n        IERC777TokensSender(senderImplementation).tokensToSend(\n            _operator, _from, _to, _amount, _data, _operatorData);\n    }\n}\n\n"},"ERC777ERC20Compat.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\npragma solidity 0.5.8;\n\n\nimport { IERC20 } from \"./IERC20.sol\";\nimport { ERC777RemoteBridge } from \"./ERC777RemoteBridge.sol\";\n\n\ncontract ERC777ERC20Compat is IERC20, ERC777RemoteBridge {\n    bool internal mErc20compatible;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) internal mAllowed;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _granularity,\n        uint256 _totalSupply,\n        address _initialOwner,\n        address[] memory _defaultOperators\n    )\n    internal ERC777RemoteBridge(_name, _symbol, _granularity, _totalSupply, _initialOwner, _defaultOperators)\n    {\n        mErc20compatible = true;\n        setInterfaceImplementation(\"ERC20Token\", address(this));\n    }\n\n    /// @notice This modifier is applied to erc20 obsolete methods that are\n    ///  implemented only to maintain backwards compatibility. When the erc20\n    ///  compatibility is disabled, this methods will fail.\n    modifier erc20 () {\n        require(mErc20compatible, \"ERC20 is disabled\");\n        _;\n    }\n\n    /// @notice For Backwards compatibility\n    /// @return The decimals of the token. Forced to 18 in ERC777.\n    function decimals() public erc20 view returns (uint8) { return uint8(18); }\n\n    /// @notice ERC20 backwards compatible transfer.\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can\u0027t be done, it should fail.\n    function transfer(address _to, uint256 _amount) public erc20 returns (bool success) {\n        doSend(msg.sender, msg.sender, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @notice ERC20 backwards compatible transferFrom.\n    /// @param _from The address holding the tokens being transferred\n    /// @param _to The address of the recipient\n    /// @param _amount The number of tokens to be transferred\n    /// @return `true`, if the transfer can\u0027t be done, it should fail.\n    function transferFrom(address _from, address _to, uint256 _amount) public erc20 returns (bool success) {\n        uint256 allowance = balancesDB.getAllowance(_from, msg.sender);\n        require(_amount \u003c= allowance, \"Not enough allowance.\");\n\n        // Cannot be after doSend because of tokensReceived re-entry\n        require(balancesDB.decApprove(_from, msg.sender, _amount));\n        doSend(msg.sender, _from, _to, _amount, \"\", \"\", false);\n        return true;\n    }\n\n    /// @notice ERC20 backwards compatible approve.\n    ///  `msg.sender` approves `_spender` to spend `_amount` tokens on its behalf.\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The number of tokens to be approved for transfer\n    /// @return `true`, if the approve can\u0027t be done, it should fail.\n    function approve(address _spender, uint256 _amount) public erc20 returns (bool success) {\n        require(balancesDB.setApprove(msg.sender, _spender, _amount));\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /// @notice ERC20 backwards compatible allowance.\n    ///  This function makes it easy to read the `allowed[]` map\n    /// @param _owner The address of the account that owns the token\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    ///  to spend\n    function allowance(address _owner, address _spender) public erc20 view returns (uint256 remaining) {\n        return balancesDB.getAllowance(_owner, _spender);\n    }\n\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n    internal\n    {\n        super.doSend(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\n        if (mErc20compatible) { emit Transfer(_from, _to, _amount); }\n    }\n\n    function doBurn(\n        address _operator,\n        address _tokenHolder,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData\n    )\n    internal\n    {\n        super.doBurn(_operator, _tokenHolder, _amount, _data, _operatorData);\n        if (mErc20compatible) { emit Transfer(_tokenHolder, address(0), _amount); }\n    }\n}\n\n"},"ERC777RemoteBridge.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\npragma solidity 0.5.8;\n\n\nimport { ERC777 } from \"./ERC777.sol\";\nimport { CStore } from \"./CStore.sol\";\n\n\ncontract ERC777RemoteBridge is ERC777 {\n\n    CStore public balancesDB;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint256 _granularity,\n        uint256 _totalSupply,\n        address _initialOwner,\n        address[] memory _defaultOperators\n    )\n    public ERC777(_name, _symbol, _granularity, new address[](0))\n    {\n        balancesDB = new CStore(_totalSupply, _initialOwner, _defaultOperators);\n    }\n\n    /**\n     * @return the total supply of the token\n     */\n    function totalSupply() public view returns (uint256) {\n        return balancesDB.getTotalSupply();\n    }\n\n    /**\n     * @notice Return the account balance of some account\n     * @param _tokenHolder Address for which the balance is returned\n     * @return the balance of `_tokenAddress`.\n     */\n    function balanceOf(address _tokenHolder) public view returns (uint256) {\n        return balancesDB.getBalance(_tokenHolder);\n    }\n\n    /**\n     * @notice Return the list of default operators\n     * @return the list of all the default operators\n     */\n    function defaultOperators() public view returns (address[] memory) {\n        return balancesDB.getDefaultOperators();\n    }\n\n    /**\n     * @notice Authorize a third party `_operator` to manage (send) `msg.sender`\u0027s tokens at remote database.\n     * @param _operator The operator that wants to be Authorized\n     */\n    function authorizeOperator(address _operator) external {\n        require(_operator != msg.sender, \"Cannot authorize yourself as an operator\");\n        if (balancesDB.getDefaultOperator(_operator)) {\n            require(balancesDB.setRevokedDefaultOperator(_operator, msg.sender, false));\n        } else {\n            require(balancesDB.setAuthorizedOperator(_operator, msg.sender, true));\n        }\n        emit AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /**\n     * @notice Revoke a third party `_operator`\u0027s rights to manage (send) `msg.sender`\u0027s tokens at remote database.\n     * @param _operator The operator that wants to be Revoked\n     */\n    function revokeOperator(address _operator) external {\n        require(_operator != msg.sender, \"Cannot revoke yourself as an operator\");\n        if (balancesDB.getDefaultOperator(_operator)) {\n            require(balancesDB.setRevokedDefaultOperator(_operator, msg.sender, true));\n        } else {\n            require(balancesDB.setAuthorizedOperator(_operator, msg.sender, false));\n        }\n        emit RevokedOperator(_operator, msg.sender);\n    }\n\n    /**\n    * @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder`\n    *  address at remote database.\n    * @param _operator address to check if it has the right to manage the tokens\n    * @param _tokenHolder address which holds the tokens to be managed\n    * @return `true` if `_operator` is authorized for `_tokenHolder`\n    */\n    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {\n        return _operator == _tokenHolder || balancesDB.getAuthorizedOperator(_operator, _tokenHolder);\n        return (_operator == _tokenHolder // solium-disable-line operator-whitespace\n        || balancesDB.getAuthorizedOperator(_operator, _tokenHolder)\n        || (balancesDB.getDefaultOperator(_operator) \u0026\u0026 !balancesDB.getRevokedDefaultOperator(_operator, _tokenHolder)));\n    }\n\n    /**\n     * @notice Helper function actually performing the sending of tokens using a backend database.\n     * @param _from The address holding the tokens being sent\n     * @param _to The address of the recipient\n     * @param _amount The number of tokens to be sent\n     * @param _data Data generated by the user to be passed to the recipient\n     * @param _operatorData Data generated by the operator to be passed to the recipient\n     * @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not\n     *  implementing `erc777_tokenHolder`.\n     *  ERC777 native Send functions MUST set this parameter to `true`, and backwards compatible ERC20 transfer\n     *  functions SHOULD set this parameter to `false`.\n     */\n    function doSend(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData,\n        bool _preventLocking\n    )\n    internal\n    {\n        requireMultiple(_amount);\n\n        callSender(_operator, _from, _to, _amount, _data, _operatorData);\n\n        require(_to != address(0), \"Cannot send to 0x0\");          // forbid sending to 0x0 (=burning)\n        // require(mBalances[_from] \u003e= _amount); // ensure enough funds\n        // (Not Required due to SafeMath throw if underflow in database and false check)\n\n        require(balancesDB.move(_from, _to, _amount));\n\n        callRecipient(_operator, _from, _to, _amount, _data, _operatorData, _preventLocking);\n\n        emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n        //if (mErc20compatible) { emit Transfer(_from, _to, _amount); }\n    }\n\n    /**\n     * @notice Helper function actually performing the burning of tokens.\n     * @param _operator The address performing the burn\n     * @param _tokenHolder The address holding the tokens being burn\n     * @param _amount The number of tokens to be burnt\n     * @param _data Data generated by the token holder\n     * @param _operatorData Data generated by the operator\n     */\n    function doBurn(\n        address _operator,\n        address _tokenHolder,\n        uint256 _amount,\n        bytes memory _data,\n        bytes memory _operatorData\n    )\n    internal\n    {\n        revert(\"Burning functionality is disabled.\");\n    }\n}\n\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IERC644.sol":{"content":"pragma solidity 0.5.8;\n\n\ninterface IERC644 {\n    function getBalance(address _acct) external view returns(uint);\n    function incBalance(address _acct, uint _val) external returns(bool);\n    function decBalance(address _acct, uint _val) external returns(bool);\n    function getAllowance(address _owner, address _spender) external view returns(uint);\n    function setApprove(address _sender, address _spender, uint256 _value) external returns(bool);\n    function decApprove(address _from, address _spender, uint _value) external returns(bool);\n    function getModule(address _acct) external view returns (bool);\n    function setModule(address _acct, bool _set) external returns(bool);\n    function getTotalSupply() external view returns(uint);\n    function incTotalSupply(uint _val) external returns(bool);\n    function decTotalSupply(uint _val) external returns(bool);\n    function transferRoot(address _new) external returns(bool);\n\n    event BalanceAdj(address indexed Module, address indexed Account, uint Amount, string Polarity);\n    event ModuleSet(address indexed Module, bool indexed Set);\n}\n\n"},"IERC777.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.8;\n\n\ninterface IERC777 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) external view returns (uint256);\n    function granularity() external view returns (uint256);\n\n    function defaultOperators() external view returns (address[] memory);\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n    function authorizeOperator(address operator) external;\n    function revokeOperator(address operator) external;\n\n    function send(address to, uint256 amount, bytes calldata data) external;\n    function operatorSend(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    function burn(uint256 amount, bytes calldata data) external;\n    function operatorBurn(address from, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n\n"},"IERC777TokensRecipient.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.8;\n\n\ninterface IERC777TokensRecipient {\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}\n\n"},"IERC777TokensSender.sol":{"content":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * This code has not been reviewed.\n * Do not use or deploy this code before reviewing it personally first.\n */\n// solhint-disable-next-line compiler-fixed\npragma solidity 0.5.8;\n\n\ninterface IERC777TokensSender {\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n}\n\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"SafeGuard.sol":{"content":"pragma solidity 0.5.8;\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Safe Guard Contract\n * @author Panos\n */\ncontract SafeGuard is Ownable {\n\n    event Transaction(address indexed destination, uint value, bytes data);\n\n    /**\n     * @dev Allows owner to execute a transaction.\n     */\n    function executeTransaction(address destination, uint value, bytes memory data)\n    public\n    onlyOwner\n    {\n        require(externalCall(destination, value, data.length, data));\n        emit Transaction(destination, value, data);\n    }\n\n    /**\n     * @dev call has been separated into its own function in order to take advantage\n     *  of the Solidity\u0027s code generator to produce a loop that copies tx.data into memory.\n     */\n    function externalCall(address destination, uint value, uint dataLength, bytes memory data)\n    private\n    returns (bool) {\n        bool result;\n        assembly { // solhint-disable-line no-inline-assembly\n        let x := mload(0x40)   // \"Allocate\" memory for output\n            // (0x40 is where \"free memory\" pointer is stored by convention)\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\n            result := call(\n            sub(gas, 34710), // 34710 is the value that solidity is currently emitting\n            // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\n            // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\n            destination,\n            value,\n            d,\n            dataLength, // Size of the input (in bytes) - this is what fixes the padding problem\n            x,\n            0                  // Output is ignored, therefore the output size is zero\n            )\n        }\n        return result;\n    }\n}\n\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}