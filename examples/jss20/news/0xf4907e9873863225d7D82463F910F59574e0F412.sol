{{

  "language": "Solidity",

  "sources": {

    "@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol": {

pragma solidity ^0.5.17;
    },

    "@keep-network/sortition-pools/contracts/BondedSortitionPool.sol": {

      "content": "pragma solidity 0.5.17;\n\nimport \"./AbstractSortitionPool.sol\";\nimport \"./RNG.sol\";\nimport \"./api/IStaking.sol\";\nimport \"./api/IBonding.sol\";\nimport \"./DynamicArray.sol\";\n\n/// @title Bonded Sortition Pool\n/// @notice A logarithmic data structure used to store the pool of eligible\n/// operators weighted by their stakes. It allows to select a group of operators\n/// based on the provided pseudo-random seed and bonding requirements.\n/// @dev Keeping pool up to date cannot be done eagerly as proliferation of\n/// privileged customers could be used to perform DOS attacks by increasing the\n/// cost of such updates. When a sortition pool prospectively selects an\n/// operator, the selected operatorâ€™s eligibility status and weight needs to be\n/// checked and, if necessary, updated in the sortition pool. If the changes\n/// would be detrimental to the operator, the operator selection is performed\n/// again with the updated input to ensure correctness.\ncontract BondedSortitionPool is AbstractSortitionPool {\n    using DynamicArray for DynamicArray.UintArray;\n    using DynamicArray for DynamicArray.AddressArray;\n    using RNG for RNG.State;\n    // The pool should specify a reasonable minimum bond\n    // for operators trying to join the pool,\n    // to prevent griefing by operators joining without enough bondable value.\n    // After we start selecting groups\n    // this value can be set to equal the most recent request's bondValue.\n\n    struct PoolParams {\n        IStaking stakingContract;\n        uint256 minimumStake;\n        IBonding bondingContract;\n        uint256 minimumBondableValue;\n        // The weight divisor in the pool can differ from the minimum stake\n        uint256 poolWeightDivisor;\n        address owner;\n    }\n\n    PoolParams poolParams;\n\n    constructor(\n        IStaking _stakingContract,\n        IBonding _bondingContract,\n        uint256 _minimumStake,\n        uint256 _minimumBondableValue,\n        uint256 _poolWeightDivisor,\n        address _poolOwner\n    ) public {\n        require(_minimumStake > 0, \"Minimum stake cannot be zero\");\n\n        poolParams = PoolParams(\n            _stakingContract,\n            _minimumStake,\n            _bondingContract,\n            _minimumBondableValue,\n            _poolWeightDivisor,\n            _poolOwner\n        );\n    }\n\n    /// @notice Selects a new group of operators of the provided size based on\n    /// the provided pseudo-random seed and bonding requirements. All operators\n    /// in the group are unique.\n    ///\n    /// If there are not enough operators in a pool to form a group or not\n    /// enough operators are eligible for work selection given the bonding\n    /// requirements, the function fails.\n    /// @param groupSize Size of the requested group\n    /// @param seed Pseudo-random number used to select operators to group\n    /// @param minimumStake The current minimum stake value\n    /// @param bondValue Size of the requested bond per operator\n    function selectSetGroup(\n        uint256 groupSize,\n        bytes32 seed,\n        uint256 minimumStake,\n        uint256 bondValue\n    ) public returns (address[] memory) {\n        PoolParams memory params = initializeSelectionParams(\n            minimumStake,\n            bondValue\n        );\n        require(\n            msg.sender == params.owner,\n            \"Only owner may select groups\"\n        );\n        uint256 paramsPtr;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            paramsPtr := params\n        }\n        return generalizedSelectGroup(\n            groupSize,\n            seed,\n            paramsPtr,\n            true\n        );\n    }\n\n    function initializeSelectionParams(\n        uint256 currentMinimumStake,\n        uint256 bondValue\n    ) internal returns (PoolParams memory params) {\n        params = poolParams;\n\n        if (params.minimumBondableValue != bondValue) {\n            params.minimumBondableValue = bondValue;\n            poolParams.minimumBondableValue = bondValue;\n        }\n\n        if (params.minimumStake != currentMinimumStake) {\n            params.minimumStake = currentMinimumStake;\n            poolParams.minimumStake = currentMinimumStake;\n        }\n\n        return params;\n    }\n\n    // Return the eligible weight of the operator,\n    // which may differ from the weight in the pool.\n    // Return 0 if ineligible.\n    function getEligibleWeight(address operator) internal view returns (uint256) {\n        address ownerAddress = poolParams.owner;\n        // Get the amount of bondable value available for this pool.\n        // We only care that this covers one single bond\n        // regardless of the weight of the operator in the pool.\n        uint256 bondableValue = poolParams.bondingContract.availableUnbondedValue(\n            operator,\n            ownerAddress,\n            address(this)\n        );\n\n        // Don't query stake if bond is insufficient.\n        if (bondableValue < poolParams.minimumBondableValue) {\n            return 0;\n        }\n\n        uint256 eligibleStake = poolParams.stakingContract.eligibleStake(\n            operator,\n            ownerAddress\n        );\n\n        // Weight = floor(eligibleStake / poolWeightDivisor)\n        // but only if eligibleStake >= minimumStake.\n        // Ethereum uint256 division performs implicit floor\n        // If eligibleStake < poolWeightDivisor, return 0 = ineligible.\n        if (eligibleStake < poolParams.minimumStake) {return 0;}\n        return (eligibleStake / poolParams.poolWeightDivisor);\n    }\n\n    function decideFate(\n        uint256 leaf,\n        DynamicArray.AddressArray memory, // `selected`, for future use\n        uint256 paramsPtr\n    ) internal view returns (Fate memory) {\n        PoolParams memory params;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            params := paramsPtr\n        }\n        address operator = leaf.operator();\n        uint256 leafWeight = leaf.weight();\n\n        if (!isLeafInitialized(leaf)) {\n            return Fate(Decision.Skip, 0);\n        }\n\n        address ownerAddress = params.owner;\n\n        // Get the amount of bondable value available for this pool.\n        // We only care that this covers one single bond\n        // regardless of the weight of the operator in the pool.\n        uint256 bondableValue = params.bondingContract.availableUnbondedValue(\n            operator,\n            ownerAddress,\n            address(this)\n        );\n\n        // Don't query stake if bond is insufficient.\n        if (bondableValue < params.minimumBondableValue) {\n            return Fate(Decision.Delete, 0);\n        }\n\n        uint256 eligibleStake = params.stakingContract.eligibleStake(\n            operator,\n            ownerAddress\n        );\n\n        // Weight = floor(eligibleStake / poolWeightDivisor)\n        // Ethereum uint256 division performs implicit floor\n        uint256 eligibleWeight = eligibleStake / params.poolWeightDivisor;\n\n        if (eligibleWeight < leafWeight || eligibleStake < params.minimumStake) {\n            return Fate(Decision.Delete, 0);\n        }\n        return Fate(Decision.Select, 0);\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/api/IBonding.sol": {

pragma solidity ^0.5.17;
    },

    "@keep-network/sortition-pools/contracts/api/IStaking.sol": {

pragma solidity ^0.5.17;
    },

    "@keep-network/sortition-pools/contracts/AbstractSortitionPool.sol": {

      "content": "pragma solidity 0.5.17;\n\nimport \"./GasStation.sol\";\nimport \"./RNG.sol\";\nimport \"./SortitionTree.sol\";\nimport \"./DynamicArray.sol\";\nimport \"./api/IStaking.sol\";\n\n/// @title Abstract Sortition Pool\n/// @notice Abstract contract encapsulating common logic of all sortition pools.\n/// @dev Inheriting implementations are expected to implement getEligibleWeight\n/// function.\ncontract AbstractSortitionPool is SortitionTree, GasStation {\n    using Leaf for uint256;\n    using Position for uint256;\n    using DynamicArray for DynamicArray.UintArray;\n    using DynamicArray for DynamicArray.AddressArray;\n    using RNG for RNG.State;\n\n    enum Decision {\n        Select, // Add to the group, and use new seed\n        Skip,   // Retry with same seed, skip this leaf\n        Delete, // Retry with same seed, delete this leaf\n        UpdateRetry, // Retry with same seed, update this leaf\n        UpdateSelect // Select and reseed, but also update this leaf\n    }\n\n    struct Fate {\n        Decision decision;\n        // The new weight of the leaf if Decision is Update*, otherwise 0\n        uint256 maybeWeight;\n    }\n\n    // Require 10 blocks after joining before the operator can be selected for\n    // a group. This reduces the degrees of freedom miners and other\n    // front-runners have in conducting pool-bumping attacks.\n    //\n    // We don't use the stack of empty leaves until we run out of space on the\n    // rightmost leaf (i.e. after 2 million operators have joined the pool).\n    // It means all insertions are at the right end, so one can't reorder\n    // operators already in the pool until the pool has been filled once.\n    // Because the index is calculated by taking the minimum number of required\n    // random bits, and seeing if it falls in the range of the total pool weight,\n    // the only scenarios where insertions on the right matter are if it crosses\n    // a power of two threshold for the total weight and unlocks another random\n    // bit, or if a random number that would otherwise be discarded happens to\n    // fall within that space.\n    uint256 constant INIT_BLOCKS = 10;\n\n    uint256 constant GAS_DEPOSIT_SIZE = 1;\n\n    /// @notice The number of blocks that must be mined before the operator who\n    // joined the pool is eligible for work selection.\n    function operatorInitBlocks() public pure returns (uint256) {\n        return INIT_BLOCKS;\n    }\n\n    // Return whether the operator is eligible for the pool.\n    function isOperatorEligible(address operator) public view returns (bool) {\n        return getEligibleWeight(operator) > 0;\n    }\n\n    // Return whether the operator is present in the pool.\n    function isOperatorInPool(address operator) public view returns (bool) {\n        return getFlaggedLeafPosition(operator) != 0;\n    }\n\n    // Return whether the operator's weight in the pool\n    // matches their eligible weight.\n    function isOperatorUpToDate(address operator) public view returns (bool) {\n        return getEligibleWeight(operator) == getPoolWeight(operator);\n    }\n\n    // Returns whether the operator has passed the initialization blocks period\n    // to be eligible for the work selection. Reverts if the operator is not in\n    // the pool.\n    function isOperatorInitialized(address operator)\n        public\n        view\n        returns (bool)\n    {\n        require(isOperatorInPool(operator), \"Operator is not in the pool\");\n\n        uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n        uint256 leafPosition = flaggedPosition.unsetFlag();\n        uint256 leaf = leaves[leafPosition];\n\n        return isLeafInitialized(leaf);\n    }\n\n    // Return the weight of the operator in the pool,\n    // which may or may not be out of date.\n    function getPoolWeight(address operator) public view returns (uint256) {\n        uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n        if (flaggedPosition == 0) {\n            return 0;\n        } else {\n            uint256 leafPosition = flaggedPosition.unsetFlag();\n            uint256 leafWeight = leaves[leafPosition].weight();\n            return leafWeight;\n        }\n    }\n\n    // Add an operator to the pool,\n    // reverting if the operator is already present.\n    function joinPool(address operator) public {\n        uint256 eligibleWeight = getEligibleWeight(operator);\n        require(\n            eligibleWeight > 0,\n            \"Operator not eligible\"\n        );\n\n        depositGas(operator);\n        insertOperator(operator, eligibleWeight);\n    }\n\n    // Update the operator's weight if present and eligible,\n    // or remove from the pool if present and ineligible.\n    function updateOperatorStatus(address operator) public {\n        uint256 eligibleWeight = getEligibleWeight(operator);\n        uint256 inPoolWeight = getPoolWeight(operator);\n\n        require(\n            eligibleWeight != inPoolWeight,\n            \"Operator already up to date\"\n        );\n\n        if (eligibleWeight == 0) {\n            removeOperator(operator);\n            releaseGas(operator);\n        } else {\n            updateOperator(operator, eligibleWeight);\n        }\n    }\n\n    function generalizedSelectGroup(\n        uint256 groupSize,\n        bytes32 seed,\n        // This uint256 is actually a void pointer.\n        // We can't pass a SelectionParams,\n        // because the implementation of the SelectionParams struct\n        // can vary between different concrete sortition pool implementations.\n        //\n        // Whatever SelectionParams struct is used by the concrete contract\n        // should be created in the `selectGroup`/`selectSetGroup` function,\n        // then coerced into a uint256 to be passed into this function.\n        // The paramsPtr is then passed to the `decideFate` implementation\n        // which can coerce it back into the concrete SelectionParams.\n        // This allows `generalizedSelectGroup`\n        // to work with any desired eligibility logic.\n        uint256 paramsPtr,\n        bool noDuplicates\n    ) internal returns (address[] memory) {\n        uint256 _root = root;\n        bool rootChanged = false;\n\n        DynamicArray.AddressArray memory selected;\n        selected = DynamicArray.addressArray(groupSize);\n\n        RNG.State memory rng;\n        rng = RNG.initialize(\n            seed,\n            _root.sumWeight(),\n            groupSize\n        );\n\n        while (selected.array.length < groupSize) {\n            rng.generateNewIndex();\n\n            (uint256 leafPosition, uint256 startingIndex) = pickWeightedLeaf(\n                rng.currentMappedIndex,\n                _root\n            );\n\n            uint256 leaf = leaves[leafPosition];\n            address operator = leaf.operator();\n            uint256 leafWeight = leaf.weight();\n\n            Fate memory fate = decideFate(\n                leaf,\n                selected,\n                paramsPtr\n            );\n\n            if (fate.decision == Decision.Select) {\n                selected.arrayPush(operator);\n                if (noDuplicates) {\n                    rng.addSkippedInterval(startingIndex, leafWeight);\n                }\n                rng.reseed(seed, selected.array.length);\n                continue;\n            }\n            if (fate.decision == Decision.Skip) {\n                rng.addSkippedInterval(startingIndex, leafWeight);\n                continue;\n            }\n            if (fate.decision == Decision.Delete) {\n                // Update the RNG\n                rng.updateInterval(startingIndex, leafWeight, 0);\n                // Remove the leaf and update root\n                _root = removeLeaf(leafPosition, _root);\n                rootChanged = true;\n                // Remove the record of the operator's leaf and release gas\n                removeLeafPositionRecord(operator);\n                releaseGas(operator);\n                continue;\n            }\n            if (fate.decision == Decision.UpdateRetry) {\n                _root = setLeaf(\n                    leafPosition,\n                    leaf.setWeight(fate.maybeWeight),\n                    _root\n                );\n                rootChanged = true;\n                rng.updateInterval(\n                    startingIndex,\n                    leafWeight,\n                    fate.maybeWeight\n                );\n                continue;\n            }\n            if (fate.decision == Decision.UpdateSelect) {\n                _root = setLeaf(\n                    leafPosition,\n                    leaf.setWeight(fate.maybeWeight),\n                    _root\n                );\n                rootChanged = true;\n                selected.arrayPush(operator);\n                rng.updateInterval(\n                    startingIndex,\n                    leafWeight,\n                    fate.maybeWeight\n                );\n                if (noDuplicates) {\n                    rng.addSkippedInterval(startingIndex, fate.maybeWeight);\n                }\n                rng.reseed(seed, selected.array.length);\n                continue;\n\n            }\n        }\n        if (rootChanged) {\n            root = _root;\n        }\n        return selected.array;\n    }\n\n    function isLeafInitialized(uint256 leaf)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 createdAt = leaf.creationBlock();\n\n        return block.number > (createdAt + operatorInitBlocks());\n    }\n\n    // Return the eligible weight of the operator,\n    // which may differ from the weight in the pool.\n    // Return 0 if ineligible.\n    function getEligibleWeight(address operator) internal view returns (uint256);\n\n    function decideFate(\n        uint256 leaf,\n        DynamicArray.AddressArray memory selected,\n        uint256 paramsPtr) internal view returns (Fate memory);\n\n    function gasDepositSize() internal pure returns (uint256) {\n        return GAS_DEPOSIT_SIZE;\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/RNG.sol": {

      "content": "pragma solidity 0.5.17;\n\nimport \"./Leaf.sol\";\nimport \"./Interval.sol\";\nimport \"./DynamicArray.sol\";\n\nlibrary RNG {\n    using DynamicArray for DynamicArray.UintArray;\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position uses per level of the tree;\n    // each branch of the tree contains 2**SLOT_BITS slots.\n    uint256 constant SLOT_BITS = 3;\n    uint256 constant LEVELS = 7;\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Derived constants, do not touch\n    uint256 constant POSITION_BITS = LEVELS * SLOT_BITS;\n    ////////////////////////////////////////////////////////////////////////////\n\n    struct State {\n        // RNG output\n        uint256 currentMappedIndex;\n        uint256 currentTruncatedIndex;\n        // The random bytes used to derive indices\n        bytes32 currentSeed;\n        // The full range of indices;\n        // generated random numbers are in [0, fullRange).\n        uint256 fullRange;\n        // The truncated range of indices;\n        // how many non-skipped indices are left to consider.\n        // Random indices are generated within this range,\n        // and mapped to the full range by skipping the specified intervals.\n        uint256 truncatedRange;\n        DynamicArray.UintArray skippedIntervals;\n    }\n\n    function initialize(\n        bytes32 seed,\n        uint256 range,\n        uint256 expectedSkippedCount\n    ) internal view returns (State memory self) {\n        self = State(\n            0,\n            0,\n            seed,\n            range,\n            range,\n            DynamicArray.uintArray(expectedSkippedCount)\n        );\n        reseed(self, seed, 0);\n        return self;\n    }\n\n    function reseed(\n        State memory self,\n        bytes32 seed,\n        uint256 nonce\n    ) internal view {\n        self.currentSeed = keccak256(\n            abi.encodePacked(seed, nonce, address(this), \"reseed\")\n        );\n    }\n\n    function retryIndex(State memory self) internal view {\n        uint256 truncatedIndex = self.currentTruncatedIndex;\n        if (self.currentTruncatedIndex < self.truncatedRange) {\n            self.currentMappedIndex = Interval.skip(\n                truncatedIndex,\n                self.skippedIntervals\n            );\n        } else {\n            generateNewIndex(self);\n        }\n    }\n\n    function updateInterval(\n        State memory self,\n        uint256 startIndex,\n        uint256 oldWeight,\n        uint256 newWeight\n    ) internal pure {\n        int256 weightDiff = int256(newWeight) - int256(oldWeight);\n        uint256 effectiveStartIndex = startIndex + newWeight;\n        self.truncatedRange = uint256(int256(self.truncatedRange) + weightDiff);\n        self.fullRange = uint256(int256(self.fullRange) + weightDiff);\n        Interval.remapIndices(\n            effectiveStartIndex,\n            weightDiff,\n            self.skippedIntervals\n        );\n    }\n\n    function addSkippedInterval(\n        State memory self,\n        uint256 startIndex,\n        uint256 weight\n    ) internal pure {\n        self.truncatedRange -= weight;\n        Interval.insert(\n            self.skippedIntervals,\n            Interval.make(startIndex, weight)\n        );\n    }\n\n    /// @notice Generate a new index based on the current seed,\n    /// without reseeding first.\n    /// This will result in the same truncated index as before\n    /// if it still fits in the current truncated range.\n    function generateNewIndex(State memory self) internal view {\n        uint256 _truncatedRange = self.truncatedRange;\n        require(_truncatedRange > 0, \"Not enough operators in pool\");\n        uint256 bits = bitsRequired(_truncatedRange);\n        uint256 truncatedIndex = truncate(bits, uint256(self.currentSeed));\n        while (truncatedIndex >= _truncatedRange) {\n            self.currentSeed = keccak256(\n                abi.encodePacked(self.currentSeed, address(this), \"generate\")\n            );\n            truncatedIndex = truncate(bits, uint256(self.currentSeed));\n        }\n        self.currentTruncatedIndex = truncatedIndex;\n        self.currentMappedIndex = Interval.skip(\n            truncatedIndex,\n            self.skippedIntervals\n        );\n    }\n\n    /// @notice Calculate how many bits are required\n    /// for an index in the range `[0 .. range-1]`.\n    ///\n    /// @dev Our sortition pool can support up to 2^21 virtual stakers,\n    /// therefore we calculate how many bits we need from 1 to 21.\n    ///\n    /// @param range The upper bound of the desired range, exclusive.\n    ///\n    /// @return uint The smallest number of bits\n    /// that can contain the number `range-1`.\n    function bitsRequired(uint256 range) internal pure returns (uint256) {\n        uint256 bits;\n        // Start at 19 to be faster for large ranges\n        for (bits = (POSITION_BITS - 1); bits >= 0; bits--) {\n            // Left shift by `bits`,\n            // so we have a 1 in the (bits + 1)th least significant bit\n            // and 0 in other bits.\n            // If this number is equal or greater than `range`,\n            // the range [0, range-1] fits in `bits` bits.\n            //\n            // Because we loop from high bits to low bits,\n            // we find the highest number of bits that doesn't fit the range,\n            // and return that number + 1.\n            if (1 << bits < range) {\n                break;\n            }\n        }\n        return bits + 1;\n    }\n\n    /// @notice Truncate `input` to the `bits` least significant bits.\n    function truncate(uint256 bits, uint256 input)\n        internal\n        pure\n        returns (uint256)\n    {\n        return input & ((1 << bits) - 1);\n    }\n\n    /// @notice Get an index in the range `[0 .. range-1]`\n    /// and the new state of the RNG,\n    /// using the provided `state` of the RNG.\n    ///\n    /// @param range The upper bound of the index, exclusive.\n    ///\n    /// @param state The previous state of the RNG.\n    /// The initial state needs to be obtained\n    /// from a trusted randomness oracle (the random beacon),\n    /// or from a chain of earlier calls to `RNG.getIndex()`\n    /// on an originally trusted seed.\n    ///\n    /// @dev Calculates the number of bits required for the desired range,\n    /// takes the least significant bits of `state`\n    /// and checks if the obtained index is within the desired range.\n    /// The original state is hashed with `keccak256` to get a new state.\n    /// If the index is outside the range,\n    /// the function retries until it gets a suitable index.\n    ///\n    /// @return index A random integer between `0` and `range - 1`, inclusive.\n    ///\n    /// @return newState The new state of the RNG.\n    /// When `getIndex()` is called one or more times,\n    /// care must be taken to always use the output `state`\n    /// of the most recent call as the input `state` of a subsequent call.\n    /// At the end of a transaction calling `RNG.getIndex()`,\n    /// the previous stored state must be overwritten with the latest output.\n    function getIndex(uint256 range, bytes32 state)\n        internal\n        view\n        returns (uint256, bytes32)\n    {\n        uint256 bits = bitsRequired(range);\n        bool found = false;\n        uint256 index;\n        bytes32 newState = state;\n        while (!found) {\n            index = truncate(bits, uint256(newState));\n            newState = keccak256(abi.encodePacked(newState, address(this)));\n            if (index < range) {\n                found = true;\n            }\n        }\n        return (index, newState);\n    }\n\n    /// @notice Return an index corresponding to a new, unique leaf.\n    ///\n    /// @dev Gets a new index in a truncated range\n    /// with the weights of all previously selected leaves subtracted.\n    /// This index is then mapped to the full range of possible indices,\n    /// skipping the ranges covered by previous leaves.\n    ///\n    /// @param range The full range in which the unique index should be.\n    ///\n    /// @param state The RNG state.\n    ///\n    /// @param previousLeaves List of indices and weights\n    /// corresponding to the _first_ index of each previously selected leaf,\n    /// and the weight of the same leaf.\n    /// An index number `i` is a starting index of leaf `o`\n    /// if querying for index `i` in the sortition pool returns `o`,\n    /// but querying for `i-1` returns a different leaf.\n    /// This list REALLY needs to be sorted from smallest to largest.\n    ///\n    /// @param sumPreviousWeights The sum of the weights of previous leaves.\n    /// Could be calculated from `previousLeafWeights`\n    /// but providing it explicitly makes the function a bit simpler.\n    ///\n    /// @return uniqueIndex An index in [0, range) that does not overlap\n    /// any of the previousLeaves,\n    /// as determined by the range [index, index + weight).\n    function getUniqueIndex(\n        uint256 range,\n        bytes32 state,\n        uint256[] memory previousLeaves,\n        uint256 sumPreviousWeights\n    )\n        internal\n        view\n        returns (uint256 uniqueIndex, bytes32 newState)\n    {\n        // Get an index in the truncated range.\n        // The truncated range covers only new leaves,\n        // but has to be mapped to the actual range of indices.\n        uint256 truncatedRange = range - sumPreviousWeights;\n        uint256 truncatedIndex;\n        (truncatedIndex, newState) = getIndex(truncatedRange, state);\n\n        // Map the truncated index to the available unique indices.\n        uniqueIndex = Interval.skip(\n            truncatedIndex,\n            DynamicArray.convert(previousLeaves)\n        );\n\n        return (uniqueIndex, newState);\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/DynamicArray.sol": {

      "content": "pragma solidity 0.5.17;\n\nlibrary DynamicArray {\n    // The in-memory dynamic Array is implemented\n    // by recording the amount of allocated memory\n    // separately from the length of the array.\n    // This gives us a perfectly normal in-memory array\n    // with all the behavior we're used to,\n    // but also makes O(1) `push` operations possible\n    // by expanding into the preallocated memory.\n    //\n    // When we run out of preallocated memory when trying to `push`,\n    // we allocate twice as much and copy the array over.\n    // With linear allocation costs this would amortize to O(1)\n    // but with EVM allocations being actually quadratic\n    // the real performance is a very technical O(N).\n    // Nonetheless, this is reasonably performant in practice.\n    //\n    // A dynamic array can be useful\n    // even when you aren't dealing with an unknown number of items.\n    // Because the array tracks the allocated space\n    // separately from the number of stored items,\n    // you can push items into the dynamic array\n    // and iterate over the currently present items\n    // without tracking their number yourself,\n    // or using a special null value for empty elements.\n    //\n    // Because Solidity doesn't really have useful safety features,\n    // only enough superficial inconveniences\n    // to lull yourself into a false sense of security,\n    // dynamic arrays require a bit of care to handle appropriately.\n    //\n    // First of all,\n    // dynamic arrays must not be created or modified manually.\n    // Use `uintArray(length)`, or `convert(existingArray)`\n    // which will perform a safe and efficient conversion for you.\n    // This also applies to storage;\n    // in-memory dynamic arrays are for efficient in-memory operations only,\n    // and it is unnecessary to store dynamic arrays.\n    // Use a regular `uint256[]` instead.\n    // The contents of `array` may be written like `dynamicArray.array[i] = x`\n    // but never reassign the `array` pointer itself\n    // nor mess with `allocatedMemory` in any way whatsoever.\n    // If you fail to follow these precautions,\n    // dragons inhabiting the no-man's-land\n    // between the array as it's seen by Solidity\n    // and the next thing allocated after it\n    // will be unleashed to wreak havoc upon your memory buffers.\n    //\n    // Second,\n    // because the `array` may be reassigned when pushing,\n    // the following pattern is unsafe:\n    // ```\n    // UintArray dynamicArray;\n    // uint256 len = dynamicArray.array.length;\n    // uint256[] danglingPointer = dynamicArray.array;\n    // danglingPointer[0] = x;\n    // dynamicArray.push(y);\n    // danglingPointer[0] = z;\n    // uint256 surprise = danglingPointer[len];\n    // ```\n    // After the above code block,\n    // `dynamicArray.array[0]` may be either `x` or `z`,\n    // and `surprise` may be `y` or out of bounds.\n    // This will not share your address space with a malevolent agent of chaos,\n    // but it will cause entirely avoidable scratchings of the head.\n    //\n    // Dynamic arrays should be safe to use like ordinary arrays\n    // if you always refer to the array field of the dynamic array\n    // when reading or writing values:\n    // ```\n    // UintArray dynamicArray;\n    // uint256 len = dynamicArray.array.length;\n    // dynamicArray.array[0] = x;\n    // dynamicArray.push(y);\n    // dynamicArray.array[0] = z;\n    // uint256 notSurprise = dynamicArray.array[len];\n    // ```\n    // After this code `notSurprise` is reliably `y`,\n    // and `dynamicArray.array[0]` is `z`.\n    struct UintArray {\n        // XXX: Do not modify this value.\n        // In fact, do not even read it.\n        // There is never a legitimate reason to do anything with this value.\n        // She is quiet and wishes to be left alone.\n        // The silent vigil of `allocatedMemory`\n        // is the only thing standing between your contract\n        // and complete chaos in its memory.\n        // Respect her wish or face the monstrosities she is keeping at bay.\n        uint256 allocatedMemory;\n        // Unlike her sharp and vengeful sister,\n        // `array` is safe to use normally\n        // for anything you might do with a normal `uint256[]`.\n        // Reads and loops will check bounds,\n        // and writing in individual indices like `myArray.array[i] = x`\n        // is perfectly fine.\n        // No curse will befall you as long as you obey this rule:\n        //\n        // XXX: Never try to replace her or separate her from her sister\n        // by writing down the accursed words\n        // `myArray.array = anotherArray` or `lonelyArray = myArray.array`.\n        //\n        // If you do, your cattle will be diseased,\n        // your children will be led astray in the woods,\n        // and your memory will be silently overwritten.\n        // Instead, give her a friend with\n        // `mySecondArray = convert(anotherArray)`,\n        // and call her by her family name first.\n        // She will recognize your respect\n        // and ward your memory against corruption.\n        uint256[] array;\n    }\n\n    struct AddressArray {\n        uint256 allocatedMemory;\n        address[] array;\n    }\n\n    /// @notice Create an empty dynamic array,\n    /// with preallocated memory for up to `length` elements.\n    /// @dev Knowing or estimating the preallocated length in advance\n    /// helps avoid frequent early allocations when filling the array.\n    /// @param length The number of items to preallocate space for.\n    /// @return A new dynamic array.\n    function uintArray(uint256 length) internal pure returns (UintArray memory) {\n        uint256[] memory array = _allocateUints(length);\n        return UintArray(length, array);\n    }\n\n    function addressArray(uint256 length) internal pure returns (AddressArray memory) {\n        address[] memory array = _allocateAddresses(length);\n        return AddressArray(length, array);\n    }\n\n    /// @notice Convert an existing non-dynamic array into a dynamic array.\n    /// @dev The dynamic array is created\n    /// with allocated memory equal to the length of the array.\n    /// @param array The array to convert.\n    /// @return A new dynamic array,\n    /// containing the contents of the argument `array`.\n    function convert(uint256[] memory array) internal pure returns (UintArray memory) {\n        return UintArray(array.length, array);\n    }\n\n    function convert(address[] memory array) internal pure returns (AddressArray memory) {\n        return AddressArray(array.length, array);\n    }\n\n    /// @notice Push `item` into the dynamic array.\n    /// @dev This function will be safe\n    /// as long as you haven't scorned either of the sisters.\n    /// If you have, the dragons will be released\n    /// to wreak havoc upon your memory.\n    /// A spell to dispel the curse exists,\n    /// but a sacred vow prohibits it from being shared\n    /// with those who do not know how to discover it on their own.\n    /// @param self The dynamic array to push into;\n    /// after the call it will be mutated in place to contain the item,\n    /// allocating more memory behind the scenes if necessary.\n    /// @param item The item you wish to push into the array.\n    function arrayPush(UintArray memory self, uint256 item) internal pure {\n        uint256 length = self.array.length;\n        uint256 allocLength = self.allocatedMemory;\n        // The dynamic array is full so we need to allocate more first.\n        // We check for >= instead of ==\n        // so that we can put the require inside the conditional,\n        // reducing the gas costs of `push` slightly.\n        if (length >= allocLength) {\n            // This should never happen if `allocatedMemory` isn't messed with.\n            require(length == allocLength, \"Array length exceeds allocation\");\n            // Allocate twice the original array length,\n            // then copy the contents over.\n            uint256 newMemory = length * 2;\n            uint256[] memory newArray = _allocateUints(newMemory);\n            _copy(newArray, self.array);\n            self.array = newArray;\n            self.allocatedMemory = newMemory;\n        }\n        // We have enough free memory so we can push into the array.\n        _push(self.array, item);\n    }\n\n    function arrayPush(AddressArray memory self, address item) internal pure {\n        uint256 length = self.array.length;\n        uint256 allocLength = self.allocatedMemory;\n        if (length >= allocLength) {\n            require(length == allocLength, \"Array length exceeds allocation\");\n            uint256 newMemory = length * 2;\n            address[] memory newArray = _allocateAddresses(newMemory);\n            _copy(newArray, self.array);\n            self.array = newArray;\n            self.allocatedMemory = newMemory;\n        }\n        _push(self.array, item);\n    }\n\n    /// @notice Pop the last item from the dynamic array,\n    /// removing it and decrementing the array length in place.\n    /// @dev This makes the dragons happy\n    /// as they have more space to roam.\n    /// Thus they have no desire to escape and ravage your buffers.\n    /// @param self The array to pop from.\n    /// @return item The previously last element in the array.\n    function arrayPop(UintArray memory self) internal pure returns (uint256 item) {\n        uint256[] memory array = self.array;\n        uint256 length = array.length;\n        require(length > 0, \"Can't pop from empty array\");\n        return _pop(array);\n    }\n\n    function arrayPop(AddressArray memory self) internal pure returns (address item) {\n        address[] memory array = self.array;\n        uint256 length = array.length;\n        require(length > 0, \"Can't pop from empty array\");\n        return _pop(array);\n    }\n\n    /// @notice Allocate an empty array,\n    /// reserving enough memory to safely store `length` items.\n    /// @dev The array starts with zero length,\n    /// but the allocated buffer has space for `length` words.\n    /// \"What be beyond the bounds of `array`?\" you may ask.\n    /// The answer is: dragons.\n    /// But do not worry,\n    /// for `Array.allocatedMemory` protects your EVM from them.\n    function _allocateUints(uint256 length)\n        private pure returns (uint256[] memory array)\n    {\n        // Calculate the size of the allocated block.\n        // Solidity arrays without a specified constant length\n        // (i.e. `uint256[]` instead of `uint256[8]`)\n        // store the length at the first memory position\n        // and the contents of the array after it,\n        // so we add 1 to the length to account for this.\n        uint256 inMemorySize = (length + 1) * 0x20;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Get some free memory\n            array := mload(0x40)\n            // Write a zero in the length field;\n            // we set the length elsewhere\n            // if we store anything in the array immediately.\n            // When we allocate we only know how many words we reserve,\n            // not how many actually get written.\n            mstore(array, 0)\n            // Move the free memory pointer\n            // to the end of the allocated block.\n            mstore(0x40, add(array, inMemorySize))\n        }\n        return array;\n    }\n\n    function _allocateAddresses(uint256 length)\n        private pure returns (address[] memory array)\n    {\n        uint256 inMemorySize = (length + 1) * 0x20;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            array := mload(0x40)\n            mstore(array, 0)\n            mstore(0x40, add(array, inMemorySize))\n        }\n        return array;\n    }\n\n    /// @notice Unsafe function to copy the contents of one array\n    /// into an empty initialized array\n    /// with sufficient free memory available.\n    function _copy(uint256[] memory dest, uint256[] memory src) private pure {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(src)\n            let byteLength := mul(length, 0x20)\n            // Store the resulting length of the array.\n            mstore(dest, length)\n            // Maintain a write pointer\n            // for the current write location in the destination array\n            // by adding the 32 bytes for the array length\n            // to the starting location.\n            let writePtr := add(dest, 0x20)\n            // Stop copying when the write pointer reaches\n            // the length of the source array.\n            // We can track the endpoint either from the write or read pointer.\n            // This uses the write pointer\n            // because that's the way it was done\n            // in the (public domain) code I stole this from.\n            let end := add(writePtr, byteLength)\n\n            for {\n                // Initialize a read pointer to the start of the source array,\n                // 32 bytes into its memory.\n                let readPtr := add(src, 0x20)\n            } lt(writePtr, end) {\n                // Increase both pointers by 32 bytes each iteration.\n                writePtr := add(writePtr, 0x20)\n                readPtr := add(readPtr, 0x20)\n            } {\n                // Write the source array into the dest memory\n                // 32 bytes at a time.\n                mstore(writePtr, mload(readPtr))\n            }\n        }\n    }\n\n    function _copy(address[] memory dest, address[] memory src) private pure {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(src)\n            let byteLength := mul(length, 0x20)\n            mstore(dest, length)\n            let writePtr := add(dest, 0x20)\n            let end := add(writePtr, byteLength)\n\n            for {\n                let readPtr := add(src, 0x20)\n            } lt(writePtr, end) {\n                writePtr := add(writePtr, 0x20)\n                readPtr := add(readPtr, 0x20)\n            } {\n                mstore(writePtr, mload(readPtr))\n            }\n        }\n    }\n\n    /// @notice Unsafe function to push past the limit of an array.\n    /// Only use with preallocated free memory.\n    function _push(uint256[] memory array, uint256 item) private pure {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Get array length\n            let length := mload(array)\n            let newLength := add(length, 1)\n            // Calculate how many bytes the array takes in memory,\n            // including the length field.\n            // This is equal to 32 * the incremented length.\n            let arraySize := mul(0x20, newLength)\n            // Calculate the first memory position after the array\n            let nextPosition := add(array, arraySize)\n            // Store the item in the available position\n            mstore(nextPosition, item)\n            // Increment array length\n            mstore(array, newLength)\n        }\n    }\n\n    function _push(address[] memory array, address item) private pure {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let length := mload(array)\n            let newLength := add(length, 1)\n            let arraySize := mul(0x20, newLength)\n            let nextPosition := add(array, arraySize)\n            mstore(nextPosition, item)\n            mstore(array, newLength)\n        }\n    }\n\n    function _pop(uint256[] memory array) private pure returns (uint256 item) {\n        uint256 length = array.length;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            // Calculate the memory position of the last element\n            let lastPosition := add(array, mul(length, 0x20))\n            // Retrieve the last item\n            item := mload(lastPosition)\n            // Decrement array length\n            mstore(array, sub(length, 1))\n        }\n        return item;\n    }\n\n    function _pop(address[] memory array) private pure returns (address item) {\n        uint256 length = array.length;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let lastPosition := add(array, mul(length, 0x20))\n            item := mload(lastPosition)\n            mstore(array, sub(length, 1))\n        }\n        return item;\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/GasStation.sol": {

      "content": "pragma solidity 0.5.17;\n\ncontract GasStation {\n    mapping(address => mapping(uint256 => uint256)) gasDeposits;\n\n    function depositGas(address addr) internal {\n        setDeposit(addr, 1);\n    }\n\n    function releaseGas(address addr) internal {\n        setDeposit(addr, 0);\n    }\n\n    function setDeposit(address addr, uint256 val) internal {\n        for (uint256 i = 0; i < gasDepositSize(); i++) {\n            gasDeposits[addr][i] = val;\n        }\n    }\n\n    function gasDepositSize() internal pure returns (uint256);\n}\n"

    },

    "@keep-network/sortition-pools/contracts/SortitionTree.sol": {

      "content": "pragma solidity 0.5.17;\n\nimport \"./StackLib.sol\";\nimport \"./Branch.sol\";\nimport \"./Position.sol\";\nimport \"./Leaf.sol\";\n\ncontract SortitionTree {\n    using StackLib for uint256[];\n    using Branch for uint256;\n    using Position for uint256;\n    using Leaf for uint256;\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position uses per level of the tree;\n    // each branch of the tree contains 2**SLOT_BITS slots.\n    uint256 constant SLOT_BITS = 3;\n    uint256 constant LEVELS = 7;\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Derived constants, do not touch\n    uint256 constant SLOT_COUNT = 2 ** SLOT_BITS;\n    uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n    uint256 constant SLOT_MAX = (2 ** SLOT_WIDTH) - 1;\n    uint256 constant POOL_CAPACITY = SLOT_COUNT ** LEVELS;\n    ////////////////////////////////////////////////////////////////////////////\n\n    // implicit tree\n    // root 8\n    // level2 64\n    // level3 512\n    // level4 4k\n    // level5 32k\n    // level6 256k\n    // level7 2M\n    uint256 root;\n    mapping(uint256 => mapping(uint256 => uint256)) branches;\n    mapping(uint256 => uint256) leaves;\n\n    // the flagged (see setFlag() and unsetFlag() in Position.sol) positions\n    // of all operators present in the pool\n    mapping(address => uint256) flaggedLeafPosition;\n\n    // the leaf after the rightmost occupied leaf of each stack\n    uint256 rightmostLeaf;\n    // the empty leaves in each stack\n    // between 0 and the rightmost occupied leaf\n    uint256[] emptyLeaves;\n\n    constructor() public {\n        root = 0;\n        rightmostLeaf = 0;\n    }\n\n    // checks if operator is already registered in the pool\n    function isOperatorRegistered(address operator) public view returns (bool) {\n        return getFlaggedLeafPosition(operator) != 0;\n    }\n\n    // Sum the number of operators in each trunk\n    function operatorsInPool() public view returns (uint256) {\n        // Get the number of leaves that might be occupied;\n        // if `rightmostLeaf` equals `firstLeaf()` the tree must be empty,\n        // otherwise the difference between these numbers\n        // gives the number of leaves that may be occupied.\n        uint256 nPossiblyUsedLeaves = rightmostLeaf;\n        // Get the number of empty leaves\n        // not accounted for by the `rightmostLeaf`\n        uint256 nEmptyLeaves = emptyLeaves.getSize();\n\n        return (nPossiblyUsedLeaves - nEmptyLeaves);\n    }\n\n    function totalWeight() public view returns (uint256) {\n        return root.sumWeight();\n    }\n\n    function insertOperator(address operator, uint256 weight) internal {\n        require(\n            !isOperatorRegistered(operator),\n            \"Operator is already registered in the pool\"\n        );\n\n        uint256 position = getEmptyLeafPosition();\n        // Record the block the operator was inserted in\n        uint256 theLeaf = Leaf.make(operator, block.number, weight);\n\n        root = setLeaf(position, theLeaf, root);\n\n        // Without position flags,\n        // the position 0x000000 would be treated as empty\n        flaggedLeafPosition[operator] = position.setFlag();\n    }\n\n    function removeOperator(address operator) internal {\n        uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n        require(\n            flaggedPosition != 0,\n            \"Operator is not registered in the pool\"\n        );\n        uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n        root = removeLeaf(unflaggedPosition, root);\n        removeLeafPositionRecord(operator);\n    }\n\n    function updateOperator(address operator, uint256 weight) internal {\n        require(\n            isOperatorRegistered(operator),\n            \"Operator is not registered in the pool\"\n        );\n\n        uint256 flaggedPosition = getFlaggedLeafPosition(operator);\n        uint256 unflaggedPosition = flaggedPosition.unsetFlag();\n        updateLeaf(unflaggedPosition, weight);\n    }\n\n    function removeLeafPositionRecord(address operator) internal {\n        flaggedLeafPosition[operator] = 0;\n    }\n\n    function getFlaggedLeafPosition(address operator)\n        internal\n        view\n        returns (uint256)\n    {\n        return flaggedLeafPosition[operator];\n    }\n\n    function removeLeaf(uint256 position, uint256 _root)\n        internal returns (uint256)\n    {\n        uint256 rightmostSubOne = rightmostLeaf - 1;\n        bool isRightmost = position == rightmostSubOne;\n\n        uint256 newRoot = setLeaf(position, 0, _root);\n\n        if (isRightmost) {\n            rightmostLeaf = rightmostSubOne;\n        } else {\n            emptyLeaves.stackPush(position);\n        }\n        return newRoot;\n    }\n\n    function updateLeaf(uint256 position, uint256 weight) internal {\n        uint256 oldLeaf = leaves[position];\n        if (oldLeaf.weight() != weight) {\n            uint256 newLeaf = oldLeaf.setWeight(weight);\n            root = setLeaf(position, newLeaf, root);\n        }\n    }\n\n    function setLeaf(uint256 position, uint256 theLeaf, uint256 _root)\n        internal returns (uint256)\n    {\n        uint256 childSlot;\n        uint256 treeNode;\n        uint256 newNode;\n        uint256 nodeWeight = theLeaf.weight();\n\n        // set leaf\n        leaves[position] = theLeaf;\n\n        uint256 parent = position;\n        // set levels 7 to 2\n        for (uint256 level = LEVELS; level >= 2; level--) {\n            childSlot = parent.slot();\n            parent = parent.parent();\n            treeNode = branches[level][parent];\n            newNode = treeNode.setSlot(childSlot, nodeWeight);\n            branches[level][parent] = newNode;\n            nodeWeight = newNode.sumWeight();\n        }\n\n        // set level Root\n        childSlot = parent.slot();\n        return _root.setSlot(childSlot, nodeWeight);\n    }\n\n    function pickWeightedLeaf(\n        uint256 index,\n        uint256 _root\n    ) internal view returns (\n        uint256 leafPosition,\n        uint256 leafFirstIndex\n    ) {\n        uint256 currentIndex = index;\n        uint256 currentNode = _root;\n        uint256 currentPosition = 0;\n        uint256 currentSlot;\n\n        require(index < currentNode.sumWeight(), \"Index exceeds weight\");\n\n        // get root slot\n        (currentSlot, currentIndex) = currentNode.pickWeightedSlot(\n            currentIndex\n        );\n\n        // get slots from levels 2 to 7\n        for (uint256 level = 2; level <= LEVELS; level++) {\n            currentPosition = currentPosition.child(currentSlot);\n            currentNode = branches[level][currentPosition];\n            (currentSlot, currentIndex) = currentNode.pickWeightedSlot(\n                currentIndex\n            );\n        }\n\n        // get leaf position\n        leafPosition = currentPosition.child(currentSlot);\n        // get the first index of the leaf\n        // This works because the last weight returned from `pickWeightedSlot()`\n        // equals the \"overflow\" from getting the current slot.\n        leafFirstIndex = index - currentIndex;\n    }\n\n    function getEmptyLeafPosition()\n        internal returns (uint256)\n    {\n        uint256 rLeaf = rightmostLeaf;\n        bool spaceOnRight = (rLeaf + 1) < POOL_CAPACITY;\n        if (spaceOnRight) {\n            rightmostLeaf = rLeaf + 1;\n            return rLeaf;\n        } else {\n            bool emptyLeavesInStack = leavesInStack();\n            require(emptyLeavesInStack, \"Pool is full\");\n            return emptyLeaves.stackPop();\n        }\n    }\n\n    function leavesInStack() internal view returns (bool) {\n        return emptyLeaves.getSize() > 0;\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/StackLib.sol": {

      "content": "pragma solidity 0.5.17;\n\nlibrary StackLib {\n    function stackPeek(uint256[] storage _array)\n        internal\n        view\n        returns (uint256)\n    {\n        require(_array.length > 0, \"No value to peek, array is empty\");\n        return (_array[_array.length - 1]);\n    }\n\n    function stackPush(uint256[] storage _array, uint256 _element) public {\n        _array.push(_element);\n    }\n\n    function stackPop(uint256[] storage _array) internal returns (uint256) {\n        require(_array.length > 0, \"No value to pop, array is empty\");\n        uint256 value = _array[_array.length - 1];\n        _array.length -= 1;\n        return value;\n    }\n\n    function getSize(uint256[] storage _array) internal view returns (uint256) {\n        return _array.length;\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/Branch.sol": {

      "content": "pragma solidity 0.5.17;\n\n/// @notice The implicit 8-ary trees of the sortition pool\n/// rely on packing 8 \"slots\" of 32-bit values into each uint256.\n/// The Branch library permits efficient calculations on these slots.\nlibrary Branch {\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position uses per level of the tree;\n    // each branch of the tree contains 2**SLOT_BITS slots.\n    uint256 constant SLOT_BITS = 3;\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Derived constants, do not touch\n    uint256 constant SLOT_COUNT = 2 ** SLOT_BITS;\n    uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n    uint256 constant LAST_SLOT = SLOT_COUNT - 1;\n    uint256 constant SLOT_MAX = (2 ** SLOT_WIDTH) - 1;\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Calculate the right shift required\n    /// to make the 32 least significant bits of an uint256\n    /// be the bits of the `position`th slot\n    /// when treating the uint256 as a uint32[8].\n    ///\n    /// @dev Not used for efficiency reasons,\n    /// but left to illustrate the meaning of a common pattern.\n    /// I wish solidity had macros, even C macros.\n    function slotShift(uint256 position) internal pure returns (uint256) {\n        return position * SLOT_WIDTH;\n    }\n\n    /// @notice Return the `position`th slot of the `node`,\n    /// treating `node` as a uint32[32].\n    function getSlot(uint256 node, uint256 position)\n        internal pure returns (uint256)\n    {\n        uint256 shiftBits = position * SLOT_WIDTH;\n        // Doing a bitwise AND with `SLOT_MAX`\n        // clears all but the 32 least significant bits.\n        // Because of the right shift by `slotShift(position)` bits,\n        // those 32 bits contain the 32 bits in the `position`th slot of `node`.\n        return (node >> shiftBits) & SLOT_MAX;\n    }\n\n    /// @notice Return `node` with the `position`th slot set to zero.\n    function clearSlot(uint256 node, uint256 position)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 shiftBits = position * SLOT_WIDTH;\n        // Shifting `SLOT_MAX` left by `slotShift(position)` bits\n        // gives us a number where all bits of the `position`th slot are set,\n        // and all other bits are unset.\n        //\n        // Using a bitwise NOT on this number,\n        // we get a uint256 where all bits are set\n        // except for those of the `position`th slot.\n        //\n        // Bitwise ANDing the original `node` with this number\n        // sets the bits of `position`th slot to zero,\n        // leaving all other bits unchanged.\n        return node & ~(SLOT_MAX << shiftBits);\n    }\n\n    /// @notice Return `node` with the `position`th slot set to `weight`.\n    ///\n    /// @param weight The weight of of the node.\n    /// Safely truncated to a 32-bit number,\n    /// but this should never be called with an overflowing weight regardless.\n    function setSlot(uint256 node, uint256 position, uint256 weight)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 shiftBits = position * SLOT_WIDTH;\n        // Clear the `position`th slot like in `clearSlot()`.\n        uint256 clearedNode = node & ~(SLOT_MAX << shiftBits);\n        // Bitwise AND `weight` with `SLOT_MAX`\n        // to clear all but the 32 least significant bits.\n        //\n        // Shift this left by `slotShift(position)` bits\n        // to obtain a uint256 with all bits unset\n        // except in the `position`th slot\n        // which contains the 32-bit value of `weight`.\n        uint256 shiftedWeight = (weight & SLOT_MAX) << shiftBits;\n        // When we bitwise OR these together,\n        // all other slots except the `position`th one come from the left argument,\n        // and the `position`th gets filled with `weight` from the right argument.\n        return clearedNode | shiftedWeight;\n    }\n\n    /// @notice Calculate the summed weight of all slots in the `node`.\n    function sumWeight(uint256 node) internal pure returns (uint256 sum) {\n        sum = node & SLOT_MAX;\n        // Iterate through each slot\n        // by shifting `node` right in increments of 32 bits,\n        // and adding the 32 least significant bits to the `sum`.\n        uint256 newNode = node >> SLOT_WIDTH;\n        while (newNode > 0) {\n            sum += (newNode & SLOT_MAX);\n            newNode = newNode >> SLOT_WIDTH;\n        }\n        return sum;\n    }\n\n    /// @notice Pick a slot in `node` that corresponds to `index`.\n    /// Treats the node like an array of virtual stakers,\n    /// the number of virtual stakers in each slot corresponding to its weight,\n    /// and picks which slot contains the `index`th virtual staker.\n    ///\n    /// @dev Requires that `index` be lower than `sumWeight(node)`.\n    /// However, this is not enforced for performance reasons.\n    /// If `index` exceeds the permitted range,\n    /// `pickWeightedSlot()` returns the rightmost slot\n    /// and an excessively high `newIndex`.\n    ///\n    /// @return slot The slot of `node` containing the `index`th virtual staker.\n    ///\n    /// @return newIndex The index of the `index`th virtual staker of `node`\n    /// within the returned slot.\n    function pickWeightedSlot(uint256 node, uint256 index)\n        internal\n        pure\n        returns (uint256 slot, uint256 newIndex)\n    {\n        newIndex = index;\n        uint256 newNode = node;\n        uint256 currentSlotWeight = newNode & SLOT_MAX;\n        while (newIndex >= currentSlotWeight) {\n            newIndex -= currentSlotWeight;\n            slot++;\n            newNode = newNode >> SLOT_WIDTH;\n            currentSlotWeight = newNode & SLOT_MAX;\n        }\n        return (slot, newIndex);\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/Position.sol": {

      "content": "pragma solidity 0.5.17;\n\nlibrary Position {\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position uses per level of the tree;\n    // each branch of the tree contains 2**SLOT_BITS slots.\n    uint256 constant SLOT_BITS = 3;\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Derived constants, do not touch\n    uint256 constant SLOT_POINTER_MAX = (2 ** SLOT_BITS) - 1;\n    uint256 constant LEAF_FLAG = 1 << 255;\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Return the last 3 bits of a position number,\n    // corresponding to its slot in its parent\n    function slot(uint256 a) internal pure returns (uint256) {\n        return a & SLOT_POINTER_MAX;\n    }\n\n    // Return the parent of a position number\n    function parent(uint256 a) internal pure returns (uint256) {\n        return a >> SLOT_BITS;\n    }\n\n    // Return the location of the child of a at the given slot\n    function child(uint256 a, uint256 s) internal pure returns (uint256) {\n        return (a << SLOT_BITS) | (s & SLOT_POINTER_MAX); // slot(s)\n    }\n\n    // Return the uint p as a flagged position uint:\n    // the least significant 21 bits contain the position\n    // and the 22nd bit is set as a flag\n    // to distinguish the position 0x000000 from an empty field.\n    function setFlag(uint256 p) internal pure returns (uint256) {\n        return p | LEAF_FLAG;\n    }\n\n    // Turn a flagged position into an unflagged position\n    // by removing the flag at the 22nd least significant bit.\n    //\n    // We shouldn't _actually_ need this\n    // as all position-manipulating code should ignore non-position bits anyway\n    // but it's cheap to call so might as well do it.\n    function unsetFlag(uint256 p) internal pure returns (uint256) {\n        return p & (~LEAF_FLAG);\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/Leaf.sol": {

      "content": "pragma solidity 0.5.17;\n\nlibrary Leaf {\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position uses per level of the tree;\n    // each branch of the tree contains 2**SLOT_BITS slots.\n    uint256 constant SLOT_BITS = 3;\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Derived constants, do not touch\n    uint256 constant SLOT_COUNT = 2 ** SLOT_BITS;\n    uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n    uint256 constant SLOT_MAX = (2 ** SLOT_WIDTH) - 1;\n\n    uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;\n    uint256 constant WEIGHT_MAX = SLOT_MAX;\n\n    uint256 constant BLOCKHEIGHT_WIDTH = 96 - WEIGHT_WIDTH;\n    uint256 constant BLOCKHEIGHT_MAX = (2 ** BLOCKHEIGHT_WIDTH) - 1;\n    ////////////////////////////////////////////////////////////////////////////\n\n    function make(address operator, uint256 creationBlock, uint256 weight)\n        internal\n        pure\n        returns (uint256)\n    {\n        // Converting a bytesX type into a larger type\n        // adds zero bytes on the right.\n        uint256 op = uint256(bytes32(bytes20(operator)));\n        // Bitwise AND the weight to erase\n        // all but the 32 least significant bits\n        uint256 wt = weight & WEIGHT_MAX;\n        // Erase all but the 64 least significant bits,\n        // then shift left by 32 bits to make room for the weight\n        uint256 cb = (creationBlock & BLOCKHEIGHT_MAX) << WEIGHT_WIDTH;\n        // Bitwise OR them all together to get\n        // [address operator || uint64 creationBlock || uint32 weight]\n        return (op | cb | wt);\n    }\n\n    function operator(uint256 leaf) internal pure returns (address) {\n        // Converting a bytesX type into a smaller type\n        // truncates it on the right.\n        return address(bytes20(bytes32(leaf)));\n    }\n\n    /// @notice Return the block number the leaf was created in.\n    function creationBlock(uint256 leaf) internal pure returns (uint256) {\n        return ((leaf >> WEIGHT_WIDTH) & BLOCKHEIGHT_MAX);\n    }\n\n    function weight(uint256 leaf) internal pure returns (uint256) {\n        // Weight is stored in the 32 least significant bits.\n        // Bitwise AND ensures that we only get the contents of those bits.\n        return (leaf & WEIGHT_MAX);\n    }\n\n    function setWeight(uint256 leaf, uint256 newWeight)\n        internal pure returns (uint256)\n    {\n        return ((leaf & ~WEIGHT_MAX) | (newWeight & WEIGHT_MAX));\n    }\n}\n"

    },

    "@keep-network/sortition-pools/contracts/Interval.sol": {

      "content": "pragma solidity 0.5.17;\n\nimport \"./Leaf.sol\";\nimport \"./DynamicArray.sol\";\n\nlibrary Interval {\n    using DynamicArray for DynamicArray.UintArray;\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position uses per level of the tree;\n    // each branch of the tree contains 2**SLOT_BITS slots.\n    uint256 constant SLOT_BITS = 3;\n    ////////////////////////////////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////////////////////////////////\n    // Derived constants, do not touch\n    uint256 constant SLOT_COUNT = 2 ** SLOT_BITS;\n    uint256 constant SLOT_WIDTH = 256 / SLOT_COUNT;\n    uint256 constant SLOT_MAX = (2 ** SLOT_WIDTH) - 1;\n\n    uint256 constant WEIGHT_WIDTH = SLOT_WIDTH;\n    uint256 constant WEIGHT_MAX = SLOT_MAX;\n\n    uint256 constant START_INDEX_WIDTH = WEIGHT_WIDTH;\n    uint256 constant START_INDEX_MAX = WEIGHT_MAX;\n    uint256 constant START_INDEX_SHIFT = WEIGHT_WIDTH;\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Interval stores information about a selected interval\n    // inside a single uint256 in a manner similar to Leaf\n    // but optimized for use within group selection\n    //\n    // The information stored consists of:\n    // - weight\n    // - starting index\n\n    function make(\n        uint256 startingIndex,\n        uint256 weight\n    ) internal pure returns (uint256) {\n        uint256 idx = (startingIndex & START_INDEX_MAX) << START_INDEX_SHIFT;\n        uint256 wt = weight & WEIGHT_MAX;\n        return (idx | wt);\n    }\n\n    function opWeight(uint256 op) internal pure returns (uint256) {\n        return (op & WEIGHT_MAX);\n    }\n\n    // Return the starting index of the interval\n    function index(uint256 a) internal pure returns (uint256) {\n        return ((a >> WEIGHT_WIDTH) & START_INDEX_MAX);\n    }\n\n    function setIndex(uint256 op, uint256 i) internal pure returns (uint256) {\n        uint256 shiftedIndex = ((i & START_INDEX_MAX) << WEIGHT_WIDTH);\n        return op & (~(START_INDEX_MAX << WEIGHT_WIDTH)) | shiftedIndex;\n    }\n\n    function insert(DynamicArray.UintArray memory intervals, uint256 interval)\n        internal\n        pure\n    {\n        uint256 tempInterval = interval;\n        for (uint256 i = 0; i < intervals.array.length; i++) {\n            uint256 thisInterval = intervals.array[i];\n            // We can compare the raw underlying uint256 values\n            // because the starting index is stored\n            // in the most significant nonzero bits.\n            if (tempInterval < thisInterval) {\n                intervals.array[i] = tempInterval;\n                tempInterval = thisInterval;\n            }\n        }\n        intervals.arrayPush(tempInterval);\n    }\n\n    function skip(uint256 truncatedIndex, DynamicArray.UintArray memory intervals)\n        internal\n        pure\n        returns (uint256 mappedIndex)\n    {\n        mappedIndex = truncatedIndex;\n        for (uint256 i = 0; i < intervals.array.length; i++) {\n            uint256 interval = intervals.array[i];\n            // If the index is greater than the starting index of the `i`th leaf,\n            // we need to skip that leaf.\n            if (mappedIndex >= index(interval)) {\n                // Add the weight of this previous leaf to the index,\n                // ensuring that we skip the leaf.\n                mappedIndex += Leaf.weight(interval);\n            } else {\n                break;\n            }\n        }\n        return mappedIndex;\n    }\n\n    /// @notice Recalculate the starting indices of the previousLeaves\n    /// when an interval is removed or added at the specified index.\n    /// @dev Applies weightDiff to each starting index in previousLeaves\n    /// that exceeds affectedStartingIndex.\n    /// @param affectedStartingIndex The starting index of the interval.\n    /// @param weightDiff The difference in weight;\n    /// negative for a deleted interval,\n    /// positive for an added interval.\n    /// @param previousLeaves The starting indices and weights\n    /// of the previously selected leaves.\n    /// @return The starting indices of the previous leaves\n    /// in a tree with the affected interval updated.\n    function remapIndices(\n        uint256 affectedStartingIndex,\n        int256 weightDiff,\n        DynamicArray.UintArray memory previousLeaves\n    )\n        internal\n        pure\n    {\n        uint256 nPreviousLeaves = previousLeaves.array.length;\n\n        for (uint256 i = 0; i < nPreviousLeaves; i++) {\n            uint256 interval = previousLeaves.array[i];\n            uint256 startingIndex = index(interval);\n            // If index is greater than the index of the affected interval,\n            // update the starting index by the weight change.\n            if (startingIndex > affectedStartingIndex) {\n                uint256 newIndex = uint256(int256(startingIndex) + weightDiff);\n                previousLeaves.array[i] = setIndex(interval, newIndex);\n            }\n        }\n    }\n}\n"

    }

  },

  "settings": {

    "libraries": {

      "@keep-network/sortition-pools/contracts/BondedSortitionPoolFactory.sol": {

        "StackLib": "0x481346923f507d900031a5b463A365E1f71B8D57"

      }

    },

    "metadata": {

      "useLiteralContent": true

    },

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "abi"

        ]

      }

    }

  }

}}