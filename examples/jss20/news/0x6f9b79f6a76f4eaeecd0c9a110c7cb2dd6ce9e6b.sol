{"AccessControl.sol":{"content":"pragma solidity ^0.5.0;\n/// @title A facet of KittyCore that manages special access privileges.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the KittyCore contract documentation to understand how the various contract facets are arranged.\n\ncontract AccessControl {\n    // This facet controls access control for CryptoKitties. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the KittyCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from KittyCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 kitties to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn\u0027t have the ability to act in those roles. This\n    // restriction is intentional so that we aren\u0027t tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public ceoAddress;\n    address public cfoAddress;\n    address public cooAddress;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress, \"only CEO\");\n        _;\n    }\n\n    /// @dev Access modifier for CFO-only functionality\n    modifier onlyCFO() {\n        require(msg.sender == cfoAddress, \"only CFO\");\n        _;\n    }\n\n    /// @dev Access modifier for COO-only functionality\n    modifier onlyCOO() {\n        require(msg.sender == cooAddress, \"only COO\");\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == cooAddress ||\n            msg.sender == ceoAddress ||\n            msg.sender == cfoAddress, \"only CLevel\"\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n    /// @param _newCEO The address of the new CEO\n    function setCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0), \"newCEO looks like no changes\");\n\n        ceoAddress = _newCEO;\n    }\n\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n    /// @param _newCFO The address of the new CFO\n    function setCFO(address _newCFO) external onlyCEO {\n        require(_newCFO != address(0), \"newCFO looks like no changes\");\n\n        cfoAddress = _newCFO;\n    }\n\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n    /// @param _newCOO The address of the new COO\n    function setCOO(address _newCOO) external onlyCEO {\n        require(_newCOO != address(0), \"newCOO looks like no changes\");\n\n        cooAddress = _newCOO;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused() {\n        require(!paused, \"current contract is paused\");\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused {\n        require(paused, \"current contract is not paused\");\n        _;\n    }\n\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\n    ///  a bug or exploit is detected and we need to limit damage.\n    function pause() external onlyCLevel whenNotPaused {\n        paused = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n    ///  one reason we may pause the contract is when CFO or COO accounts are\n    ///  compromised.\n    /// @notice This is public rather than external so it can be called by\n    ///  derived contracts.\n    function unpause() public onlyCEO whenPaused {\n        // can\u0027t unpause if contract was upgraded\n        paused = false;\n    }\n}\n"},"ERC721.sol":{"content":"pragma solidity ^0.5.11;\r\n\r\ncontract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function transfer(address payable _to, uint256 _tokenId) external;\r\n    function approve(address payable _to, uint256 _tokenId) external;\r\n    function takeOwnership(uint256 _tokenId) public;\r\n}\r\n"},"GridBase.sol":{"content":"pragma solidity ^0.5.11;\r\n\r\nimport \"./ownable.sol\";\r\nimport \"./AccessControl.sol\";\r\n//import \"./GridOwnership.sol\";\r\n//import \"./safemath.sol\";\r\n//import \"./console.sol\";\r\n\r\ncontract GridBase is Ownable, AccessControl {\r\n\r\n    //using SafeMath for uint256;\r\n\r\n    uint public levelUpFee = 0.01 ether;\r\n    uint public limitGridsEachtime = 100;\r\n    uint public discountGridsCount = 0;\r\n\r\n    //uint fee;\r\n\r\n    struct structGird {\r\n        uint16 x;\r\n        uint16 y;\r\n        uint level;\r\n        address payable owner;\r\n        address payable inviter;\r\n    }\r\n\r\n    structGird[] public arr_struct_grid;\r\n\r\n    mapping (address =\u003e uint) public mappingOwnerGridCount;\r\n    mapping (uint16 =\u003e uint) public mappingPositionToGirdId;\r\n\r\n    // Set in case the core contract is broken and an upgrade is required\r\n    address public newContractAddress;\r\n\r\n    address payable public authorAddress;\r\n    address payable public foundationAddress;\r\n\r\n    /// @notice Creates the main CryptoKitties smart contract instance.\r\n    constructor () public {\r\n        // Starts paused.\r\n        paused = true;\r\n\r\n        // the creator of the contract is the initial CEO\r\n        ceoAddress = msg.sender;\r\n        // the creator of the contract is also the initial COO\r\n        cooAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n    }\r\n\r\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\r\n    ///  breaking bug. This method does nothing but keep track of the new contract and\r\n    ///  emit a message indicating that the new address is set. It\u0027s up to clients of this\r\n    ///  contract to update to the new contract address in that case. (This contract will\r\n    ///  be paused indefinitely if such an upgrade takes place.)\r\n    /// @param _v2Address new address\r\n    function setNewContractAddress(address _v2Address) external onlyCEO whenPaused {\r\n        // See README.md for updgrade plan\r\n        newContractAddress = _v2Address;\r\n        emit ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    function setAuthorAddress(address payable _address) external onlyCEO whenPaused {\r\n        require(_address != address(0), \"authorAddress can not be empty\");\r\n        authorAddress = _address;\r\n    }\r\n\r\n    function setFoundationAddress(address payable _address) external onlyCEO whenPaused {\r\n        require(_address != address(0), \"foundationAddress can not be empty\");\r\n        foundationAddress = _address;\r\n    }\r\n\r\n    /*/// @notice Returns all the relevant information about a specific kitty.\r\n    /// @param _id The ID of the kitty of interest.\r\n    function getGrid(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n        uint16 x,\r\n        uint16 y,\r\n        uint256 level\r\n    ) {\r\n        structGird memory _grid = arr_struct_grid[_id];\r\n\r\n        x = uint16(_grid.x);\r\n        y = uint16(_grid.y);\r\n        level = uint256(_grid.level);\r\n    }*/\r\n\r\n    /// @dev Override unpause so it requires all external contract addresses\r\n    ///  to be set before contract can be unpaused. Also, we can\u0027t have\r\n    ///  newContractAddress set either, because then the contract was upgraded.\r\n    /// @notice This is public rather than external so we can call super.unpause\r\n    ///  without using an expensive CALL.\r\n    function unpause() public onlyCEO whenPaused {\r\n        require(newContractAddress == address(0), \"set newContractAddress first\");\r\n        require(authorAddress != address(0), \"set authorAddress first\");\r\n        require(foundationAddress != address(0), \"set foundationAddress first\");\r\n\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n\r\n    function withdraw() external onlyOwner whenPaused {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    function setLevelUpFee(uint _fee) external onlyCLevel whenPaused {\r\n        levelUpFee = _fee;\r\n    }\r\n\r\n    function setlimitGridsEachtime(uint _limit) external onlyCLevel whenPaused {\r\n        limitGridsEachtime = _limit;\r\n    }\r\n\r\n\r\n  function getContractStatus() external view onlyCLevel returns(uint, uint, uint) {\r\n    return (levelUpFee, limitGridsEachtime, address(this).balance);\r\n  }\r\n\r\n  function getLevelUpFee() external view whenNotPaused returns(uint) {\r\n    return levelUpFee;\r\n  }\r\n\r\n  function getLimitGridsEachtime() external view whenNotPaused returns(uint) {\r\n    return limitGridsEachtime;\r\n  }\r\n\r\n  function getContractBalance() external view onlyCLevel returns(uint) {\r\n    return address(this).balance;\r\n  }\r\n}\r\n"},"GridMain.sol":{"content":"pragma solidity ^0.5.11;\r\n\r\nimport \"./GridOwnership.sol\";\r\nimport \"./safemath.sol\";\r\n//import \"./console.sol\";\r\n\r\ncontract GridMain is GridOwnership {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath16 for uint16;\r\n\r\n    //uint16 public version = 101;\r\n\r\n    function buyGird(uint16 _i, uint16 _j, uint16 _k, uint16 _l, address payable _inviter) external payable whenNotPaused {\r\n        require(_i \u003e= 1 \u0026\u0026 _i \u003c= 100, \"value invalid\");\r\n        require(_j \u003e= 1 \u0026\u0026 _j \u003c= 100, \"value invalid\");\r\n        require(_k \u003e= _i \u0026\u0026 _k \u003c= 100, \"value invalid\");\r\n        require(_l \u003e= _j \u0026\u0026 _l \u003c= 100, \"value invalid\");\r\n        //require(_k \u003e= _i \u0026\u0026 _l \u003e= _j, \"value invalid\");\r\n        require((_k-_i+1)*(_l-_j+1) \u003c= limitGridsEachtime, \"too many grids you selected, that may cause problems.\");\r\n        uint16 _x;\r\n        uint16 _y;\r\n        //string memory position;\r\n        uint16 position;\r\n        uint256 currentPrice = 0;\r\n        uint256 gridId = 0;\r\n        uint256 tempLevelUpFee = 0;\r\n        address payable inviter;\r\n\r\n        if(_inviter == address(0)){\r\n            inviter = owner;\r\n        }else{\r\n            inviter = _inviter;\r\n        }\r\n\r\n        //log(\"mappingPositionToGirdId[position]: \", mappingPositionToGirdId[position]);\r\n        //log(\"arr_struct_grid[1].level: \", arr_struct_grid[1].level);\r\n        //log(\"msg.value: \", msg.value);\r\n        //uint fee = msg.value;\r\n        //address acc = msg.sender;\r\n\r\n        for(_x = _i; _x\u003c=_k; _x++){\r\n            for(_y = _j; _y\u003c=_l; _y++){\r\n                //position = strConcat(uint2str(_x),uint2str(_y));\r\n                //log(\"position: \", position);\r\n                position = (_x-1)*100+_y;\r\n                gridId = mappingPositionToGirdId[position];\r\n                if(gridId \u003e 0){\r\n                    structGird storage _grid = arr_struct_grid[gridId-1];\r\n                    //if(_grid.level \u003e 0){\r\n                        //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\r\n                        //mappingPositionToOwner[position] = msg.sender;\r\n                        currentPrice += _grid.level * levelUpFee + levelUpFee;\r\n                        _grid.owner.transfer(_grid.level * levelUpFee + levelUpFee / 5);\r\n                    _grid.inviter.transfer(levelUpFee / 10);\r\n                    authorAddress.transfer(levelUpFee / 10);\r\n                    foundationAddress.transfer(levelUpFee / 10);\r\n                    owner.transfer(levelUpFee/50);\r\n                    mappingOwnerGridCount[_grid.owner] = mappingOwnerGridCount[_grid.owner].sub(1);\r\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\r\n                    _grid.level = _grid.level.add(1);\r\n                    _grid.owner = msg.sender;\r\n                    if(_grid.inviter != inviter){\r\n                        _grid.inviter = inviter;\r\n                    }\r\n                    //}\r\n                }else{\r\n                    //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\r\n                    //mappingGirdPositionToOwner[position] = msg.sender;\r\n                    //tempLevelUpFee = levelUpFee;\r\n                    if(discountGridsCount \u003c 1000){\r\n                        //currentPrice += levelUpFee;\r\n                    }else if(discountGridsCount \u003c 3000){\r\n                        tempLevelUpFee = levelUpFee*1/10;\r\n                    }else if(discountGridsCount \u003c 6000){\r\n                        tempLevelUpFee = levelUpFee*3/10;\r\n                    }else if(discountGridsCount \u003c 10000){\r\n                        tempLevelUpFee = levelUpFee*6/10;\r\n                    }else{\r\n                        tempLevelUpFee = levelUpFee;\r\n                    }\r\n                    discountGridsCount = discountGridsCount.add(1);\r\n                    currentPrice += tempLevelUpFee;\r\n                    uint id = arr_struct_grid.push(structGird(_x, _y, 1, msg.sender, inviter));\r\n                    mappingPositionToGirdId[position] = id;\r\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\r\n                    owner.transfer(tempLevelUpFee);\r\n                }\r\n            }\r\n        }\r\n        require(msg.value \u003e= currentPrice, \"out of your balance\");\r\n        //require(address(this).balance \u003e= currentPrice, \"out of contract balance, please buy level0 grids\");\r\n        /*for(_x = _i; _x\u003c=_k; _x++){\r\n            for(_y = _j; _y\u003c=_l; _y++){\r\n                //position = strConcat(uint2str(_x),uint2str(_y));\r\n                position = (_x-1)*100+_y;\r\n                gridId = mappingPositionToGirdId[position];\r\n                if(gridId \u003e 0){\r\n                    structGird memory _grid = arr_struct_grid[gridId-1];\r\n                 //\u0026\u0026 _grid.level \u003e 0){\r\n                    //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\r\n                    //mappingPositionToOwner[position] = msg.sender;\r\n                    //mappingPositionToGird[position].level = mappingPositionToGird[position].level.add(1);\r\n                    //mappingPositionToGird[position].owner = msg.sender;\r\n                    _grid.owner.transfer(_grid.level * levelUpFee + levelUpFee / 5);\r\n                    _grid.inviter.transfer(levelUpFee / 10);\r\n                    authorAddress.transfer(levelUpFee / 10);\r\n                    foundationAddress.transfer(levelUpFee / 10);\r\n                    owner.transfer(levelUpFee/50);\r\n\r\n                    mappingOwnerGridCount[_grid.owner] = mappingOwnerGridCount[_grid.owner].sub(1);\r\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\r\n                    _grid.level = _grid.level.add(1);\r\n                    _grid.owner = msg.sender;\r\n                    _grid.inviter = inviter;\r\n                }else{\r\n                    uint id = arr_struct_grid.push(structGird(_x, _y, 1, msg.sender, inviter));\r\n                    mappingPositionToGirdId[position] = id;\r\n                    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].add(1);\r\n                    owner.transfer(levelUpFee);\r\n                    //mappingGirdPositionToOwner[position] = msg.sender;\r\n                    //mappingPositionToGird[position] = structGird(_x, _y, 1, msg.sender);\r\n                }\r\n            }\r\n        }*/\r\n        msg.sender.transfer(msg.value.sub(currentPrice));\r\n    }\r\n\r\n    function getGridPrice(uint16 _i, uint16 _j, uint16 _k, uint16 _l) external view whenNotPaused returns(uint256){\r\n        require(_i \u003e= 1 \u0026\u0026 _i \u003c= 100, \"value invalid\");\r\n        require(_j \u003e= 1 \u0026\u0026 _j \u003c= 100, \"value invalid\");\r\n        require(_k \u003e= _i \u0026\u0026 _k \u003c= 100, \"value invalid\");\r\n        require(_l \u003e= _j \u0026\u0026 _l \u003c= 100, \"value invalid\");\r\n        //require(_k \u003e= _i \u0026\u0026 _l \u003e= _j, \"value invalid\");\r\n        require((_k-_i+1)*(_l-_j+1) \u003c= limitGridsEachtime, \"too many grids you selected, that may cause problems.\");\r\n        uint16 _x;\r\n        uint16 _y;\r\n        //string memory position;\r\n        uint16 position;\r\n\r\n        //log(\"mappingPositionToGirdId[position]: \", mappingPositionToGirdId[position]);\r\n        //log(\"arr_struct_grid[1].level: \", arr_struct_grid[1].level);\r\n        //log(\"msg.value: \", msg.value);\r\n        //uint fee = msg.value;\r\n        //address acc = msg.sender;\r\n\r\n        uint256 currentPrice = 0;\r\n        uint256 gridId = 0;\r\n        uint256 tempLevelUpFee = 0;\r\n        for(_x = _i; _x\u003c=_k; _x++){\r\n            for(_y = _j; _y\u003c=_l; _y++){\r\n                //position = strConcat(uint2str(_x),uint2str(_y));\r\n                //log(\"position: \", position);\r\n                position = (_x-1)*100+_y;\r\n                gridId = mappingPositionToGirdId[position];\r\n                if(gridId \u003e 0){\r\n                    structGird memory _grid = arr_struct_grid[gridId-1];\r\n                    //if(_grid.level \u003e 0){\r\n                        //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\r\n                        //mappingPositionToOwner[position] = msg.sender;\r\n                        currentPrice += _grid.level * levelUpFee + levelUpFee;\r\n                    //}\r\n                }else{\r\n                    //uint16 id = arr_struct_grid.push(structGird(_x, _y, 1)) - 1;\r\n                    //mappingGirdPositionToOwner[position] = msg.sender;\r\n                    if(discountGridsCount \u003c 1000){\r\n                        //currentPrice += levelUpFee;\r\n                    }else if(discountGridsCount \u003c 3000){\r\n                        tempLevelUpFee = levelUpFee*1/10;\r\n                    }else if(discountGridsCount \u003c 6000){\r\n                        tempLevelUpFee = levelUpFee*3/10;\r\n                    }else if(discountGridsCount \u003c 10000){\r\n                        tempLevelUpFee = levelUpFee*6/10;\r\n                    }else{\r\n                        tempLevelUpFee = levelUpFee;\r\n                    }\r\n                    //discountGridsCount = discountGridsCount.add(1);\r\n                    currentPrice += tempLevelUpFee;\r\n                    //currentPrice += levelUpFee;\r\n                }\r\n            }\r\n        }\r\n\r\n        return currentPrice;\r\n    }\r\n}\r\n"},"GridOwnership.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./GridBase.sol\";\r\nimport \"./ERC721.sol\";\r\nimport \"./safemath.sol\";\r\n\r\ncontract GridOwnership is ERC721, GridBase {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping (uint =\u003e address) gridApprovals;\r\n\r\n  modifier onlyOwnerOf(uint _gridId) {\r\n    require(msg.sender == arr_struct_grid[_gridId].owner, \"you are not owner of this grid\");\r\n    _;\r\n  }\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance) {\r\n    return mappingOwnerGridCount[_owner];\r\n  }\r\n\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner) {\r\n    _owner = arr_struct_grid[_tokenId].owner;\r\n    require(_owner != address(0), \"address invalid\");\r\n  }\r\n\r\n  function _transfer(address _from, address payable _to, uint256 _tokenId) private {\r\n    mappingOwnerGridCount[_to] = mappingOwnerGridCount[_to].add(1);\r\n    mappingOwnerGridCount[msg.sender] = mappingOwnerGridCount[msg.sender].sub(1);\r\n    arr_struct_grid[_tokenId].owner = _to;\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  function transfer(address payable _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) whenNotPaused {\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_to != address(0), \"address invalid\");\r\n    // Disallow transfers to this contract to prevent accidental misuse.\r\n    // The contract should never own any kitties (except very briefly\r\n    // after a gen0 cat is created and before it goes on auction).\r\n    require(_to != address(this), \"address invalid\");\r\n    // Disallow transfers to the auction contracts to prevent accidental\r\n    // misuse. Auction contracts should only take ownership of kitties\r\n    // through the allow + transferFrom flow.\r\n    //require(_to != address(saleAuction));\r\n    //require(_to != address(siringAuction));\r\n    _transfer(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  function approve(address payable _to, uint256 _tokenId) external onlyOwnerOf(_tokenId) whenNotPaused {\r\n    gridApprovals[_tokenId] = _to;\r\n    emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  function takeOwnership(uint256 _tokenId) public {\r\n    require(gridApprovals[_tokenId] == msg.sender, \"you are not that guy\");\r\n    address owner = ownerOf(_tokenId);\r\n    _transfer(owner, msg.sender, _tokenId);\r\n  }\r\n}"},"ownable.sol":{"content":"pragma solidity ^0.5.11;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event ContractOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n    function transferContractOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"new owner can not be empty\");\r\n        emit ContractOwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n"},"safemath.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath32\r\n * @dev SafeMath library implemented for uint32\r\n */\r\nlibrary SafeMath32 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint32 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint32 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function mod(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath16\r\n * @dev SafeMath library implemented for uint16\r\n */\r\nlibrary SafeMath16 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint16 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint16 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint16 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function mod(uint16 a, uint16 b, string memory errorMessage) internal pure returns (uint16) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n"}}