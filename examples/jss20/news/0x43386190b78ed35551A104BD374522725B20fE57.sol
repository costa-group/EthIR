{"DeliverFunds.sol":{"content":"pragma solidity 0.5.12;\r\n\r\ncontract DeliverFunds {\r\n    constructor(address payable target) public payable {\r\n        selfdestruct(target);\r\n    }\r\n}"},"EthexSuperprize.sol":{"content":"pragma solidity 0.5.12;\r\n\r\n/**\r\n * (E)t)h)e)x) Superprize Contract \r\n *  This smart-contract is the part of Ethex Lottery fair game.\r\n *  See latest version at https://github.com/ethex-bet/ethex-lottery \r\n *  http://ethex.bet\r\n */\r\n \r\n import \"./DeliverFunds.sol\";\r\n import \"./Ownable.sol\";\r\n \r\n contract EthexSuperprize is Ownable {\r\n    struct Payout {\r\n        uint256 index;\r\n        uint256 amount;\r\n        uint256 block;\r\n        address payable winnerAddress;\r\n        uint256 betId;\r\n    }\r\n     \r\n    Payout[] public payouts;\r\n    \r\n    address public lotoAddress;\r\n    address payable public newVersionAddress;\r\n    EthexSuperprize public previousContract;\r\n    uint256 public hold;\r\n    \r\n    event Superprize (\r\n        uint256 index,\r\n        uint256 amount,\r\n        address winner,\r\n        uint256 betId,\r\n        byte state\r\n    );\r\n    \r\n    uint8 internal constant PARTS = 6;\r\n    uint256 internal constant PRECISION = 1 ether;\r\n    uint256 internal constant MONTHLY = 150000;\r\n\r\n    function() external payable { }\r\n    \r\n    function initSuperprize(address payable winner, uint256 betId) external {\r\n        require(msg.sender == lotoAddress, \"Loto only\");\r\n        uint256 amount = address(this).balance - hold;\r\n        hold = address(this).balance;\r\n        uint256 sum;\r\n        uint256 temp;\r\n        for (uint256 i = 1; i \u003c PARTS; i++) {\r\n            temp = amount * PRECISION * (i - 1 + 10) / 75 / PRECISION;\r\n            sum += temp;\r\n            payouts.push(Payout(i, temp, block.number + i * MONTHLY, winner, betId));\r\n        }\r\n        payouts.push(Payout(PARTS, amount - sum, block.number + PARTS * MONTHLY, winner, betId));\r\n        emit Superprize(0, amount, winner, betId, 0);\r\n    }\r\n    \r\n    function paySuperprize() external onlyOwner {\r\n        if (payouts.length == 0)\r\n            return;\r\n        Payout[] memory payoutArray = new Payout[](payouts.length);\r\n        uint i = payouts.length;\r\n        while (i \u003e 0) {\r\n            i--;\r\n            if (payouts[i].block \u003c= block.number) {\r\n                emit Superprize(payouts[i].index, payouts[i].amount, payouts[i].winnerAddress, payouts[i].betId, 0x01);\r\n                hold -= payouts[i].amount;\r\n            }\r\n            payoutArray[i] = payouts[i];\r\n            payouts.pop();\r\n        }\r\n        for (i = 0; i \u003c payoutArray.length; i++)\r\n            if (payoutArray[i].block \u003e block.number)\r\n                payouts.push(payoutArray[i]);\r\n        for (i = 0; i \u003c payoutArray.length; i++)\r\n            if (payoutArray[i].block \u003c= block.number \u0026\u0026 !payoutArray[i].winnerAddress.send(payoutArray[i].amount))\r\n                (new DeliverFunds).value(payoutArray[i].amount)(payoutArray[i].winnerAddress);\r\n    }\r\n     \r\n    function setOldVersion(address payable oldAddress) external onlyOwner {\r\n        previousContract = EthexSuperprize(oldAddress);\r\n        lotoAddress = previousContract.lotoAddress();\r\n        hold = previousContract.hold();\r\n        uint256 index;\r\n        uint256 amount;\r\n        uint256 betBlock;\r\n        address payable winner;\r\n        uint256 betId;\r\n        uint256 payoutsCount = previousContract.getPayoutsCount();\r\n        for (uint i = 0; i \u003c payoutsCount; i++) {\r\n            (index, amount, betBlock, winner, betId) = previousContract.payouts(i);\r\n            payouts.push(Payout(index, amount, betBlock, winner, betId));\r\n        }\r\n        previousContract.migrate();\r\n    }\r\n    \r\n    function setNewVersion(address payable newVersion) external onlyOwner {\r\n        newVersionAddress = newVersion;\r\n    }\r\n    \r\n    function setLoto(address loto) external onlyOwner {\r\n        lotoAddress = loto;\r\n    }\r\n    \r\n    function migrate() external {\r\n        require(msg.sender == owner || msg.sender == newVersionAddress);\r\n        require(newVersionAddress != address(0));\r\n        newVersionAddress.transfer(address(this).balance);\r\n    }   \r\n\r\n    function getPayoutsCount() public view returns (uint256) { return payouts.length; }\r\n}"},"Ownable.sol":{"content":"pragma solidity 0.5.12;\r\n\r\ncontract Ownable {\r\n    address payable public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}"}}