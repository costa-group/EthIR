{{

  "language": "Solidity",

  "sources": {

    "solidity/contracts/cryptography/BLS.sol": {

pragma solidity ^0.5.17;
    },

    "solidity/contracts/cryptography/AltBn128.sol": {

      "content": "pragma solidity 0.5.17;\n\nimport \"../utils/ModUtils.sol\";\n\n/**\n * @title Operations on alt_bn128\n * @dev Implementations of common elliptic curve operations on Ethereum's\n * (poorly named) alt_bn128 curve. Whenever possible, use post-Byzantium\n * pre-compiled contracts to offset gas costs. Note that these pre-compiles\n * might not be available on all (eg private) chains.\n */\nlibrary AltBn128 {\n\n    using ModUtils for uint256;\n\n    // G1Point implements a point in G1 group.\n    struct G1Point {\n        uint256 x;\n        uint256 y;\n    }\n\n    // gfP2 implements a field of size pÂ² as a quadratic extension of the base field.\n    struct gfP2 {\n        uint256 x;\n        uint256 y;\n    }\n\n    // G2Point implements a point in G2 group.\n    struct G2Point {\n        gfP2 x;\n        gfP2 y;\n    }\n\n    // p is a prime over which we form a basic field\n    // Taken from go-ethereum/crypto/bn256/cloudflare/constants.go\n    uint256 constant p = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    function getP() internal pure returns (uint256) {\n        return p;\n    }\n\n    /**\n     * @dev Gets generator of G1 group.\n     * Taken from go-ethereum/crypto/bn256/cloudflare/curve.go\n     */\n    uint256 constant g1x = 1;\n    uint256 constant g1y = 2;\n    function g1() internal pure returns (G1Point memory) {\n        return G1Point(g1x, g1y);\n    }\n\n    /**\n     * @dev Gets generator of G2 group.\n     * Taken from go-ethereum/crypto/bn256/cloudflare/twist.go\n     */\n    uint256 constant g2xx = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant g2xy = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant g2yx = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant g2yy = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    function g2() internal pure returns (G2Point memory) {\n        return G2Point(\n            gfP2(g2xx, g2xy),\n            gfP2(g2yx, g2yy)\n        );\n    }\n\n    /**\n     * @dev Gets twist curve B constant.\n     * Taken from go-ethereum/crypto/bn256/cloudflare/twist.go\n     */\n    uint256 constant twistBx = 266929791119991161246907387137283842545076965332900288569378510910307636690;\n    uint256 constant twistBy = 19485874751759354771024239261021720505790618469301721065564631296452457478373;\n    function twistB() private pure returns (gfP2 memory) {\n        return gfP2(twistBx, twistBy);\n    }\n\n    /**\n     * @dev Gets root of the point where x and y are equal.\n     */\n    uint256 constant hexRootX = 21573744529824266246521972077326577680729363968861965890554801909984373949499;\n    uint256 constant hexRootY = 16854739155576650954933913186877292401521110422362946064090026408937773542853;\n    function hexRoot() private pure returns (gfP2 memory) {\n        return gfP2(hexRootX, hexRootY);\n    }\n\n    /**\n     * @dev g1YFromX computes a Y value for a G1 point based on an X value.\n     * This computation is simply evaluating the curve equation for Y on a\n     * given X, and allows a point on the curve to be represented by just\n     * an X value + a sign bit.\n     */\n    function g1YFromX(uint256 x)\n        internal\n        view returns(uint256)\n    {\n        return ((x.modExp(3, p) + 3) % p).modSqrt(p);\n    }\n\n    /**\n     * @dev g2YFromX computes a Y value for a G2 point based on an X value.\n     * This computation is simply evaluating the curve equation for Y on a\n     * given X, and allows a point on the curve to be represented by just\n     * an X value + a sign bit.\n     */\n    function g2YFromX(gfP2 memory _x)\n        internal\n        pure returns(gfP2 memory y)\n    {\n        (uint256 xx, uint256 xy) = _gfP2CubeAddTwistB(_x.x, _x.y);\n\n        // Using formula y = x ^ (p^2 + 15) / 32 from\n        // https://github.com/ethereum/beacon_chain/blob/master/beacon_chain/utils/bls.py\n        // (p^2 + 15) / 32 results into a big 512bit value, so breaking it to two uint256 as (a * a + b)\n        uint256 a = 3869331240733915743250440106392954448556483137451914450067252501901456824595;\n        uint256 b = 146360017852723390495514512480590656176144969185739259173561346299185050597;\n\n        (uint256 xbx, uint256 xby) = _gfP2Pow(xx, xy, b);\n        (uint256 yax, uint256 yay) = _gfP2Pow(xx, xy, a);\n        (uint256 ya2x, uint256 ya2y) = _gfP2Pow(yax, yay, a);\n        (y.x, y.y) = _gfP2Multiply(ya2x, ya2y, xbx, xby);\n\n        // Multiply y by hexRoot constant to find correct y.\n        while (!_g2X2y(xx, xy, y.x, y.y)) {\n            (y.x, y.y) = _gfP2Multiply(y.x, y.y, hexRootX, hexRootY);\n        }\n    }\n\n    /**\n     * @dev Hash a byte array message, m, and map it deterministically to a\n     * point on G1. Note that this approach was chosen for its simplicity /\n     * lower gas cost on the EVM, rather than good distribution of points on\n     * G1.\n     */\n    function g1HashToPoint(bytes memory m)\n        internal\n        view returns(G1Point memory)\n    {\n        bytes32 h = sha256(m);\n        uint256 x = uint256(h) % p;\n        uint256 y;\n\n        while (true) {\n            y = g1YFromX(x);\n            if (y > 0) {\n                return G1Point(x, y);\n            }\n            x += 1;\n        }\n    }\n\n    /**\n     * @dev Calculates whether the provided number is even or odd.\n     * @return 0x01 if y is an even number and 0x00 if it's odd.\n     */\n    function parity(uint256 value) private pure returns (byte) {\n        return bytes32(value)[31] & 0x01;\n    }\n\n    /**\n     * @dev Compress a point on G1 to a single uint256 for serialization.\n     */\n    function g1Compress(G1Point memory point)\n        internal\n        pure returns(bytes32)\n    {\n        bytes32 m = bytes32(point.x);\n\n        byte leadM = m[0] | parity(point.y) << 7;\n        uint256 mask = 0xff << 31*8;\n        m = (m & ~bytes32(mask)) | (leadM >> 0);\n\n        return m;\n    }\n\n    /**\n     * @dev Compress a point on G2 to a pair of uint256 for serialization.\n     */\n    function g2Compress(G2Point memory point)\n        internal\n        pure returns(bytes memory)\n    {\n        bytes32 m = bytes32(point.x.x);\n\n        byte leadM = m[0] | parity(point.y.x) << 7;\n        uint256 mask = 0xff << 31*8;\n        m = (m & ~bytes32(mask)) | (leadM >> 0);\n\n        return abi.encodePacked(m, bytes32(point.x.y));\n    }\n\n    /**\n     * @dev Decompress a point on G1 from a single uint256.\n     */\n    function g1Decompress(bytes32 m)\n        internal\n        view returns(G1Point memory)\n    {\n        bytes32 mX = bytes32(0);\n        byte leadX = m[0] & 0x7f;\n        uint256 mask = 0xff << 31*8;\n        mX = (m & ~bytes32(mask)) | (leadX >> 0);\n\n        uint256 x = uint256(mX);\n        uint256 y = g1YFromX(x);\n\n        if (parity(y) != (m[0] & 0x80) >> 7) {\n            y = p - y;\n        }\n\n        require(isG1PointOnCurve(G1Point(x, y)), \"Malformed bn256.G1 point.\");\n\n        return G1Point(x, y);\n    }\n\n    /**\n     * @dev Unmarshals a point on G1 from bytes in an uncompressed form.\n     */\n    function g1Unmarshal(bytes memory m) internal pure returns(G1Point memory) {\n        require(\n            m.length == 64,\n            \"Invalid G1 bytes length\"\n        );\n\n        bytes32 x;\n        bytes32 y;\n\n        /* solium-disable-next-line */\n        assembly {\n            x := mload(add(m, 0x20))\n            y := mload(add(m, 0x40))\n        }\n\n        return G1Point(uint256(x), uint256(y));\n    }\n\n    /**\n     * @dev Marshals a point on G1 to bytes form.\n     */\n    function g1Marshal(G1Point memory point) internal pure returns(bytes memory) {\n        bytes memory m = new bytes(64);\n        bytes32 x = bytes32(point.x);\n        bytes32 y = bytes32(point.y);\n\n        /* solium-disable-next-line */\n        assembly {\n            mstore(add(m, 32), x)\n            mstore(add(m, 64), y)\n        }\n\n        return m;\n    }\n\n    /**\n     * @dev Unmarshals a point on G2 from bytes in an uncompressed form.\n     */\n    function g2Unmarshal(bytes memory m) internal pure returns(G2Point memory) {\n        require(\n            m.length == 128,\n            \"Invalid G2 bytes length\"\n        );\n\n        uint256 xx;\n        uint256 xy;\n        uint256 yx;\n        uint256 yy;\n\n        /* solium-disable-next-line */\n        assembly {\n            xx := mload(add(m, 0x20))\n            xy := mload(add(m, 0x40))\n            yx := mload(add(m, 0x60))\n            yy := mload(add(m, 0x80))\n        }\n\n        return G2Point(gfP2(xx, xy), gfP2(yx,yy));\n    }\n\n    /**\n     * @dev Decompress a point on G2 from a pair of uint256.\n     */\n    function g2Decompress(bytes memory m)\n        internal\n        pure returns(G2Point memory)\n    {\n        require(\n            m.length == 64,\n            \"Invalid G2 compressed bytes length\"\n        );\n\n        bytes32 x1;\n        bytes32 x2;\n        uint256 temp;\n\n        // Extract two bytes32 from bytes array\n        /* solium-disable-next-line */\n        assembly {\n            temp := add(m, 32)\n            x1 := mload(temp)\n            temp := add(m, 64)\n            x2 := mload(temp)\n        }\n\n        bytes32 mX = bytes32(0);\n        byte leadX = x1[0] & 0x7f;\n        uint256 mask = 0xff << 31*8;\n        mX = (x1 & ~bytes32(mask)) | (leadX >> 0);\n\n        gfP2 memory x = gfP2(uint256(mX), uint256(x2));\n        gfP2 memory y = g2YFromX(x);\n\n        if (parity(y.x) != (m[0] & 0x80) >> 7) {\n            y.x = p - y.x;\n            y.y = p - y.y;\n        }\n\n        return G2Point(x, y);\n    }\n\n    /**\n     * @dev Wrap the point addition pre-compile introduced in Byzantium. Return\n     * the sum of two points on G1. Revert if the provided points aren't on the\n     * curve.\n     */\n    function g1Add(G1Point memory a, G1Point memory b)\n        internal view returns (G1Point memory c) {\n        /* solium-disable-next-line */\n        assembly {\n            let arg := mload(0x40)\n            mstore(arg, mload(a))\n            mstore(add(arg, 0x20), mload(add(a, 0x20)))\n            mstore(add(arg, 0x40), mload(b))\n            mstore(add(arg, 0x60), mload(add(b, 0x20)))\n            // 0x60 is the ECADD precompile address\n            if iszero(staticcall(not(0), 0x06, arg, 0x80, c, 0x40)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Return the sum of two gfP2 field elements.\n     */\n    function gfP2Add(gfP2 memory a, gfP2 memory b) internal pure returns(gfP2 memory) {\n        return gfP2(\n            addmod(a.x, b.x, p),\n            addmod(a.y, b.y, p)\n        );\n    }\n\n    /**\n     * @dev Return multiplication of two gfP2 field elements.\n     */\n    function gfP2Multiply(gfP2 memory a, gfP2 memory b) internal pure returns(gfP2 memory) {\n        return gfP2(\n            addmod(mulmod(a.x, b.y, p), mulmod(b.x, a.y, p), p),\n            addmod(mulmod(a.y, b.y, p), p - mulmod(a.x, b.x, p), p)\n        );\n    }\n\n    /**\n     * @dev Return gfP2 element to the power of the provided exponent.\n     */\n    function gfP2Pow(gfP2 memory _a, uint256 _exp) internal pure returns(gfP2 memory result) {\n        (uint256 x, uint256 y) = _gfP2Pow(_a.x, _a.y, _exp);\n        return gfP2(x, y);\n    }\n\n    function gfP2Square(gfP2 memory a) internal pure returns (gfP2 memory) {\n        return gfP2Multiply(a, a);\n    }\n\n    function gfP2Cube(gfP2 memory a) internal pure returns (gfP2 memory) {\n        return gfP2Multiply(a, gfP2Square(a));\n    }\n\n    function gfP2CubeAddTwistB(gfP2 memory a) internal pure returns (gfP2 memory) {\n        (uint256 x, uint256 y) = _gfP2CubeAddTwistB(a.x, a.y);\n        return gfP2(x, y);\n    }\n\n    /**\n     * @dev Return true if G2 point's y^2 equals x.\n     */\n    function g2X2y(gfP2 memory x, gfP2 memory y) internal pure returns(bool) {\n        gfP2 memory y2;\n        y2 = gfP2Square(y);\n\n        return (y2.x == x.x && y2.y == x.y);\n    }\n\n    /**\n     * @dev Return true if G1 point is on the curve.\n     */\n    function isG1PointOnCurve(G1Point memory point) internal view returns (bool) {\n        return point.y.modExp(2, p) == (point.x.modExp(3, p) + 3) % p;\n    }\n\n    /**\n     * @dev Return true if G2 point is on the curve.\n     */\n    function isG2PointOnCurve(G2Point memory point) internal pure returns(bool) {\n        (uint256 y2x, uint256 y2y) = _gfP2Square(point.y.x, point.y.y);\n        (uint256 x3x, uint256 x3y) = _gfP2CubeAddTwistB(point.x.x, point.x.y);\n\n        return (y2x == x3x && y2y == x3y);\n    }\n\n    /**\n     * @dev Wrap the scalar point multiplication pre-compile introduced in\n     * Byzantium. The result of a point from G1 multiplied by a scalar should\n     * match the point added to itself the same number of times. Revert if the\n     * provided point isn't on the curve.\n     */\n    function scalarMultiply(G1Point memory p_1, uint256 scalar)\n        internal view returns (G1Point memory p_2) {\n        assembly {\n            let arg := mload(0x40)\n            mstore(arg, mload(p_1))\n            mstore(add(arg, 0x20), mload(add(p_1, 0x20)))\n            mstore(add(arg, 0x40), scalar)\n            // 0x70 is the ECMUL precompile address\n            if iszero(staticcall(not(0), 0x07, arg, 0x60, p_2, 0x40)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    /**\n     * @dev Wrap the pairing check pre-compile introduced in Byzantium. Return\n     * the result of a pairing check of 2 pairs (G1 p1, G2 p2) (G1 p3, G2 p4)\n     */\n    function pairing(\n        G1Point memory p1,\n        G2Point memory p2,\n        G1Point memory p3,\n        G2Point memory p4\n    ) internal view returns (bool result) {\n        uint256 _c;\n        /* solium-disable-next-line */\n        assembly {\n            let c := mload(0x40)\n            let arg := add(c, 0x20)\n\n            mstore(arg, mload(p1))\n            mstore(add(arg, 0x20), mload(add(p1, 0x20)))\n\n            let p2x := mload(p2)\n            mstore(add(arg, 0x40), mload(p2x))\n            mstore(add(arg, 0x60), mload(add(p2x, 0x20)))\n\n            let p2y := mload(add(p2, 0x20))\n            mstore(add(arg, 0x80), mload(p2y))\n            mstore(add(arg, 0xa0), mload(add(p2y, 0x20)))\n\n            mstore(add(arg, 0xc0), mload(p3))\n            mstore(add(arg, 0xe0), mload(add(p3, 0x20)))\n\n            let p4x := mload(p4)\n            mstore(add(arg, 0x100), mload(p4x))\n            mstore(add(arg, 0x120), mload(add(p4x, 0x20)))\n\n            let p4y := mload(add(p4, 0x20))\n            mstore(add(arg, 0x140), mload(p4y))\n            mstore(add(arg, 0x160), mload(add(p4y, 0x20)))\n\n            // call(gasLimit, to, value, inputOffset, inputSize, outputOffset, outputSize)\n            if iszero(staticcall(not(0), 0x08, arg, 0x180, c, 0x20)) {\n                revert(0, 0)\n            }\n            _c := mload(c)\n        }\n        return _c != 0;\n    }\n\n    function _gfP2Add(uint256 ax, uint256 ay, uint256 bx, uint256 by)\n        private pure returns(uint256 x, uint256 y) {\n        x = addmod(ax, bx, p);\n        y = addmod(ay, by, p);\n    }\n\n    function _gfP2Multiply(uint256 ax, uint256 ay, uint256 bx, uint256 by)\n        private pure returns(uint256 x, uint256 y) {\n        x = addmod(mulmod(ax, by, p), mulmod(bx, ay, p), p);\n        y = addmod(mulmod(ay, by, p), p - mulmod(ax, bx, p), p);\n    }\n\n    function _gfP2CubeAddTwistB(uint256 ax, uint256 ay)\n        private pure returns (uint256 x, uint256 y) {\n        (uint256 a3x, uint256 a3y) = _gfP2Cube(ax, ay);\n        return _gfP2Add(a3x, a3y, twistBx, twistBy);\n    }\n\n    function _gfP2Pow(uint256 _ax, uint256 _ay, uint256 _exp)\n        private pure returns (uint256 x, uint256 y) {\n        uint256 exp = _exp;\n        x = 0;\n        y = 1;\n        uint256 ax = _ax;\n        uint256 ay = _ay;\n\n        // Reduce exp dividing by 2 gradually to 0 while computing final\n        // result only when exp is an odd number.\n        while (exp > 0) {\n            if (parity(exp) == 0x01) {\n                (x, y) = _gfP2Multiply(x, y, ax, ay);\n            }\n\n            exp = exp / 2;\n            (ax, ay) = _gfP2Multiply(ax, ay, ax, ay);\n        }\n    }\n\n    function _gfP2Square(uint256 _ax, uint256 _ay)\n        private pure returns (uint256 x, uint256 y) {\n        return _gfP2Multiply(_ax, _ay, _ax, _ay);\n    }\n\n    function _gfP2Cube(uint256 _ax, uint256 _ay)\n        private pure returns (uint256 x, uint256 y) {\n        (uint256 _bx, uint256 _by) = _gfP2Square(_ax, _ay);\n        return _gfP2Multiply(_ax, _ay, _bx, _by);\n    }\n\n    function _g2X2y(uint256 xx, uint256 xy, uint256 yx, uint256 yy)\n        private pure returns (bool) {\n        (uint256 y2x, uint256 y2y) = _gfP2Square(yx, yy);\n\n        return (y2x == xx && y2y == xy);\n    }\n}\n"

    },

    "solidity/contracts/utils/ModUtils.sol": {

      "content": "pragma solidity 0.5.17;\n\n\nlibrary ModUtils {\n\n    /**\n     * @dev Wrap the modular exponent pre-compile introduced in Byzantium.\n     * Returns base^exponent mod p.\n     */\n    function modExp(uint256 base, uint256 exponent, uint256 p)\n        internal\n        view returns(uint256 o)\n    {\n        /* solium-disable-next-line */\n        assembly {\n            // Args for the precompile: [<length_of_BASE> <length_of_EXPONENT>\n            // <length_of_MODULUS> <BASE> <EXPONENT> <MODULUS>]\n            let output := mload(0x40)\n            let args := add(output, 0x20)\n            mstore(args, 0x20)\n            mstore(add(args, 0x20), 0x20)\n            mstore(add(args, 0x40), 0x20)\n            mstore(add(args, 0x60), base)\n            mstore(add(args, 0x80), exponent)\n            mstore(add(args, 0xa0), p)\n\n            // 0x05 is the modular exponent contract address\n            if iszero(staticcall(not(0), 0x05, args, 0xc0, output, 0x20)) {\n                revert(0, 0)\n            }\n            o := mload(output)\n        }\n    }\n\n    /**\n     * @dev Calculates and returns the square root of a mod p,\n     * or 0 if there is no such root.\n     */\n    function modSqrt(uint256 a, uint256 p)\n        internal\n        view returns(uint256)\n    {\n\n        if (legendre(a, p) != 1) {\n            return 0;\n        }\n\n        if (a == 0) {\n            return 0;\n        }\n\n        if (p == 2) {\n            return p;\n        }\n\n        if (p % 4 == 3) {\n            return modExp(a, (p + 1) / 4, p);\n        }\n\n        uint256 s = p - 1;\n        uint256 e = 0;\n\n        while (s % 2 == 0) {\n            s = s / 2;\n            e = e + 1;\n        }\n\n        // Note the smaller int- finding n with Legendre symbol or -1\n        // should be quick\n        uint256 n = 2;\n        while (legendre(n, p) != -1) {\n            n = n + 1;\n        }\n\n        uint256 x = modExp(a, (s + 1) / 2, p);\n        uint256 b = modExp(a, s, p);\n        uint256 g = modExp(n, s, p);\n        uint256 r = e;\n        uint256 gs = 0;\n        uint256 m = 0;\n        uint256 t = b;\n\n        while (true) {\n            t = b;\n            m = 0;\n\n            for (m = 0; m < r; m++) {\n                if (t == 1) {\n                    break;\n                }\n                t = modExp(t, 2, p);\n            }\n\n            if (m == 0) {\n                return x;\n            }\n\n            gs = modExp(g, uint256(2) ** (r - m - 1), p);\n            g = (gs * gs) % p;\n            x = (x * gs) % p;\n            b = (b * g) % p;\n            r = m;\n        }\n    }\n\n    /**\n     * @dev Calculates the Legendre symbol of the given a mod p.\n     * @return Returns 1 if a is a quadratic residue mod p, -1 if it is\n     * a non-quadratic residue, and 0 if a is 0.\n     */\n    function legendre(uint256 a, uint256 p)\n        internal\n        view returns(int256)\n    {\n        uint256 raised = modExp(a, (p - 1) / uint256(2), p);\n\n        if (raised == 0 || raised == 1) {\n            return int256(raised);\n        } else if (raised == p - 1) {\n            return -1;\n        }\n\n        require(false, \"Failed to calculate legendre.\");\n    }\n}\n"

    }

  },

  "settings": {

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "abi"

        ]

      }

    }

  }

}}