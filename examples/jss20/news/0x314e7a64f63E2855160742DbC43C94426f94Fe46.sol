{{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/libraries/operator/GroupSelection.sol": {
      "content": "pragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../../utils/BytesLib.sol\";\n\n/// @title Group Selection\n/// @notice The group selection protocol is an interactive method of selecting\n/// candidate group from the set of all stakers given a pseudorandom seed value.\n///\n/// The protocol produces a representative result, where each staker's profit is\n/// proportional to the number of tokens they have staked. Produced candidate\n/// groups are of constant size.\n///\n/// Group selection protocol accepts seed as an input - a pseudorandom value\n/// used to construct candidate tickets. Each candidate group member can\n/// submit their tickets. The maximum number of tickets one can submit depends\n/// on their staking weight - relation of the minimum stake to the candidate's\n/// stake.\n///\n/// There is a certain timeout, expressed in blocks, when tickets can be\n/// submitted. Each ticket is a mix of staker's address, virtual staker index\n/// and group selection seed. Candidate group members are selected based on\n/// the best tickets submitted. There has to be a minimum number of tickets\n/// submitted, equal to the candidate group size so that the protocol can\n/// complete successfully.\nlibrary GroupSelection {\n\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n\n    struct Storage {\n        // Tickets submitted by member candidates during the current group\n        // selection execution and accepted by the protocol for the\n        // consideration.\n        uint64[] tickets;\n\n        // Information about ticket submitters (group member candidates).\n        mapping(uint256 => address) candidate;\n\n        // Pseudorandom seed value used as an input for the group selection.\n        uint256 seed;\n\n        // Timeout in blocks after which the ticket submission is finished.\n        uint256 ticketSubmissionTimeout;\n\n        // Number of block at which the group selection started and from which\n        // ticket submissions are accepted.\n        uint256 ticketSubmissionStartBlock;\n\n        // Indicates whether a group selection is currently in progress.\n        // Concurrent group selections are not allowed.\n        bool inProgress;\n\n        // Captures the minimum stake when group selection starts. This is to ensure the\n        // same staking weight divisor is applied for all member candidates participating.\n        uint256 minimumStake;\n\n        // Map simulates a sorted linked list of ticket values by their indexes.\n        // key -> value represent indices from the tickets[] array.\n        // 'key' index holds an index of a ticket and 'value' holds an index\n        // of the next ticket. Tickets are sorted by their value in\n        // descending order starting from the tail.\n        // Ex. tickets = [151, 42, 175, 7]\n        // tail: 2 because tickets[2] = 175\n        // previousTicketIndex[0] -> 1\n        // previousTicketIndex[1] -> 3\n        // previousTicketIndex[2] -> 0\n        // previousTicketIndex[3] -> 3 note: index that holds a lowest\n        // value points to itself because there is no `nil` in Solidity.\n        // Traversing from tail: [2]->[0]->[1]->[3] result in 175->151->42->7\n        bytes previousTicketIndices;\n\n        // Tail represents an index of a ticket in a tickets[] array which holds\n        // the highest ticket value. It is a tail of the linked list defined by\n        // `previousTicketIndex`.\n        uint256 tail;\n\n        // Size of a group in the threshold relay.\n        uint256 groupSize;\n    }\n\n    /// @notice Starts group selection protocol.\n    /// @param _seed pseudorandom seed value used as an input for the group\n    /// selection. All submitted tickets needs to have the seed mixed-in into the\n    /// value.\n    function start(Storage storage self, uint256 _seed) public {\n        // We execute the minimum required cleanup here needed in case the\n        // previous group selection failed and did not clean up properly in\n        // stop function.\n        cleanupTickets(self);\n        self.inProgress = true;\n        self.seed = _seed;\n        self.ticketSubmissionStartBlock = block.number;\n    }\n\n    /// @notice Stops group selection protocol clearing up all the submitted\n    /// tickets. This function may be expensive if not executed as a part of\n    /// another transaction consuming a lot of gas and as a result, getting\n    /// gas refund for clearing up the storage.\n    function stop(Storage storage self) public {\n        cleanupCandidates(self);\n        cleanupTickets(self);\n        self.inProgress = false;\n    }\n\n    /// @notice Submits ticket to request to participate in a new candidate group.\n    /// @param ticket Bytes representation of a ticket that holds the following:\n    /// - ticketValue: first 8 bytes of a result of keccak256 cryptography hash\n    ///   function on the combination of the group selection seed (previous\n    ///   beacon output), staker-specific value (address) and virtual staker index.\n    /// - stakerValue: a staker-specific value which is the address of the staker.\n    /// - virtualStakerIndex: 4-bytes number within a range of 1 to staker's weight;\n    ///   has to be unique for all tickets submitted by the given staker for the\n    ///   current candidate group selection.\n    /// @param stakingWeight Ratio of the minimum stake to the candidate's\n    /// stake.\n    function submitTicket(\n        Storage storage self,\n        bytes32 ticket,\n        uint256 stakingWeight\n    ) public {\n        uint64 ticketValue;\n        uint160 stakerValue;\n        uint32 virtualStakerIndex;\n\n        bytes memory ticketBytes = abi.encodePacked(ticket);\n        /* solium-disable-next-line */\n        assembly {\n            // ticket value is 8 bytes long\n            ticketValue := mload(add(ticketBytes, 8))\n            // staker value is 20 bytes long\n            stakerValue := mload(add(ticketBytes, 28))\n            // virtual staker index is 4 bytes long\n            virtualStakerIndex := mload(add(ticketBytes, 32))\n        }\n\n        submitTicket(\n            self,\n            ticketValue,\n            uint256(stakerValue),\n            uint256(virtualStakerIndex),\n            stakingWeight\n        );\n    }\n\n    /// @notice Submits ticket to request to participate in a new candidate group.\n    /// @param ticketValue First 8 bytes of a result of keccak256 cryptography hash\n    /// function on the combination of the group selection seed (previous\n    /// beacon output), staker-specific value (address) and virtual staker index.\n    /// @param stakerValue Staker-specific value which is the address of the staker.\n    /// @param virtualStakerIndex 4-bytes number within a range of 1 to staker's weight;\n    /// has to be unique for all tickets submitted by the given staker for the\n    /// current candidate group selection.\n    /// @param stakingWeight Ratio of the minimum stake to the candidate's\n    /// stake.\n    function submitTicket(\n        Storage storage self,\n        uint64 ticketValue,\n        uint256 stakerValue,\n        uint256 virtualStakerIndex,\n        uint256 stakingWeight\n    ) public {\n        if (block.number > self.ticketSubmissionStartBlock.add(self.ticketSubmissionTimeout)) {\n            revert(\"Ticket submission is over\");\n        }\n\n        if (self.candidate[ticketValue] != address(0)) {\n            revert(\"Duplicate ticket\");\n        }\n\n        if (isTicketValid(\n            ticketValue,\n            stakerValue,\n            virtualStakerIndex,\n            stakingWeight,\n            self.seed\n        )) {\n            addTicket(self, ticketValue);\n        } else {\n            revert(\"Invalid ticket\");\n        }\n    }\n\n    /// @notice Performs full verification of the ticket.\n    function isTicketValid(\n        uint64 ticketValue,\n        uint256 stakerValue,\n        uint256 virtualStakerIndex,\n        uint256 stakingWeight,\n        uint256 groupSelectionSeed\n    ) internal view returns(bool) {\n        uint64 ticketValueExpected;\n        bytes memory ticketBytes = abi.encodePacked(\n            keccak256(\n                abi.encodePacked(\n                    groupSelectionSeed,\n                    stakerValue,\n                    virtualStakerIndex\n                )\n            )\n        );\n        // use first 8 bytes to compare ticket values\n        /* solium-disable-next-line */\n        assembly {\n            ticketValueExpected := mload(add(ticketBytes, 8))\n        }\n\n        bool isVirtualStakerIndexValid = virtualStakerIndex > 0 && virtualStakerIndex <= stakingWeight;\n        bool isStakerValueValid = stakerValue == uint256(msg.sender);\n        bool isTicketValueValid = ticketValue == ticketValueExpected;\n\n        return isVirtualStakerIndexValid && isStakerValueValid && isTicketValueValid;\n    }\n\n    /// @notice Adds a new, verified ticket. Ticket is accepted when it is lower\n    /// than the currently highest ticket or when the number of tickets is still\n    /// below the group size.\n    function addTicket(Storage storage self, uint64 newTicketValue) internal {\n        uint256[] memory previousTicketIndex = readPreviousTicketIndices(self);\n        uint256[] memory ordered = getTicketValueOrderedIndices(\n            self,\n            previousTicketIndex\n        );\n\n        // any ticket goes when the tickets array size is lower than the group size\n        if (self.tickets.length < self.groupSize) {\n            // no tickets\n            if (self.tickets.length == 0) {\n                self.tickets.push(newTicketValue);\n            // higher than the current highest\n            } else if (newTicketValue > self.tickets[self.tail]) {\n                self.tickets.push(newTicketValue);\n                uint256 oldTail = self.tail;\n                self.tail = self.tickets.length-1;\n                previousTicketIndex[self.tail] = oldTail;\n            // lower than the current lowest\n            } else if (newTicketValue < self.tickets[ordered[0]]) {\n                self.tickets.push(newTicketValue);\n                // last element points to itself\n                previousTicketIndex[self.tickets.length - 1] = self.tickets.length - 1;\n                // previous lowest ticket points to the new lowest\n                previousTicketIndex[ordered[0]] = self.tickets.length - 1;\n            // higher than the lowest ticket value and lower than the highest ticket value\n            } else {\n                self.tickets.push(newTicketValue);\n                uint256 j = findReplacementIndex(self, newTicketValue, ordered);\n                previousTicketIndex[self.tickets.length - 1] = previousTicketIndex[j];\n                previousTicketIndex[j] = self.tickets.length - 1;\n            }\n            self.candidate[newTicketValue] = msg.sender;\n        } else if (newTicketValue < self.tickets[self.tail]) {\n            uint256 ticketToRemove = self.tickets[self.tail];\n            // new ticket is lower than currently lowest\n            if (newTicketValue < self.tickets[ordered[0]]) {\n                // replacing highest ticket with the new lowest\n                self.tickets[self.tail] = newTicketValue;\n                uint256 newTail = previousTicketIndex[self.tail];\n                previousTicketIndex[ordered[0]] = self.tail;\n                previousTicketIndex[self.tail] = self.tail;\n                self.tail = newTail;\n            } else { // new ticket is between lowest and highest\n                uint256 j = findReplacementIndex(self, newTicketValue, ordered);\n                self.tickets[self.tail] = newTicketValue;\n                // do not change the order if a new ticket is still highest\n                if (j != self.tail) {\n                    uint newTail = previousTicketIndex[self.tail];\n                    previousTicketIndex[self.tail] = previousTicketIndex[j];\n                    previousTicketIndex[j] = self.tail;\n                    self.tail = newTail;\n                }\n            }\n            // we are replacing tickets so we also need to replace information\n            // about the submitter\n            delete self.candidate[ticketToRemove];\n            self.candidate[newTicketValue] = msg.sender;\n        }\n        storePreviousTicketIndices(self, previousTicketIndex);\n    }\n\n    /// @notice Use binary search to find an index for a new ticket in the tickets[] array\n    function findReplacementIndex(\n        Storage storage self,\n        uint64 newTicketValue,\n        uint256[] memory ordered\n    ) internal view returns (uint256) {\n        uint256 lo = 0;\n        uint256 hi = ordered.length - 1;\n        uint256 mid = 0;\n        while (lo <= hi) {\n            mid = (lo + hi) >> 1;\n            if (newTicketValue < self.tickets[ordered[mid]]) {\n                hi = mid - 1;\n            } else if (newTicketValue > self.tickets[ordered[mid]]) {\n                lo = mid + 1;\n            } else {\n                return ordered[mid];\n            }\n        }\n\n        return ordered[lo];\n    }\n\n    function readPreviousTicketIndices(Storage storage self)\n        internal view returns (uint256[] memory uncompressed)\n    {\n        bytes memory compressed = self.previousTicketIndices;\n        uncompressed = new uint256[](self.groupSize);\n        for (uint256 i = 0; i < compressed.length; i++) {\n            uncompressed[i] = uint256(uint8(compressed[i]));\n        }\n    }\n\n    function storePreviousTicketIndices(\n        Storage storage self,\n        uint256[] memory uncompressed\n    ) internal {\n        bytes memory compressed = new bytes(uncompressed.length);\n        for (uint256 i = 0; i < compressed.length; i++) {\n            compressed[i] = bytes1(uint8(uncompressed[i]));\n        }\n        self.previousTicketIndices = compressed;\n    }\n\n    /// @notice Creates an array of ticket indexes based on their values in the\n    ///  ascending order:\n    ///\n    /// ordered[n-1] = tail\n    /// ordered[n-2] = previousTicketIndex[tail]\n    /// ordered[n-3] = previousTicketIndex[ordered[n-2]]\n    function getTicketValueOrderedIndices(\n        Storage storage self,\n        uint256[] memory previousIndices\n    ) internal view returns (uint256[] memory) {\n        uint256[] memory ordered = new uint256[](self.tickets.length);\n        if (ordered.length > 0) {\n            ordered[self.tickets.length-1] = self.tail;\n            if (ordered.length > 1) {\n                for (uint256 i = self.tickets.length - 1; i > 0; i--) {\n                    ordered[i-1] = previousIndices[ordered[i]];\n                }\n            }\n        }\n\n        return ordered;\n    }\n\n    /// @notice Gets selected participants in ascending order of their tickets.\n    function selectedParticipants(Storage storage self) public view returns (address[] memory) {\n        require(\n            block.number >= self.ticketSubmissionStartBlock.add(self.ticketSubmissionTimeout),\n            \"Ticket submission in progress\"\n        );\n\n        require(self.tickets.length >= self.groupSize, \"Not enough tickets submitted\");\n\n        uint256[] memory previousTicketIndex = readPreviousTicketIndices(self);\n        address[] memory selected = new address[](self.groupSize);\n        uint256 ticketIndex = self.tail;\n        selected[self.tickets.length - 1] = self.candidate[self.tickets[ticketIndex]];\n        for (uint256 i = self.tickets.length - 1; i > 0; i--) {\n            ticketIndex = previousTicketIndex[ticketIndex];\n            selected[i-1] = self.candidate[self.tickets[ticketIndex]];\n        }\n\n        return selected;\n    }\n\n    /// @notice Clears up data of the group selection tickets.\n    function cleanupTickets(Storage storage self) internal {\n        delete self.tickets;\n        self.tail = 0;\n    }\n\n    /// @notice Clears up data of the group selection candidates.\n    /// This operation may have a significant cost if not executed as a part of\n    /// another transaction consuming a lot of gas and as a result, getting\n    /// gas refund for clearing up the storage.\n    function cleanupCandidates(Storage storage self) internal {\n        for (uint i = 0; i < self.tickets.length; i++) {\n            delete self.candidate[self.tickets[i]];\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "solidity/contracts/utils/BytesLib.sol": {
      "content": "pragma solidity 0.5.17;\n\n/*\nVerison pulled from https://github.com/summa-tx/bitcoin-spv/blob/2535e4edaeaac4b2b095903fce684ae1c05761bc/solidity/contracts/BytesLib.sol\n*/\n\n/*\nhttps://github.com/GNSPS/solidity-bytes-utils/\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\nFor more information, please refer to <https://unlicense.org>\n*/\n\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                        ),\n                        // and now shift left the number of bytes to\n                        // leave space for the length in the slot\n                        exp(0x100, sub(32, newlength))\n                        ),\n                        // increase length by the double of the memory\n                        // bytes length\n                        mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                    ),\n                    and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        uint _totalLen = _start + 20;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Address conversion out of bounds.\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Uint8 conversion out of bounds.\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        uint _totalLen = _start + 32;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Uint conversion out of bounds.\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}