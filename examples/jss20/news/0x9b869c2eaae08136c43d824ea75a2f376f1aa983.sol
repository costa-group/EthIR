{{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destoys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n *  their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * This test is non-exhaustive, and there may be false-negatives: during the\n     * execution of a contract's constructor, its address will be reported as\n     * not containing a contract.\n     *\n     * IMPORTANT: It is unsafe to assume that an address for which this\n     * function returns false is an externally-owned account (EOA) and not a\n     * contract.\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "dai.sol": {
      "content": "// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.5.12;\n\nimport \"./lib.sol\";\n\ncontract Dai is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address guy) external note auth { wards[guy] = 1; }\n    function deny(address guy) external note auth { wards[guy] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Dai/not-authorized\");\n        _;\n    }\n\n    // --- ERC20 Data ---\n    string  public constant name     = \"Dai Stablecoin\";\n    string  public constant symbol   = \"DAI\";\n    string  public constant version  = \"1\";\n    uint8   public constant decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint)                      public nonces;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n\n    // --- Math ---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    constructor(uint256 chainId_) public {\n        wards[msg.sender] = 1;\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId_,\n            address(this)\n        ));\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n    function transferFrom(address src, address dst, uint wad)\n        public returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        }\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n    function mint(address usr, uint wad) external auth {\n        balanceOf[usr] = add(balanceOf[usr], wad);\n        totalSupply    = add(totalSupply, wad);\n        emit Transfer(address(0), usr, wad);\n    }\n    function burn(address usr, uint wad) external {\n        require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n            require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\n        }\n        balanceOf[usr] = sub(balanceOf[usr], wad);\n        totalSupply    = sub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n    function approve(address usr, uint wad) external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    // --- Alias ---\n    function push(address usr, uint wad) external {\n        transferFrom(msg.sender, usr, wad);\n    }\n    function pull(address usr, uint wad) external {\n        transferFrom(usr, msg.sender, wad);\n    }\n    function move(address src, address dst, uint wad) external {\n        transferFrom(src, dst, wad);\n    }\n\n    // --- Approve by signature ---\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     spender,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"Dai/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\n        uint wad = allowed ? uint(-1) : 0;\n        allowance[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}\n"
    },
    "lib.sol": {
      "content": "// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.5.12;\n\ncontract LibNote {\n    event LogNote(\n        bytes4   indexed  sig,\n        address  indexed  usr,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: selector, caller, arg1 and arg2\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 caller,                              // msg.sender\n                 calldataload(4),                     // arg1\n                 calldataload(36)                     // arg2\n                )\n        }\n    }\n}\n"
    },
    "join.sol": {
      "content": "/// join.sol -- Basic token adapters\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.5.12;\n\nimport \"./lib.sol\";\n\ncontract GemLike {\n    function decimals() public view returns (uint);\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n}\n\ncontract DSTokenLike {\n    function mint(address,uint) external;\n    function burn(address,uint) external;\n}\n\ncontract VatLike {\n    function slip(bytes32,address,int) external;\n    function move(address,address,uint) external;\n}\n\n/*\n    Here we provide *adapters* to connect the Vat to arbitrary external\n    token implementations, creating a bounded context for the Vat. The\n    adapters here are provided as working examples:\n\n      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\n                   semantics.\n\n      - `ETHJoin`: For native Ether.\n\n      - `DaiJoin`: For connecting internal Dai balances to an external\n                   `DSToken` implementation.\n\n    In practice, adapter implementations will be varied and specific to\n    individual collateral types, accounting for different transfer\n    semantics and token standards.\n\n    Adapters need to implement two basic methods:\n\n      - `join`: enter collateral into the system\n      - `exit`: remove collateral from the system\n\n*/\n\ncontract GemJoin is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"GemJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;\n    bytes32 public ilk;\n    GemLike public gem;\n    uint    public dec;\n    uint    public live;  // Access Flag\n\n    constructor(address vat_, bytes32 ilk_, address gem_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        ilk = ilk_;\n        gem = GemLike(gem_);\n        dec = gem.decimals();\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n    function join(address usr, uint wad) external note {\n        require(live == 1, \"GemJoin/not-live\");\n        require(int(wad) >= 0, \"GemJoin/overflow\");\n        vat.slip(ilk, usr, int(wad));\n        require(gem.transferFrom(msg.sender, address(this), wad), \"GemJoin/failed-transfer\");\n    }\n    function exit(address usr, uint wad) external note {\n        require(wad <= 2 ** 255, \"GemJoin/overflow\");\n        vat.slip(ilk, msg.sender, -int(wad));\n        require(gem.transfer(usr, wad), \"GemJoin/failed-transfer\");\n    }\n}\n\ncontract ETHJoin is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"ETHJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;\n    bytes32 public ilk;\n    uint    public live;  // Access Flag\n\n    constructor(address vat_, bytes32 ilk_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        ilk = ilk_;\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n    function join(address usr) external payable note {\n        require(live == 1, \"ETHJoin/not-live\");\n        require(int(msg.value) >= 0, \"ETHJoin/overflow\");\n        vat.slip(ilk, usr, int(msg.value));\n    }\n    function exit(address payable usr, uint wad) external note {\n        require(int(wad) >= 0, \"ETHJoin/overflow\");\n        vat.slip(ilk, msg.sender, -int(wad));\n        usr.transfer(wad);\n    }\n}\n\ncontract DaiJoin is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { wards[usr] = 1; }\n    function deny(address usr) external note auth { wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"DaiJoin/not-authorized\");\n        _;\n    }\n\n    VatLike public vat;\n    DSTokenLike public dai;\n    uint    public live;  // Access Flag\n\n    constructor(address vat_, address dai_) public {\n        wards[msg.sender] = 1;\n        live = 1;\n        vat = VatLike(vat_);\n        dai = DSTokenLike(dai_);\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n    uint constant ONE = 10 ** 27;\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function join(address usr, uint wad) external note {\n        vat.move(address(this), usr, mul(ONE, wad));\n        dai.burn(msg.sender, wad);\n    }\n    function exit(address usr, uint wad) external note {\n        require(live == 1, \"DaiJoin/not-live\");\n        vat.move(msg.sender, address(this), mul(ONE, wad));\n        dai.mint(usr, wad);\n    }\n}\n"
    },
    "pot.sol": {
      "content": "/// pot.sol -- Dai Savings Rate\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.5.12;\n\nimport \"./lib.sol\";\n\n/*\n   \"Savings Dai\" is obtained when Dai is deposited into\n   this contract. Each \"Savings Dai\" accrues Dai interest\n   at the \"Dai Savings Rate\".\n\n   This contract does not implement a user tradeable token\n   and is intended to be used with adapters.\n\n         --- `save` your `dai` in the `pot` ---\n\n   - `dsr`: the Dai Savings Rate\n   - `pie`: user balance of Savings Dai\n\n   - `join`: start saving some dai\n   - `exit`: remove some dai\n   - `drip`: perform rate collection\n\n*/\n\ncontract VatLike {\n    function move(address,address,uint256) external;\n    function suck(address,address,uint256) external;\n}\n\ncontract Pot is LibNote {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address guy) external note auth { wards[guy] = 1; }\n    function deny(address guy) external note auth { wards[guy] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Pot/not-authorized\");\n        _;\n    }\n\n    // --- Data ---\n    mapping (address => uint256) public pie;  // user Savings Dai\n\n    uint256 public Pie;  // total Savings Dai\n    uint256 public dsr;  // the Dai Savings Rate\n    uint256 public chi;  // the Rate Accumulator\n\n    VatLike public vat;  // CDP engine\n    address public vow;  // debt engine\n    uint256 public rho;  // time of last drip\n\n    uint256 public live;  // Access Flag\n\n    // --- Init ---\n    constructor(address vat_) public {\n        wards[msg.sender] = 1;\n        vat = VatLike(vat_);\n        dsr = ONE;\n        chi = ONE;\n        rho = now;\n        live = 1;\n    }\n\n    // --- Math ---\n    uint256 constant ONE = 10 ** 27;\n    function rpow(uint x, uint n, uint base) internal pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = mul(x, y) / ONE;\n    }\n\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, uint256 data) external note auth {\n        require(live == 1, \"Pot/not-live\");\n        require(now == rho, \"Pot/rho-not-updated\");\n        if (what == \"dsr\") dsr = data;\n        else revert(\"Pot/file-unrecognized-param\");\n    }\n\n    function file(bytes32 what, address addr) external note auth {\n        if (what == \"vow\") vow = addr;\n        else revert(\"Pot/file-unrecognized-param\");\n    }\n\n    function cage() external note auth {\n        live = 0;\n        dsr = ONE;\n    }\n\n    // --- Savings Rate Accumulation ---\n    function drip() external note returns (uint tmp) {\n        require(now >= rho, \"Pot/invalid-now\");\n        tmp = rmul(rpow(dsr, now - rho, ONE), chi);\n        uint chi_ = sub(tmp, chi);\n        chi = tmp;\n        rho = now;\n        vat.suck(address(vow), address(this), mul(Pie, chi_));\n    }\n\n    // --- Savings Dai Management ---\n    function join(uint wad) external note {\n        require(now == rho, \"Pot/rho-not-updated\");\n        pie[msg.sender] = add(pie[msg.sender], wad);\n        Pie             = add(Pie,             wad);\n        vat.move(msg.sender, address(this), mul(chi, wad));\n    }\n\n    function exit(uint wad) external note {\n        pie[msg.sender] = sub(pie[msg.sender], wad);\n        Pie             = sub(Pie,             wad);\n        vat.move(address(this), msg.sender, mul(chi, wad));\n    }\n}\n"
    },
    "vat.sol": {
      "content": "/// vat.sol -- Dai CDP database\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.5.12;\n\ncontract Vat {\n    // --- Auth ---\n    mapping (address => uint) public wards;\n    function rely(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 1; }\n    function deny(address usr) external note auth { require(live == 1, \"Vat/not-live\"); wards[usr] = 0; }\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    mapping(address => mapping (address => uint)) public can;\n    function hope(address usr) external note { can[msg.sender][usr] = 1; }\n    function nope(address usr) external note { can[msg.sender][usr] = 0; }\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    // --- Data ---\n    struct Ilk {\n        uint256 Art;   // Total Normalised Debt     [wad]\n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n    mapping (address => uint256)                   public dai;  // [rad]\n    mapping (address => uint256)                   public sin;  // [rad]\n\n    uint256 public debt;  // Total Dai Issued    [rad]\n    uint256 public vice;  // Total Unbacked Dai  [rad]\n    uint256 public Line;  // Total Debt Ceiling  [rad]\n    uint256 public live;  // Access Flag\n\n    // --- Logs ---\n    event LogNote(\n        bytes4   indexed  sig,\n        bytes32  indexed  arg1,\n        bytes32  indexed  arg2,\n        bytes32  indexed  arg3,\n        bytes             data\n    ) anonymous;\n\n    modifier note {\n        _;\n        assembly {\n            // log an 'anonymous' event with a constant 6 words of calldata\n            // and four indexed topics: the selector and the first three args\n            let mark := msize                         // end of memory ensures zero\n            mstore(0x40, add(mark, 288))              // update free memory pointer\n            mstore(mark, 0x20)                        // bytes type data offset\n            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n            log4(mark, 288,                           // calldata\n                 shl(224, shr(224, calldataload(0))), // msg.sig\n                 calldataload(4),                     // arg1\n                 calldataload(36),                    // arg2\n                 calldataload(68)                     // arg3\n                )\n        }\n    }\n\n    // --- Init ---\n    constructor() public {\n        wards[msg.sender] = 1;\n        live = 1;\n    }\n\n    // --- Math ---\n    function add(uint x, int y) internal pure returns (uint z) {\n        z = x + uint(y);\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n    function sub(uint x, int y) internal pure returns (uint z) {\n        z = x - uint(y);\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n    function mul(uint x, int y) internal pure returns (int z) {\n        z = int(x) * y;\n        require(int(x) >= 0);\n        require(y == 0 || z / y == int(x));\n    }\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    // --- Administration ---\n    function init(bytes32 ilk) external note auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n    }\n    function file(bytes32 what, uint data) external note auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n    }\n    function file(bytes32 ilk, bytes32 what, uint data) external note auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n    }\n    function cage() external note auth {\n        live = 0;\n    }\n\n    // --- Fungibility ---\n    function slip(bytes32 ilk, address usr, int256 wad) external note auth {\n        gem[ilk][usr] = add(gem[ilk][usr], wad);\n    }\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external note {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = sub(gem[ilk][src], wad);\n        gem[ilk][dst] = add(gem[ilk][dst], wad);\n    }\n    function move(address src, address dst, uint256 rad) external note {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = sub(dai[src], rad);\n        dai[dst] = add(dai[dst], rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- CDP Manipulation ---\n    function frob(bytes32 i, address u, address v, address w, int dink, int dart) external note {\n        // system is live\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        // ilk has been initialised\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = add(urn.ink, dink);\n        urn.art = add(urn.art, dart);\n        ilk.Art = add(ilk.Art, dart);\n\n        int dtab = mul(ilk.rate, dart);\n        uint tab = mul(ilk.rate, urn.art);\n        debt     = add(debt, dtab);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        require(either(dart <= 0, both(mul(ilk.Art, ilk.rate) <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        // urn is either less risky than before, or it is safe\n        require(either(both(dart <= 0, dink >= 0), tab <= mul(urn.ink, ilk.spot)), \"Vat/not-safe\");\n\n        // urn is either more safe, or the owner consents\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        // collateral src consents\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        // debt dst consents\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        // urn has no debt, or a non-dusty amount\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = sub(gem[i][v], dink);\n        dai[w]    = add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n    }\n    // --- CDP Fungibility ---\n    function fork(bytes32 ilk, address src, address dst, int dink, int dart) external note {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = sub(u.ink, dink);\n        u.art = sub(u.art, dart);\n        v.ink = add(v.ink, dink);\n        v.art = add(v.art, dart);\n\n        uint utab = mul(u.art, i.rate);\n        uint vtab = mul(v.art, i.rate);\n\n        // both sides consent\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        // both sides safe\n        require(utab <= mul(u.ink, i.spot), \"Vat/not-safe-src\");\n        require(vtab <= mul(v.ink, i.spot), \"Vat/not-safe-dst\");\n\n        // both sides non-dusty\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n    }\n    // --- CDP Confiscation ---\n    function grab(bytes32 i, address u, address v, address w, int dink, int dart) external note auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = add(urn.ink, dink);\n        urn.art = add(urn.art, dart);\n        ilk.Art = add(ilk.Art, dart);\n\n        int dtab = mul(ilk.rate, dart);\n\n        gem[i][v] = sub(gem[i][v], dink);\n        sin[w]    = sub(sin[w],    dtab);\n        vice      = sub(vice,      dtab);\n    }\n\n    // --- Settlement ---\n    function heal(uint rad) external note {\n        address u = msg.sender;\n        sin[u] = sub(sin[u], rad);\n        dai[u] = sub(dai[u], rad);\n        vice   = sub(vice,   rad);\n        debt   = sub(debt,   rad);\n    }\n    function suck(address u, address v, uint rad) external note auth {\n        sin[u] = add(sin[u], rad);\n        dai[v] = add(dai[v], rad);\n        vice   = add(vice,   rad);\n        debt   = add(debt,   rad);\n    }\n\n    // --- Rates ---\n    function fold(bytes32 i, address u, int rate) external note auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate = add(ilk.rate, rate);\n        int rad  = mul(ilk.Art, rate);\n        dai[u]   = add(dai[u], rad);\n        debt     = add(debt,   rad);\n    }\n}\n"
    },
    "DaiHrd.sol": {
      "content": "pragma solidity 0.5.12;\n\nimport { Context } from \"@openzeppelin/contracts/GSN/Context.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC777 } from \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport { IERC777Recipient } from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport { IERC777Sender } from \"@openzeppelin/contracts/token/ERC777/IERC777Sender.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { IERC1820Registry } from \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\nimport { RuntimeConstants } from \"./RuntimeConstants.sol\";\n\n// ERC777 is inlined because we need to change `_callTokensToSend` to protect against Uniswap replay attacks\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is RuntimeConstants, Context, IERC777, IERC20 {\n\tusing SafeMath for uint256;\n\tusing Address for address;\n\n\tIERC1820Registry constant private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n\tmapping(address => uint256) private _balances;\n\n\tuint256 private _totalSupply;\n\n\tstring private _name;\n\tstring private _symbol;\n\n\t// We inline the result of the following hashes because Solidity doesn't resolve them at compile time.\n\t// See https://github.com/ethereum/solidity/issues/4024.\n\n\t// keccak256(\"ERC777TokensSender\")\n\tbytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\n\t\t0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n\t// keccak256(\"ERC777TokensRecipient\")\n\tbytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\n\t\t0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n\t// This isn't ever read from - it's only used to respond to the defaultOperators query.\n\taddress[] private _defaultOperatorsArray;\n\n\t// Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n\tmapping(address => bool) private _defaultOperators;\n\n\t// For each account, a mapping of its operators and revoked default operators.\n\tmapping(address => mapping(address => bool)) private _operators;\n\tmapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n\t// ERC20-allowances\n\tmapping (address => mapping (address => uint256)) private _allowances;\n\n\t// KEYDONIX: Protect against Uniswap Exchange reentrancy bug: https://blog.openzeppelin.com/exploiting-uniswap-from-reentrancy-to-actual-profit/\n\tbool uniswapExchangeReentrancyGuard = false;\n\n\t/**\n\t * @dev `defaultOperators` may be an empty array.\n\t */\n\tconstructor(string memory name, string memory symbol, address[] memory defaultOperators) public {\n\t\t_name = name;\n\t\t_symbol = symbol;\n\n\t\t_defaultOperatorsArray = defaultOperators;\n\t\tfor (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n\t\t\t_defaultOperators[_defaultOperatorsArray[i]] = true;\n\t\t}\n\n\t\t// register interfaces\n\t\t_erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n\t\t_erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n\t}\n\n\t/**\n\t * @dev See {IERC777-name}.\n\t */\n\tfunction name() public view returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev See {IERC777-symbol}.\n\t */\n\tfunction symbol() public view returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev See {ERC20Detailed-decimals}.\n\t *\n\t * Always returns 18, as per the\n\t * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n\t */\n\tfunction decimals() public pure returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {IERC777-granularity}.\n\t *\n\t * This implementation always returns `1`.\n\t */\n\tfunction granularity() public view returns (uint256) {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * @dev See {IERC777-totalSupply}.\n\t */\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n\t */\n\tfunction balanceOf(address tokenHolder) public view returns (uint256) {\n\t\treturn _balances[tokenHolder];\n\t}\n\n\t/**\n\t * @dev See {IERC777-send}.\n\t *\n\t * Also emits a {Transfer} event for ERC20 compatibility.\n\t */\n\tfunction send(address recipient, uint256 amount, bytes calldata data) external {\n\t\t_send(_msgSender(), _msgSender(), recipient, amount, data, \"\", true);\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n\t * interface if it is a contract.\n\t *\n\t * Also emits a {Sent} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool) {\n\t\trequire(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n\t\taddress from = _msgSender();\n\n\t\t_callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n\t\t_move(from, from, recipient, amount, \"\", \"\");\n\n\t\t_callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC777-burn}.\n\t *\n\t * Also emits a {Transfer} event for ERC20 compatibility.\n\t */\n\tfunction burn(uint256 amount, bytes calldata data) external {\n\t\t_burn(_msgSender(), _msgSender(), amount, data, \"\");\n\t}\n\n\t/**\n\t * @dev See {IERC777-isOperatorFor}.\n\t */\n\tfunction isOperatorFor(address operator, address tokenHolder) public view returns (bool) {\n\t\treturn operator == tokenHolder ||\n\t\t\t(_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n\t\t\t_operators[tokenHolder][operator];\n\t}\n\n\t/**\n\t * @dev See {IERC777-authorizeOperator}.\n\t */\n\tfunction authorizeOperator(address operator) external {\n\t\trequire(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n\t\tif (_defaultOperators[operator]) {\n\t\t\tdelete _revokedDefaultOperators[_msgSender()][operator];\n\t\t} else {\n\t\t\t_operators[_msgSender()][operator] = true;\n\t\t}\n\n\t\temit AuthorizedOperator(operator, _msgSender());\n\t}\n\n\t/**\n\t * @dev See {IERC777-revokeOperator}.\n\t */\n\tfunction revokeOperator(address operator) external {\n\t\trequire(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n\t\tif (_defaultOperators[operator]) {\n\t\t\t_revokedDefaultOperators[_msgSender()][operator] = true;\n\t\t} else {\n\t\t\tdelete _operators[_msgSender()][operator];\n\t\t}\n\n\t\temit RevokedOperator(operator, _msgSender());\n\t}\n\n\t/**\n\t * @dev See {IERC777-defaultOperators}.\n\t */\n\tfunction defaultOperators() public view returns (address[] memory) {\n\t\treturn _defaultOperatorsArray;\n\t}\n\n\t/**\n\t * @dev See {IERC777-operatorSend}.\n\t *\n\t * Emits {Sent} and {Transfer} events.\n\t */\n\tfunction operatorSend(address sender, address recipient, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n\t\trequire(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n\t\t_send(_msgSender(), sender, recipient, amount, data, operatorData, true);\n\t}\n\n\t/**\n\t * @dev See {IERC777-operatorBurn}.\n\t *\n\t * Emits {Burned} and {Transfer} events.\n\t */\n\tfunction operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external {\n\t\trequire(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n\t\t_burn(_msgSender(), account, amount, data, operatorData);\n\t}\n\n\t/**\n\t * @dev See {IERC20-allowance}.\n\t *\n\t * Note that operator and allowance concepts are orthogonal: operators may\n\t * not have allowance, and accounts with allowance may not be operators\n\t * themselves.\n\t */\n\tfunction allowance(address holder, address spender) public view returns (uint256) {\n\t\treturn _allowances[holder][spender];\n\t}\n\n\t/**\n\t * @dev See {IERC20-approve}.\n\t *\n\t * Note that accounts cannot have allowance issued by their operators.\n\t */\n\tfunction approve(address spender, uint256 value) external returns (bool) {\n\t\taddress holder = _msgSender();\n\t\t_approve(holder, spender, value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Note that operator and allowance concepts are orthogonal: operators cannot\n\t * call `transferFrom` (unless they have allowance), and accounts with\n\t * allowance cannot call `operatorSend` (unless they are operators).\n\t *\n\t * Emits {Sent}, {Transfer} and {Approval} events.\n\t */\n\tfunction transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\n\t\trequire(recipient != address(0), \"ERC777: transfer to the zero address\");\n\t\trequire(holder != address(0), \"ERC777: transfer from the zero address\");\n\n\t\taddress spender = _msgSender();\n\n\t\t// KEYDONIX: Block re-entrancy specifically for uniswap, which is vulnerable to ERC-777 tokens\n\t\tif (msg.sender == uniswapExchange) {\n\t\t\trequire(!uniswapExchangeReentrancyGuard, \"Attempted to execute a Uniswap exchange while in the middle of a Uniswap exchange\");\n\t\t\tuniswapExchangeReentrancyGuard = true;\n\t\t}\n\t\t_callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\t\tif (msg.sender == uniswapExchange) {\n\t\t\tuniswapExchangeReentrancyGuard = false;\n\t\t}\n\n\t\t_move(spender, holder, recipient, amount, \"\", \"\");\n\t\t_approve(holder, spender, _allowances[holder][spender].sub(amount, \"ERC777: transfer amount exceeds allowance\"));\n\n\t\t_callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * If a send hook is registered for `account`, the corresponding function\n\t * will be called with `operator`, `data` and `operatorData`.\n\t *\n\t * See {IERC777Sender} and {IERC777Recipient}.\n\t *\n\t * Emits {Minted} and {Transfer} events.\n\t *\n\t * Requirements\n\t *\n\t * - `account` cannot be the zero address.\n\t * - if `account` is a contract, it must implement the {IERC777Recipient}\n\t * interface.\n\t */\n\tfunction _mint(address operator, address account, uint256 amount, bytes memory userData, bytes memory operatorData) internal {\n\t\trequire(account != address(0), \"ERC777: mint to the zero address\");\n\n\t\t// Update state variables\n\t\t_totalSupply = _totalSupply.add(amount);\n\t\t_balances[account] = _balances[account].add(amount);\n\n\t\t_callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n\n\t\temit Minted(operator, account, amount, userData, operatorData);\n\t\temit Transfer(address(0), account, amount);\n\t}\n\n\t// KEYDONIX: changed visibility from private to internal, we reference this function in derived contract\n\t/**\n\t * @dev Send tokens\n\t * @param operator address operator requesting the transfer\n\t * @param from address token holder address\n\t * @param to address recipient address\n\t * @param amount uint256 amount of tokens to transfer\n\t * @param userData bytes extra information provided by the token holder (if any)\n\t * @param operatorData bytes extra information provided by the operator (if any)\n\t * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n\t */\n\tfunction _send(address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool requireReceptionAck) internal {\n\t\trequire(from != address(0), \"ERC777: send from the zero address\");\n\t\trequire(to != address(0), \"ERC777: send to the zero address\");\n\n\t\t_callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n\t\t_move(operator, from, to, amount, userData, operatorData);\n\n\t\t_callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n\t}\n\n\t// KEYDONIX: changed visibility from private to internal, we reference this function in derived contract\n\t/**\n\t * @dev Burn tokens\n\t * @param operator address operator requesting the operation\n\t * @param from address token holder address\n\t * @param amount uint256 amount of tokens to burn\n\t * @param data bytes extra information provided by the token holder\n\t * @param operatorData bytes extra information provided by the operator (if any)\n\t */\n\n\tfunction _burn(address operator, address from, uint256 amount, bytes memory data, bytes memory operatorData) internal {\n\t\trequire(from != address(0), \"ERC777: burn from the zero address\");\n\n\t\t_callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n\t\t// Update state variables\n\t\t_balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n\t\t_totalSupply = _totalSupply.sub(amount);\n\n\t\temit Burned(operator, from, amount, data, operatorData);\n\t\temit Transfer(from, address(0), amount);\n\t}\n\n\tfunction _move(address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) private {\n\t\t_balances[from] = _balances[from].sub(amount, \"ERC777: transfer amount exceeds balance\");\n\t\t_balances[to] = _balances[to].add(amount);\n\n\t\temit Sent(operator, from, to, amount, userData, operatorData);\n\t\temit Transfer(from, to, amount);\n\t}\n\n\tfunction _approve(address holder, address spender, uint256 value) private {\n\t\t// TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\n\t\t// currently unnecessary.\n\t\t//require(holder != address(0), \"ERC777: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC777: approve to the zero address\");\n\n\t\t_allowances[holder][spender] = value;\n\t\temit Approval(holder, spender, value);\n\t}\n\n\t/**\n\t * @dev Call from.tokensToSend() if the interface is registered\n\t * @param operator address operator requesting the transfer\n\t * @param from address token holder address\n\t * @param to address recipient address\n\t * @param amount uint256 amount of tokens to transfer\n\t * @param userData bytes extra information provided by the token holder (if any)\n\t * @param operatorData bytes extra information provided by the operator (if any)\n\t */\n\tfunction _callTokensToSend(address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData) private {\n\t\taddress implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n\t\tif (implementer != address(0)) {\n\t\t\tIERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n\t * tokensReceived() was not registered for the recipient\n\t * @param operator address operator requesting the transfer\n\t * @param from address token holder address\n\t * @param to address recipient address\n\t * @param amount uint256 amount of tokens to transfer\n\t * @param userData bytes extra information provided by the token holder (if any)\n\t * @param operatorData bytes extra information provided by the operator (if any)\n\t * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n\t */\n\tfunction _callTokensReceived(address operator, address from, address to, uint256 amount, bytes memory userData, bytes memory operatorData, bool requireReceptionAck) private {\n\t\taddress implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n\t\tif (implementer != address(0)) {\n\t\t\tIERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n\t\t} else if (requireReceptionAck) {\n\t\t\trequire(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n\t\t}\n\t}\n}\n\ncontract MakerFunctions {\n\t// KEYDONIX: Renamed from `rmul` for clarity\n\t// KEYDONIX: Changed ONE to 10**27 for clarity\n\tfunction safeMul27(uint x, uint y) internal pure returns (uint z) {\n\t\tz = safeMul(x, y) / 10 ** 27;\n\t}\n\n\tfunction rpow(uint x, uint n, uint base) internal pure returns (uint z) {\n\t\tassembly {\n\t\t\tswitch x case 0 {switch n case 0 {z := base} default {z := 0}}\n\t\t\tdefault {\n\t\t\t\tswitch mod(n, 2) case 0 { z := base } default { z := x }\n\t\t\t\tlet half := div(base, 2)  // for rounding.\n\t\t\t\tfor { n := div(n, 2) } n { n := div(n,2) } {\n\t\t\t\tlet xx := mul(x, x)\n\t\t\t\tif iszero(eq(div(xx, x), x)) { revert(0,0) }\n\t\t\t\tlet xxRound := add(xx, half)\n\t\t\t\tif lt(xxRound, xx) { revert(0,0) }\n\t\t\t\tx := div(xxRound, base)\n\t\t\t\tif mod(n,2) {\n\t\t\t\t\tlet zx := mul(z, x)\n\t\t\t\t\tif and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n\t\t\t\t\tlet zxRound := add(zx, half)\n\t\t\t\t\tif lt(zxRound, zx) { revert(0,0) }\n\t\t\t\t\tz := div(zxRound, base)\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// KEYDONIX: Renamed from `mul` due to shadowing warning from Solidity\n\tfunction safeMul(uint x, uint y) internal pure returns (uint z) {\n\t\trequire(y == 0 || (z = x * y) / y == x);\n\t}\n}\n\ncontract ReverseRegistrar {\n\tfunction setName(string memory name) public returns (bytes32 node);\n}\n\ncontract DaiHrd is ERC777, MakerFunctions {\n\tevent Deposit(address indexed from, uint256 depositedAttodai, uint256 mintedAttodaiHrd);\n\tevent Withdrawal(address indexed from, address indexed to, uint256 withdrawnAttodai, uint256 burnedAttodaiHrd);\n\tevent DepositVatDai(address indexed account, uint256 depositedAttorontodai, uint256 mintedAttodaiHrd);\n\tevent WithdrawalVatDai(address indexed from, address indexed to, uint256 withdrawnAttorontodai, uint256 burnedAttodaiHrd);\n\n\t// uses this super constructor syntax instead of the preferred alternative syntax because my editor doesn't like the class syntax\n\tconstructor(ReverseRegistrar reverseRegistrar) ERC777(\"DAI-HRD\", \"DAI-HRD\", new address[](0)) public {\n\t\tdai.approve(address(daiJoin), uint(-1));\n\t\tvat.hope(address(pot));\n\t\tvat.hope(address(daiJoin));\n\t\tif (reverseRegistrar != ReverseRegistrar(0)) {\n\t\t\treverseRegistrar.setName(\"dai-hrd.eth\");\n\t\t}\n\t}\n\n\tfunction deposit(uint256 attodai) external returns(uint256 attodaiHrd) {\n\t\tdai.transferFrom(msg.sender, address(this), attodai);\n\t\tdaiJoin.join(address(this), dai.balanceOf(address(this)));\n\t\tuint256 depositedAttopot = depositVatDaiForAccount(msg.sender);\n\t\temit Deposit(msg.sender, attodai, depositedAttopot);\n\t\treturn depositedAttopot;\n\t}\n\n\t// If the user has vat dai directly (after performing vault actions, for instance), they don't need to create the DAI ERC20 just so we can burn it, we'll accept vat dai\n\tfunction depositVatDai(uint256 attorontovatDai) external returns(uint256 attodaiHrd) {\n\t\tvat.move(msg.sender, address(this), attorontovatDai);\n\t\tuint256 depositedAttopot = depositVatDaiForAccount(msg.sender);\n\t\temit DepositVatDai(msg.sender, attorontovatDai, depositedAttopot);\n\t\treturn depositedAttopot;\n\t}\n\n\tfunction withdrawTo(address recipient, uint256 attodaiHrd) external returns(uint256 attodai) {\n\t\t// Don't need rontodaiPerPot, so we don't call updateAndFetchChi\n\t\tif (pot.rho() != now) pot.drip();\n\t\treturn withdraw(recipient, attodaiHrd);\n\t}\n\n\tfunction withdrawToDenominatedInDai(address recipient, uint256 attodai) external returns(uint256 attodaiHrd) {\n\t\tuint256 rontodaiPerPot = updateAndFetchChi();\n\t\tattodaiHrd = convertAttodaiToAttodaiHrd(attodai, rontodaiPerPot);\n\t\tuint256 attodaiWithdrawn = withdraw(recipient, attodaiHrd);\n\t\trequire(attodaiWithdrawn >= attodai, \"DaiHrd/withdrawToDenominatedInDai: Not withdrawing enough DAI to cover request\");\n\t\treturn attodaiHrd;\n\t}\n\n\tfunction withdrawVatDai(address recipient, uint256 attodaiHrd) external returns(uint256 attorontodai) {\n\t\trequire(recipient != address(0) && recipient != address(this), \"DaiHrd/withdrawVatDai: Invalid recipient\");\n\t\t// Don't need rontodaiPerPot, so we don't call updateAndFetchChi\n\t\tif (pot.rho() != now) pot.drip();\n\t\t_burn(address(0), msg.sender, attodaiHrd, new bytes(0), new bytes(0));\n\t\tpot.exit(attodaiHrd);\n\t\tattorontodai = vat.dai(address(this));\n\t\tvat.move(address(this), recipient, attorontodai);\n\t\temit WithdrawalVatDai(msg.sender, recipient, attorontodai, attodaiHrd);\n\t\treturn attorontodai;\n\t}\n\n\t// Dai specific functions. These functions all behave similar to standard ERC777 functions with input or output denominated in Dai instead of DaiHrd\n\tfunction balanceOfDenominatedInDai(address tokenHolder) external view returns(uint256 attodai) {\n\t\tuint256 rontodaiPerPot = calculatedChi();\n\t\tuint256 attodaiHrd = balanceOf(tokenHolder);\n\t\treturn convertAttodaiHrdToAttodai(attodaiHrd, rontodaiPerPot);\n\t}\n\n\tfunction totalSupplyDenominatedInDai() external view returns(uint256 attodai) {\n\t\tuint256 rontodaiPerPot = calculatedChi();\n\t\treturn convertAttodaiHrdToAttodai(totalSupply(), rontodaiPerPot);\n\t}\n\n\tfunction sendDenominatedInDai(address recipient, uint256 attodai, bytes calldata data) external {\n\t\tuint256 rontodaiPerPot = calculatedChi();\n\t\tuint256 attodaiHrd = convertAttodaiToAttodaiHrd(attodai, rontodaiPerPot);\n\t\t_send(_msgSender(), _msgSender(), recipient, attodaiHrd, data, \"\", true);\n\t}\n\n\tfunction burnDenominatedInDai(uint256 attodai, bytes calldata data) external {\n\t\tuint256 rontodaiPerPot = calculatedChi();\n\t\tuint256 attodaiHrd = convertAttodaiToAttodaiHrd(attodai, rontodaiPerPot);\n\t\t_burn(_msgSender(), _msgSender(), attodaiHrd, data, \"\");\n\t}\n\n\tfunction operatorSendDenominatedInDai(address sender, address recipient, uint256 attodai, bytes calldata data, bytes calldata operatorData) external {\n\t\trequire(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n\n\t\tuint256 rontodaiPerPot = calculatedChi();\n\t\tuint256 attodaiHrd = convertAttodaiToAttodaiHrd(attodai, rontodaiPerPot);\n\t\t_send(_msgSender(), sender, recipient, attodaiHrd, data, operatorData, true);\n\t}\n\n\tfunction operatorBurnDenominatedInDai(address account, uint256 attodai, bytes calldata data, bytes calldata operatorData) external {\n\t\trequire(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n\n\t\tuint256 rontodaiPerPot = calculatedChi();\n\t\tuint256 attodaiHrd = convertAttodaiToAttodaiHrd(attodai, rontodaiPerPot);\n\t\t_burn(_msgSender(), account, attodaiHrd, data, operatorData);\n\t}\n\n\t// Utility Functions\n\tfunction calculatedChi() public view returns (uint256 rontodaiPerPot) {\n\t\t// mirrors Maker's calculation: rmul(rpow(dsr, now - rho, ONE), chi);\n\t\treturn safeMul27(rpow(pot.dsr(), now - pot.rho(), 10 ** 27), pot.chi());\n\t}\n\n\tfunction convertAttodaiToAttodaiHrd(uint256 attodai, uint256 rontodaiPerPot ) private pure returns (uint256 attodaiHrd) {\n\t\t// + 1 is to compensate rounding? since attodaiHrd is rounded down\n\t\treturn attodai.mul(10 ** 27).add(rontodaiPerPot - 1).div(rontodaiPerPot);\n\t}\n\n\tfunction convertAttodaiHrdToAttodai(uint256 attodaiHrd, uint256 rontodaiPerPot ) private pure returns (uint256 attodai) {\n\t\treturn attodaiHrd.mul(rontodaiPerPot).div(10 ** 27);\n\t}\n\n\tfunction updateAndFetchChi() private returns (uint256 rontodaiPerPot) {\n\t\treturn (pot.rho() == now) ? pot.chi() : pot.drip();\n\t}\n\n\t// Takes whatever vat dai has already been transferred to DaiHrd, gives to pot (DSR) and mints tokens for user\n\tfunction depositVatDaiForAccount(address account) private returns (uint256 attopotDeposited) {\n\t\tuint256 rontodaiPerPot = updateAndFetchChi();\n\t\tuint256 attopotToDeposit = vat.dai(address(this)) / rontodaiPerPot;\n\t\tpot.join(attopotToDeposit);\n\t\t_mint(address(0), account, attopotToDeposit, new bytes(0), new bytes(0));\n\t\treturn attopotToDeposit;\n\t}\n\n\t// Internal implementations of functions with multiple entrypoints. drip() should be called prior to this call\n\tfunction withdraw(address recipient, uint256 attodaiHrd) private returns(uint256 attodaiWithdrawn) {\n\t\trequire(recipient != address(0) && recipient != address(this), \"DaiHrd/withdraw: Invalid recipient\");\n\t\t_burn(address(0), msg.sender, attodaiHrd, new bytes(0), new bytes(0));\n\t\tpot.exit(attodaiHrd);\n\t\tdaiJoin.exit(address(this), vat.dai(address(this)) / 10**27);\n\t\tuint256 attodai = dai.balanceOf(address(this));\n\t\tdai.transfer(recipient, attodai);\n\t\temit Withdrawal(msg.sender, recipient, attodai, attodaiHrd);\n\t\treturn attodai;\n\t}\n}\n"
    },
    "RuntimeConstants.sol": {
      "content": "// THIS FILE IS AUTOGENERATED DURING MIGRATION, DO NOT EDIT BY HAND\npragma solidity 0.5.12;\n\nimport { Dai } from \"./dai.sol\";\nimport { DaiJoin } from \"./join.sol\";\nimport { Pot } from \"./pot.sol\";\nimport { Vat } from \"./vat.sol\";\n\ncontract RuntimeConstants {\n\tDai constant public dai = Dai(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\tVat constant public vat = Vat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\n\tPot constant public pot = Pot(0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7);\n\tDaiJoin constant public daiJoin = DaiJoin(0x9759A6Ac90977b93B58547b4A71c78317f391A28);\n\taddress constant public uniswapExchange = 0x918Af0FB5517aC5b8B34240203408CeDBBa09Bd9;\n}\n"
    }
  }
}}