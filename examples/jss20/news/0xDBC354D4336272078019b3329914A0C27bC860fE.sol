{"HipToken.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \u0027./SafeMathLib.sol\u0027;\n\ncontract HipToken {\n    using SafeMathLib for uint;\n\n    mapping (address =\u003e uint) public balances;\n    mapping (address =\u003e uint) public frozenBalances;\n    mapping (address =\u003e mapping (address =\u003e uint)) public allowed;\n    mapping (uint =\u003e FrozenTokens) public frozenTokensMap;\n\n    event Transfer(address indexed sender, address indexed receiver, uint value);\n    event Approval(address approver, address spender, uint value);\n    event TokensFrozen(address indexed freezer, uint amount, uint id, uint lengthFreezeDays);\n    event TokensUnfrozen(address indexed unfreezer, uint amount, uint id);\n    event TokensBurned(address burner, uint amount);\n\n    uint constant public decimals = 18;\n    uint public totalSupply;\n    uint public numCoinsFrozen;\n    uint numFrozenStructs;\n\n    struct FrozenTokens {\n        uint id;\n        uint dateFrozen;\n        uint lengthFreezeDays;\n        uint amount;\n        bool frozen;\n        address owner;\n    }\n\n    constructor(address bank, uint initialBalance) public {\n        balances[bank] = initialBalance;\n        totalSupply = initialBalance;\n    }\n\n    function freeze(uint amount, uint freezeDays) public {\n        balances[msg.sender] = balances[msg.sender].minus(amount);\n        frozenBalances[msg.sender] = frozenBalances[msg.sender].plus(amount);\n        numFrozenStructs = numFrozenStructs.plus(1);\n        numCoinsFrozen = numCoinsFrozen.plus(amount);\n        frozenTokensMap[numFrozenStructs] = FrozenTokens(numFrozenStructs, now, freezeDays, amount, true, msg.sender);\n        emit TokensFrozen(msg.sender, amount, numFrozenStructs, freezeDays);\n    }\n\n    function unFreeze(uint id) public {\n        FrozenTokens storage f = frozenTokensMap[id];\n        require(f.dateFrozen + (f.lengthFreezeDays * 1 days) \u003c now, \u0027May not unfreeze until freeze time is up\u0027);\n        require(f.frozen, \u0027Can only unfreeze frozen tokens\u0027);\n        f.frozen = false;\n        frozenBalances[f.owner] = frozenBalances[f.owner].minus(f.amount);\n        balances[f.owner] = balances[f.owner].plus(f.amount);\n        numCoinsFrozen = numCoinsFrozen.minus(f.amount);\n        emit TokensUnfrozen(f.owner, f.amount, id);\n    }\n\n    function burn(uint amount) public {\n        balances[msg.sender] = balances[msg.sender].minus(amount);\n        totalSupply = totalSupply.minus(amount);\n        emit TokensBurned(msg.sender, amount);\n    }\n\n    function transfer(address to, uint value) public returns (bool success)\n    {\n        // deduct\n        balances[msg.sender] = balances[msg.sender].minus(value);\n        // add\n        balances[to] = balances[to].plus(value);\n\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) public returns (bool success)\n    {\n        uint allowance = allowed[from][msg.sender];\n\n        // deduct\n        balances[from] = balances[from].minus(value);\n\n        // add\n        balances[to] = balances[to].plus(value);\n\n        // adjust allowance\n        allowed[from][msg.sender] = allowance.minus(value);\n\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint balance) {\n        return balances[owner];\n    }\n\n    function frozenBalanceOf(address owner) public view returns (uint balance) {\n        return frozenBalances[owner];\n    }\n\n    function approve(address spender, uint value) public returns (bool success)\n    {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n}\n"},"SafeMathLib.sol":{"content":"pragma solidity ^0.5.0;\n\nlibrary SafeMathLib {\n  function times(uint a, uint b) public pure returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function minus(uint a, uint b) public pure returns (uint) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) public pure returns (uint) {\n    uint c = a + b;\n    assert(c\u003e=a \u0026\u0026 c\u003e=b);\n    return c;\n  }\n\n}\n"}}