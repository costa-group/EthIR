{"ERC20Interface.sol":{"content":"pragma solidity 0.4.18;\n\n\n// https://github.com/ethereum/EIPs/issues/20\ninterface ERC20 {\n    function totalSupply() public view returns (uint supply);\n    function balanceOf(address _owner) public view returns (uint balance);\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\n    function decimals() public view returns(uint digits);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n"},"FeeBurnerInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\ninterface FeeBurnerInterface {\n    function handleFees (uint tradeWeiAmount, address reserve, address wallet) public returns(bool);\n    function setReserveData(address reserve, uint feesInBps, address kncWallet) public;\n}\n"},"KyberReserveInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\n\n/// @title Kyber Reserve contract\ninterface KyberReserveInterface {\n\n    function trade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 destToken,\n        address destAddress,\n        uint conversionRate,\n        bool validate\n    )\n        public\n        payable\n        returns(bool);\n\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns(uint);\n}\n"},"OrderbookReserve.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./OrderListInterface.sol\";\nimport \"./OrderIdManager.sol\";\nimport \"./OrderbookReserveInterface.sol\";\nimport \"../../../Utils2.sol\";\nimport \"../../../KyberReserveInterface.sol\";\n\n\ncontract FeeBurnerRateInterface {\n    uint public kncPerEthRatePrecision;\n}\n\n\ninterface MedianizerInterface {\n    function peek() public view returns (bytes32, bool);\n}\n\n\ncontract OrderbookReserve is OrderIdManager, Utils2, KyberReserveInterface, OrderbookReserveInterface {\n\n    uint public constant BURN_TO_STAKE_FACTOR = 5;      // stake per order must be xfactor expected burn amount.\n    uint public constant MAX_BURN_FEE_BPS = 100;        // 1%\n    uint public constant MIN_REMAINING_ORDER_RATIO = 2; // Ratio between min new order value and min order value.\n    uint public constant MAX_USD_PER_ETH = 100000;      // Above this value price is surely compromised.\n\n    uint32 constant public TAIL_ID = 1;         // tail Id in order list contract\n    uint32 constant public HEAD_ID = 2;         // head Id in order list contract\n\n    struct OrderLimits {\n        uint minNewOrderSizeUsd; // Basis for setting min new order size Eth\n        uint maxOrdersPerTrade;     // Limit number of iterated orders per trade / getRate loops.\n        uint minNewOrderSizeWei;    // Below this value can\u0027t create new order.\n        uint minOrderSizeWei;       // below this value order will be removed.\n    }\n\n    uint public kncPerEthBaseRatePrecision; // according to base rate all stakes are calculated.\n\n    struct ExternalContracts {\n        ERC20 kncToken;          // not constant. to enable testing while not on main net\n        ERC20 token;             // only supported token.\n        FeeBurnerRateInterface feeBurner;\n        address kyberNetwork;\n        MedianizerInterface medianizer; // price feed Eth - USD from maker DAO.\n        OrderListFactoryInterface orderListFactory;\n    }\n\n    //struct for getOrderData() return value. used only in memory.\n    struct OrderData {\n        address maker;\n        uint32 nextId;\n        bool isLastOrder;\n        uint128 srcAmount;\n        uint128 dstAmount;\n    }\n\n    OrderLimits public limits;\n    ExternalContracts public contracts;\n\n    // sorted lists of orders. one list for token to Eth, other for Eth to token.\n    // Each order is added in the correct position in the list to keep it sorted.\n    OrderListInterface public tokenToEthList;\n    OrderListInterface public ethToTokenList;\n\n    //funds data\n    mapping(address =\u003e mapping(address =\u003e uint)) public makerFunds; // deposited maker funds.\n    mapping(address =\u003e uint) public makerKnc;            // for knc staking.\n    mapping(address =\u003e uint) public makerTotalOrdersWei; // per maker how many Wei in orders, for stake calculation.\n\n    uint public makerBurnFeeBps;    // knc burn fee per order that is taken.\n\n    //each maker will have orders that will be reused.\n    mapping(address =\u003e OrderIdData) public makerOrdersTokenToEth;\n    mapping(address =\u003e OrderIdData) public makerOrdersEthToToken;\n\n    function OrderbookReserve(\n        ERC20 knc,\n        ERC20 reserveToken,\n        address burner,\n        address network,\n        MedianizerInterface medianizer,\n        OrderListFactoryInterface factory,\n        uint minNewOrderUsd,\n        uint maxOrdersPerTrade,\n        uint burnFeeBps\n    )\n        public\n    {\n\n        require(knc != address(0));\n        require(reserveToken != address(0));\n        require(burner != address(0));\n        require(network != address(0));\n        require(medianizer != address(0));\n        require(factory != address(0));\n        require(burnFeeBps != 0);\n        require(burnFeeBps \u003c= MAX_BURN_FEE_BPS);\n        require(maxOrdersPerTrade != 0);\n        require(minNewOrderUsd \u003e 0);\n\n        contracts.kyberNetwork = network;\n        contracts.feeBurner = FeeBurnerRateInterface(burner);\n        contracts.medianizer = medianizer;\n        contracts.orderListFactory = factory;\n        contracts.kncToken = knc;\n        contracts.token = reserveToken;\n\n        makerBurnFeeBps = burnFeeBps;\n        limits.minNewOrderSizeUsd = minNewOrderUsd;\n        limits.maxOrdersPerTrade = maxOrdersPerTrade;\n\n        require(setMinOrderSizeEth());\n    \n        require(contracts.kncToken.approve(contracts.feeBurner, (2**255)));\n\n        //can only support tokens with decimals() API\n        setDecimals(contracts.token);\n\n        kncPerEthBaseRatePrecision = contracts.feeBurner.kncPerEthRatePrecision();\n    }\n\n    ///@dev separate init function for this contract, if this init is in the C\u0027tor. gas consumption too high.\n    function init() public returns(bool) {\n        if ((tokenToEthList != address(0)) \u0026\u0026 (ethToTokenList != address(0))) return true;\n        if ((tokenToEthList != address(0)) || (ethToTokenList != address(0))) revert();\n\n        tokenToEthList = contracts.orderListFactory.newOrdersContract(this);\n        ethToTokenList = contracts.orderListFactory.newOrdersContract(this);\n\n        return true;\n    }\n\n    function setKncPerEthBaseRate() public {\n        uint kncPerEthRatePrecision = contracts.feeBurner.kncPerEthRatePrecision();\n        if (kncPerEthRatePrecision \u003c kncPerEthBaseRatePrecision) {\n            kncPerEthBaseRatePrecision = kncPerEthRatePrecision;\n        }\n    }\n\n    function getConversionRate(ERC20 src, ERC20 dst, uint srcQty, uint blockNumber) public view returns(uint) {\n        require((src == ETH_TOKEN_ADDRESS) || (dst == ETH_TOKEN_ADDRESS));\n        require((src == contracts.token) || (dst == contracts.token));\n        require(srcQty \u003c= MAX_QTY);\n\n        if (kncRateBlocksTrade() || (srcQty == 0)) return 0;\n\n        blockNumber; // in this reserve no order expiry == no use for blockNumber. here to avoid compiler warning.\n\n        //user order ETH -\u003e token is matched with maker order token -\u003e ETH\n        OrderListInterface list = (src == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\n\n        uint32 orderId;\n        OrderData memory orderData;\n\n        uint128 userRemainingSrcQty = uint128(srcQty);\n        uint128 totalUserDstAmount = 0;\n        uint maxOrders = limits.maxOrdersPerTrade;\n\n        for (\n            (orderId, orderData.isLastOrder) = list.getFirstOrder();\n            ((userRemainingSrcQty \u003e 0) \u0026\u0026 (!orderData.isLastOrder) \u0026\u0026 (maxOrders-- \u003e 0));\n            orderId = orderData.nextId\n        ) {\n            orderData = getOrderData(list, orderId);\n            // maker dst quantity is the requested quantity he wants to receive. user src quantity is what user gives.\n            // so user src quantity is matched with maker dst quantity\n            if (orderData.dstAmount \u003c= userRemainingSrcQty) {\n                totalUserDstAmount += orderData.srcAmount;\n                userRemainingSrcQty -= orderData.dstAmount;\n            } else {\n                totalUserDstAmount += uint128(uint(orderData.srcAmount) * uint(userRemainingSrcQty) /\n                    uint(orderData.dstAmount));\n                userRemainingSrcQty = 0;\n            }\n        }\n\n        if (userRemainingSrcQty != 0) return 0; //not enough tokens to exchange.\n\n        return calcRateFromQty(srcQty, totalUserDstAmount, getDecimals(src), getDecimals(dst));\n    }\n\n    event OrderbookReserveTrade(ERC20 srcToken, ERC20 dstToken, uint srcAmount, uint dstAmount);\n\n    function trade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 dstToken,\n        address dstAddress,\n        uint conversionRate,\n        bool validate\n    )\n        public\n        payable\n        returns(bool)\n    {\n        require(msg.sender == contracts.kyberNetwork);\n        require((srcToken == ETH_TOKEN_ADDRESS) || (dstToken == ETH_TOKEN_ADDRESS));\n        require((srcToken == contracts.token) || (dstToken == contracts.token));\n        require(srcAmount \u003c= MAX_QTY);\n\n        conversionRate;\n        validate;\n\n        if (srcToken == ETH_TOKEN_ADDRESS) {\n            require(msg.value == srcAmount);\n        } else {\n            require(msg.value == 0);\n            require(srcToken.transferFrom(msg.sender, this, srcAmount));\n        }\n\n        uint totalDstAmount = doTrade(\n                srcToken,\n                srcAmount,\n                dstToken\n            );\n\n        require(conversionRate \u003c= calcRateFromQty(srcAmount, totalDstAmount, getDecimals(srcToken),\n            getDecimals(dstToken)));\n\n        //all orders were successfully taken. send to dstAddress\n        if (dstToken == ETH_TOKEN_ADDRESS) {\n            dstAddress.transfer(totalDstAmount);\n        } else {\n            require(dstToken.transfer(dstAddress, totalDstAmount));\n        }\n\n        OrderbookReserveTrade(srcToken, dstToken, srcAmount, totalDstAmount);\n        return true;\n    }\n\n    function doTrade(\n        ERC20 srcToken,\n        uint srcAmount,\n        ERC20 dstToken\n    )\n        internal\n        returns(uint)\n    {\n        OrderListInterface list = (srcToken == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\n\n        uint32 orderId;\n        OrderData memory orderData;\n        uint128 userRemainingSrcQty = uint128(srcAmount);\n        uint128 totalUserDstAmount = 0;\n\n        for (\n            (orderId, orderData.isLastOrder) = list.getFirstOrder();\n            ((userRemainingSrcQty \u003e 0) \u0026\u0026 (!orderData.isLastOrder));\n            orderId = orderData.nextId\n        ) {\n        // maker dst quantity is the requested quantity he wants to receive. user src quantity is what user gives.\n        // so user src quantity is matched with maker dst quantity\n            orderData = getOrderData(list, orderId);\n            if (orderData.dstAmount \u003c= userRemainingSrcQty) {\n                totalUserDstAmount += orderData.srcAmount;\n                userRemainingSrcQty -= orderData.dstAmount;\n                require(takeFullOrder({\n                    maker: orderData.maker,\n                    orderId: orderId,\n                    userSrc: srcToken,\n                    userDst: dstToken,\n                    userSrcAmount: orderData.dstAmount,\n                    userDstAmount: orderData.srcAmount\n                }));\n            } else {\n                uint128 partialDstQty = uint128(uint(orderData.srcAmount) * uint(userRemainingSrcQty) /\n                    uint(orderData.dstAmount));\n                totalUserDstAmount += partialDstQty;\n                require(takePartialOrder({\n                    maker: orderData.maker,\n                    orderId: orderId,\n                    userSrc: srcToken,\n                    userDst: dstToken,\n                    userPartialSrcAmount: userRemainingSrcQty,\n                    userTakeDstAmount: partialDstQty,\n                    orderSrcAmount: orderData.srcAmount,\n                    orderDstAmount: orderData.dstAmount\n                }));\n                userRemainingSrcQty = 0;\n            }\n        }\n\n        require(userRemainingSrcQty == 0 \u0026\u0026 totalUserDstAmount \u003e 0);\n\n        return totalUserDstAmount;\n    }\n\n    ///@param srcAmount is the token amount that will be payed. must be deposited before hand in the makers account.\n    ///@param dstAmount is the eth amount the maker expects to get for his tokens.\n    function submitTokenToEthOrder(uint128 srcAmount, uint128 dstAmount)\n        public\n        returns(bool)\n    {\n        return submitTokenToEthOrderWHint(srcAmount, dstAmount, 0);\n    }\n\n    function submitTokenToEthOrderWHint(uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\n        public\n        returns(bool)\n    {\n        uint32 newId = fetchNewOrderId(makerOrdersTokenToEth[msg.sender]);\n        return addOrder(false, newId, srcAmount, dstAmount, hintPrevOrder);\n    }\n\n    ///@param srcAmount is the Ether amount that will be payed, must be deposited before hand.\n    ///@param dstAmount is the token amount the maker expects to get for his Ether.\n    function submitEthToTokenOrder(uint128 srcAmount, uint128 dstAmount)\n        public\n        returns(bool)\n    {\n        return submitEthToTokenOrderWHint(srcAmount, dstAmount, 0);\n    }\n\n    function submitEthToTokenOrderWHint(uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\n        public\n        returns(bool)\n    {\n        uint32 newId = fetchNewOrderId(makerOrdersEthToToken[msg.sender]);\n        return addOrder(true, newId, srcAmount, dstAmount, hintPrevOrder);\n    }\n\n    ///@dev notice here a batch of orders represented in arrays. order x is represented by x cells of all arrays.\n    ///@dev all arrays expected to the same length.\n    ///@param isEthToToken per each order. is order x eth to token (= src is Eth) or vice versa.\n    ///@param srcAmount per each order. source amount for order x.\n    ///@param dstAmount per each order. destination amount for order x.\n    ///@param hintPrevOrder per each order what is the order it should be added after in ordered list. 0 for no hint.\n    ///@param isAfterPrevOrder per each order, set true if should be added in list right after previous added order.\n    function addOrderBatch(bool[] isEthToToken, uint128[] srcAmount, uint128[] dstAmount,\n        uint32[] hintPrevOrder, bool[] isAfterPrevOrder)\n        public\n        returns(bool)\n    {\n        require(isEthToToken.length == hintPrevOrder.length);\n        require(isEthToToken.length == dstAmount.length);\n        require(isEthToToken.length == srcAmount.length);\n        require(isEthToToken.length == isAfterPrevOrder.length);\n\n        address maker = msg.sender;\n        uint32 prevId;\n        uint32 newId = 0;\n\n        for (uint i = 0; i \u003c isEthToToken.length; ++i) {\n            prevId = isAfterPrevOrder[i] ? newId : hintPrevOrder[i];\n            newId = fetchNewOrderId(isEthToToken[i] ? makerOrdersEthToToken[maker] : makerOrdersTokenToEth[maker]);\n            require(addOrder(isEthToToken[i], newId, srcAmount[i], dstAmount[i], prevId));\n        }\n\n        return true;\n    }\n\n    function updateTokenToEthOrder(uint32 orderId, uint128 newSrcAmount, uint128 newDstAmount)\n        public\n        returns(bool)\n    {\n        require(updateTokenToEthOrderWHint(orderId, newSrcAmount, newDstAmount, 0));\n        return true;\n    }\n\n    function updateTokenToEthOrderWHint(\n        uint32 orderId,\n        uint128 newSrcAmount,\n        uint128 newDstAmount,\n        uint32 hintPrevOrder\n    )\n        public\n        returns(bool)\n    {\n        require(updateOrder(false, orderId, newSrcAmount, newDstAmount, hintPrevOrder));\n        return true;\n    }\n\n    function updateEthToTokenOrder(uint32 orderId, uint128 newSrcAmount, uint128 newDstAmount)\n        public\n        returns(bool)\n    {\n        return updateEthToTokenOrderWHint(orderId, newSrcAmount, newDstAmount, 0);\n    }\n\n    function updateEthToTokenOrderWHint(\n        uint32 orderId,\n        uint128 newSrcAmount,\n        uint128 newDstAmount,\n        uint32 hintPrevOrder\n    )\n        public\n        returns(bool)\n    {\n        require(updateOrder(true, orderId, newSrcAmount, newDstAmount, hintPrevOrder));\n        return true;\n    }\n\n    function updateOrderBatch(bool[] isEthToToken, uint32[] orderId, uint128[] newSrcAmount,\n        uint128[] newDstAmount, uint32[] hintPrevOrder)\n        public\n        returns(bool)\n    {\n        require(isEthToToken.length == orderId.length);\n        require(isEthToToken.length == newSrcAmount.length);\n        require(isEthToToken.length == newDstAmount.length);\n        require(isEthToToken.length == hintPrevOrder.length);\n\n        for (uint i = 0; i \u003c isEthToToken.length; ++i) {\n            require(updateOrder(isEthToToken[i], orderId[i], newSrcAmount[i], newDstAmount[i],\n                hintPrevOrder[i]));\n        }\n\n        return true;\n    }\n\n    event TokenDeposited(address indexed maker, uint amount);\n\n    function depositToken(address maker, uint amount) public {\n        require(maker != address(0));\n        require(amount \u003c MAX_QTY);\n\n        require(contracts.token.transferFrom(msg.sender, this, amount));\n\n        makerFunds[maker][contracts.token] += amount;\n        TokenDeposited(maker, amount);\n    }\n\n    event EtherDeposited(address indexed maker, uint amount);\n\n    function depositEther(address maker) public payable {\n        require(maker != address(0));\n\n        makerFunds[maker][ETH_TOKEN_ADDRESS] += msg.value;\n        EtherDeposited(maker, msg.value);\n    }\n\n    event KncFeeDeposited(address indexed maker, uint amount);\n\n    // knc will be staked per order. part of the amount will be used as fee.\n    function depositKncForFee(address maker, uint amount) public {\n        require(maker != address(0));\n        require(amount \u003c MAX_QTY);\n\n        require(contracts.kncToken.transferFrom(msg.sender, this, amount));\n\n        makerKnc[maker] += amount;\n\n        KncFeeDeposited(maker, amount);\n\n        if (orderAllocationRequired(makerOrdersTokenToEth[maker])) {\n            require(allocateOrderIds(\n                makerOrdersTokenToEth[maker], /* makerOrders */\n                tokenToEthList.allocateIds(uint32(NUM_ORDERS)) /* firstAllocatedId */\n            ));\n        }\n\n        if (orderAllocationRequired(makerOrdersEthToToken[maker])) {\n            require(allocateOrderIds(\n                makerOrdersEthToToken[maker], /* makerOrders */\n                ethToTokenList.allocateIds(uint32(NUM_ORDERS)) /* firstAllocatedId */\n            ));\n        }\n    }\n\n    function withdrawToken(uint amount) public {\n\n        address maker = msg.sender;\n        uint makerFreeAmount = makerFunds[maker][contracts.token];\n\n        require(makerFreeAmount \u003e= amount);\n\n        makerFunds[maker][contracts.token] -= amount;\n\n        require(contracts.token.transfer(maker, amount));\n    }\n\n    function withdrawEther(uint amount) public {\n\n        address maker = msg.sender;\n        uint makerFreeAmount = makerFunds[maker][ETH_TOKEN_ADDRESS];\n\n        require(makerFreeAmount \u003e= amount);\n\n        makerFunds[maker][ETH_TOKEN_ADDRESS] -= amount;\n\n        maker.transfer(amount);\n    }\n\n    function withdrawKncFee(uint amount) public {\n\n        address maker = msg.sender;\n        \n        require(makerKnc[maker] \u003e= amount);\n        require(makerUnlockedKnc(maker) \u003e= amount);\n\n        makerKnc[maker] -= amount;\n\n        require(contracts.kncToken.transfer(maker, amount));\n    }\n\n    function cancelTokenToEthOrder(uint32 orderId) public returns(bool) {\n        require(cancelOrder(false, orderId));\n        return true;\n    }\n\n    function cancelEthToTokenOrder(uint32 orderId) public returns(bool) {\n        require(cancelOrder(true, orderId));\n        return true;\n    }\n\n    function setMinOrderSizeEth() public returns(bool) {\n        //get eth to $ from maker dao;\n        bytes32 usdPerEthInWei;\n        bool valid;\n        (usdPerEthInWei, valid) = contracts.medianizer.peek();\n        require(valid);\n\n        // ensuring that there is no underflow or overflow possible,\n        // even if the price is compromised\n        uint usdPerEth = uint(usdPerEthInWei) / (1 ether);\n        require(usdPerEth != 0);\n        require(usdPerEth \u003c MAX_USD_PER_ETH);\n\n        // set Eth order limits according to price\n        uint minNewOrderSizeWei = limits.minNewOrderSizeUsd * PRECISION * (1 ether) / uint(usdPerEthInWei);\n\n        limits.minNewOrderSizeWei = minNewOrderSizeWei;\n        limits.minOrderSizeWei = limits.minNewOrderSizeWei / MIN_REMAINING_ORDER_RATIO;\n\n        return true;\n    }\n\n    ///@dev Each maker stakes per order KNC that is factor of the required burn amount.\n    ///@dev If Knc per Eth rate becomes lower by more then factor, stake will not be enough and trade will be blocked.\n    function kncRateBlocksTrade() public view returns (bool) {\n        return (contracts.feeBurner.kncPerEthRatePrecision() \u003e kncPerEthBaseRatePrecision * BURN_TO_STAKE_FACTOR);\n    }\n\n    function getTokenToEthAddOrderHint(uint128 srcAmount, uint128 dstAmount) public view returns (uint32) {\n        require(dstAmount \u003e= limits.minNewOrderSizeWei);\n        return tokenToEthList.findPrevOrderId(srcAmount, dstAmount);\n    }\n\n    function getEthToTokenAddOrderHint(uint128 srcAmount, uint128 dstAmount) public view returns (uint32) {\n        require(srcAmount \u003e= limits.minNewOrderSizeWei);\n        return ethToTokenList.findPrevOrderId(srcAmount, dstAmount);\n    }\n\n    function getTokenToEthUpdateOrderHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\n        public\n        view\n        returns (uint32)\n    {\n        require(dstAmount \u003e= limits.minNewOrderSizeWei);\n        uint32 prevId = tokenToEthList.findPrevOrderId(srcAmount, dstAmount);\n        address add;\n        uint128 noUse;\n        uint32 next;\n\n        if (prevId == orderId) {\n            (add, noUse, noUse, prevId, next) = tokenToEthList.getOrderDetails(orderId);\n        }\n\n        return prevId;\n    }\n\n    function getEthToTokenUpdateOrderHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount)\n        public\n        view\n        returns (uint32)\n    {\n        require(srcAmount \u003e= limits.minNewOrderSizeWei);\n        uint32 prevId = ethToTokenList.findPrevOrderId(srcAmount, dstAmount);\n        address add;\n        uint128 noUse;\n        uint32 next;\n\n        if (prevId == orderId) {\n            (add, noUse, noUse, prevId, next) = ethToTokenList.getOrderDetails(orderId);\n        }\n\n        return prevId;\n    }\n\n    function getTokenToEthOrder(uint32 orderId)\n        public view\n        returns (\n            address _maker,\n            uint128 _srcAmount,\n            uint128 _dstAmount,\n            uint32 _prevId,\n            uint32 _nextId\n        )\n    {\n        return tokenToEthList.getOrderDetails(orderId);\n    }\n\n    function getEthToTokenOrder(uint32 orderId)\n        public view\n        returns (\n            address _maker,\n            uint128 _srcAmount,\n            uint128 _dstAmount,\n            uint32 _prevId,\n            uint32 _nextId\n        )\n    {\n        return ethToTokenList.getOrderDetails(orderId);\n    }\n\n    function makerRequiredKncStake(address maker) public view returns (uint) {\n        return(calcKncStake(makerTotalOrdersWei[maker]));\n    }\n\n    function makerUnlockedKnc(address maker) public view returns (uint) {\n        uint requiredKncStake = makerRequiredKncStake(maker);\n        if (requiredKncStake \u003e makerKnc[maker]) return 0;\n        return (makerKnc[maker] - requiredKncStake);\n    }\n\n    function calcKncStake(uint weiAmount) public view returns(uint) {\n        return(calcBurnAmount(weiAmount) * BURN_TO_STAKE_FACTOR);\n    }\n\n    function calcBurnAmount(uint weiAmount) public view returns(uint) {\n        return(weiAmount * makerBurnFeeBps * kncPerEthBaseRatePrecision / (10000 * PRECISION));\n    }\n\n    function calcBurnAmountFromFeeBurner(uint weiAmount) public view returns(uint) {\n        return(weiAmount * makerBurnFeeBps * contracts.feeBurner.kncPerEthRatePrecision() / (10000 * PRECISION));\n    }\n\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\n    function getEthToTokenMakerOrderIds(address maker) public view returns(uint32[] orderList) {\n        OrderIdData storage makerOrders = makerOrdersEthToToken[maker];\n        orderList = new uint32[](getNumActiveOrderIds(makerOrders));\n        uint activeOrder = 0;\n\n        for (uint32 i = 0; i \u003c NUM_ORDERS; ++i) {\n            if ((makerOrders.takenBitmap \u0026 (uint(1) \u003c\u003c i) \u003e 0)) orderList[activeOrder++] = makerOrders.firstOrderId + i;\n        }\n    }\n\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\n    function getTokenToEthMakerOrderIds(address maker) public view returns(uint32[] orderList) {\n        OrderIdData storage makerOrders = makerOrdersTokenToEth[maker];\n        orderList = new uint32[](getNumActiveOrderIds(makerOrders));\n        uint activeOrder = 0;\n\n        for (uint32 i = 0; i \u003c NUM_ORDERS; ++i) {\n            if ((makerOrders.takenBitmap \u0026 (uint(1) \u003c\u003c i) \u003e 0)) orderList[activeOrder++] = makerOrders.firstOrderId + i;\n        }\n    }\n\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\n    function getEthToTokenOrderList() public view returns(uint32[] orderList) {\n        OrderListInterface list = ethToTokenList;\n        return getList(list);\n    }\n\n    ///@dev This function is not fully optimized gas wise. Consider before calling on chain.\n    function getTokenToEthOrderList() public view returns(uint32[] orderList) {\n        OrderListInterface list = tokenToEthList;\n        return getList(list);\n    }\n\n    event NewLimitOrder(\n        address indexed maker,\n        uint32 orderId,\n        bool isEthToToken,\n        uint128 srcAmount,\n        uint128 dstAmount,\n        bool addedWithHint\n    );\n\n    function addOrder(bool isEthToToken, uint32 newId, uint128 srcAmount, uint128 dstAmount, uint32 hintPrevOrder)\n        internal\n        returns(bool)\n    {\n        require(srcAmount \u003c MAX_QTY);\n        require(dstAmount \u003c MAX_QTY);\n        address maker = msg.sender;\n\n        require(secureAddOrderFunds(maker, isEthToToken, srcAmount, dstAmount));\n        require(validateLegalRate(srcAmount, dstAmount, isEthToToken));\n\n        bool addedWithHint = false;\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\n\n        if (hintPrevOrder != 0) {\n            addedWithHint = list.addAfterId(maker, newId, srcAmount, dstAmount, hintPrevOrder);\n        }\n\n        if (!addedWithHint) {\n            require(list.add(maker, newId, srcAmount, dstAmount));\n        }\n\n        NewLimitOrder(maker, newId, isEthToToken, srcAmount, dstAmount, addedWithHint);\n\n        return true;\n    }\n\n    event OrderUpdated(\n        address indexed maker,\n        bool isEthToToken,\n        uint orderId,\n        uint128 srcAmount,\n        uint128 dstAmount,\n        bool updatedWithHint\n    );\n\n    function updateOrder(bool isEthToToken, uint32 orderId, uint128 newSrcAmount,\n        uint128 newDstAmount, uint32 hintPrevOrder)\n        internal\n        returns(bool)\n    {\n        require(newSrcAmount \u003c MAX_QTY);\n        require(newDstAmount \u003c MAX_QTY);\n        address maker;\n        uint128 currDstAmount;\n        uint128 currSrcAmount;\n        uint32 noUse;\n        uint noUse2;\n\n        require(validateLegalRate(newSrcAmount, newDstAmount, isEthToToken));\n\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\n\n        (maker, currSrcAmount, currDstAmount, noUse, noUse) = list.getOrderDetails(orderId);\n        require(maker == msg.sender);\n\n        if (!secureUpdateOrderFunds(maker, isEthToToken, currSrcAmount, currDstAmount, newSrcAmount, newDstAmount)) {\n            return false;\n        }\n\n        bool updatedWithHint = false;\n\n        if (hintPrevOrder != 0) {\n            (updatedWithHint, noUse2) = list.updateWithPositionHint(orderId, newSrcAmount, newDstAmount, hintPrevOrder);\n        }\n\n        if (!updatedWithHint) {\n            require(list.update(orderId, newSrcAmount, newDstAmount));\n        }\n\n        OrderUpdated(maker, isEthToToken, orderId, newSrcAmount, newDstAmount, updatedWithHint);\n\n        return true;\n    }\n\n    event OrderCanceled(address indexed maker, bool isEthToToken, uint32 orderId, uint128 srcAmount, uint dstAmount);\n\n    function cancelOrder(bool isEthToToken, uint32 orderId) internal returns(bool) {\n\n        address maker = msg.sender;\n        OrderListInterface list = isEthToToken ? ethToTokenList : tokenToEthList;\n        OrderData memory orderData = getOrderData(list, orderId);\n\n        require(orderData.maker == maker);\n\n        uint weiAmount = isEthToToken ? orderData.srcAmount : orderData.dstAmount;\n        require(releaseOrderStakes(maker, weiAmount, 0));\n\n        require(removeOrder(list, maker, isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token, orderId));\n\n        //funds go back to makers account\n        makerFunds[maker][isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token] += orderData.srcAmount;\n\n        OrderCanceled(maker, isEthToToken, orderId, orderData.srcAmount, orderData.dstAmount);\n\n        return true;\n    }\n\n    ///@param maker is the maker of this order\n    ///@param isEthToToken which order type the maker is updating / adding\n    ///@param srcAmount is the orders src amount (token or ETH) could be negative if funds are released.\n    function bindOrderFunds(address maker, bool isEthToToken, int srcAmount)\n        internal\n        returns(bool)\n    {\n        address fundsAddress = isEthToToken ? ETH_TOKEN_ADDRESS : contracts.token;\n\n        if (srcAmount \u003c 0) {\n            makerFunds[maker][fundsAddress] += uint(-srcAmount);\n        } else {\n            require(makerFunds[maker][fundsAddress] \u003e= uint(srcAmount));\n            makerFunds[maker][fundsAddress] -= uint(srcAmount);\n        }\n\n        return true;\n    }\n\n    ///@param maker is the maker address\n    ///@param weiAmount is the wei amount inside order that should result in knc staking\n    function bindOrderStakes(address maker, int weiAmount) internal returns(bool) {\n\n        if (weiAmount \u003c 0) {\n            uint decreaseWeiAmount = uint(-weiAmount);\n            if (decreaseWeiAmount \u003e makerTotalOrdersWei[maker]) decreaseWeiAmount = makerTotalOrdersWei[maker];\n            makerTotalOrdersWei[maker] -= decreaseWeiAmount;\n            return true;\n        }\n\n        require(makerKnc[maker] \u003e= calcKncStake(makerTotalOrdersWei[maker] + uint(weiAmount)));\n\n        makerTotalOrdersWei[maker] += uint(weiAmount);\n\n        return true;\n    }\n\n    ///@dev if totalWeiAmount is 0 we only release stakes.\n    ///@dev if totalWeiAmount == weiForBurn. all staked amount will be burned. so no knc returned to maker\n    ///@param maker is the maker address\n    ///@param totalWeiAmount is total wei amount that was released from order - including taken wei amount.\n    ///@param weiForBurn is the part in order wei amount that was taken and should result in burning.\n    function releaseOrderStakes(address maker, uint totalWeiAmount, uint weiForBurn) internal returns(bool) {\n\n        require(weiForBurn \u003c= totalWeiAmount);\n\n        if (totalWeiAmount \u003e makerTotalOrdersWei[maker]) {\n            makerTotalOrdersWei[maker] = 0;\n        } else {\n            makerTotalOrdersWei[maker] -= totalWeiAmount;\n        }\n\n        if (weiForBurn == 0) return true;\n\n        uint burnAmount = calcBurnAmountFromFeeBurner(weiForBurn);\n\n        require(makerKnc[maker] \u003e= burnAmount);\n        makerKnc[maker] -= burnAmount;\n\n        return true;\n    }\n\n    ///@dev funds are valid only when required knc amount can be staked for this order.\n    function secureAddOrderFunds(address maker, bool isEthToToken, uint128 srcAmount, uint128 dstAmount)\n        internal returns(bool)\n    {\n        uint weiAmount = isEthToToken ? srcAmount : dstAmount;\n\n        require(weiAmount \u003e= limits.minNewOrderSizeWei);\n        require(bindOrderFunds(maker, isEthToToken, int(srcAmount)));\n        require(bindOrderStakes(maker, int(weiAmount)));\n\n        return true;\n    }\n\n    ///@dev funds are valid only when required knc amount can be staked for this order.\n    function secureUpdateOrderFunds(address maker, bool isEthToToken, uint128 prevSrcAmount, uint128 prevDstAmount,\n        uint128 newSrcAmount, uint128 newDstAmount)\n        internal\n        returns(bool)\n    {\n        uint weiAmount = isEthToToken ? newSrcAmount : newDstAmount;\n        int weiDiff = isEthToToken ? (int(newSrcAmount) - int(prevSrcAmount)) :\n            (int(newDstAmount) - int(prevDstAmount));\n\n        require(weiAmount \u003e= limits.minNewOrderSizeWei);\n\n        require(bindOrderFunds(maker, isEthToToken, int(newSrcAmount) - int(prevSrcAmount)));\n\n        require(bindOrderStakes(maker, weiDiff));\n\n        return true;\n    }\n\n    event FullOrderTaken(address maker, uint32 orderId, bool isEthToToken);\n\n    function takeFullOrder(\n        address maker,\n        uint32 orderId,\n        ERC20 userSrc,\n        ERC20 userDst,\n        uint128 userSrcAmount,\n        uint128 userDstAmount\n    )\n        internal\n        returns (bool)\n    {\n        OrderListInterface list = (userSrc == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\n\n        //userDst == maker source\n        require(removeOrder(list, maker, userDst, orderId));\n\n        FullOrderTaken(maker, orderId, userSrc == ETH_TOKEN_ADDRESS);\n\n        return takeOrder(maker, userSrc, userSrcAmount, userDstAmount, 0);\n    }\n\n    event PartialOrderTaken(address maker, uint32 orderId, bool isEthToToken, bool isRemoved);\n\n    function takePartialOrder(\n        address maker,\n        uint32 orderId,\n        ERC20 userSrc,\n        ERC20 userDst,\n        uint128 userPartialSrcAmount,\n        uint128 userTakeDstAmount,\n        uint128 orderSrcAmount,\n        uint128 orderDstAmount\n    )\n        internal\n        returns(bool)\n    {\n        require(userPartialSrcAmount \u003c orderDstAmount);\n        require(userTakeDstAmount \u003c orderSrcAmount);\n\n        //must reuse parameters, otherwise stack too deep error.\n        orderSrcAmount -= userTakeDstAmount;\n        orderDstAmount -= userPartialSrcAmount;\n\n        OrderListInterface list = (userSrc == ETH_TOKEN_ADDRESS) ? tokenToEthList : ethToTokenList;\n        uint weiValueNotReleasedFromOrder = (userSrc == ETH_TOKEN_ADDRESS) ? orderDstAmount : orderSrcAmount;\n        uint additionalReleasedWei = 0;\n\n        if (weiValueNotReleasedFromOrder \u003c limits.minOrderSizeWei) {\n            // remaining order amount too small. remove order and add remaining funds to free funds\n            makerFunds[maker][userDst] += orderSrcAmount;\n            additionalReleasedWei = weiValueNotReleasedFromOrder;\n\n            //for remove order we give makerSrc == userDst\n            require(removeOrder(list, maker, userDst, orderId));\n        } else {\n            bool isSuccess;\n\n            // update order values, taken order is always first order\n            (isSuccess,) = list.updateWithPositionHint(orderId, orderSrcAmount, orderDstAmount, HEAD_ID);\n            require(isSuccess);\n        }\n\n        PartialOrderTaken(maker, orderId, userSrc == ETH_TOKEN_ADDRESS, additionalReleasedWei \u003e 0);\n\n        //stakes are returned for unused wei value\n        return(takeOrder(maker, userSrc, userPartialSrcAmount, userTakeDstAmount, additionalReleasedWei));\n    }\n    \n    function takeOrder(\n        address maker,\n        ERC20 userSrc,\n        uint userSrcAmount,\n        uint userDstAmount,\n        uint additionalReleasedWei\n    )\n        internal\n        returns(bool)\n    {\n        uint weiAmount = userSrc == (ETH_TOKEN_ADDRESS) ? userSrcAmount : userDstAmount;\n\n        //token / eth already collected. just update maker balance\n        makerFunds[maker][userSrc] += userSrcAmount;\n\n        // send dst tokens in one batch. not here\n        //handle knc stakes and fee. releasedWeiValue was released and not traded.\n        return releaseOrderStakes(maker, (weiAmount + additionalReleasedWei), weiAmount);\n    }\n\n    function removeOrder(\n        OrderListInterface list,\n        address maker,\n        ERC20 makerSrc,\n        uint32 orderId\n    )\n        internal returns(bool)\n    {\n        require(list.remove(orderId));\n        OrderIdData storage orders = (makerSrc == ETH_TOKEN_ADDRESS) ?\n            makerOrdersEthToToken[maker] : makerOrdersTokenToEth[maker];\n        require(releaseOrderId(orders, orderId));\n\n        return true;\n    }\n\n    function getList(OrderListInterface list) internal view returns(uint32[] memory orderList) {\n        OrderData memory orderData;\n        uint32 orderId;\n        bool isEmpty;\n\n        (orderId, isEmpty) = list.getFirstOrder();\n        if (isEmpty) return(new uint32[](0));\n\n        uint numOrders = 0;\n\n        for (; !orderData.isLastOrder; orderId = orderData.nextId) {\n            orderData = getOrderData(list, orderId);\n            numOrders++;\n        }\n\n        orderList = new uint32[](numOrders);\n\n        (orderId, orderData.isLastOrder) = list.getFirstOrder();\n\n        for (uint i = 0; i \u003c numOrders; i++) {\n            orderList[i] = orderId;\n            orderData = getOrderData(list, orderId);\n            orderId = orderData.nextId;\n        }\n    }\n\n    function getOrderData(OrderListInterface list, uint32 orderId) internal view returns (OrderData data) {\n        uint32 prevId;\n        (data.maker, data.srcAmount, data.dstAmount, prevId, data.nextId) = list.getOrderDetails(orderId);\n        data.isLastOrder = (data.nextId == TAIL_ID);\n    }\n\n    function validateLegalRate (uint srcAmount, uint dstAmount, bool isEthToToken)\n        internal view returns(bool)\n    {\n        uint rate;\n\n        /// notice, rate is calculated from taker perspective,\n        ///     for taker amounts are opposite. order srcAmount will be DstAmount for taker.\n        if (isEthToToken) {\n            rate = calcRateFromQty(dstAmount, srcAmount, getDecimals(contracts.token), ETH_DECIMALS);\n        } else {\n            rate = calcRateFromQty(dstAmount, srcAmount, ETH_DECIMALS, getDecimals(contracts.token));\n        }\n\n        if (rate \u003e MAX_RATE) return false;\n        return true;\n    }\n}\n"},"OrderbookReserveInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./OrderListFactoryInterface.sol\";\n\n\ninterface OrderbookReserveInterface {\n    function init() public returns(bool);\n    function kncRateBlocksTrade() public view returns(bool);\n}\n"},"OrderIdManager.sol":{"content":"pragma solidity 0.4.18;\n\n\ncontract OrderIdManager {\n    struct OrderIdData {\n        uint32 firstOrderId;\n        uint takenBitmap;\n    }\n\n    uint constant public NUM_ORDERS = 32;\n\n    function fetchNewOrderId(OrderIdData storage freeOrders)\n        internal\n        returns(uint32)\n    {\n        uint orderBitmap = freeOrders.takenBitmap;\n        uint bitPointer = 1;\n\n        for (uint i = 0; i \u003c NUM_ORDERS; ++i) {\n\n            if ((orderBitmap \u0026 bitPointer) == 0) {\n                freeOrders.takenBitmap = orderBitmap | bitPointer;\n                return(uint32(uint(freeOrders.firstOrderId) + i));\n            }\n\n            bitPointer *= 2;\n        }\n\n        revert();\n    }\n\n    /// @dev mark order as free to use.\n    function releaseOrderId(OrderIdData storage freeOrders, uint32 orderId)\n        internal\n        returns(bool)\n    {\n        require(orderId \u003e= freeOrders.firstOrderId);\n        require(orderId \u003c (freeOrders.firstOrderId + NUM_ORDERS));\n\n        uint orderBitNum = uint(orderId) - uint(freeOrders.firstOrderId);\n        uint bitPointer = uint(1) \u003c\u003c orderBitNum;\n\n        require(bitPointer \u0026 freeOrders.takenBitmap \u003e 0);\n\n        freeOrders.takenBitmap \u0026= ~bitPointer;\n        return true;\n    }\n\n    function allocateOrderIds(\n        OrderIdData storage makerOrders,\n        uint32 firstAllocatedId\n    )\n        internal\n        returns(bool)\n    {\n        if (makerOrders.firstOrderId \u003e 0) {\n            return false;\n        }\n\n        makerOrders.firstOrderId = firstAllocatedId;\n        makerOrders.takenBitmap = 0;\n\n        return true;\n    }\n\n    function orderAllocationRequired(OrderIdData storage freeOrders) internal view returns (bool) {\n\n        if (freeOrders.firstOrderId == 0) return true;\n        return false;\n    }\n\n    function getNumActiveOrderIds(OrderIdData storage makerOrders) internal view returns (uint numActiveOrders) {\n        for (uint i = 0; i \u003c NUM_ORDERS; ++i) {\n            if ((makerOrders.takenBitmap \u0026 (uint(1) \u003c\u003c i)) \u003e 0) numActiveOrders++;\n        }\n    }\n}\n"},"OrderListFactoryInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./OrderListInterface.sol\";\n\n\ninterface OrderListFactoryInterface {\n    function newOrdersContract(address admin) public returns(OrderListInterface);\n}\n"},"OrderListInterface.sol":{"content":"pragma solidity 0.4.18;\n\n\ninterface OrderListInterface {\n    function getOrderDetails(uint32 orderId) public view returns (address, uint128, uint128, uint32, uint32);\n    function add(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\n    function remove(uint32 orderId) public returns (bool);\n    function update(uint32 orderId, uint128 srcAmount, uint128 dstAmount) public returns (bool);\n    function getFirstOrder() public view returns(uint32 orderId, bool isEmpty);\n    function allocateIds(uint32 howMany) public returns(uint32);\n    function findPrevOrderId(uint128 srcAmount, uint128 dstAmount) public view returns(uint32);\n\n    function addAfterId(address maker, uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\n        returns (bool);\n\n    function updateWithPositionHint(uint32 orderId, uint128 srcAmount, uint128 dstAmount, uint32 prevId) public\n        returns(bool, uint);\n}\n"},"PermissionlessOrderbookReserveLister.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./OrderbookReserve.sol\";\nimport \"../../../FeeBurnerInterface.sol\";\n\n\ncontract InternalNetworkInterface {\n    function addReserve(\n        KyberReserveInterface reserve,\n        bool isPermissionless\n    )\n        public\n        returns(bool);\n\n    function removeReserve(\n        KyberReserveInterface reserve,\n        uint index\n    )\n        public\n        returns(bool);\n\n    function listPairForReserve(\n        address reserve,\n        ERC20 token,\n        bool ethToToken,\n        bool tokenToEth,\n        bool add\n    )\n        public\n        returns(bool);\n\n    FeeBurnerInterface public feeBurnerContract;\n}\n\n\ncontract PermissionlessOrderbookReserveLister {\n    // KNC burn fee per wei value of an order. 25 in BPS = 0.25%.\n    uint constant public ORDERBOOK_BURN_FEE_BPS = 25;\n\n    uint public minNewOrderValueUsd = 1000; // set in order book minimum USD value of a new limit order\n    uint public maxOrdersPerTrade;          // set in order book maximum orders to be traversed in rate query and trade\n\n    InternalNetworkInterface public kyberNetworkContract;\n    OrderListFactoryInterface public orderFactoryContract;\n    MedianizerInterface public medianizerContract;\n    ERC20 public kncToken;\n\n    enum ListingStage {NO_RESERVE, RESERVE_ADDED, RESERVE_INIT, RESERVE_LISTED}\n\n    mapping(address =\u003e OrderbookReserveInterface) public reserves; //Permissionless orderbook reserves mapped per token\n    mapping(address =\u003e ListingStage) public reserveListingStage;   //Reserves listing stage\n    mapping(address =\u003e bool) tokenListingBlocked;\n\n    function PermissionlessOrderbookReserveLister(\n        InternalNetworkInterface kyber,\n        OrderListFactoryInterface factory,\n        MedianizerInterface medianizer,\n        ERC20 knc,\n        address[] unsupportedTokens,\n        uint maxOrders,\n        uint minOrderValueUsd\n    )\n        public\n    {\n        require(kyber != address(0));\n        require(factory != address(0));\n        require(medianizer != address(0));\n        require(knc != address(0));\n        require(maxOrders \u003e 1);\n        require(minOrderValueUsd \u003e 0);\n\n        kyberNetworkContract = kyber;\n        orderFactoryContract = factory;\n        medianizerContract = medianizer;\n        kncToken = knc;\n        maxOrdersPerTrade = maxOrders;\n        minNewOrderValueUsd = minOrderValueUsd;\n\n        for (uint i = 0; i \u003c unsupportedTokens.length; i++) {\n            require(unsupportedTokens[i] != address(0));\n            tokenListingBlocked[unsupportedTokens[i]] = true;\n        }\n    }\n\n    event TokenOrderbookListingStage(ERC20 token, ListingStage stage);\n\n    /// @dev anyone can call\n    function addOrderbookContract(ERC20 token) public returns(bool) {\n        require(reserveListingStage[token] == ListingStage.NO_RESERVE);\n        require(!(tokenListingBlocked[token]));\n\n        reserves[token] = new OrderbookReserve({\n            knc: kncToken,\n            reserveToken: token,\n            burner: kyberNetworkContract.feeBurnerContract(),\n            network: kyberNetworkContract,\n            medianizer: medianizerContract,\n            factory: orderFactoryContract,\n            minNewOrderUsd: minNewOrderValueUsd,\n            maxOrdersPerTrade: maxOrdersPerTrade,\n            burnFeeBps: ORDERBOOK_BURN_FEE_BPS\n        });\n\n        reserveListingStage[token] = ListingStage.RESERVE_ADDED;\n\n        TokenOrderbookListingStage(token, ListingStage.RESERVE_ADDED);\n        return true;\n    }\n\n    /// @dev anyone can call\n    function initOrderbookContract(ERC20 token) public returns(bool) {\n        require(reserveListingStage[token] == ListingStage.RESERVE_ADDED);\n        require(reserves[token].init());\n\n        reserveListingStage[token] = ListingStage.RESERVE_INIT;\n        TokenOrderbookListingStage(token, ListingStage.RESERVE_INIT);\n        return true;\n    }\n\n    /// @dev anyone can call\n    function listOrderbookContract(ERC20 token) public returns(bool) {\n        require(reserveListingStage[token] == ListingStage.RESERVE_INIT);\n\n        require(\n            kyberNetworkContract.addReserve(\n                KyberReserveInterface(reserves[token]),\n                true\n            )\n        );\n\n        require(\n            kyberNetworkContract.listPairForReserve(\n                KyberReserveInterface(reserves[token]),\n                token,\n                true,\n                true,\n                true\n            )\n        );\n\n        FeeBurnerInterface feeBurner = FeeBurnerInterface(kyberNetworkContract.feeBurnerContract());\n\n        feeBurner.setReserveData(\n            reserves[token], /* reserve */\n            ORDERBOOK_BURN_FEE_BPS, /* fee */\n            reserves[token] /* kncWallet */\n        );\n\n        reserveListingStage[token] = ListingStage.RESERVE_LISTED;\n        TokenOrderbookListingStage(token, ListingStage.RESERVE_LISTED);\n        return true;\n    }\n\n    function unlistOrderbookContract(ERC20 token, uint hintReserveIndex) public {\n        require(reserveListingStage[token] == ListingStage.RESERVE_LISTED);\n        require(reserves[token].kncRateBlocksTrade());\n        require(kyberNetworkContract.removeReserve(KyberReserveInterface(reserves[token]), hintReserveIndex));\n        reserveListingStage[token] = ListingStage.NO_RESERVE;\n        reserves[token] = OrderbookReserveInterface(0);\n        TokenOrderbookListingStage(token, ListingStage.NO_RESERVE);\n    }\n\n    /// @dev permission less reserve currently supports one token per reserve.\n    function getOrderbookListingStage(ERC20 token)\n        public\n        view\n        returns(address, ListingStage)\n    {\n        return (reserves[token], reserveListingStage[token]);\n    }\n}\n"},"Utils.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./ERC20Interface.sol\";\n\n\n/// @title Kyber constants contract\ncontract Utils {\n\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n    uint  constant internal PRECISION = (10**18);\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\n    uint  constant internal MAX_DECIMALS = 18;\n    uint  constant internal ETH_DECIMALS = 18;\n    mapping(address=\u003euint) internal decimals;\n\n    function setDecimals(ERC20 token) internal {\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\n        else decimals[token] = token.decimals();\n    }\n\n    function getDecimals(ERC20 token) internal view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\n        uint tokenDecimals = decimals[token];\n        // technically, there might be token with decimals 0\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        if(tokenDecimals == 0) return token.decimals();\n\n        return tokenDecimals;\n    }\n\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(srcQty \u003c= MAX_QTY);\n        require(rate \u003c= MAX_RATE);\n\n        if (dstDecimals \u003e= srcDecimals) {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\n        require(dstQty \u003c= MAX_QTY);\n        require(rate \u003c= MAX_RATE);\n        \n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint numerator;\n        uint denominator;\n        if (srcDecimals \u003e= dstDecimals) {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n}\n"},"Utils2.sol":{"content":"pragma solidity 0.4.18;\n\n\nimport \"./Utils.sol\";\n\n\ncontract Utils2 is Utils {\n\n    /// @dev get the balance of a user.\n    /// @param token The token type\n    /// @return The balance\n    function getBalance(ERC20 token, address user) public view returns(uint) {\n        if (token == ETH_TOKEN_ADDRESS)\n            return user.balance;\n        else\n            return token.balanceOf(user);\n    }\n\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\n\n        if (decimals[token] == 0) {\n            setDecimals(token);\n        }\n\n        return decimals[token];\n    }\n\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\n        internal pure returns(uint)\n    {\n        require(srcAmount \u003c= MAX_QTY);\n        require(destAmount \u003c= MAX_QTY);\n\n        if (dstDecimals \u003e= srcDecimals) {\n            require((dstDecimals - srcDecimals) \u003c= MAX_DECIMALS);\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\n        } else {\n            require((srcDecimals - dstDecimals) \u003c= MAX_DECIMALS);\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\n        }\n    }\n}\n"}}