{"ConsensusUSD.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./IERC20.sol\";\nimport \"./IConsensusUSD.sol\";\n\n\ncontract ConsensusUSD is ERC20, IConsensusUSD {\n\nfallback() external payable {\nrevert();\n}\n\nreceive() external payable {\nrevert();\n}\n\nstring public name;\nuint8 public decimals;\nstring public symbol;\nstring public version = \u0027H1.0\u0027;\n\nmapping (address =\u003e uint256) validStablecoins;\nmapping (address =\u003e mapping (address =\u003e uint256)) lockedAssets;\n\nusing SafeMath for uint256;\n\n\nconstructor() public {\ndecimals = 18;\ntotalSupply = 0;\nname = \"Consensus USD\";\nsymbol = \"XUSD\";\n\nvalidStablecoins[0x6B175474E89094C44Da98b954EedeAC495271d0F] = 1; // DAI  (MC DAI       )\nvalidStablecoins[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 1; // USDT (ERC20 Tether )\nvalidStablecoins[0x4Fabb145d64652a948d72533023f6E7A623C7C53] = 1; // BUSD (Binance USD  )\nvalidStablecoins[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = 1; // USDC (USD Coin     )\nvalidStablecoins[0x0000000000085d4780B73119b644AE5ecd22b376] = 1; // tUSD (TrueUSD      )\n\n}\n\n\nfunction isValidAsset(address _asset) external view override returns (bool isValid) {\nreturn validStablecoins[_asset] == 1;\n}\n\nfunction assetLockedOf(address _owner, address _asset) external view override returns (uint256 asset) {\nreturn lockedAssets[_owner][_asset];\n}\n\n\nfunction mint(uint256 _amount, address _assetUsed) public override returns (bool success) {\n\nassert(validStablecoins[_assetUsed] == 1 );\nrequire(IERC20(_assetUsed).transferFrom(msg.sender, address(this), _amount));\n\nlockedAssets[msg.sender][_assetUsed] = lockedAssets[msg.sender][_assetUsed].add(_amount);\n\ntotalSupply          = totalSupply          .add(_amount);\nbalances[msg.sender] = balances[msg.sender] .add(_amount);\n\nemit Mint(msg.sender, _amount);\n\nreturn true;\n}\n\nfunction retrieve(uint256 _amount, address _assetRetrieved) public override returns (bool success) {\n\nassert(validStablecoins[_assetRetrieved] == 1 );\n\nassert( balances[msg.sender]                               .sub(_amount) \u003e= 0 );\nassert( lockedAssets[msg.sender][_assetRetrieved] .sub(_amount) \u003e= 0 );\n\nbalances[msg.sender] = balances[msg.sender] .sub(_amount);\ntotalSupply          = totalSupply          .sub(_amount);\n\nrequire(IERC20(_assetRetrieved).transfer(msg.sender, _amount));\nlockedAssets[msg.sender][_assetRetrieved] = lockedAssets[msg.sender][_assetRetrieved].sub(_amount);\n\nemit Burn(msg.sender, _amount);\n\nreturn true;\n}\n\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n\ncontract ERC20 is IERC20 {\n\nuint256 public override totalSupply;\nmapping (address =\u003e uint256) balances;\nmapping (address =\u003e mapping (address =\u003e uint256)) allowed;\nusing SafeMath for uint256;\n\n\nfunction transfer(address _to, uint256 _value) public override returns (bool success) {\nif (balances[msg.sender] \u003e= _value \u0026\u0026 balances[_to].add(_value) \u003e balances[_to]) {\n\nbalances[msg.sender] = balances[msg.sender] .sub(_value);\nbalances[_to]        = balances[_to]        .add(_value);\n\nemit Transfer(msg.sender, _to, _value);\n\nreturn true;\n} else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\nif (balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e= _value \u0026\u0026 balances[_to].add(_value) \u003e balances[_to]) {\n\nbalances[_to]              = balances[_to]              .add(_value);\nbalances[_from]            = balances[_from]            .sub(_value);\nallowed[_from][msg.sender] = allowed[_from][msg.sender] .sub(_value);\n\nemit Transfer(_from, _to, _value);\n\nreturn true;\n} else { return false; }\n}\n\n\nfunction balanceOf(address _owner) external view override returns (uint256 balance) {\nreturn balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) public override returns (bool success) {\n\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\n\nreturn true;\n}\n\nfunction allowance(address _owner, address _spender) external view override returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\n\n}\n"},"IConsensusUSD.sol":{"content":"pragma solidity ^0.6.0;\n\n\n\ninterface IConsensusUSD {\n\n    /// @param _amount The amount of consensus dollar tokens to mint\n    /// @param _assetUsed The token address of asset used to mint consensus dollar tokens\n    /// @return success indicating if minting was successful\n    function mint(uint256 _amount, address _assetUsed) external returns (bool success);\n\n    /// @param _amount The amount of asset to retrieve from contract, equals the amount of tokens burnt\n    /// @param _assetRetrieved The token address of asset which is going to be retrieved\n    /// @return success indicating if retrieval was successful\n    function retrieve(uint256 _amount,  address _assetRetrieved) external returns (bool success);\n\n    /// @param _asset Token address of asset\n    /// @return success indicating if token address is valid asset or not\n    function isValidAsset(address _asset) external view returns (bool success);\n\n    /// @param _owner Address of which to consult locked asset balance\n    /// @param _asset Token address of asset\n    /// @return asset uint256 amount of specified asset locked by _owner\n    function assetLockedOf(address _owner, address _asset) external view returns (uint256 asset);\n\n    event Mint(address indexed _minter, uint256 _value);\n    event Burn(address indexed _burner, uint256 _value);\n\n}\n"},"IERC20.sol":{"content":"pragma solidity ^0.6.0;\n\n\n\ninterface IERC20 {\n\n    /// @return total amount of tokens\n    function totalSupply() external view returns (uint256);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance of address _owner\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}