{"IERC20.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IERC721.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface IERC721 {\n    function ownerOf(uint256 _tokenId) external view returns (address);\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}"},"IERC721Receiver.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}"},"IMVDProxy.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface IMVDProxy {\n\n    function init(address votingTokenAddress, address functionalityProposalManagerAddress, address stateHolderAddress, address functionalityModelsManagerAddress, address functionalitiesManagerAddress, address walletAddress) external;\n\n    function getDelegates() external view returns(address,address,address,address,address,address);\n    function getToken() external view returns(address);\n    function getMVDFunctionalityProposalManagerAddress() external view returns(address);\n    function getStateHolderAddress() external view returns(address);\n    function getMVDFunctionalityModelsManagerAddress() external view returns(address);\n    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n    function getMVDWalletAddress() external view returns(address);\n    function setDelegate(uint256 position, address newAddress) external returns(address oldAddress);\n    function changeProxy(address newAddress, bytes calldata initPayload) external;\n    function isValidProposal(address proposal) external view returns (bool);\n    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n    function newProposal(string calldata codeName, bool emergency, address sourceLocation, uint256 sourceLocationId, address location, bool submitable, string calldata methodSignature, string calldata returnParametersJSONArray, bool isInternal, bool needsSender, string calldata replaces) external returns(address proposalAddress);\n    function startProposal(address proposalAddress) external;\n    function disableProposal(address proposalAddress) external;\n    function transfer(address receiver, uint256 value, address token) external;\n    function transfer721(address receiver, uint256 tokenId, bytes calldata data, bool safe, address token) external;\n    function setProposal() external;\n    function read(string calldata codeName, bytes calldata data) external view returns(bytes memory returnData);\n    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\n    function callFromManager(address location, bytes calldata payload) external returns(bool, bytes memory);\n    function emitFromManager(string calldata codeName, address proposal, string calldata replaced, address replacedSourceLocation, uint256 replacedSourceLocationId, address location, bool submitable, string calldata methodSignature, bool isInternal, bool needsSender, address proposalAddress) external;\n\n    function emitEvent(string calldata eventSignature, bytes calldata firstIndex, bytes calldata secondIndex, bytes calldata data) external;\n\n    event ProxyChanged(address indexed newAddress);\n    event DelegateChanged(uint256 position, address indexed oldAddress, address indexed newAddress);\n\n    event Proposal(address proposal);\n    event ProposalCheck(address indexed proposal);\n    event ProposalSet(address indexed proposal, bool success);\n    event FunctionalitySet(string codeName, address indexed proposal, string replaced, address replacedSourceLocation, uint256 replacedSourceLocationId, address indexed replacedLocation, bool replacedWasSubmitable, string replacedMethodSignature, bool replacedWasInternal, bool replacedNeededSender, address indexed replacedProposal);\n\n    event Event(string indexed key, bytes32 indexed firstIndex, bytes32 indexed secondIndex, bytes data);\n}"},"IMVDWallet.sol":{"content":"pragma solidity ^0.6.0;\n\ninterface IMVDWallet {\n\n    function getProxy() external view returns (address);\n\n    function setProxy() external;\n\n    function setNewWallet(address payable newWallet, address tokenAddress) external;\n\n    function transfer(address receiver, uint256 value, address tokenAddress) external;\n    \n    function transfer(address receiver, uint256 tokenId, bytes calldata data, bool safe, address token) external;\n\n    function flushToNewWallet(address token) external;\n\n    function flush721ToNewWallet(uint256 tokenId, bytes calldata data, bool safe, address tokenAddress) external;\n}"},"MVDWallet.sol":{"content":"pragma solidity ^0.6.0;\n\nimport \"./IMVDWallet.sol\";\nimport \"./IMVDProxy.sol\";\nimport \"./IERC20.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\n\ncontract MVDWallet is IMVDWallet, IERC721Receiver {\n\n    address private _proxy;\n    address payable private _newWallet;\n\n    function setNewWallet(address payable newWallet, address tokenAddress) public override {\n        require(msg.sender == _proxy, \"Unauthorized Access!\");\n        _newWallet = newWallet;\n        _newWallet.transfer(address(this).balance);\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(_newWallet, token.balanceOf(address(this)));\n    }\n\n    function flushToNewWallet(address tokenAddress) public override {\n        require(_newWallet != address(0), \"Unauthorized Access!\");\n        if(tokenAddress == address(0)) {\n            payable(_newWallet).transfer(address(this).balance);\n            return;\n        }\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(_newWallet, token.balanceOf(address(this)));\n    }\n\n    function flush721ToNewWallet(uint256 tokenId, bytes memory data, bool safe, address tokenAddress) public override {\n        require(_newWallet != address(0), \"Unauthorized Access!\");\n        _transfer(_newWallet, tokenId, data, safe, tokenAddress);\n    }\n\n    function transfer(address receiver, uint256 value, address token) public override {\n        require(msg.sender == _proxy, \"Unauthorized Access!\");\n        if(value == 0) {\n            return;\n        }\n        if(token == address(0)) {\n            payable(receiver).transfer(value);\n            return;\n        }\n        IERC20(token).transfer(receiver, value);\n    }\n\n    function transfer(address receiver, uint256 tokenId, bytes memory data, bool safe, address token) public override {\n        require(msg.sender == _proxy, \"Unauthorized Access!\");\n        _transfer(receiver, tokenId, data, safe, token);\n    }\n\n    function _transfer(address receiver, uint256 tokenId, bytes memory data, bool safe, address token) private {\n        if(safe) {\n            IERC721(token).safeTransferFrom(address(this), receiver, tokenId, data);\n        } else {\n            IERC721(token).transferFrom(address(this), receiver, tokenId);\n        }\n    }\n\n    receive() external payable {\n        if(_newWallet != address(0)) {\n            _newWallet.transfer(address(this).balance);\n        }\n    }\n\n    function getProxy() public override view returns(address) {\n        return _proxy;\n    }\n\n    function setProxy() public override {\n        require(_proxy == address(0) || _proxy == msg.sender, _proxy != address(0) ? \"Proxy already set!\" : \"Only Proxy can toggle itself!\");\n        _proxy = _proxy == address(0) ?  msg.sender : address(0);\n    }\n\n    function onERC721Received(address, address, uint256 tokenId, bytes memory data) public override returns (bytes4) {\n        if(_newWallet != address(0)) {\n            _transfer(_newWallet, tokenId, data, true, msg.sender);\n        }\n        return 0x150b7a02;\n    }\n}"}}