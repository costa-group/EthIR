{"contract.sol":{"content":"pragma solidity 0.5.14;\nimport \"./DappToken.sol\";\ncontract XProtocal {\n    using SafeMath for uint256;\n    struct UserStruct {\n        uint id;\n        uint orignalRefID;\n        uint referrerID;\n        uint currentLevel;\n        uint totalEarningEth;\n        address[] referral;\n    }\n    struct LevelStruct {\n        uint ethValue;\n        uint tokenValue;\n        uint tokenOrignalValue;\n    }\n    address public ownerAddress;\n    uint public adminFee = 15 ether;\n    uint public currentId = 0;\n    uint referrer1Limit = 2;\n    bool public lockStatus;\n    bytes32 private secretPhase;\n    XProtocalToken Token;\n    mapping (uint =\u003e LevelStruct) public LEVEL_PRICE;\n    mapping (address =\u003e UserStruct) public users;\n    mapping (uint =\u003e address) public userList;\n    mapping (address =\u003e mapping (uint =\u003e uint)) public EarnedEth;\n    mapping (address =\u003e uint) public loopCheck;\n    mapping (address =\u003e uint) public createdDate;\n    event regLevelEvent(address indexed UserAddress, uint indexed UserId, uint Time);\n    event buyLevelEvent(address indexed UserAddress, uint Levelno, uint Time);\n    event getMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint orignalRefID, uint Time);\n    event lostMoneyForLevelEvent(address indexed UserAddress, uint UserId, address indexed ReferrerAddress, uint ReferrerId, uint Levelno, uint LevelPrice, uint Time);    \n    constructor(XProtocalToken _tokkenAddress, bytes32 _secretPhase) public {\n        ownerAddress = msg.sender;\n        secretPhase = _secretPhase;\n        Token = _tokkenAddress;\n        LEVEL_PRICE[1] = LevelStruct({\n            ethValue: 0.1 ether,\n            tokenOrignalValue: 2,\n            tokenValue: 10\n        });\n        LEVEL_PRICE[2] = LevelStruct({\n            ethValue: 0.15 ether,\n            tokenOrignalValue: 3,\n            tokenValue: 15\n        });\n        LEVEL_PRICE[3] = LevelStruct({\n            ethValue: 0.5 ether,\n            tokenOrignalValue: 10,\n            tokenValue: 50\n        });\n        LEVEL_PRICE[4] = LevelStruct({\n            ethValue: 3 ether,\n            tokenOrignalValue: 120,\n            tokenValue: 600\n        });\n        LEVEL_PRICE[5] = LevelStruct({\n            ethValue: 5 ether,\n            tokenOrignalValue: 200,\n            tokenValue: 1000\n        });\n        LEVEL_PRICE[6] = LevelStruct({\n            ethValue: 10 ether,\n            tokenOrignalValue: 400,\n            tokenValue: 2000\n        });\n        LEVEL_PRICE[7] = LevelStruct({\n            ethValue: 22 ether,\n            tokenOrignalValue: 1320,\n            tokenValue: 6600\n        });\n        LEVEL_PRICE[8] = LevelStruct({\n            ethValue: 28 ether,\n            tokenOrignalValue: 1680,\n            tokenValue: 8400\n        });\n        LEVEL_PRICE[9] = LevelStruct({\n            ethValue: 36 ether,\n            tokenOrignalValue: 2160,\n            tokenValue: 10800\n        });\n        UserStruct memory userStruct;\n        currentId = currentId.add(1);\n        userStruct = UserStruct({\n            id: currentId,\n            orignalRefID: 1,\n            referrerID: 0,\n            currentLevel:1,\n            totalEarningEth:0,\n            referral: new address[](0)\n        });\n        users[ownerAddress] = userStruct;\n        userList[currentId] = ownerAddress;\n        users[ownerAddress].currentLevel = 9;\n    } \n    modifier onlyOwner() {\n        require(msg.sender == ownerAddress, \"Only owner\");\n        _;\n    }\n    function regUser(uint _referrerID, uint _orignalRef) external payable {\n        require(lockStatus == false, \"Contract Locked\");\n        require(users[msg.sender].id == 0, \"User exist\");\n        require(_referrerID \u003c= currentId, \"Incorrect parentID Id\");\n        require(_orignalRef \u003c= currentId, \"Incorrect referrer Id\");\n        require(msg.value == LEVEL_PRICE[1].ethValue, \"Incorrect Value\");\n        require(users[userList[_referrerID]].referral.length  \u003c referrer1Limit, \"User already have 2 childs\");\n        UserStruct memory userStruct;\n        currentId = currentId.add(1);\n        userStruct = UserStruct({\n            id: currentId,\n            referrerID: _referrerID,\n            currentLevel: 1,\n            orignalRefID: _orignalRef,\n            totalEarningEth:0,\n            referral: new address[](0)\n        });\n        users[msg.sender] = userStruct;\n        userList[currentId] = msg.sender;\n        users[userList[_referrerID]].referral.push(msg.sender);\n        loopCheck[msg.sender] = 0;\n        createdDate[msg.sender] = now;\n        loopCheck[msg.sender] = 0;\n        payForLevel(true, 1, msg.sender, ((LEVEL_PRICE[1].ethValue.mul(adminFee)).div(10**20)));\n        emit regLevelEvent(msg.sender, currentId, now);\n        Token.mint(msg.sender, LEVEL_PRICE[1].tokenValue, secretPhase);\n        Token.mint(userList[_orignalRef], LEVEL_PRICE[1].tokenOrignalValue, secretPhase);\n    }\n    function buyLevel(uint256 _level) external payable {\n        require(lockStatus == false, \"Contract Locked\");\n        require(users[msg.sender].id != 0, \"User not exist\"); \n        require(_level \u003e 0 \u0026\u0026 _level \u003c= 9, \"Incorrect level\");\n        require(msg.value == LEVEL_PRICE[_level].ethValue, \"Incorrect Value\");\n        if (_level == 1) {\n            users[msg.sender].currentLevel = 1;\n        } else {\n            if(users[msg.sender].currentLevel + 1 != _level) {\n                require(users[msg.sender].currentLevel + 1 == _level, \"Buy the previous level\");\n            }\n            users[msg.sender].currentLevel = _level;\n        }\n        loopCheck[msg.sender] = 0;\n        payForLevel(true, _level, msg.sender, ((LEVEL_PRICE[_level].ethValue.mul(adminFee)).div(10**20)));\n        emit buyLevelEvent(msg.sender, _level, now);\n        Token.mint(msg.sender, LEVEL_PRICE[_level].tokenValue, secretPhase);\n        Token.mint(userList[users[msg.sender].orignalRefID], LEVEL_PRICE[_level].tokenOrignalValue, secretPhase);\n    }\n    function payForLevel(bool _isNew, uint _level, address _userAddress, uint _adminPrice) internal {\n            address referer;\n            if(_isNew) {\n                if (_level == 1 || _level == 4 || _level == 7) {\n                    referer = userList[users[_userAddress].referrerID];\n                } else if (_level == 2 || _level == 5 || _level == 8) {\n                    referer = userList[users[_userAddress].referrerID];\n                    referer = userList[users[referer].referrerID];\n                } else if (_level == 3 || _level == 6 || _level == 9) {\n                    referer = userList[users[_userAddress].referrerID];\n                    referer = userList[users[referer].referrerID];\n                    referer = userList[users[referer].referrerID];\n                }\n            } else {\n                referer = userList[users[_userAddress].referrerID];\n            }\n            if (loopCheck[msg.sender] \u003e= 9) {\n                referer = userList[1];\n            }\n            if (users[referer].currentLevel \u003e= _level) {\n                require((address(uint160(referer)).send(LEVEL_PRICE[_level].ethValue.sub(_adminPrice))) \u0026\u0026 \n                    (address(uint160(ownerAddress)).send(_adminPrice)));\n                users[referer].totalEarningEth = users[referer].totalEarningEth.add(LEVEL_PRICE[_level].ethValue);\n                EarnedEth[referer][_level] = EarnedEth[referer][_level].add(LEVEL_PRICE[_level].ethValue);\n                emit getMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, users[msg.sender].orignalRefID, now);\n        } else {\n            if (loopCheck[msg.sender] \u003c 9) {\n                loopCheck[msg.sender] = loopCheck[msg.sender].add(1);\n                emit lostMoneyForLevelEvent(msg.sender, users[msg.sender].id, referer, users[referer].id, _level, LEVEL_PRICE[_level].ethValue ,now);\n                payForLevel(false, _level, referer, _adminPrice);\n            }\n        }\n    }\n    function viewUserReferral(address _userAddress) external view returns (address[] memory) {\n        return users[_userAddress].referral;\n    }\n    function contractLock(bool _lockStatus) public onlyOwner returns (bool) {\n        lockStatus = _lockStatus;\n        return true;\n    }\n    function updateFeePercentage(uint256 _adminFee) public onlyOwner returns (bool) {\n        adminFee = _adminFee.mul(10**18);\n        return true;  \n    }\n    function failSafe(address payable _toUser, uint _amount) public onlyOwner returns (bool) {\n        require(_toUser != address(0), \"Invalid Address\");\n        require(address(this).balance \u003e= _amount, \"Insufficient balance\");\n        (_toUser).transfer(_amount);\n        return true;\n    }\n    function () external payable {\n        revert(\"Invalid Transaction\");\n    }\n}"},"DappToken.sol":{"content":"pragma solidity ^0.5.14;\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n}\ncontract ERC20 {\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    function transfer(address to, uint256 value) public returns(bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract XProtocalToken is ERC20 {\n    using SafeMath for uint256;\n    string  public constant name = \"X Protocal\";\n    string  public constant symbol = \"XPT\";\n    uint256 public totalSupply;\n    address public owner;\n    address private contractAddress;\n    bytes32 private secretPhase;\n    bool public isEnabled = false;\n    uint public sellEndTime = now + 426 days;\n    mapping(address =\u003e uint256) public balanceOf;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n    mapping (address =\u003e bool) public frozenAccount;\n    event FrozenFunds(address target, bool frozen);\n    constructor (bytes32 _secretPhase) public {\n        owner = msg.sender;\n        secretPhase = _secretPhase;\n    }\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n    modifier onlyContract() {\n        require(msg.sender == contractAddress, \"Only contract\");\n        _;\n    }\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] \u003e= _value, \"not enough balance\");\n        require (isEnabled, \"cannot send token at this point\");                   // Check if sender is frozen\n        require(!frozenAccount[_to]); \n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    function mint(address _to, uint256 _value, bytes32 _secretPhase) public onlyContract returns (bool success) {\n        require(secretPhase == _secretPhase, \"sorry wrong secrat\");\n        if (sellEndTime \u003c= now) {\n            return false;\n        }\n        totalSupply += _value;\n        balanceOf[_to] += _value;\n        return true;\n    }\n    function setContractAddress(address _contractAddress) public onlyOwner {\n        contractAddress = _contractAddress;\n    }\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value \u003c= balanceOf[_from], \"from error\");\n        require(_value \u003c= allowance[_from][msg.sender], \"allowance\");\n        require (isEnabled, \"cannot send token at this point\");\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n        require(!frozenAccount[_to]); \n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n    function changeowner(address _newOwner) public onlyOwner returns(bool) {\n        require(_newOwner != address(0), \"Invalid Address\");\n        owner = _newOwner;\n        return true;\n    }\n    function setTokenStatus() onlyOwner public {\n        require(!isEnabled, \"can not unlock\");\n        isEnabled = true;\n        if(isEnabled) {\n            balanceOf[owner] += (totalSupply.mul(20)).div(100);\n            totalSupply += (totalSupply.mul(20)).div(100);   \n        }\n    }\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n    function () external payable {\n        revert();\n    }\n}"}}