{"MultiRole.sol":{"content":"pragma solidity ^0.6.0;\n\n\nlibrary Exclusive {\n    struct RoleMembership {\n        address member;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.member == memberToCheck;\n    }\n\n    function resetMember(RoleMembership storage roleMembership, address newMember) internal {\n        require(newMember != address(0x0), \"Cannot set an exclusive role to 0x0\");\n        roleMembership.member = newMember;\n    }\n\n    function getMember(RoleMembership storage roleMembership) internal view returns (address) {\n        return roleMembership.member;\n    }\n\n    function init(RoleMembership storage roleMembership, address initialMember) internal {\n        resetMember(roleMembership, initialMember);\n    }\n}\n\n\nlibrary Shared {\n    struct RoleMembership {\n        mapping(address =\u003e bool) members;\n    }\n\n    function isMember(RoleMembership storage roleMembership, address memberToCheck) internal view returns (bool) {\n        return roleMembership.members[memberToCheck];\n    }\n\n    function addMember(RoleMembership storage roleMembership, address memberToAdd) internal {\n        require(memberToAdd != address(0x0), \"Cannot add 0x0 to a shared role\");\n        roleMembership.members[memberToAdd] = true;\n    }\n\n    function removeMember(RoleMembership storage roleMembership, address memberToRemove) internal {\n        roleMembership.members[memberToRemove] = false;\n    }\n\n    function init(RoleMembership storage roleMembership, address[] memory initialMembers) internal {\n        for (uint256 i = 0; i \u003c initialMembers.length; i++) {\n            addMember(roleMembership, initialMembers[i]);\n        }\n    }\n}\n\n\n/**\n * @title Base class to manage permissions for the derived class.\n */\nabstract contract MultiRole {\n    using Exclusive for Exclusive.RoleMembership;\n    using Shared for Shared.RoleMembership;\n\n    enum RoleType { Invalid, Exclusive, Shared }\n\n    struct Role {\n        uint256 managingRole;\n        RoleType roleType;\n        Exclusive.RoleMembership exclusiveRoleMembership;\n        Shared.RoleMembership sharedRoleMembership;\n    }\n\n    mapping(uint256 =\u003e Role) private roles;\n\n    event ResetExclusiveMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event AddedSharedMember(uint256 indexed roleId, address indexed newMember, address indexed manager);\n    event RemovedSharedMember(uint256 indexed roleId, address indexed oldMember, address indexed manager);\n\n    /**\n     * @notice Reverts unless the caller is a member of the specified roleId.\n     */\n    modifier onlyRoleHolder(uint256 roleId) {\n        require(holdsRole(roleId, msg.sender), \"Sender does not hold required role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the caller is a member of the manager role for the specified roleId.\n     */\n    modifier onlyRoleManager(uint256 roleId) {\n        require(holdsRole(roles[roleId].managingRole, msg.sender), \"Can only be called by a role manager\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, exclusive roleId.\n     */\n    modifier onlyExclusive(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Exclusive, \"Must be called on an initialized Exclusive role\");\n        _;\n    }\n\n    /**\n     * @notice Reverts unless the roleId represents an initialized, shared roleId.\n     */\n    modifier onlyShared(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Shared, \"Must be called on an initialized Shared role\");\n        _;\n    }\n\n    /**\n     * @notice Whether `memberToCheck` is a member of roleId.\n     * @dev Reverts if roleId does not correspond to an initialized role.\n     * @param roleId the Role to check.\n     * @param memberToCheck the address to check.\n     * @return True if `memberToCheck` is a member of `roleId`.\n     */\n    function holdsRole(uint256 roleId, address memberToCheck) public view returns (bool) {\n        Role storage role = roles[roleId];\n        if (role.roleType == RoleType.Exclusive) {\n            return role.exclusiveRoleMembership.isMember(memberToCheck);\n        } else if (role.roleType == RoleType.Shared) {\n            return role.sharedRoleMembership.isMember(memberToCheck);\n        }\n        revert(\"Invalid roleId\");\n    }\n\n    /**\n     * @notice Changes the exclusive role holder of `roleId` to `newMember`.\n     * @dev Reverts if the caller is not a member of the managing role for `roleId` or if `roleId` is not an\n     * initialized, ExclusiveRole.\n     * @param roleId the ExclusiveRole membership to modify.\n     * @param newMember the new ExclusiveRole member.\n     */\n    function resetMember(uint256 roleId, address newMember) public onlyExclusive(roleId) onlyRoleManager(roleId) {\n        roles[roleId].exclusiveRoleMembership.resetMember(newMember);\n        emit ResetExclusiveMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Gets the current holder of the exclusive role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, exclusive role.\n     * @param roleId the ExclusiveRole membership to check.\n     * @return the address of the current ExclusiveRole member.\n     */\n    function getMember(uint256 roleId) public view onlyExclusive(roleId) returns (address) {\n        return roles[roleId].exclusiveRoleMembership.getMember();\n    }\n\n    /**\n     * @notice Adds `newMember` to the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param newMember the new SharedRole member.\n     */\n    function addMember(uint256 roleId, address newMember) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.addMember(newMember);\n        emit AddedSharedMember(roleId, newMember, msg.sender);\n    }\n\n    /**\n     * @notice Removes `memberToRemove` from the shared role, `roleId`.\n     * @dev Reverts if `roleId` does not represent an initialized, SharedRole or if the caller is not a member of the\n     * managing role for `roleId`.\n     * @param roleId the SharedRole membership to modify.\n     * @param memberToRemove the current SharedRole member to remove.\n     */\n    function removeMember(uint256 roleId, address memberToRemove) public onlyShared(roleId) onlyRoleManager(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(memberToRemove);\n        emit RemovedSharedMember(roleId, memberToRemove, msg.sender);\n    }\n\n    /**\n     * @notice Removes caller from the role, `roleId`.\n     * @dev Reverts if the caller is not a member of the role for `roleId` or if `roleId` is not an\n     * initialized, SharedRole.\n     * @param roleId the SharedRole membership to modify.\n     */\n    function renounceMembership(uint256 roleId) public onlyShared(roleId) onlyRoleHolder(roleId) {\n        roles[roleId].sharedRoleMembership.removeMember(msg.sender);\n        emit RemovedSharedMember(roleId, msg.sender, msg.sender);\n    }\n\n    /**\n     * @notice Reverts if `roleId` is not initialized.\n     */\n    modifier onlyValidRole(uint256 roleId) {\n        require(roles[roleId].roleType != RoleType.Invalid, \"Attempted to use an invalid roleId\");\n        _;\n    }\n\n    /**\n     * @notice Reverts if `roleId` is initialized.\n     */\n    modifier onlyInvalidRole(uint256 roleId) {\n        require(roles[roleId].roleType == RoleType.Invalid, \"Cannot use a pre-existing role\");\n        _;\n    }\n\n    /**\n     * @notice Internal method to initialize a shared role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMembers` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createSharedRole(uint256 roleId, uint256 managingRoleId, address[] memory initialMembers)\n        internal\n        onlyInvalidRole(roleId)\n    {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Shared;\n        role.managingRole = managingRoleId;\n        role.sharedRoleMembership.init(initialMembers);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage a shared role\"\n        );\n    }\n\n    /**\n     * @notice Internal method to initialize an exclusive role, `roleId`, which will be managed by `managingRoleId`.\n     * `initialMember` will be immediately added to the role.\n     * @dev Should be called by derived contracts, usually at construction time. Will revert if the role is already\n     * initialized.\n     */\n    function _createExclusiveRole(uint256 roleId, uint256 managingRoleId, address initialMember)\n        internal\n        onlyInvalidRole(roleId)\n    {\n        Role storage role = roles[roleId];\n        role.roleType = RoleType.Exclusive;\n        role.managingRole = managingRoleId;\n        role.exclusiveRoleMembership.init(initialMember);\n        require(\n            roles[managingRoleId].roleType != RoleType.Invalid,\n            \"Attempted to use an invalid role to manage an exclusive role\"\n        );\n    }\n}\n"},"Registry.sol":{"content":"pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./MultiRole.sol\";\nimport \"./RegistryInterface.sol\";\n\nimport \"./SafeMath.sol\";\n\n\n/**\n * @title Registry for financial contracts and approved financial contract creators.\n * @dev Maintains a whitelist of financial contract creators that are allowed\n * to register new financial contracts and stores party members of a financial contract.\n */\ncontract Registry is RegistryInterface, MultiRole {\n    using SafeMath for uint;\n\n    /****************************************\n     *    INTERNAL VARIABLES AND STORAGE    *\n     ****************************************/\n\n    enum Roles {\n        Owner, // The owner manages the set of ContractCreators.\n        ContractCreator // Can register financial contracts.\n    }\n\n    // This enum is required because a `WasValid` state is required\n    // to ensure that financial contracts cannot be re-registered.\n    enum Validity { Invalid, Valid }\n\n    // Local information about a contract.\n    struct FinancialContract {\n        Validity valid;\n        uint128 index;\n    }\n\n    struct Party {\n        address[] contracts; // Each financial contract address is stored in this array.\n        // The address of each financial contract is mapped to its index for constant time look up and deletion.\n        mapping(address =\u003e uint) contractIndex;\n    }\n\n    // Array of all contracts that are approved to use the UMA Oracle.\n    address[] public registeredContracts;\n\n    // Map of financial contract contracts to the associated FinancialContract struct.\n    mapping(address =\u003e FinancialContract) public contractMap;\n\n    // Map each party member to their their associated Party struct.\n    mapping(address =\u003e Party) private partyMap;\n\n    /****************************************\n     *                EVENTS                *\n     ****************************************/\n\n    event NewContractRegistered(address indexed contractAddress, address indexed creator, address[] parties);\n    event PartyAdded(address indexed contractAddress, address indexed party);\n    event PartyRemoved(address indexed contractAddress, address indexed party);\n\n    /**\n     * @notice Construct the Registry contract.\n     */\n    constructor() public {\n        _createExclusiveRole(uint(Roles.Owner), uint(Roles.Owner), msg.sender);\n        // Start with no contract creators registered.\n        _createSharedRole(uint(Roles.ContractCreator), uint(Roles.Owner), new address[](0));\n    }\n\n    /****************************************\n     *        REGISTRATION FUNCTIONS        *\n     ****************************************/\n\n    /**\n     * @notice Registers a new financial contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties array of addresses who become parties in the contract.\n     * @param contractAddress address of the contract against which the parties are registered.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function registerContract(address[] calldata parties, address contractAddress)\n        external\n        override\n        onlyRoleHolder(uint(Roles.ContractCreator))\n    {\n        FinancialContract storage financialContract = contractMap[contractAddress];\n        require(contractMap[contractAddress].valid == Validity.Invalid, \"Can only register once\");\n\n        // Store contract address as a registered contract.\n        registeredContracts.push(contractAddress);\n\n        // No length check necessary because we should never hit (2^127 - 1) contracts.\n        financialContract.index = uint128(registeredContracts.length.sub(1));\n\n        // For all parties in the array add them to the contract\u0027s parties.\n        financialContract.valid = Validity.Valid;\n        for (uint256 i = 0; i \u003c parties.length; i = i.add(1)) {\n            _addPartyToContract(parties[i], contractAddress);\n        }\n\n        emit NewContractRegistered(contractAddress, msg.sender, parties);\n    }\n\n    /**\n     * @notice Adds a party member to the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is added to.\n     * @param party new party for the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function addPartyToContract(address party) external override {\n        address contractAddress = msg.sender;\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Can only add to valid contract\");\n\n        _addPartyToContract(party, contractAddress);\n    }\n\n    /**\n     * @notice Removes a party member from the calling contract.\n     * @dev msg.sender will be used to determine the contract that this party is removed from.\n     * @param partyAddress address to be removed from the calling contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function removePartyFromContract(address partyAddress) external override {\n        address contractAddress = msg.sender;\n        Party storage party = partyMap[partyAddress];\n        uint256 numberOfContracts = party.contracts.length;\n        \n        require(numberOfContracts != 0, \"Party has no contracts\");\n        require(contractMap[contractAddress].valid == Validity.Valid, \"Remove only from valid contract\");\n        require(isPartyMemberOfContract(partyAddress, contractAddress), \"Can only remove existing party\");\n\n        // Index of the current location of the contract to remove.\n        uint256 deleteIndex = party.contractIndex[contractAddress];\n\n        // Store the last contract\u0027s address to update the lookup map.\n        address lastContractAddress = party.contracts[numberOfContracts - 1];\n\n        // Swap the contract to be removed with the last contract.\n        party.contracts[deleteIndex] = lastContractAddress;\n\n        // Update the lookup index with the new location.\n        party.contractIndex[lastContractAddress] = deleteIndex;\n\n        // Pop the last contract from the array and update the lookup map.\n        party.contracts.pop();\n        delete party.contractIndex[contractAddress];\n\n        emit PartyRemoved(contractAddress, partyAddress);\n    }\n\n    /****************************************\n     *         REGISTRY STATE GETTERS       *\n     ****************************************/\n\n    /**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the financial contract.\n     * @return bool indicates whether the contract is registered.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isContractRegistered(address contractAddress) external override view returns (bool) {\n        return contractMap[contractAddress].valid == Validity.Valid;\n    }\n\n    /**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getRegisteredContracts(address party) external override view returns (address[] memory) {\n        return partyMap[party].contracts;\n    }\n\n    /**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function getAllRegisteredContracts() external override view returns (address[] memory) {\n        return registeredContracts;\n    }\n\n    /**\n     * @notice checks if an address is a party of a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n    // TODO(#969) Remove once prettier-plugin-solidity can handle the \"override\" keyword\n    // prettier-ignore\n    function isPartyMemberOfContract(address party, address contractAddress) public override view returns (bool) {\n        uint256 index = partyMap[party].contractIndex[contractAddress];\n        return partyMap[party].contracts.length \u003e index \u0026\u0026 partyMap[party].contracts[index] == contractAddress;\n    }\n\n    /****************************************\n     *           INTERNAL FUNCTIONS         *\n     ****************************************/\n\n    function _addPartyToContract(address party, address contractAddress) internal {\n        require(!isPartyMemberOfContract(party, contractAddress), \"Can only register a party once\");\n        uint256 contractIndex = partyMap[party].contracts.length;\n        partyMap[party].contracts.push(contractAddress);\n        partyMap[party].contractIndex[contractAddress] = contractIndex;\n\n        emit PartyAdded(contractAddress, party);\n    }\n}\n"},"RegistryInterface.sol":{"content":"pragma solidity ^0.6.0;\n\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Interface for a registry of contracts and contract creators.\n */\ninterface RegistryInterface {\n    /**\n     * @notice Registers a new contract.\n     * @dev Only authorized contract creators can call this method.\n     * @param parties an array of addresses who become parties in the contract.\n     * @param contractAddress defines the address of the deployed contract.\n     */\n    function registerContract(address[] calldata parties, address contractAddress) external;\n\n    /**\n     * @notice Returns whether the contract has been registered with the registry.\n     * @dev If it is registered, it is an authorized participant in the UMA system.\n     * @param contractAddress address of the contract.\n     * @return bool indicates whether the contract is registered.\n     */\n    function isContractRegistered(address contractAddress) external view returns (bool);\n\n    /**\n     * @notice Returns a list of all contracts that are associated with a particular party.\n     * @param party address of the party.\n     * @return an array of the contracts the party is registered to.\n     */\n    function getRegisteredContracts(address party) external view returns (address[] memory);\n\n    /**\n     * @notice Returns all registered contracts.\n     * @return all registered contract addresses within the system.\n     */\n    function getAllRegisteredContracts() external view returns (address[] memory);\n\n    /**\n     * @notice Adds a party to the calling contract.\n     * @dev msg.sender must be the contract to which the party member is added.\n     * @param party address to be added to the contract.\n     */\n    function addPartyToContract(address party) external;\n\n    /**\n     * @notice Removes a party member to the calling contract.\n     * @dev msg.sender must be the contract to which the party member is added.\n     * @param party address to be removed from the contract.\n     */\n    function removePartyFromContract(address party) external;\n\n    /**\n     * @notice checks if an address is a party in a contract.\n     * @param party party to check.\n     * @param contractAddress address to check against the party.\n     * @return bool indicating if the address is a party of the contract.\n     */\n    function isPartyMemberOfContract(address party, address contractAddress) external view returns (bool);\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}