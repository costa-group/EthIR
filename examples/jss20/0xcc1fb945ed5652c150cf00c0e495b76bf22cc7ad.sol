{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n// and modified it.\r\n\r\npragma solidity \u003e=0.7;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 weiValue) internal returns (bytes memory) {\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        require(data.length == 0 || isContract(target));\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            revert(string(returndata));\r\n        }\r\n    }\r\n}"},"MultiSig.sol":{"content":"/**\r\n * SPDX-License-Identifier: MIT\r\n */\r\n\r\npragma solidity \u003e=0.7;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./RLPEncode.sol\";\r\n\r\ncontract MultiSig {\r\n\r\n  mapping (address =\u003e uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\r\n\r\n  uint16 public signerCount;\r\n\r\n  // Observation: the nonce is not increase when the transaction fails.\r\n  uint256 private sequenceNumber; // A sequence number that contains the address of this contract to make it globally unique\r\n  bytes public contractId; // most likely unique id of this contract\r\n\r\n  event SignerChange(\r\n    address indexed signer,\r\n    uint8 cosignaturesNeeded\r\n  );\r\n\r\n  event Transacted(\r\n    address indexed toAddress,  // The address the transaction was sent to\r\n    bytes4 selector, // selected operation\r\n    address[] signers // Addresses of the signers used to initiate the transaction\r\n  );\r\n\r\n  constructor (address owner) {\r\n    // We use the gas price to get a unique id into our transactions.\r\n    // Note that 32 bits do not guarantee that no one can generate a contract with the\r\n    // same id, but it practically rules out that someone accidentally creates two\r\n    // two multisig contracts with the same id, and that\u0027s all we need to prevent\r\n    // replay-attacks.\r\n    contractId = toBytes(uint32(address(this)));\r\n    _setSigner(owner, 1); // start with the contract creator as owner\r\n  }\r\n\r\n  /**\r\n   * It should be possible to store ether on this address.\r\n   */\r\n  receive() external payable {\r\n  }\r\n\r\n  /**\r\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\r\n   */\r\n  function checkSignatures(address to, uint value, bytes calldata data,\r\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public view returns (address[] memory) {\r\n    bytes32 transactionHash = calculateTransactionHash(nextSequenceNumber(), contractId, to, value, data);\r\n    return verifySignatures(transactionHash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * Checks if the execution of a transaction would succeed if it was properly signed.\r\n   */\r\n  function checkExecution(address to, uint value, bytes calldata data) public {\r\n    Address.functionCallWithValue(to, data, value);\r\n    require(false, \"Test passed. Reverting.\");\r\n  }\r\n\r\n  function execute(address to, uint value, bytes calldata data,\r\n  uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public returns (bytes memory) {\r\n    // ok to increment here already, will be rolled back in case of failure and saves us one local variable\r\n    sequenceNumber = nextSequenceNumber();\r\n    bytes32 transactionHash = calculateTransactionHash(sequenceNumber, contractId, to, value, data);\r\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\r\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\r\n    emit Transacted(to, extractSelector(data), found);\r\n    return returndata;\r\n  }\r\n\r\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\r\n    if (data.length \u003c 4){\r\n      return bytes4(0);\r\n    } else {\r\n      return bytes4(data[0]) | (bytes4(data[1]) \u003e\u003e 8) | (bytes4(data[2]) \u003e\u003e 16) | (bytes4(data[3]) \u003e\u003e 24);\r\n    }\r\n  }\r\n\r\n  function nextSequenceNumber() public view returns (uint256){\r\n    return sequenceNumber + 1;\r\n  }\r\n\r\n  function toBytes(uint number) internal pure returns (bytes memory){\r\n    uint len = 0;\r\n    uint temp = 1;\r\n    while (number \u003e= temp){\r\n      temp = temp \u003c\u003c 8;\r\n      len++;\r\n    }\r\n    temp = number;\r\n    bytes memory data = new bytes(len);\r\n    for (uint i = len; i\u003e0; i--) {\r\n      data[i-1] = bytes1(uint8(temp));\r\n      temp = temp \u003e\u003e 8;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  // Note: does not work with contract creation\r\n  function calculateTransactionHash(uint sequence, bytes storage id, address to, uint value, bytes calldata data)\r\n    private pure returns (bytes32){\r\n    bytes[] memory all = new bytes[](9);\r\n    all[0] = toBytes(sequence); // sequence number instead of nonce\r\n    all[1] = id; // contract id instead of gas price\r\n    all[2] = toBytes(21000); // gas limit\r\n    all[3] = abi.encodePacked(to);\r\n    all[4] = toBytes(value);\r\n    all[5] = data;\r\n    all[6] = toBytes(1);\r\n    all[7] = toBytes(0);\r\n    for (uint i = 0; i\u003c8; i++){\r\n      all[i] = RLPEncode.encodeBytes(all[i]);\r\n    }\r\n    all[8] = all[7];\r\n    return keccak256(RLPEncode.encodeList(all));\r\n  }\r\n\r\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s)\r\n    private view returns (address[] memory) {\r\n    address[] memory found = new address[](r.length);\r\n    for (uint i = 0; i \u003c r.length; i++) {\r\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\r\n      uint8 cosignaturesNeeded = signers[signer];\r\n      require(cosignaturesNeeded \u003e 0 \u0026\u0026 cosignaturesNeeded \u003c= r.length, \"cosigner error\");\r\n      found[i] = signer;\r\n    }\r\n    requireNoDuplicates(found);\r\n    return found;\r\n  }\r\n\r\n  function requireNoDuplicates(address[] memory found) private pure {\r\n    for (uint i = 0; i \u003c found.length; i++) {\r\n      for (uint j = i+1; j \u003c found.length; j++) {\r\n        require(found[i] != found[j], \"duplicate signature\");\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call this method through execute\r\n   */\r\n  function setSigner(address signer, uint8 cosignaturesNeeded) public authorized {\r\n    _setSigner(signer, cosignaturesNeeded);\r\n    require(signerCount \u003e 0);\r\n  }\r\n\r\n  function migrate(address destination) public {\r\n    _migrate(msg.sender, destination);\r\n  }\r\n\r\n  function migrate(address source, address destination) public authorized {\r\n    require(source == address(this));\r\n    _migrate(source, destination);\r\n  }\r\n\r\n  function _migrate(address source, address destination) private {\r\n    require(signers[destination] == 0); // do not overwrite existing signer!\r\n    _setSigner(destination, signers[source]);\r\n    _setSigner(source, 0);\r\n  }\r\n\r\n  function _setSigner(address signer, uint8 cosignaturesNeeded) private {\r\n    require(!Address.isContract(signer), \"signer cannot be a contract\");\r\n    uint8 prevValue = signers[signer];\r\n    signers[signer] = cosignaturesNeeded;\r\n    if (prevValue \u003e 0 \u0026\u0026 cosignaturesNeeded == 0){\r\n      signerCount--;\r\n    } else if (prevValue == 0 \u0026\u0026 cosignaturesNeeded \u003e 0){\r\n      signerCount++;\r\n    }\r\n    emit SignerChange(signer, cosignaturesNeeded);\r\n  }\r\n\r\n  modifier authorized() {\r\n    require(address(this) == msg.sender || signers[msg.sender] == 1, \"not authorized\");\r\n    _;\r\n  }\r\n\r\n}"},"RLPEncode.sol":{"content":"/// SPDX-License-Identifier: MIT\r\n/// @title RLP Encoding Library for Solidity\r\n/// @author Sam Mayo (sammayo888@gmail.com)\r\n/// @dev Library for rlp encoding arbitrary bytes or lists.\r\n\r\npragma solidity \u003e=0.7;\r\n\r\nlibrary RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n    /// @dev Rlp encodes a bytes\r\n    /// @param self The bytes to be encoded\r\n    /// @return The rlp encoded bytes\r\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\r\n        if(self.length == 1 \u0026\u0026 self[0] \u003c 0x80) {\r\n            return self;\r\n        } else {\r\n            return encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n    }\r\n    \r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\r\n        bytes memory list = flatten(self);\r\n        return encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private pure returns (bytes memory) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        uint len = self.length;\r\n        if(len \u003c= 55) {\r\n            bytes memory encoded = new bytes(len+1);\r\n            uint8 lenshort = uint8(len);\r\n            // length encoding byte\r\n            encoded[0] = byte(prefix1+lenshort);\r\n\r\n            // string/list contents\r\n            uint encodedPtr;\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n            return encoded;\r\n        } else {\r\n            uint8 lenLen;\r\n            uint i = 0x1;\r\n            while(len/i != 0) {\r\n                lenLen++;\r\n                i *= 0x100;\r\n            }\r\n\r\n            // 1 is the length of the length of the length\r\n           bytes memory encoded = new bytes(1+lenLen+len);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(prefix2+lenLen);\r\n\r\n            // length bytes\r\n            for(i=1; i\u003c=lenLen; i++) {\r\n                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));\r\n            }\r\n\r\n            // string/list contents\r\n            uint encodedPtr;\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n            return encoded;\r\n        }\r\n    }\r\n    \r\n    function flatten(bytes[] memory self) private pure returns (bytes memory) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i\u003cself.length; i++) {\r\n            len += self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(uint i=0; i\u003cself.length; i++) {\r\n            bytes memory item = self[i];\r\n            \r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr += self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson\u0027s string utils library\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len \u003e= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}"}}