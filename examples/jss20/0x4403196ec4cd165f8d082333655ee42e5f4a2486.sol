{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}"},"Adors.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./Pausable.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\nimport \"./ERC165.sol\";\n\ncontract ViVADOR is ERC165, IERC1155, ERC1155Metadata, Pausable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 =\u003e mapping(address =\u003e uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address =\u003e mapping(address =\u003e bool)) private _operatorApprovals;\n    \n    // Mapping validators\n    mapping (address =\u003e bool) private _validators;\n    \n    // Mapping original NFT minters\n    mapping (uint256 =\u003e address payable) private _tokenMinters;\n    \n    // A nonce to ensure we have a unique id each time we mint.\n    uint256 public nonce;\n    \n    // The fee for burning an asset\n    // This fee goes to the asset minter\n    uint256 private burnFee = 0 ether;\n\n    /*\n     *     bytes4(keccak256(\u0027balanceOf(address,uint256)\u0027)) == 0x00fdd58e\n     *     bytes4(keccak256(\u0027balanceOfBatch(address[],uint256[])\u0027)) == 0x4e1273f4\n     *     bytes4(keccak256(\u0027setApprovalForAll(address,bool)\u0027)) == 0xa22cb465\n     *     bytes4(keccak256(\u0027isApprovedForAll(address,address)\u0027)) == 0xe985e9c5\n     *     bytes4(keccak256(\u0027safeTransferFrom(address,address,uint256,uint256,bytes)\u0027)) == 0xf242432a\n     *     bytes4(keccak256(\u0027safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\u0027)) == 0x2eb2c2d6\n     *\n     *     =\u003e 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256(\u0027uri(uint256)\u0027)) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setBaseMetadataURI}.\n     */\n    constructor (string memory uri) public {\n        _setBaseMetadataURI(uri);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /*\n    * Only allowed validators modifier\n    */\n    modifier onlyValidator() {\n        require(_validators[msg.sender] == true, \"Only validators are allowed\");\n        _;\n    }\n    \n    event ValidatorSet(address validator, bool status);\n    \n    /*\n    * change validator status\n    */\n    \n    function setValidator(address validator, bool status) isOwner public {\n        _validators[validator] = status;\n        emit ValidatorSet(validator, status);\n    }\n    \n    /*\n    * Check if an address is a validator\n    */\n    function isValidator(address validator) public view returns (bool) {\n        return _validators[validator]; \n    } \n    \n    /**\n    * Set a fee for burning an asset\n    */\n    function setBurnfee(uint256 fee) public isOwner {\n        burnFee = fee;    \n    }    \n    \n    /**\n    * Get the current fee for burning an asset\n    */\n    function getBurnfee() public view returns (uint256) {\n        return burnFee;\n    }    \n    \n\n    /**\n        @dev Get the specified address\u0027 balance for token with specified ID.\n\n        Attempting to query the zero account for a balance will result in a revert.\n\n        @param account The address of the token holder\n        @param id ID of the token\n        @return The account\u0027s balance of the token type requested\n     */\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n        @dev Get the balance of multiple account/token pairs.\n\n        If any of the query accounts is the zero account, this query will revert.\n\n        @param accounts The addresses of the token holders\n        @param ids IDs of the tokens\n        @return Balances for each account and token id pair\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and IDs must have same lengths\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i \u003c accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator.\n     *\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     *\n     * Because an account already has operator privileges for itself, this function will revert\n     * if the account attempts to set the approval status for itself.\n     *\n     * @param operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address operator, bool approved) whenNotPaused public virtual override {\n        require(msg.sender != operator, \"ERC1155: cannot set approval status for self\");\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n        @notice Queries the approval status of an operator for a given account.\n        @param account   The account of the Tokens\n        @param operator  Address of authorized operator\n        @return           True if the operator is approved, false if not\n    */\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n        @dev Transfers `value` amount of an `id` from the `from` address to the `to` address specified.\n        Caller must be approved to manage the tokens being transferred out of the `from` account.\n        If `to` is a smart contract, will call `onERC1155Received` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param id ID of the token type\n        @param value Transfer amount\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        whenNotPaused\n        public\n        override\n    {\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender) == true,\n            \"ERC1155: need operator approval for 3rd party transfers\"\n        );\n\n        _balances[id][from] = _balances[id][from].sub(value, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(value);\n\n        emit TransferSingle(msg.sender, from, to, id, value);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, value, data);\n    }\n\n    /**\n        @dev Transfers `values` amount(s) of `ids` from the `from` address to the\n        `to` address specified. Caller must be approved to manage the tokens being\n        transferred out of the `from` account. If `to` is a smart contract, will\n        call `onERC1155BatchReceived` on `to` and act appropriately.\n        @param from Source address\n        @param to Target address\n        @param ids IDs of each token type\n        @param values Transfer amounts per token type\n        @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n    */\n    \n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    )\n        whenNotPaused\n        public\n        virtual\n        override\n    {\n        require(ids.length == values.length, \"ERC1155: IDs and values must have same lengths\");\n        require(to != address(0), \"ERC1155: target address must be non-zero\");\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender) == true,\n            \"ERC1155: need operator approval for 3rd party transfers\"\n        );\n\n        for (uint256 i = 0; i \u003c ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                value,\n                \"ERC1155: insufficient balance of some token type for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(value);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, values);\n\n        _doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, ids, values, data);\n    }\n    \n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substituion mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurence of the `{id}` substring in either the\n     * URI or any of the values in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://adors.org/vault/{id}.json` URI would be\n     * interpreted by clients as\n     * `https://adors.org/vault/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    \n    function setURI(string memory newuri) isOwner public {\n        _setBaseMetadataURI(newuri);\n    }\n    \n    /**\n     * @dev Internal function to mint an amount of a token with the given ID\n     * @param to The address that will own the minted token\n     * @param id ID of the token to be minted\n     * @param value Amount of the token to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function _mint(address to, uint256 id, uint256 value, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        _balances[id][to] = _balances[id][to].add(value);\n        emit TransferSingle(msg.sender, address(0), to, id, value);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, address(0), to, id, value, data);\n    }\n\n    \n    function mint(address to, uint256 value, bytes memory data) whenNotPaused onlyValidator public {\n        uint256 id = ++nonce;\n        _tokenMinters[id] = msg.sender;\n        _mint(to, id, value, data);\n        emit URI(baseMetadataURI, id);\n    }\n    \n    /**\n     * @dev Internal function to batch mint amounts of tokens with the given IDs\n     * @param to The address that will own the minted token\n     * @param ids IDs of the tokens to be minted\n     * @param values Amounts of the tokens to be minted\n     * @param data Data forwarded to `onERC1155Received` if `to` is a contract receiver\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: batch mint to the zero address\");\n        require(ids.length == values.length, \"ERC1155: minted IDs and values must have same lengths\");\n\n        for (uint256 i = 0; i \u003c ids.length; i++) {\n            _balances[ids[i]][to] = values[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, values);\n\n        _doSafeBatchTransferAcceptanceCheck(msg.sender, address(0), to, ids, values, data);\n    }\n    \n    function mintBatch(address to, uint256[] memory values, bytes memory data) whenNotPaused onlyValidator public {\n        uint256[] memory ids = new uint256[](values.length);\n        \n        for (uint256 i = 0; i \u003c values.length; i++) {\n               ids[i] = ++nonce;\n               _tokenMinters[ids[i]] = msg.sender;\n        }\n        _mintBatch(to, ids, values, data);\n        _logURIs(ids);\n    }\n    \n    /*\n    * get the minter of a token\n    */\n    \n    function minterOf(uint256 id) public view returns (address) {\n        return _tokenMinters[id];\n    }\n    \n    /**\n     * @dev Internal function to burn an amount of a token with the given ID\n     * @param account Account which owns the token to be burnt\n     * @param id ID of the token to be burnt\n     * @param value Amount of the token to be burnt\n     */\n    function _burn(address account, uint256 id, uint256 value) internal virtual {\n        require(account != address(0), \"ERC1155: attempting to burn tokens on zero account\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            value,\n            \"ERC1155: attempting to burn more than balance\"\n        );\n        emit TransferSingle(msg.sender, account, address(0), id, value);\n    }\n    \n    function burn(uint256 id, uint256 value) whenNotPaused payable public {\n        address payable minter = _tokenMinters[id];\n        \n        if (minter != msg.sender) {\n            // require burnFee if not the minter burning\n            require(msg.value \u003e= burnFee);\n            minter.transfer(burnFee);\n        } \n        _burn(msg.sender, id, value);   \n    }\n\n    /**\n     * @dev Internal function to batch burn an amounts of tokens with the given IDs\n     * @param account Account which owns the token to be burnt\n     * @param ids IDs of the tokens to be burnt\n     * @param values Amounts of the tokens to be burnt\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory values) internal virtual {\n        require(account != address(0), \"ERC1155: attempting to burn batch of tokens on zero account\");\n        require(ids.length == values.length, \"ERC1155: burnt IDs and values must have same lengths\");\n\n        for(uint256 i = 0; i \u003c ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                values[i],\n                \"ERC1155: attempting to burn more than balance for some token\"\n            );\n        }\n\n        emit TransferBatch(msg.sender, account, address(0), ids, values);\n    }\n    \n    function burnBatch(uint256[] memory ids, uint256[] memory values) whenNotPaused payable public {\n        uint256 totalBurnFee = msg.value;\n        \n        for (uint256 i = 0; i \u003c ids.length; i++) {\n            address payable minter = _tokenMinters[ids[i]];\n                        \n            if (minter != msg.sender) {\n                require(totalBurnFee \u003e= burnFee, \"Not enough fee to burn assets\");\n                minter.transfer(burnFee);\n                totalBurnFee = totalBurnFee.sub(burnFee);\n            }    \n            \n        }\n        _burnBatch(msg.sender, ids, values);\n    }\n    \n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    )\n        private\n    {\n        if(to.isContract()) {\n            require(\n                IERC1155Receiver(to).onERC1155Received(operator, from, id, value, data) ==\n                    IERC1155Receiver(to).onERC1155Received.selector,\n                \"ERC1155: got unknown value from onERC1155Received\"\n            );\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    )\n        private\n    {\n        if(to.isContract()) {\n            require(\n                IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, values, data) ==\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector,\n                \"ERC1155: got unknown value from onERC1155BatchReceived\"\n            );\n        }\n    }\n    \n     function withdrawFund() isOwner public {\n        uint256 balance = address(this).balance;\n        owner.transfer(balance);\n    }\n}"},"ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256(\u0027supportsInterface(bytes4)\u0027)) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it\u0027s supported.\n     */\n    mapping(bytes4 =\u003e bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}"},"IERC1155.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n    @title ERC-1155 Multi Token Standard basic interface\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n */\ninterface IERC1155 is IERC165 {\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external;\n}"},"IERC1155MetadataURI.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @notice Contract that handles metadata related methods.\n * @dev Methods assume a deterministic generation of URI based on token IDs.\n *      Methods also assume that URI uses hex representation of token IDs.\n */\ncontract ERC1155Metadata {\n  // URI\u0027s default URI prefix\n  string internal baseMetadataURI;\n  event URI(string _uri, uint256 indexed _id);\n\n  /**\n   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n   * @dev URIs are defined in RFC 3986.\n   *      URIs are assumed to be deterministically generated based on token ID\n   *      Token IDs are assumed to be represented in their hex format in URIs\n   * @return URI string\n   */\n  function uri(uint256 _id) public view returns (string memory) {\n    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), \".json\"));\n  }\n\n  /**\n   * @notice Will emit default URI log event for corresponding token _id\n   * @param _tokenIDs Array of IDs of tokens to log default URI\n   */\n  function _logURIs(uint256[] memory _tokenIDs) internal {\n    string memory baseURL = baseMetadataURI;\n    string memory tokenURI;\n\n    for (uint256 i = 0; i \u003c _tokenIDs.length; i++) {\n      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), \".json\"));\n      emit URI(tokenURI, _tokenIDs[i]);\n    }\n  }\n\n  /**\n   * @notice Will update the base URL of token\u0027s URI\n   * @param _newBaseMetadataURI New base URL of token\u0027s URI\n   */\n  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n    baseMetadataURI = _newBaseMetadataURI;\n  }\n\n  /**\n   * @notice Convert uint256 to string\n   * @param _i Unsigned integer to convert to string\n   */\n  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n    if (_i == 0) {\n      return \"0\";\n    }\n\n    uint256 j = _i;\n    uint256 ii = _i;\n    uint256 len;\n\n    // Get number of bytes\n    while (j != 0) {\n      len++;\n      j /= 10;\n    }\n\n    bytes memory bstr = new bytes(len);\n    uint256 k = len - 1;\n\n    // Get each individual ASCII\n    while (ii != 0) {\n      bstr[k--] = byte(uint8(48 + ii % 10));\n      ii /= 10;\n    }\n\n    // Convert to string\n    return string(bstr);\n  }\n}"},"IERC1155Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC165.sol\";\n\n/**\n    @title ERC-1155 Multi Token Receiver Interface\n    @dev See https://eips.ethereum.org/EIPS/eip-1155\n*/\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}"},"IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"},"Owner.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title Owner\n * @dev Set \u0026 change owner\n */\ncontract Ownable {\n\n    address payable internal owner;\n    \n    // event for EVM logging\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\n    \n    // modifier to check if caller is owner\n    modifier isOwner() {\n        // If the first argument of \u0027require\u0027 evaluates to \u0027false\u0027, execution terminates and all\n        // changes to the state and to Ether balances are reverted.\n        // This used to consume all gas in old EVM versions, but not anymore.\n        // It is often a good idea to use \u0027require\u0027 to check if functions are called correctly.\n        // As a second argument, you can also provide an explanation about what went wrong.\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n    \n    /**\n     * @dev Set contract deployer as owner\n     */\n    constructor() public {\n        owner = msg.sender; // \u0027msg.sender\u0027 is sender of current call, contract deployer for a constructor\n        emit OwnerSet(address(0), owner);\n    }\n\n    /**\n     * @dev Change owner\n     * @param newOwner address of new owner\n     */\n    function changeOwner(address payable newOwner) public isOwner {\n        emit OwnerSet(owner, newOwner);\n        owner = newOwner;\n    }\n\n    /**\n     * @dev Return owner address \n     * @return address of owner\n     */\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}"},"Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./Owner.sol\";\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev modifier to allow actions only when the contract IS paused\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev modifier to allow actions only when the contract IS NOT paused\n   */\n  modifier whenPaused {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() isOwner whenNotPaused public returns (bool) {\n    paused = true;\n    Pause();\n    return true;\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() isOwner whenPaused public returns (bool) {\n    paused = false;\n    Unpause();\n    return true;\n  }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}