{"GoldenTest.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\nimport \"./LuckyDraw.sol\";\r\n\r\ncontract Events {\r\n    event newName(\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n\r\n\r\n    event onRoundEnd\r\n    (\r\n        DataStructs.EventReturns compressedData,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        uint256 newPot,\r\n        uint256 genAmount\r\n    );\r\n    event onWithdrawFunds\r\n    (\r\n        address playerAddress,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onPotDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n\r\n    //  fired whenever a player tries a reinvest after round timer\r\n    // hit zero, and causes end round to be ran.\r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 genAmount\r\n    );\r\n\r\n    event topInvestorsDistribute(\r\n        address first,\r\n        address second,\r\n        address third\r\n    );\r\n\r\n    event topPromotersDistribute(\r\n        address first,\r\n        address second,\r\n        address third\r\n    );\r\n\r\n    event luckyDrawDeclared(\r\n        address winner,\r\n        uint256 amt,\r\n        uint256 time\r\n    );\r\n\r\n    event nextRoundStarted(\r\n        uint256 roundId,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    );\r\n\r\n}\r\n\r\ncontract GoldenKingdom is Events {\r\n    using SafeMath for uint256;\r\n    using NameFilter for string;\r\n\r\n    LuckyDraw private luckyDraw;\r\n\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public externalWallet;\r\n    string constant public name = \"Golden Kingdom\";\r\n    string constant public symbol = \"GK\";\r\n\r\n    // Round duration\r\n    uint256 constant private rndInit_ = 1 hours;                // round timer starts at this\r\n    uint256 constant private rndInc_ = 180 seconds;              // every full key purchased adds this much to the timer\r\n    uint256 constant private rndMax_ =  48 hours;               // max length a round timer can be\r\n\r\n    uint256 public rID_;\r\n\r\n    // Price of each key is 0.001 ETH\r\n    uint256 public keyPrice = 1000000000000000;\r\n\r\n    mapping (bytes32 =\u003e address) public pAddrxName;          // (addr =\u003e pName) returns player address by name\r\n    mapping (address =\u003e DataStructs.Player) public plyr_;    // (addr =\u003e data) player data\r\n    mapping (address =\u003e mapping (uint256 =\u003e DataStructs.PlayerRounds)) public plyrRnds_;     // (addr =\u003e rID =\u003e data) player round data by player id \u0026 round ids\r\n\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public playerEarned_; //How much amount a player has earned till now.(addr =\u003e rID =\u003e amount)\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public playerExtraEarnings_;\r\n    mapping (uint256 =\u003e DataStructs.Round) public round_;   // (rID =\u003e data) round data\r\n\r\n    mapping(address =\u003e uint256) internal referralBalance_;\r\n    mapping(address =\u003e address) internal firstReferrer;\r\n\r\n    uint256 public keyHolderFees_;\r\n    uint256 public treasureAmount_;\r\n    uint256 public adminKeyVault_;\r\n    uint256 public luckyDrawVault_;\r\n    uint256 internal tokenInvestorsSupply_ = 0;\r\n    uint256 public totalSupply_ = 0;\r\n\r\n    uint256 lastLuckyDrawTime = 0;\r\n    uint256 public lastLuckyDrawAmt = 0;\r\n    uint256 luckyDrawDuration = 24 hours;\r\n    bool public luckyDrawEnabled = true;\r\n\r\n    uint256 lastPromoterDistTime = 0;\r\n    uint256 lastInvestorDistTime = 0;\r\n    uint256 topleaderboardDuration = 7 days;\r\n\r\n    struct Leaderboard {\r\n        uint256 amt;\r\n        address addr;\r\n    }\r\n\r\n    //Promoters Datastructures\r\n    Leaderboard[3] public topPromoters;\r\n    uint256 public promoterDistRound;\r\n    uint256 public topPromotersVault = 0;\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public promoters; // get promotional earnings by player and investment round\r\n    address[3] public lastTopPromoters;\r\n\r\n    //Investors Datastructures\r\n    Leaderboard[3] public topInvestors;\r\n    uint256 public investorDistRound;\r\n    uint256 public topInvestorsVault = 0;\r\n    mapping(address =\u003e mapping(uint256 =\u003e uint256)) public investors; // get investment by player and investment round\r\n    address[3] public lastTopInvestors;\r\n\r\n    constructor(address _externalWallet)\r\n        public isHuman()\r\n    {\r\n        externalWallet = _externalWallet;\r\n        keyHolderFees_ = 61;\r\n        treasureAmount_ = 20;\r\n        _owner = msg.sender;\r\n        luckyDraw = LuckyDraw(address(0x9f43fa07a28399F7370EFdBbD7DC02e39a715141));\r\n        lastLuckyDrawTime = now;\r\n        lastPromoterDistTime = now;\r\n        lastInvestorDistTime = now;\r\n        promoterDistRound = 1;\r\n        investorDistRound = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev allows only the user to run the function\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"only Owner\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n     * @dev allows only the external wallet to run the function\r\n     */\r\n    modifier onlyExternalWallet() {\r\n        require(msg.sender == externalWallet, \"only External Wallet can call this function\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has\r\n     * been activated.\r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"ouch, contract is not ready yet !\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting\r\n     */\r\n    modifier isHuman() {\r\n        require(msg.sender == tx.origin, \"nope, you\u0027re not an Human buddy !!\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth \u003e= 50000000000000000, \"Minimum contribution amount is 0.05 ETH\");\r\n        _;\r\n    }\r\n//-------------------------------------------------------------------------------------------------------//\r\n//-------------------------------------------------------------------------------------------------------//\r\n\r\n    function changeKeyPrice(uint256 _amt)\r\n        onlyOwner()\r\n        public\r\n    {\r\n        keyPrice = _amt;\r\n    }\r\n\r\n    function changeExternalWallet(address _newAddress)\r\n    onlyOwner()\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(_newAddress != address(0x0));\r\n\r\n        externalWallet = _newAddress;\r\n        return true;\r\n\r\n    }\r\n\r\n    function ()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        isActivated()\r\n        public\r\n        payable\r\n    {\r\n        //set up our tx event data and determine if player is new or not\r\n        DataStructs.EventReturns memory _eventData_ =  _eventData_;\r\n\r\n        // fetch player id\r\n         address _playerAddr = msg.sender;\r\n\r\n        // buy core\r\n        purchaseCore(_playerAddr, 0x0, _eventData_);\r\n    }\r\n\r\n     /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n     /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function stopLuckyDraw()\r\n        onlyOwner()\r\n        public\r\n    {\r\n        require(luckyDrawEnabled = true, \"Luckydraw is already stopped\");\r\n        luckyDrawEnabled = false;\r\n    }\r\n\r\n    function startLuckyDraw()\r\n        onlyOwner()\r\n        public\r\n    {\r\n        require(luckyDrawEnabled = false, \"Lucky draw is already running\");\r\n        luckyDrawEnabled = true;\r\n    }\r\n\r\n\r\n    function purchaseViaAddr(address _affAddress)\r\n        isHuman()\r\n        isActivated()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        //  set up our tx event data and determine if player is new or not\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        // fetch player id\r\n        address _playerAddr = msg.sender;\r\n        address _affAddr = _affAddress;\r\n\r\n        // purchase core\r\n        purchaseCore(_playerAddr, _affAddr, _eventData_);\r\n    }\r\n\r\n    function reinvestDividendEarnings(uint256 _keys)\r\n        isHuman()\r\n        isActivated()\r\n        private\r\n    {\r\n\r\n        address _playerAddr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        address _affAddr = firstReferrer[msg.sender];\r\n        uint256 _eth = _keys.mul(keyPrice).div(1000000000000000000);\r\n        uint256 _rID = rID_;\r\n\r\n        if (plyrRnds_[_playerAddr][_rID].keys == 0) {\r\n            _eventData_ = managePlayer(_playerAddr, _eventData_);\r\n            round_[_rID].playerCounter = round_[_rID].playerCounter + 1;\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n        // if they reinvest at least 1 whole key\r\n        if (_keys \u003e= 1000000000000000000)\r\n        {\r\n        updateTimer(_keys, _rID);\r\n\r\n        // set new leaders\r\n        if (round_[_rID].plyr != _playerAddr)\r\n            round_[_rID].plyr = _playerAddr;\r\n\r\n        // set the new leader bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 100;\r\n        }\r\n        // update player\r\n        plyrRnds_[_playerAddr][_rID].keys = (_keys.mul(1).div(100)).add(plyrRnds_[_playerAddr][_rID].keys);\r\n        plyrRnds_[_playerAddr][_rID].eth = plyrRnds_[_playerAddr][_rID].eth.add(_eth);\r\n        plyr_[_playerAddr].eth = plyr_[_playerAddr].eth.add(_eth);\r\n\r\n        // update round\r\n        round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n        round_[_rID].eth = round_[_rID].eth.add(_eth);\r\n        investors[_playerAddr][investorDistRound] = investors[_playerAddr][investorDistRound].add(_eth);\r\n        addInvestor(_playerAddr);\r\n        luckyDraw.add(_playerAddr);\r\n\r\n        //check if its been over a day since the last lucky draw happened\r\n        if (now.sub(lastLuckyDrawTime) \u003e= luckyDrawDuration  \u0026\u0026 luckyDrawEnabled == true){\r\n            //pick a winner and transfer ETH to account\r\n            address luckyDrawWinner = luckyDraw.draw();\r\n            plyr_[luckyDrawWinner].gen = plyr_[luckyDrawWinner].gen.add(luckyDrawVault_);\r\n            lastLuckyDrawAmt = luckyDrawVault_;\r\n            luckyDrawVault_ = 0;\r\n            lastLuckyDrawTime = now;\r\n            emit luckyDrawDeclared(luckyDrawWinner, lastLuckyDrawAmt, now);\r\n        }\r\n\r\n\r\n        _eventData_ = distributeInternal(_rID, _playerAddr, _affAddr, _keys, _eventData_);\r\n\r\n    }\r\n\r\n    function reinvestReferralEarnings(uint256 _keys)\r\n        isHuman()\r\n        isActivated()\r\n        private\r\n    {\r\n\r\n        address _playerAddr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        address _affAddr = firstReferrer[msg.sender];\r\n        uint256 _eth = _keys.mul(keyPrice).div(1000000000000000000);\r\n        uint256 _rID = rID_;\r\n\r\n        if (plyrRnds_[_playerAddr][_rID].keys == 0) {\r\n            _eventData_ = managePlayer(_playerAddr, _eventData_);\r\n            round_[_rID].playerCounter = round_[_rID].playerCounter + 1;\r\n\r\n        }\r\n\r\n        // if they reinvest at least 1 whole key\r\n        if (_keys \u003e= 1000000000000000000)\r\n        {\r\n        updateTimer(_keys, _rID);\r\n\r\n        // set new leaders\r\n        if (round_[_rID].plyr != _playerAddr)\r\n            round_[_rID].plyr = _playerAddr;\r\n\r\n        // set the new leader bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 100;\r\n        }\r\n        // update player\r\n        plyrRnds_[_playerAddr][_rID].keys = (_keys.mul(1).div(100)).add(plyrRnds_[_playerAddr][_rID].keys);\r\n        plyrRnds_[_playerAddr][_rID].eth = plyrRnds_[_playerAddr][_rID].eth.add(_eth);\r\n        plyr_[_playerAddr].eth = plyr_[_playerAddr].eth.add(_eth);\r\n\r\n        // update round\r\n        round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n        round_[_rID].eth = round_[_rID].eth.add(_eth);\r\n\r\n        investors[_playerAddr][investorDistRound] = investors[_playerAddr][investorDistRound].add(_eth);\r\n        addInvestor(_playerAddr);\r\n        luckyDraw.add(_playerAddr);\r\n\r\n        //check if its been over a day since the last lucky draw happened\r\n        if (now.sub(lastLuckyDrawTime) \u003e= luckyDrawDuration \u0026\u0026 luckyDrawEnabled == true){\r\n            //pick a winner and transfer ETH to account\r\n            address luckyDrawWinner = luckyDraw.draw();\r\n            plyr_[luckyDrawWinner].gen = plyr_[luckyDrawWinner].gen.add(luckyDrawVault_);\r\n            lastLuckyDrawAmt = luckyDrawVault_;\r\n            luckyDrawVault_ = 0;\r\n            lastLuckyDrawTime = now;\r\n            emit luckyDrawDeclared(luckyDrawWinner, lastLuckyDrawAmt, now);\r\n        }\r\n\r\n\r\n        _eventData_ = distributeInternal(_rID, _playerAddr, _affAddr, _keys, _eventData_);\r\n\r\n    }\r\n\r\n    function reinvestAllEarnings()\r\n        isHuman()\r\n        isActivated()\r\n        public\r\n    {\r\n\r\n        address _playerAddr = msg.sender;\r\n        uint256 _rID = rID_;\r\n        uint256 eth = 0;\r\n        uint256 _now = now;\r\n\r\n        // set up our tx event data\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        //Check if the round is running, then only the player can reinvest\r\n        if (_now \u003e round_[_rID].strt \u0026\u0026 (_now \u003c= round_[_rID].end || (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].plyr == 0)))\r\n        {\r\n\r\n            updateGenVault(_playerAddr, plyr_[_playerAddr].lrnd);\r\n\r\n            uint256 _keys = referralBalance_[_playerAddr].add(plyr_[_playerAddr].gen);\r\n            require(_keys \u003e 0, \"Sorry, you don\u0027t have sufficient earning to reinvest\");\r\n\r\n            //make the player referral earnings to 0.\r\n            playerEarned_[_playerAddr][_rID] = playerEarned_[_playerAddr][_rID].add(plyr_[_playerAddr].gen);\r\n            referralBalance_[_playerAddr] = 0;\r\n            plyr_[_playerAddr].gen = 0;\r\n\r\n            address _affAddr = firstReferrer[msg.sender];\r\n            uint256 _eth = _keys.mul(keyPrice).div(1000000000000000000);\r\n            eth = _eth;\r\n\r\n            if (plyrRnds_[_playerAddr][_rID].keys == 0) {\r\n            _eventData_ = managePlayer(_playerAddr, _eventData_);\r\n            round_[_rID].playerCounter = round_[_rID].playerCounter + 1;\r\n\r\n        }\r\n\r\n\r\n            // if they reinvest at least 1 whole key\r\n            if (_keys \u003e= 1000000000000000000)\r\n            {\r\n            updateTimer(_keys, _rID);\r\n\r\n            // set new leaders\r\n            if (round_[_rID].plyr != _playerAddr)\r\n                round_[_rID].plyr = _playerAddr;\r\n\r\n            // set the new leader bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            }\r\n            // update player\r\n            plyrRnds_[_playerAddr][_rID].keys = (_keys.mul(1).div(100)).add(plyrRnds_[_playerAddr][_rID].keys);\r\n            plyrRnds_[_playerAddr][_rID].eth = plyrRnds_[_playerAddr][_rID].eth.add(_eth);\r\n            plyr_[_playerAddr].eth = plyr_[_playerAddr].eth.add(_eth);\r\n\r\n            // update round\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = round_[_rID].eth.add(_eth);\r\n\r\n\r\n            // distribute keys amongst all\r\n             _eventData_ = distributeInternal(_rID, _playerAddr, _affAddr, _keys, _eventData_);\r\n        }\r\n        // if round is not active and end round needs to be ran\r\n        else if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].ended == false) {\r\n            // end the round (distributes treasure) \u0026 start new round\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            //_eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            // fire buy and distribute event\r\n            emit Events.onReLoadAndDistribute\r\n            (\r\n                msg.sender,\r\n                plyr_[_playerAddr].name,\r\n                _eventData_.compressedData,\r\n               // _eventData_.compressedIDs,\r\n                _eventData_.winnerAddr,\r\n                _eventData_.winnerName,\r\n                _eventData_.amountWon,\r\n                _eventData_.newPot,\r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n\r\n        investors[_playerAddr][investorDistRound] = investors[_playerAddr][investorDistRound].add(eth);\r\n        addInvestor(_playerAddr);\r\n        luckyDraw.add(_playerAddr);\r\n\r\n        //check if its been over a day since the last lucky draw happened\r\n        if (now.sub(lastLuckyDrawTime) \u003e= luckyDrawDuration  \u0026\u0026 luckyDrawEnabled == true){\r\n            //pick a winner and transfer ETH to account\r\n            address luckyDrawWinner = luckyDraw.draw();\r\n            plyr_[luckyDrawWinner].gen = plyr_[luckyDrawWinner].gen.add(luckyDrawVault_);\r\n            lastLuckyDrawAmt = luckyDrawVault_;\r\n            luckyDrawVault_ = 0;\r\n            lastLuckyDrawTime = now;\r\n            emit luckyDrawDeclared(luckyDrawWinner, lastLuckyDrawAmt, now);\r\n        }\r\n\r\n    }\r\n\r\n    function withdrawDividendEarnings()\r\n        isActivated()\r\n        isHuman()\r\n        public\r\n    {\r\n        uint256 _now = now;\r\n        uint256 _rID = rID_;\r\n\r\n        address _playerAddress = msg.sender;\r\n\r\n        // set up our tx event data\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        //Is the round active, then only withdraw can happen\r\n        if (_now \u003e round_[_rID].strt  \u0026\u0026 (_now \u003c= round_[_rID].end || (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].plyr == 0)))\r\n        {\r\n            updateGenVault(_playerAddress, plyr_[_playerAddress].lrnd);\r\n\r\n            uint256 _earnings = plyr_[_playerAddress].gen + plyr_[_playerAddress].win;\r\n\r\n            if(_earnings \u003e 0)\r\n            {\r\n                uint256 _withdrawAmount = (_earnings.div(2)).mul(keyPrice).div(1000000000000000000);\r\n                uint256 _reinvestAmount = _earnings.div(2);\r\n                _earnings = 0;\r\n\r\n                require(address(this).balance \u003e= _withdrawAmount, \"Contract doesn\u0027t have sufficient amount to give you\");\r\n\r\n                playerEarned_[_playerAddress][_rID] = playerEarned_[_playerAddress][_rID].add(plyr_[_playerAddress].gen);\r\n                plyr_[_playerAddress].gen = 0;\r\n                plyr_[_playerAddress].win = 0;\r\n                totalSupply_ = totalSupply_.sub(_reinvestAmount);\r\n\r\n                address(msg.sender).transfer(_withdrawAmount);\r\n                reinvestDividendEarnings(_reinvestAmount);\r\n            }\r\n\r\n            // fire withdraw event\r\n            emit Events.onWithdrawFunds\r\n            (\r\n                msg.sender,\r\n                _withdrawAmount,\r\n                now\r\n            );\r\n\r\n        }\r\n\r\n        // if round is not active and end round needs to be ran\r\n        else if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].ended == false) {\r\n            // end the round (distributes treasure) \u0026 start new round\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            //_eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            // fire buy and distribute event\r\n            emit Events.onReLoadAndDistribute\r\n            (\r\n                msg.sender,\r\n                plyr_[_playerAddress].name,\r\n                _eventData_.compressedData,\r\n               // _eventData_.compressedIDs,\r\n                _eventData_.winnerAddr,\r\n                _eventData_.winnerName,\r\n                _eventData_.amountWon,\r\n                _eventData_.newPot,\r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function withdrawReferralEarnings ()\r\n        isHuman()\r\n        isActivated()\r\n        public\r\n     {\r\n\r\n        address _playerAddress = msg.sender;\r\n        // set up our tx event data\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        require(referralBalance_[_playerAddress] \u003e 0, \"Sorry, you can\u0027t withdraw 0 referral earning\");\r\n\r\n        uint256 _now = now;\r\n        uint256 _rID = rID_;\r\n\r\n        //Is the round active, then only withdraw can happen\r\n        if (_now \u003e round_[_rID].strt  \u0026\u0026 (_now \u003c= round_[_rID].end || (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].plyr == 0)))\r\n        {\r\n            uint256 _earnings = referralBalance_[_playerAddress];\r\n\r\n            if(_earnings \u003e 0)\r\n            {\r\n                uint256 _withdrawAmount = (_earnings.div(2)).mul(keyPrice).div(1000000000000000000);\r\n                uint256 _reinvestAmount = _earnings.div(2);\r\n                _earnings = 0;\r\n\r\n                require(address(this).balance \u003e= _withdrawAmount, \"Contract doesn\u0027t have sufficient amount to give you\");\r\n\r\n                referralBalance_[_playerAddress] = 0;\r\n\r\n                totalSupply_ = totalSupply_.sub(_reinvestAmount);\r\n\r\n                address(msg.sender).transfer(_withdrawAmount);\r\n                reinvestReferralEarnings(_reinvestAmount);\r\n\r\n                // fire withdraw event\r\n                emit Events.onWithdrawFunds\r\n                (\r\n                    msg.sender,\r\n                    _withdrawAmount,\r\n                    now\r\n                );\r\n            }\r\n        }\r\n\r\n        // if round is not active and end round needs to be ran\r\n        else if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].ended == false) {\r\n            // end the round (distributes treasure)\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n\r\n            // fire buy and distribute event\r\n            emit Events.onReLoadAndDistribute\r\n            (\r\n                msg.sender,\r\n                plyr_[_playerAddress].name,\r\n                _eventData_.compressedData,\r\n                _eventData_.winnerAddr,\r\n                _eventData_.winnerName,\r\n                _eventData_.amountWon,\r\n                _eventData_.newPot,\r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n\r\n     }\r\n\r\n     function distributeTopInvestors()\r\n        onlyOwner()\r\n        public\r\n    {\r\n        if (now.sub(lastInvestorDistTime) \u003e= topleaderboardDuration){\r\n\r\n            uint256 totAmt = topInvestorsVault;\r\n            topInvestorsVault = 0;\r\n            investorDistRound = investorDistRound.add(1);\r\n\r\n            address first = topInvestors[0].addr;\r\n            address second  = topInvestors[1].addr;\r\n            address third  = topInvestors[2].addr;\r\n\r\n            plyr_[first].gen = plyr_[first].gen.add(totAmt.mul(50).div(100));\r\n            topInvestors[0].addr = address(0x0);\r\n            topInvestors[0].amt = 0;\r\n\r\n            plyr_[second].gen = plyr_[second].gen.add(totAmt.mul(30).div(100));\r\n            topInvestors[1].addr = address(0x0);\r\n            topInvestors[1].amt = 0;\r\n\r\n            plyr_[third].gen = plyr_[third].gen.add(totAmt.mul(20).div(100));\r\n            topInvestors[2].addr = address(0x0);\r\n            topInvestors[2].amt = 0;\r\n\r\n            lastTopInvestors[0] = first;\r\n            lastTopInvestors[1] = second;\r\n            lastTopInvestors[2] = third;\r\n\r\n            emit topInvestorsDistribute(first, second, third);\r\n        }\r\n        else{\r\n            revert(\"There is still time or a round is running\");\r\n        }\r\n    }\r\n\r\n    function distributeTopPromoters()\r\n        onlyOwner()\r\n        public\r\n    {\r\n        if (now.sub(lastPromoterDistTime) \u003e= topleaderboardDuration){\r\n\r\n            uint256 totAmt = topPromotersVault;\r\n            topPromotersVault = 0;\r\n            investorDistRound = investorDistRound.add(1);\r\n\r\n            address first = topPromoters[0].addr;\r\n            address second  = topPromoters[1].addr;\r\n            address third  = topPromoters[2].addr;\r\n\r\n            plyr_[first].gen = plyr_[first].gen.add(totAmt.mul(50).div(100));\r\n            topPromoters[0].addr = address(0x0);\r\n            topPromoters[0].amt = 0;\r\n\r\n            plyr_[second].gen = plyr_[second].gen.add(totAmt.mul(30).div(100));\r\n            topPromoters[1].addr = address(0x0);\r\n            topPromoters[1].amt = 0;\r\n\r\n            plyr_[third].gen = plyr_[third].gen.add(totAmt.mul(20).div(100));\r\n            topPromoters[2].addr = address(0x0);\r\n            topPromoters[2].amt = 0;\r\n\r\n            lastTopPromoters[0] = first;\r\n            lastTopPromoters[1] = second;\r\n            lastTopPromoters[2] = third;\r\n\r\n            emit topPromotersDistribute(first, second, third);\r\n\r\n        }\r\n        else{\r\n            revert(\"There is still time.\");\r\n        }\r\n    }\r\n\r\n    function addPromoter(address _add)\r\n        isActivated()\r\n        private\r\n        returns (bool)\r\n    {\r\n        if (_add == address(0x0)){\r\n            return false;\r\n        }\r\n\r\n        uint256 _amt = promoters[_add][promoterDistRound];\r\n        // if the amount is less than the last on the leaderboard, reject\r\n        if (topPromoters[2].amt \u003e= _amt){\r\n            return false;\r\n        }\r\n\r\n        address firstAddr = topPromoters[0].addr;\r\n        uint256 firstAmt = topPromoters[0].amt;\r\n        address secondAddr = topPromoters[1].addr;\r\n        uint256 secondAmt = topPromoters[1].amt;\r\n\r\n\r\n        // if the user should be at the top\r\n        if (_amt \u003e topPromoters[0].amt){\r\n\r\n            if (topPromoters[0].addr == _add){\r\n                topPromoters[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else{\r\n                firstAddr = topPromoters[0].addr;\r\n                firstAmt = topPromoters[0].amt;\r\n                secondAddr = topPromoters[1].addr;\r\n                secondAmt = topPromoters[1].amt;\r\n\r\n                topPromoters[0].addr = _add;\r\n                topPromoters[0].amt = _amt;\r\n                topPromoters[1].addr = firstAddr;\r\n                topPromoters[1].amt = firstAmt;\r\n                topPromoters[2].addr = secondAddr;\r\n                topPromoters[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n        }\r\n        // if the user should be at the second position\r\n        else if (_amt \u003e= topPromoters[1].amt){\r\n\r\n            if (topPromoters[0].addr == _add){\r\n                topPromoters[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topPromoters[1].addr == _add){\r\n                topPromoters[1].amt = _amt;\r\n                return true;\r\n            }\r\n            else{\r\n                secondAddr = topPromoters[1].addr;\r\n                secondAmt = topPromoters[1].amt;\r\n\r\n                topPromoters[1].addr = _add;\r\n                topPromoters[1].amt = _amt;\r\n                topPromoters[2].addr = secondAddr;\r\n                topPromoters[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n\r\n        }\r\n        // if the user should be at the third position\r\n        else if (_amt \u003e= topPromoters[2].amt){\r\n\r\n            if (topPromoters[0].addr == _add){\r\n                topPromoters[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topPromoters[1].addr == _add){\r\n                topPromoters[1].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topPromoters[2].addr == _add){\r\n                topPromoters[2].amt = _amt;\r\n                return true;\r\n            }\r\n            else{\r\n                topPromoters[2].addr = _add;\r\n                topPromoters[2].amt = _amt;\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function addInvestor(address _add)\r\n        isActivated()\r\n        private\r\n        returns (bool)\r\n    {\r\n        if (_add == address(0x0)){\r\n            return false;\r\n        }\r\n\r\n        uint256 _amt = investors[_add][investorDistRound];\r\n        // if the amount is less than the last on the leaderboard, reject\r\n        if (topInvestors[2].amt \u003e= _amt){\r\n            return false;\r\n        }\r\n\r\n        address firstAddr = topInvestors[0].addr;\r\n        uint256 firstAmt = topInvestors[0].amt;\r\n        address secondAddr = topInvestors[1].addr;\r\n        uint256 secondAmt = topInvestors[1].amt;\r\n\r\n        // if the user should be at the top\r\n        if (_amt \u003e topInvestors[0].amt){\r\n\r\n            if (topInvestors[0].addr == _add){\r\n                topInvestors[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else{\r\n                firstAddr = topInvestors[0].addr;\r\n                firstAmt = topInvestors[0].amt;\r\n                secondAddr = topInvestors[1].addr;\r\n                secondAmt = topInvestors[1].amt;\r\n\r\n                topInvestors[0].addr = _add;\r\n                topInvestors[0].amt = _amt;\r\n                topInvestors[1].addr = firstAddr;\r\n                topInvestors[1].amt = firstAmt;\r\n                topInvestors[2].addr = secondAddr;\r\n                topInvestors[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n        }\r\n        // if the user should be at the second position\r\n        else if (_amt \u003e= topInvestors[1].amt){\r\n\r\n            if (topInvestors[0].addr == _add){\r\n                topInvestors[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topInvestors[1].addr == _add){\r\n                topInvestors[1].amt = _amt;\r\n                return true;\r\n            }\r\n            else{\r\n                secondAddr = topInvestors[1].addr;\r\n                secondAmt = topInvestors[1].amt;\r\n\r\n                topInvestors[1].addr = _add;\r\n                topInvestors[1].amt = _amt;\r\n                topInvestors[2].addr = secondAddr;\r\n                topInvestors[2].amt = secondAmt;\r\n                return true;\r\n            }\r\n\r\n        }\r\n        // if the user should be at the third position\r\n        else if (_amt \u003e= topInvestors[2].amt){\r\n\r\n            if (topInvestors[0].addr == _add){\r\n                topInvestors[0].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topInvestors[1].addr == _add){\r\n                topInvestors[1].amt = _amt;\r\n                return true;\r\n            }\r\n            else if (topInvestors[2].addr == _add){\r\n                topInvestors[2].amt = _amt;\r\n                return true;\r\n            }\r\n            else{\r\n                topInvestors[2].addr = _add;\r\n                topInvestors[2].amt = _amt;\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function purchaseViaName(bytes32 _affName)\r\n        isHuman()\r\n        isActivated()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        //  set up our tx event data and determine if player is new or not\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        // fetch player id\r\n        address _playerAddr = msg.sender;\r\n        address _affAddr = pAddrxName[_affName];\r\n\r\n        // purchase core\r\n        purchaseCore(_playerAddr, _affAddr, _eventData_);\r\n    }\r\n\r\n    function purchaseCore(address _playerAddr, address _affAddr, DataStructs.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        // Check if round is active\r\n        if (_now \u003e round_[_rID].strt \u0026\u0026 (_now \u003c= round_[_rID].end || (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].plyr == 0)))\r\n        {\r\n            // call core\r\n\r\n             coreLogic(_rID, _playerAddr, msg.value, _affAddr, _eventData_);\r\n\r\n\r\n        // if round is not active\r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].ended == false)\r\n            {\r\n                // end the round (distributes pot) \u0026 start new round\r\n\t\t\t    round_[_rID].ended = true;\r\n                  _eventData_ = endRound(_eventData_);\r\n\r\n                // build event data\r\n                 _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n\r\n                 // // fire buy and distribute event\r\n                emit onRoundEnd\r\n                (\r\n                    _eventData_,\r\n                    msg.sender,\r\n                    _eventData_.compressedIDs,\r\n                    _eventData_.newPot,\r\n                    msg.value,\r\n                    _eventData_.genAmount\r\n                );\r\n\r\n            }\r\n\r\n            // Send back the eth\r\n            address(_playerAddr).transfer(msg.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev this is the core logic for any purchase that happens while a round\r\n     * is live.\r\n     */\r\n    function coreLogic(uint256 _rID, address _playerAddr, uint256 _eth, address _affAddr, DataStructs.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        // if player is new to round\r\n        if (plyrRnds_[_playerAddr][_rID].keys == 0) {\r\n            _eventData_ = managePlayer(_playerAddr, _eventData_);\r\n            round_[_rID].playerCounter = round_[_rID].playerCounter + 1;\r\n        }\r\n\r\n\r\n        uint256 amountToExternalWallet = _eth.div(2);\r\n        address(externalWallet).transfer(amountToExternalWallet);\r\n\r\n        // mint the new keys\r\n        uint256 _keys = keysRec(_eth);\r\n\r\n        // if they bought at least 1 whole key\r\n        if (_keys \u003e= 1000000000000000000)\r\n        {\r\n            updateTimer(_keys, _rID);\r\n\r\n            // set new leaders\r\n            if (round_[_rID].plyr != _playerAddr)\r\n                round_[_rID].plyr = _playerAddr;\r\n\r\n            // set the new leader bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 100;\r\n        }\r\n\r\n\r\n\r\n        // update player\r\n         plyrRnds_[_playerAddr][_rID].keys = (_keys.mul(1).div(100)).add(plyrRnds_[_playerAddr][_rID].keys);\r\n         plyrRnds_[_playerAddr][_rID].eth = _eth.add(plyrRnds_[_playerAddr][_rID].eth);\r\n         plyr_[_playerAddr].eth = plyr_[_playerAddr].eth.add(_eth);\r\n\r\n        // update round\r\n        round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n        round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n\r\n        // distribute keys amongst all\r\n\r\n        _eventData_ = distributeInternal(_rID, _playerAddr, _affAddr, _keys, _eventData_);\r\n\r\n        investors[_playerAddr][investorDistRound] = investors[_playerAddr][investorDistRound].add(_eth);\r\n        addInvestor(_playerAddr);\r\n        luckyDraw.add(_playerAddr);\r\n\r\n        //check if its been over a day since the last lucky draw happened\r\n        if (now.sub(lastLuckyDrawTime) \u003e= luckyDrawDuration  \u0026\u0026 luckyDrawEnabled == true){\r\n\r\n            //pick a winner and transfer ETH to account\r\n            address luckyDrawWinner = luckyDraw.draw();\r\n            plyr_[luckyDrawWinner].gen = plyr_[luckyDrawWinner].gen.add(luckyDrawVault_);\r\n            lastLuckyDrawAmt = luckyDrawVault_;\r\n            luckyDrawVault_ = 0;\r\n            lastLuckyDrawTime = now;\r\n            emit luckyDrawDeclared(luckyDrawWinner, lastLuckyDrawAmt, now);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev distributes eth based on fees to gen and pot\r\n     */\r\n    function distributeInternal(uint256 _rID, address _playerAddr, address _affAddr, uint256 _keys, DataStructs.EventReturns memory _eventData_)\r\n        private\r\n        returns(DataStructs.EventReturns)\r\n    {\r\n        // calculate keys Holder\u0027s share to be distributed as dividends(61%)\r\n        uint256 _keyHolderShare = (_keys.mul(keyHolderFees_)) .div(100);\r\n\r\n        //admin share is 3%\r\n        uint256 _adminShare = (_keys.mul(3)).div(100);\r\n        adminKeyVault_ = adminKeyVault_.add(_adminShare);\r\n\r\n        // distribute share to affiliate 12%\r\n        uint256 _affShare = (_keys.mul(12)).div(100);\r\n\r\n        // calculate treasure Amount (20%)\r\n        uint256 _treasureAmount = _keys.mul(treasureAmount_).div(100);\r\n\r\n        // update the top leaderboard vaults\r\n        topPromotersVault = topPromotersVault.add(_keys.div(100));\r\n        topInvestorsVault = topInvestorsVault.add(_keys.div(100));\r\n\r\n        // Calculate amount given to the person(investor)\r\n        uint256 _investorAmount = _keys.mul(1).div(100);\r\n        plyr_[_playerAddr].keys = plyr_[_playerAddr].keys.add(_investorAmount);\r\n\r\n        totalSupply_ = totalSupply_.add(_keys);\r\n\r\n        //increase lucky draw allowance\r\n        luckyDrawVault_ = luckyDrawVault_.add(_keys.div(100));\r\n\r\n        // decide what to do with affiliate share of fees\r\n         calculateReferralBonus(_affShare,_affAddr,_playerAddr);\r\n\r\n\r\n        if (round_[_rID].playerCounter == 1)\r\n        {\r\n            round_[_rID].treasure = _keyHolderShare.add(round_[_rID].treasure);\r\n            tokenInvestorsSupply_ = tokenInvestorsSupply_.add(_investorAmount);\r\n        }\r\n        else\r\n        {\r\n            //distribute gen share (thats what updateMasks() does) and adjust\r\n            updateMasks(_rID, _playerAddr, _keyHolderShare, _investorAmount);\r\n            //Updating the total keys a investor has received, to calculate the mask value.\r\n            tokenInvestorsSupply_ = tokenInvestorsSupply_.add(_investorAmount);\r\n        }\r\n\r\n        // add keys to treasure\r\n        round_[_rID].treasure = _treasureAmount.add(round_[_rID].treasure);\r\n\r\n        // set up event data\r\n        _eventData_.genAmount = _keyHolderShare.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _treasureAmount;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev decides if round end needs to be run \u0026 new round started.  and if\r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n    function managePlayer(address _pAddress, DataStructs.EventReturns memory _eventData_)\r\n        private\r\n        returns (DataStructs.EventReturns)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to dividends vault.\r\n        if (plyr_[_pAddress].lrnd != 0)\r\n        {\r\n            updateGenVault(_pAddress, plyr_[_pAddress].lrnd);\r\n\r\n            // update player\u0027s last round played\r\n\r\n            plyr_[_pAddress].gen = plyr_[_pAddress].gen.add(plyr_[_pAddress].keys);\r\n\r\n            plyr_[_pAddress].keys = 0;\r\n        }\r\n\r\n        plyr_[_pAddress].lrnd = rID_;\r\n\r\n        // set the joined round bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n     /**\r\n     * @dev ends the round. manages paying out winner/splitting up pot\r\n     */\r\n    function endRound(DataStructs.EventReturns memory _eventData_)\r\n        private\r\n        returns (DataStructs.EventReturns)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab our winning player\r\n        address _winPAddress = round_[_rID].plyr;\r\n\r\n        // grab our treasure amount\r\n        uint256 _treasure = round_[_rID].treasure;\r\n\r\n        // calculate our winner share, community rewards, gen share,\r\n        // and amount reserved for next pot\r\n        uint256 _winnerAmount = (_treasure.mul(40)) / 100;\r\n        uint256 _adminAmount = (_treasure.mul(19)) / 100;\r\n        uint256 _toCurrentHolders = (_treasure.mul(40)) / 100;\r\n        uint256 _toNextRound = _treasure.div(100);\r\n\r\n        // calculate ppt for round mask\r\n        uint256 _ppt = (_toCurrentHolders.mul(1000000000000000000)) / (tokenInvestorsSupply_);\r\n\r\n\r\n        // pay our winner\r\n        plyr_[_winPAddress].win = _winnerAmount.add(plyr_[_winPAddress].win);\r\n\r\n        // Admin share\r\n        adminKeyVault_ = adminKeyVault_.add(_adminAmount);\r\n\r\n        // distribute gen portion to key holders\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n        // Prepare event data\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.winnerAddr = plyr_[_winPAddress].addr;\r\n        _eventData_.winnerName = plyr_[_winPAddress].name;\r\n        _eventData_.amountWon = _winnerAmount;\r\n        _eventData_.genAmount = _toCurrentHolders;\r\n        _eventData_.newPot = _toNextRound;\r\n\r\n        activated_ = false;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    /**\r\n     * @dev start next round\r\n     */\r\n    function startNextRound()\r\n        public\r\n        onlyOwner()\r\n    {\r\n\r\n        //setup local round id\r\n        uint256 _rID = rID_;\r\n\r\n        uint256 _now = now;\r\n\r\n         // set up our tx event data\r\n        DataStructs.EventReturns memory _eventData_ = _eventData_;\r\n\r\n        //check if end round needs to be ran\r\n        if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].ended == false)\r\n        {\r\n             // end the round (distributes treasure) \u0026 start new round\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            // build event data\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n        }\r\n\r\n\r\n        require(activated_ == false, \"round is already runnning.\");\r\n\r\n\r\n        uint256 _treasure = round_[_rID].treasure;\r\n        uint256 _toNextRound = _treasure.div(100);\r\n\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndInit_);\r\n        round_[_rID].treasure = _toNextRound;\r\n\r\n\r\n        activated_ = true;\r\n\r\n        emit nextRoundStarted(rID_, round_[_rID].strt, round_[_rID].end);\r\n    }\r\n\r\n     /**\r\n     * @dev last declared winner of lucky draw\r\n     */\r\n    function getLastLuckyDrawWinner()\r\n        public\r\n        view\r\n        returns(address winner)\r\n    {\r\n        return luckyDraw.getWinner();\r\n    }\r\n\r\n    /**\r\n     * @dev update lucky draw contract address\r\n     */\r\n    function updateLuckDrawContract(address _contractAddress)\r\n        public\r\n        onlyOwner()\r\n    {\r\n        luckyDraw = LuckyDraw(_contractAddress);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(address _pAddress, uint256 _rIDlast)\r\n        private\r\n    {\r\n\r\n        uint256 _earnings;\r\n        uint256 _extraEarnings;\r\n        (_earnings, _extraEarnings) = calcUnMaskedEarnings(_pAddress, _rIDlast);\r\n\r\n        if (_earnings \u003e 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pAddress].gen = _earnings.add(plyr_[_pAddress].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pAddress][_rIDlast].mask = _earnings.add(plyrRnds_[_pAddress][_rIDlast].mask);\r\n\r\n            //assign extra earnings to admin\r\n            adminKeyVault_ = adminKeyVault_.add(_extraEarnings);\r\n            playerExtraEarnings_[_pAddress][_rIDlast] = playerExtraEarnings_[_pAddress][_rIDlast].add(_extraEarnings);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev updates round timer based on number of whole keys bought.\r\n     */\r\n    function updateTimer(uint256 _keys, uint256 _rID)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n\r\n        // compare to max and set new end time\r\n        if (_newTime \u003c (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n\r\n    function registerName(string _nameString)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _plyrAddress = msg.sender;\r\n\r\n        require(pAddrxName[_name] == address(0x0), \"Name already registered\");\r\n\r\n        _owner.transfer(msg.value);\r\n\r\n        pAddrxName[_name] = _plyrAddress;\r\n        plyr_[_plyrAddress].name = _name;\r\n\r\n        // fire event\r\n        emit Events.newName(_plyrAddress, _name, msg.value, now);\r\n    }\r\n\r\n    function getPlayerName(address _add)\r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return plyr_[_add].name;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev updates masks for round and player when keys are bought\r\n     * @return dust left over\r\n     */\r\n    function updateMasks(uint256 _rID, address _playerAddr, uint256 _gen, uint256 _investorAmount)\r\n        private\r\n        //returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here.  is were going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n\r\n            the player will have an additional mask that basically says \"based\r\n            on the rounds mask, my shares, and how much i\u0027ve already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n\r\n            // calc profit per key \u0026 round mask based on this buy:  (dust goes to pot)\r\n            uint256 _ppt = (_gen.mul(1000000000000000000)) / (tokenInvestorsSupply_);\r\n            round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n            // calculate player earning from their own buy (only based on the keys\r\n            // they just bought).  \u0026 update player earnings mask\r\n\r\n            plyrRnds_[_playerAddr][_rID].mask = ((round_[_rID].mask.mul(_investorAmount)) / (1000000000000000000)).add(plyrRnds_[_playerAddr][_rID].mask);\r\n\r\n     }\r\n\r\n\r\n    function transferFundsToSmartContract()\r\n    public\r\n    onlyExternalWallet()\r\n    payable {\r\n\r\n    }\r\n\r\n    function overtimeWithdraw()\r\n    public\r\n    onlyOwner()\r\n    returns (bool){\r\n\r\n        uint256 _now = now;\r\n        uint256 _rID = rID_;\r\n\r\n         if (_now \u003e round_[_rID].end \u0026\u0026 round_[_rID].ended == true)\r\n            {\r\n                if ((_now.sub(round_[_rID].end)) \u003e= 30 days )\r\n                {\r\n                    address(externalWallet).transfer(address(this).balance);\r\n                    return true;\r\n                }\r\n            }\r\n        return false;\r\n\r\n    }\r\n\r\n    function withdrawTokensByAdmin()\r\n    public\r\n    onlyOwner() {\r\n        uint256 withdrawEthAmount  = adminKeyVault_.mul(keyPrice).div(1000000000000000000);\r\n\r\n        //Check whether sufficient funds are there\r\n        require(address(this).balance \u003e= withdrawEthAmount,\"Not sufficient balance in smart contract\");\r\n\r\n        //reduce the withdrawal amount from total supply\r\n        totalSupply_ = totalSupply_.sub(adminKeyVault_);\r\n\r\n        adminKeyVault_ = 0;\r\n\r\n        // transfer eth to admin\u0027s address\r\n        address(_owner).transfer(withdrawEthAmount);\r\n    }\r\n\r\n    function keysRec(uint256 _newEth)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return(_newEth.div(keyPrice).mul(1000000000000000000)); //considereing 18 decimals for the key\r\n    }\r\n\r\n    function calculateReferralBonus(uint256 _referralBonus, address _referredBy, address _playerAddr) private returns(bool) {\r\n\r\n        if(\r\n            // is this a referred purchase?\r\n            _referredBy != 0x0000000000000000000000000000000000000000 \u0026\u0026\r\n\r\n            // Ohoo noo, you can\u0027t refer yourself buddy :P\r\n            _referredBy != _playerAddr\r\n        )\r\n        {\r\n            //If the user has already been referred by someone previously, can\u0027t be referred by someone else\r\n            if(firstReferrer[msg.sender] != 0x0000000000000000000000000000000000000000) {\r\n                    _referredBy  = firstReferrer[msg.sender];\r\n            }\r\n            else {\r\n                firstReferrer[msg.sender] = _referredBy;\r\n            }\r\n\r\n        //check for second referrer\r\n            if(firstReferrer[_referredBy] != 0x0000000000000000000000000000000000000000)\r\n            {\r\n                address _secondReferrer = firstReferrer[_referredBy];\r\n                //check for third referrer\r\n                if(firstReferrer[_secondReferrer] != 0x0000000000000000000000000000000000000000) {\r\n                    address _thirdReferrer = firstReferrer[_secondReferrer];\r\n\r\n                    //transfer 1% of total referral commission to third referrer\r\n                    referralBalance_[_thirdReferrer] = referralBalance_[_thirdReferrer].add(_referralBonus.mul(1).div(12));\r\n\r\n                    //transfer 3% of total referral commission to second referrer\r\n                    referralBalance_[_secondReferrer] = referralBalance_[_secondReferrer].add(_referralBonus.mul(3).div(12));\r\n\r\n                    //transfer 8% of total referral commission to first referrer\r\n                    referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus.mul(8).div(12));\r\n\r\n\r\n                }\r\n                //No Third Referrer then transfer to first and second referrer and to Admin\r\n                else {\r\n                    //transfer 3% of total referral commission to second referrer\r\n                    referralBalance_[_secondReferrer] = referralBalance_[_secondReferrer].add(_referralBonus.mul(3).div(12));\r\n                    //transfer 8% of total referral commission to first referrer\r\n                    referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus.mul(8).div(12));\r\n\r\n                    //transfer 1% to admin\r\n                    adminKeyVault_ = adminKeyVault_.add(_referralBonus.mul(1).div(12));\r\n\r\n                }\r\n            } //no second referrer then transfer 8% to the first referrer and rest 4% to admin\r\n            else {\r\n                referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus.mul(8).div(12));\r\n\r\n                //transfer 4% to admin\r\n                adminKeyVault_ = adminKeyVault_.add(_referralBonus.mul(4).div(12));\r\n            }\r\n\r\n            promoters[_referredBy][promoterDistRound] = promoters[_referredBy][promoterDistRound].add(_referralBonus.div(12).mul(100));\r\n            addPromoter(_referredBy);\r\n            return true;\r\n    }\r\n\r\n    //might be possible that the referrer is 0x0 but previously someone has referred the user\r\n    else if(\r\n            //0x0 coming from the UI\r\n            _referredBy == 0x0000000000000000000000000000000000000000 \u0026\u0026\r\n\r\n            //check if the somone has previously referred the user\r\n            firstReferrer[msg.sender] != 0x0000000000000000000000000000000000000000\r\n\r\n        )\r\n        {\r\n           //check for second referrer\r\n            if(firstReferrer[_referredBy] != 0x0000000000000000000000000000000000000000)\r\n            {\r\n                address _secondReferrer1 = firstReferrer[_referredBy];\r\n                //check for third referrer\r\n                if(firstReferrer[_secondReferrer1] != 0x0000000000000000000000000000000000000000) {\r\n                    address _thirdReferrer1 = firstReferrer[_secondReferrer1];\r\n\r\n                    //transfer 1% of total referral commission to third referrer\r\n                    referralBalance_[_thirdReferrer1] = referralBalance_[_thirdReferrer1].add(_referralBonus.mul(1).div(12));\r\n\r\n                    //transfer 3% of total referral commission to second referrer\r\n                    referralBalance_[_secondReferrer] = referralBalance_[_secondReferrer].add(_referralBonus.mul(3).div(12));\r\n\r\n                    //transfer 8% of total referral commission to first referrer\r\n                    referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus.mul(8).div(12));\r\n\r\n                }\r\n                //No Third Referrer then transfer to first and second referrer\r\n                else {\r\n                    //transfer 3% of total referral commission to second referrer\r\n                    referralBalance_[_secondReferrer] = referralBalance_[_secondReferrer].add(_referralBonus.mul(3).div(12));\r\n                    //transfer 8% of total referral commission to first referrer\r\n                    referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus.mul(8).div(12));\r\n\r\n                    //transfer 1% to admin\r\n                    adminKeyVault_ = adminKeyVault_.add(_referralBonus.mul(1).div(12));\r\n                }\r\n            } //no second referrer then transfer all to the first referrer\r\n            else {\r\n                referralBalance_[_referredBy] = referralBalance_[_referredBy].add(_referralBonus.mul(8).div(12));\r\n\r\n                //transfer 4% to admin\r\n                adminKeyVault_ = adminKeyVault_.add(_referralBonus.mul(4).div(12));\r\n            }\r\n            promoters[_referredBy][promoterDistRound] = promoters[_referredBy][promoterDistRound].add(_referralBonus.div(12).mul(100));\r\n            addPromoter(_referredBy);\r\n            return true;\r\n        }\r\n\r\n        else {\r\n            // Transfer all 12% to Admin\r\n            adminKeyVault_ = adminKeyVault_.add(_referralBonus);\r\n        }\r\n        return false;\r\n\r\n\r\n     }\r\n\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs\r\n     * have time to set things up on the web end                   **/\r\n    bool public activated_ = false;\r\n    function activate()\r\n        public\r\n    {\r\n        // only admin  just can activate\r\n        require(msg.sender == _owner, \"only admin can activate\");\r\n\r\n\r\n        // if round 1 has already finished.\r\n        require(rID_ == 0, \"This is not the first round, please click startNextRound() to start new round\");\r\n\r\n        // can only be ran once\r\n        require(activated_ == false, \"Golden Kingdom already activated\");\r\n\r\n        // activate the contract\r\n        activated_ = true;\r\n\r\n        // let\u0027s start the first round\r\n        rID_ = 1;\r\n            round_[1].strt = now ;\r\n            round_[1].end = now + rndInit_ ;\r\n    }\r\n//----------------------------------------------------------------------------------------------//\r\n//                                  READ ONLY FUNCTIONS\r\n//----------------------------------------------------------------------------------------------//\r\n\r\n    function getReferralBalance(address referralAddress)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n    return referralBalance_[referralAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev calculates unmasked earnings (just calculates, does not update mask)\r\n     * @return earnings in wei format\r\n     */\r\n    function calcUnMaskedEarnings(address _pAddress, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256, uint256)\r\n    {\r\n        uint256 _earnings =   (((round_[_rIDlast].mask).mul(plyrRnds_[_pAddress][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pAddress][_rIDlast].mask).sub(playerExtraEarnings_[_pAddress][_rIDlast]);\r\n        uint256 _playerMaxEarningCap = (plyrRnds_[_pAddress][rID_].eth.mul(2)).div(keyPrice).mul(1000000000000000000);\r\n\r\n        if\r\n            (\r\n               (_earnings.add(playerEarned_[_pAddress][_rIDlast]).add(plyr_[_pAddress].keys)) \u003e= _playerMaxEarningCap\r\n            )\r\n            return(\r\n                    _playerMaxEarningCap.sub((playerEarned_[_pAddress][_rIDlast]).add((plyr_[_pAddress].keys))),\r\n                   _earnings.sub(_playerMaxEarningCap).add((playerEarned_[_pAddress][_rIDlast]).add((plyr_[_pAddress].keys)))\r\n                  );\r\n        else\r\n            return(_earnings, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev returns player info based on address.  if no address is given, it will\r\n     * use msg.sender\r\n     * -functionhash- 0xee0b5d8b\r\n     * @param _playerAddr address of the player you want to lookup\r\n     * @return player name\r\n     * @return keys owned (current round)\r\n     * @return winnings vault\r\n     * @return general vault\r\n     * @return affiliate vault\r\n\t * @return player round eth\r\n     */\r\n    function getPlayerInfoByAddress(address _playerAddr)\r\n        public\r\n        view\r\n        returns( uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n\r\n       // setup local rID\r\n        //uint256 _rID = rID_;\r\n\r\n        uint256 _earnings;\r\n        uint256 _extraEarnings;\r\n\r\n        (_earnings, _extraEarnings) = calcUnMaskedEarnings(_playerAddr, plyr_[_playerAddr].lrnd);\r\n\r\n        if(rID_ == plyr_[_playerAddr].lrnd)\r\n        {\r\n            return\r\n            (  plyrRnds_[_playerAddr][rID_].keys,         //1\r\n                plyr_[_playerAddr].win,                    //2\r\n                (plyr_[_playerAddr].gen).add(_earnings),       //3\r\n                referralBalance_[_playerAddr],                    //4\r\n                plyrRnds_[_playerAddr][rID_].eth           //5\r\n            );\r\n        }\r\n        else\r\n        {\r\n            return\r\n            (  plyrRnds_[_playerAddr][rID_].keys,         //1\r\n                plyr_[_playerAddr].win,                    //2\r\n                (plyr_[_playerAddr].gen).add(_earnings).add(plyr_[_playerAddr].keys),       //3\r\n                referralBalance_[_playerAddr],                    //4\r\n                plyrRnds_[_playerAddr][rID_].eth           //5\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev returns time left.  dont spam this, you\u0027ll ddos yourself from your node\r\n     * provider\r\n     * -functionhash- 0xc7e284b8\r\n     * @return time left in seconds\r\n     */\r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n\r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        if (_now \u003c round_[_rID].end)\r\n            if (_now \u003e round_[_rID].strt )\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].strt ).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n\r\n}\r\n\r\nlibrary DataStructs {\r\n    //compressedData key\r\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\r\n        // 0 - new player (bool)\r\n        // 1 - joined round (bool)\r\n        // 2 - new  leader (bool)\r\n        // 3-5 - air drop tracker (uint 0-999)\r\n        // 6-16 - round end time\r\n        // 17 - winnerTeam\r\n        // 18 - 28 timestamp\r\n        // 29 - team\r\n        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\r\n        // 31 - airdrop happened bool\r\n        // 32 - airdrop tier\r\n        // 33 - airdrop amount won\r\n    //compressedIDs key\r\n    // [77-52][51-26][25-0]\r\n        // 0-25 - pID\r\n        // 26-51 - winPID\r\n        // 52-77 - rID\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n     }\r\n    struct Player {\r\n        address addr;       // player address\r\n        bytes32 name;       // player name\r\n        uint256 win;        // winnings vault\r\n        uint256 gen;        // Keys as dividends\r\n        uint256 lrnd;       // last round played\r\n        uint256 keys;       // keys player has got with his purchase\r\n        uint256 eth;        // Amount invested by player\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask\r\n    }\r\n    struct Round {\r\n        address plyr;   // playerAddr of player in lead\r\n        uint256 playerCounter;   // Number of players in a round\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 treasure;    // keys in trasure (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n    }\r\n}\r\n\r\n// interface PlayerBookInterface {\r\n//     function getPlayerID(address _addr) external returns (uint256);\r\n//     function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n//     function getPlayerAddr(uint256 _pID) external view returns (address);\r\n//     function getNameFee() external view returns (uint256);\r\n//     function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n//     function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n//     function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n// }\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.\r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x\r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length \u003c= 32 \u0026\u0026 _length \u003e 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 \u0026\u0026 _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert \u0026 check\r\n        for (uint256 i = 0; i \u003c _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] \u003e 0x40 \u0026\u0026 _temp[i] \u003c 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                    // OR lowercase a-z\r\n                    (_temp[i] \u003e 0x60 \u0026\u0026 _temp[i] \u003c 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] \u003e 0x2f \u0026\u0026 _temp[i] \u003c 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                 // see if we have a character other than a number\r\n                if (_hasNonNumber == false \u0026\u0026 (_temp[i] \u003c 0x30 || _temp[i] \u003e 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n     * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n}\r\n"},"LuckyDraw.sol":{"content":"pragma solidity ^0.4.24;\r\n\r\ncontract LuckyDraw {\r\n    address public admin;\r\n    address[] private players;\r\n    address private winner;\r\n\r\n    constructor() public{\r\n        admin = msg.sender;\r\n        winner = address(0x0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == admin, \"Only Admin\");\r\n        _;\r\n    }\r\n\r\n    function random()\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(block.difficulty, now, players)));\r\n    }\r\n\r\n    function add(address _plyrAddr)\r\n        public\r\n    {\r\n        players.push(_plyrAddr);\r\n    }\r\n\r\n    function draw()\r\n        public\r\n        returns (address)\r\n    {\r\n        winner =  players[random() % players.length];\r\n        players = new address[](0);\r\n        return winner;\r\n    }\r\n\r\n    function getPlayers()\r\n        public\r\n        view\r\n        returns(address[])\r\n    {\r\n        return players;\r\n    }\r\n    function getPlayersCount()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return players.length;\r\n    }\r\n    function getWinner()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return winner;\r\n    }\r\n}\r\n"}}