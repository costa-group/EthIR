{"ApprovalChain.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IFactRegistry.sol\";\nimport \"IQueryableFactRegistry.sol\";\nimport \"Identity.sol\";\nimport \"MApprovalChain.sol\";\nimport \"MFreezable.sol\";\nimport \"MGovernance.sol\";\nimport \"Common.sol\";\nimport \"MainStorage.sol\";\n\n/*\n  Implements a data structure that supports instant registration\n  and slow time-locked removal of entries.\n*/\ncontract ApprovalChain is MainStorage, MApprovalChain, MGovernance, MFreezable {\n\n    using Addresses for address;\n\n    function addEntry(\n        ApprovalChainData storage chain, address entry, uint256 maxLength, string memory identifier)\n        internal\n        onlyGovernance()\n        notFrozen()\n    {\n        address[] storage list = chain.list;\n        require(entry.isContract(), \"ADDRESS_NOT_CONTRACT\");\n        bytes32 hash_real = keccak256(abi.encodePacked(Identity(entry).identify()));\n        bytes32 hash_identifier = keccak256(abi.encodePacked(identifier));\n        require(hash_real == hash_identifier, \"UNEXPECTED_CONTRACT_IDENTIFIER\");\n        require(list.length \u003c maxLength, \"CHAIN_AT_MAX_CAPACITY\");\n        require(findEntry(list, entry) == ENTRY_NOT_FOUND, \"ENTRY_ALREADY_EXISTS\");\n\n        // Verifier must have at least one fact registered before adding to chain,\n        // unless it\u0027s the first verifier in te chain.\n        require(\n            list.length == 0 || IQueryableFactRegistry(entry).hasRegisteredFact(),\n            \"ENTRY_NOT_ENABLED\");\n        chain.list.push(entry);\n        chain.unlockedForRemovalTime[entry] = 0;\n    }\n\n    function findEntry(address[] storage list, address entry)\n        internal view returns (uint256)\n    {\n        uint256 n_entries = list.length;\n        for (uint256 i = 0; i \u003c n_entries; i++) {\n            if (list[i] == entry) {\n                return i;\n            }\n        }\n\n        return ENTRY_NOT_FOUND;\n    }\n\n\n    function safeFindEntry(address[] storage list, address entry)\n        internal view returns (uint256 idx)\n    {\n        idx = findEntry(list, entry);\n\n        require(idx != ENTRY_NOT_FOUND, \"ENTRY_DOES_NOT_EXIST\");\n    }\n\n    function announceRemovalIntent(\n        ApprovalChainData storage chain, address entry, uint256 removalDelay)\n        internal\n        onlyGovernance()\n        notFrozen()\n    {\n        safeFindEntry(chain.list, entry);\n        require(now + removalDelay \u003e now, \"INVALID_REMOVAL_DELAY\");\n        // solium-disable-next-line security/no-block-members\n        chain.unlockedForRemovalTime[entry] = now + removalDelay;\n    }\n\n\n    function removeEntry(ApprovalChainData storage chain, address entry)\n        internal\n        onlyGovernance()\n        notFrozen()\n    {\n        address[] storage list = chain.list;\n        // Make sure entry exists.\n        uint256 idx = safeFindEntry(list, entry);\n        uint256 unlockedForRemovalTime = chain.unlockedForRemovalTime[entry];\n\n        // solium-disable-next-line security/no-block-members\n        require(unlockedForRemovalTime \u003e 0, \"REMOVAL_NOT_ANNOUNCED\");\n        // solium-disable-next-line security/no-block-members\n        require(now \u003e= unlockedForRemovalTime, \"REMOVAL_NOT_ENABLED_YET\");\n\n        uint256 n_entries = list.length;\n\n        // Removal of last entry is forbidden.\n        require(n_entries \u003e 1, \"LAST_ENTRY_MAY_NOT_BE_REMOVED\");\n\n        if (idx != n_entries - 1) {\n            list[idx] = list[n_entries - 1];\n        }\n        list.pop();\n    }\n\n    function verifyFact(\n        ApprovalChainData storage chain, bytes32 fact, string memory noVerifiersErrorMessage,\n        string memory invalidFactErrorMessage)\n        internal view\n    {\n        address[] storage list = chain.list;\n        uint256 n_entries = list.length;\n        require(n_entries \u003e 0, noVerifiersErrorMessage);\n        for (uint256 i = 0; i \u003c n_entries; i++) {\n            require(IFactRegistry(list[i]).isValid(fact), invalidFactErrorMessage);\n        }\n    }\n}\n"},"AvailabilityVerifiers.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"MApprovalChain.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  A :sol:mod:`Committee` contract is a contract that the exchange service sends committee member\n  signatures to attesting that they have a copy of the data over which a new Merkel root is to be\n  accepted as the new state root. In addition, the exchange contract can call an availability\n  verifier to check if such signatures were indeed provided by a sufficient number of committee\n  members as hard coded in the :sol:mod:`Committee` contract for a given state transition\n  (as reflected by the old and new vault and order roots).\n\n  The exchange contract will normally query only one :sol:mod:`Committee` contract for data\n  availability checks. However, in the event that the committee needs to be updated, additional\n  availability verifiers may be registered with the exchange contract by the\n  contract :sol:mod:`MainGovernance`. Such new availability verifiers are then also be required to\n  attest to the data availability for state transitions and only if all the availability verifiers\n  attest to it, the state transition is accepted.\n\n  Removal of availability verifiers is also the responsibility of the :sol:mod:`MainGovernance`.\n  The removal process is more sensitive than availability verifier registration as it may affect the\n  soundness of the system. Hence, this is performed in two steps:\n\n  1. The :sol:mod:`MainGovernance` first announces the intent to remove an availability verifier by calling :sol:func:`announceAvailabilityVerifierRemovalIntent`\n  2. After the expiration of a `VERIFIER_REMOVAL_DELAY` time lock, actual removal may be performed by calling :sol:func:`removeAvailabilityVerifier`\n\n  The removal delay ensures that a user concerned about the soundness of the system has ample time\n  to leave the exchange.\n*/\ncontract AvailabilityVerifiers is MainStorage, MApprovalChain, LibConstants {\n    function getRegisteredAvailabilityVerifiers()\n        external view\n        returns (address[] memory _verifers)\n    {\n        return availabilityVerifiersChain.list;\n    }\n\n    function isAvailabilityVerifier(address verifierAddress)\n        external view\n        returns (bool)\n    {\n        return findEntry(availabilityVerifiersChain.list, verifierAddress) != ENTRY_NOT_FOUND;\n    }\n\n    function registerAvailabilityVerifier(address verifier, string calldata identifier)\n        external\n    {\n        addEntry(availabilityVerifiersChain, verifier, MAX_VERIFIER_COUNT, identifier);\n    }\n\n    function announceAvailabilityVerifierRemovalIntent(address verifier)\n        external\n    {\n        announceRemovalIntent(availabilityVerifiersChain, verifier, VERIFIER_REMOVAL_DELAY);\n    }\n\n    function removeAvailabilityVerifier(address verifier)\n        external\n    {\n        removeEntry(availabilityVerifiersChain, verifier);\n    }\n}\n"},"Common.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nlibrary Addresses {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n}\n\n"},"Deposits.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"IVerifierActions.sol\";\nimport \"MFreezable.sol\";\nimport \"MOperator.sol\";\nimport \"MUsers.sol\";\nimport \"MTokens.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  For a user to perform a deposit to the contract two calls need to take place:\n\n  1. A call to an ERC20 contract, authorizing this contract to trasnfer funds on behalf of the user.\n  2. A call to :sol:func:`deposit` indicating the amount, token ID and target vault ID to which to send the deposit.\n\n  The amount should be quantized, according to the specific quantization defined for the token ID.\n\n  The result of the operation, assuming all requirements are met, is that an amount of ERC20 tokens\n  equaling the amount specified in the :sol:func:`deposit` call times the quantization factor is\n  transferred on behalf of the user to the contract. In addition, the contract adds the funds to an\n  accumulator of pending deposits for the provided user, token ID and vault ID.\n\n  Once a deposit is made, the exchange may include it in a proof which will result in addition\n  of the amount(s) deposited to the off-chain vault with the specified ID. When the contract\n  receives such valid proof, it deducts the transfered funds from the pending deposits for the\n  specified user, token ID and vault ID.\n\n  The exchange will not be able to move the deposited funds to the off-chain vault if the vault does\n  not belong to the StarkKey associated with the user EthKey. However, this is not enforced by the\n  contract but by the inability to create a valid STARK proof for such transfer.\n\n  Until that point, the user may cancel the deposit by performing a time-locked cancel-deposit\n  operation consisting of two calls:\n\n  1. A call to :sol:func:`depositCancel`, setting a timer to enable reclaiming the deposit. Until this timer expires the user cannot reclaim funds as the exchange may still be processing the deposit for inclusion in the off chain vault.\n  2. A call to :sol:func:`depositReclaim`, to perform the actual transfer of funds from the contract back to the ERC20 contract. This will only succeed if the timer set in the previous call has expired. The result should be the transfer of all funds not accounted for in proofs for off-chain inclusion, back to the user account on the ERC20 contract.\n\n  Implements IVerifierActions.acceptDeposit.\n  Uses MFreezable, MVerifiers, MUsers and MTokens.\n*/\ncontract Deposits is MainStorage, LibConstants, IVerifierActions, MFreezable, MOperator,\n                     MUsers, MTokens {\n    event LogDeposit(\n        uint256 starkKey,\n        uint256 vaultId,\n        uint256 tokenId,\n        uint256 nonQuantizedAmount,\n        uint256 quantizedAmount\n    );\n\n    event LogDepositCancel(\n        uint256 starkKey,\n        uint256 vaultId,\n        uint256 tokenId\n    );\n\n    event LogDepositCancelReclaimed(\n        uint256 starkKey,\n        uint256 vaultId,\n        uint256 tokenId,\n        uint256 nonQuantizedAmount,\n        uint256 quantizedAmount\n    );\n\n    function getDepositBalance(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 vaultId\n    )\n        external view\n        returns (uint256 balance)\n    {\n        balance = fromQuantized(tokenId, pendingDeposits[starkKey][tokenId][vaultId]);\n    }\n\n    function getQuantizedDepositBalance(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 vaultId\n    )\n        external view\n        returns (uint256 balance)\n    {\n        balance = pendingDeposits[starkKey][tokenId][vaultId];\n    }\n\n    function getCancellationRequest(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 vaultId\n    )\n        external view\n        returns (uint256 request)\n    {\n        request = cancellationRequests[starkKey][tokenId][vaultId];\n    }\n\n    function deposit(\n        uint256 tokenId,\n        uint256 vaultId,\n        uint256 quantizedAmount\n    )\n        public\n        notFrozen()\n    {\n        // No need to verify amount \u003e 0, a deposit with amount = 0 can be used to undo cancellation.\n        require(vaultId \u003c= MAX_VAULT_ID, \"OUT_OF_RANGE_VAULT_ID\");\n\n        // Fetch user and key.\n        address user = msg.sender;\n        uint256 starkKey = getStarkKey(user);\n\n        // Update the balance.\n        pendingDeposits[starkKey][tokenId][vaultId] += quantizedAmount;\n        require(pendingDeposits[starkKey][tokenId][vaultId] \u003e= quantizedAmount, \"DEPOSIT_OVERFLOW\");\n\n        // Disable the timeout.\n        delete cancellationRequests[starkKey][tokenId][vaultId];\n\n        // Transfer the tokens to the Deposit contract.\n        transferIn(tokenId, quantizedAmount);\n\n        // Log event.\n        emit LogDeposit(\n            starkKey, vaultId, tokenId, fromQuantized(tokenId, quantizedAmount), quantizedAmount);\n    }\n\n    function deposit(\n        uint256 tokenId,\n        uint256 vaultId\n    )\n        external payable\n    {\n        require(isEther(tokenId), \"INVALID_TOKEN_ID\");\n        deposit(tokenId, vaultId, toQuantized(tokenId, msg.value));\n    }\n\n\n    function depositCancel(uint256 tokenId, uint256 vaultId)\n        external\n        // No modifiers: This function can always be used, even when frozen.\n    {\n        require(vaultId \u003c= MAX_VAULT_ID, \"OUT_OF_RANGE_VAULT_ID\");\n\n        // Fetch user and key.\n        address user = msg.sender;\n        uint256 starkKey = getStarkKey(user);\n\n        // Start the timeout.\n        // solium-disable-next-line security/no-block-members\n        cancellationRequests[starkKey][tokenId][vaultId] = now;\n\n        // Log event.\n        emit LogDepositCancel(starkKey, vaultId, tokenId);\n    }\n\n    function depositReclaim(uint256 tokenId, uint256 vaultId)\n        external\n        // No modifiers: This function can always be used, even when frozen.\n    {\n        require(vaultId \u003c= MAX_VAULT_ID, \"OUT_OF_RANGE_VAULT_ID\");\n\n        // Fetch user and key.\n        address user = msg.sender;\n        uint256 starkKey = getStarkKey(user);\n\n        // Make sure enough time has passed.\n        uint256 requestTime = cancellationRequests[starkKey][tokenId][vaultId];\n        require(requestTime != 0, \"DEPOSIT_NOT_CANCELED\");\n        uint256 freeTime = requestTime + DEPOSIT_CANCEL_DELAY;\n        assert(freeTime \u003e= DEPOSIT_CANCEL_DELAY);\n        // solium-disable-next-line security/no-block-members\n        require(now \u003e= freeTime, \"DEPOSIT_LOCKED\");\n\n        // Clear deposit.\n        uint256 quantizedAmount = pendingDeposits[starkKey][tokenId][vaultId];\n        delete pendingDeposits[starkKey][tokenId][vaultId];\n        delete cancellationRequests[starkKey][tokenId][vaultId];\n\n        // Refund deposit.\n        transferOut(tokenId, quantizedAmount);\n\n        // Log event.\n        emit LogDepositCancelReclaimed(\n            starkKey, vaultId, tokenId, fromQuantized(tokenId, quantizedAmount), quantizedAmount);\n    }\n\n    function acceptDeposit(\n        uint256 starkKey,\n        uint256 vaultId,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal\n    {\n        // Fetch deposit.\n        require(\n            pendingDeposits[starkKey][tokenId][vaultId] \u003e= quantizedAmount,\n            \"DEPOSIT_INSUFFICIENT\");\n\n        // Subtract accepted quantized amount.\n        pendingDeposits[starkKey][tokenId][vaultId] -= quantizedAmount;\n    }\n}\n"},"Escapes.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"IVerifierActions.sol\";\nimport \"MFreezable.sol\";\nimport \"MUsers.sol\";\nimport \"MTokens.sol\";\nimport \"IFactRegistry.sol\";\nimport \"MStateRoot.sol\";\nimport \"MWithdrawal.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  Escaping the exchange is the last resort for users that wish to withdraw their funds without\n  relying on off-chain exchange services. The Escape functionality may only be invoked once the\n  contract has become frozen. This will be as the result of an unserviced full withdraw request\n  (see :sol:mod:`FullWithdrawals`). At that point, any escaper entity may perform an escape\n  operation as follows:\n\n  1. Escapers must obtain a Merkle path of a vault to be evicted with respect to the frozen vault tree root. Typically, once the exchange is frozen, such data will be made public or would be obtainable from an exchange API, depending on the data availability approach used by the exchange.\n  2. Escapers call the :sol:mod:`EscapeVerifier` contract with the Merkle proof for the vault to be evicted. If the proof is valid, this results in the registration of such proof.\n  3. Escapers call :sol:func:`escape` function with the same parameters as submitted to the :sol:mod:`EscapeVerifier` (i.e. the vault ID, Stark Key of the vault owner, the token ID and the vault balance), sans the Merkle proof. If a proof was accepted for the same parameters by the :sol:mod:`EscapeVerifier`, and no prior escape call was made for the vault, the contract adds the vault balance to an on-chain pending withdrawals account under the Stark Key of the vault owner and the appropriate token ID.\n  4. The owner of the vault may then withdraw this amount from the pending withdrawals account by calling the normal withdraw function (see :sol:mod:`Withdrawals`) to transfer the funds to the users Eth or ERC20 account (depending on the token type).\n\n  Note that while anyone can perform the initial steps of the escape operation (including the\n  exchange operator, for example), only the owner of the vault may perform the final step of\n  transfersing the funds.\n\n  Uses MFreezable, MStateRoot and MWithdrawal.\n*/\ncontract Escapes is MainStorage, MFreezable, MStateRoot, MWithdrawal {\n    function initialize (\n        IFactRegistry escapeVerifier\n    ) internal\n    {\n        escapeVerifier_ = escapeVerifier;\n    }\n\n    /*\n      Escape when the contract is frozen.\n    */\n    function escape(\n        uint256 starkKey,\n        uint256 vaultId,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        external\n        onlyFrozen()\n    {\n        require(!escapesUsed[vaultId], \"ESCAPE_ALREADY_USED\");\n\n        // Escape can be used only once.\n        escapesUsed[vaultId] = true;\n        escapesUsedCount += 1;\n\n        bytes32 claimHash = keccak256(\n            abi.encode(\n        starkKey, tokenId, quantizedAmount, getVaultRoot(), getVaultTreeHeight(), vaultId));\n\n        require(escapeVerifier_.isValid(claimHash), \"ESCAPE_LACKS_PROOF\");\n\n        allowWithdrawal(starkKey, tokenId, quantizedAmount);\n    }\n}\n"},"Freezable.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"MFreezable.sol\";\nimport \"MGovernance.sol\";\nimport \"MainStorage.sol\";\n\n/*\n  Implements MFreezable.\n*/\ncontract Freezable is MainStorage, LibConstants, MGovernance, MFreezable {\n    event LogFrozen();\n    event LogUnFrozen();\n\n    modifier notFrozen()\n    {\n        require(!stateFrozen, \"STATE_IS_FROZEN\");\n        _;\n    }\n\n    modifier onlyFrozen()\n    {\n        require(stateFrozen, \"STATE_NOT_FROZEN\");\n        _;\n    }\n\n    function isFrozen()\n        external view\n        returns (bool frozen) {\n        frozen = stateFrozen;\n    }\n\n    function freeze()\n        internal\n        notFrozen()\n    {\n        // solium-disable-next-line security/no-block-members\n        unFreezeTime = now + UNFREEZE_DELAY;\n\n        // Update state.\n        stateFrozen = true;\n\n        // Log event.\n        emit LogFrozen();\n    }\n\n    function unFreeze()\n        external\n        onlyFrozen()\n        onlyGovernance()\n    {\n        // solium-disable-next-line security/no-block-members\n        require(now \u003e= unFreezeTime, \"UNFREEZE_NOT_ALLOWED_YET\");\n\n        // Update state.\n        stateFrozen = false;\n\n        // Increment roots to invalidate them, w/o losing information.\n        vaultRoot += 1;\n        orderRoot += 1;\n\n        // Log event.\n        emit LogUnFrozen();\n    }\n\n}\n"},"FullWithdrawals.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"IVerifierActions.sol\";\nimport \"MFreezable.sol\";\nimport \"MOperator.sol\";\nimport \"MUsers.sol\";\nimport \"MTokens.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  At any point in time, a user may opt to perform a full withdrawal request for a given off-chain\n  vault. Such a request is a different flow than the normal withdrawal flow\n  (see :sol:mod:`Withdrawals`) in the following ways:\n\n  1. The user calls a contract function instead of calling an off-chain service API.\n  2. Upon the successful fulfillment of the operation, the entire vault balance is withdrawn, and it is effectively evicted (no longer belongs to the user). Hence, a full withdrawal request does not include an amount to withdraw.\n  3. Failure of the offchain exchange to service a full withdrawal request within a given timeframe gives the user the option to freeze the exchange disabling the ability to update its state.\n\n  A full withdrawal operation is executed as follows:\n\n  1. The user submits a full withdrawal request by calling :sol:func:`fullWithdrawalRequest` with the vault ID to be withdrawn.\n  2. Under normal operation of the exchange service, the exchange submits a STARK proof indicating the fulfillment of the withdrawal from the vault.\n  3. If the exchange fails to service the request (does not submit a valid proof as above), upon the expiration of a :sol:cons:`FREEZE_GRACE_PERIOD`, the user is entitled to freeze the contract by calling :sol:func:`freezeRequest` and indicating the vaultId for which the full withdrawal request has not been serviced.\n  4. Upon acceptance of the proof above, the contract adds the withdrawn amount to an on-chain pending withdrawals account under the stark key of the vault owner and the appropriate token ID. At the same time, the full withdrawal request is cleared.\n  5. The user may then withdraw this amount from the pending withdrawals account by calling the normal withdraw function (see :sol:mod:`Withdrawals`) to transfer the funds to the users Eth or ERC20 account (depending on the token type).\n\n  If a user requests a full withdrawal for a vault that is not associated with the StarkKey of the\n  user, the exchange may prove this and the full withdrawal request is cleared without any effect on\n  the vault (and no funds will be released on-chain for withdrawal).\n\n  Full withdrawal requests cannot be cancelled by a user.\n\n  To avoid the potential attack of the exchange by a flood of full withdrawal requests, the rate of\n  such requests must be limited. In the currently implementation, this is achieved by making the\n  cost of the request exceed 1M gas.\n\n  Implements IVerifierActions.clearFullWithdrawalRequest.\n  Uses MFreezable, MOperator, MUsers.\n*/\ncontract FullWithdrawals is MainStorage, LibConstants, IVerifierActions, MFreezable,\n    MOperator, MUsers {\n\n    event LogFullWithdrawalRequest(\n        uint256 starkKey,\n        uint256 vaultId\n    );\n\n    function fullWithdrawalRequest(\n        uint256 vaultId\n    )\n        external\n        notFrozen()\n    {\n        // Fetch user and key.\n        address user = msg.sender;\n        uint256 starkKey = getStarkKey(user);\n\n        // Verify vault ID in range.\n        require(vaultId \u003c= MAX_VAULT_ID, \"OUT_OF_RANGE_VAULT_ID\");\n\n        // Start timer on escape request.\n        // solium-disable-next-line security/no-block-members\n        fullWithdrawalRequests[starkKey][vaultId] = now;\n\n        // Log request.\n        emit LogFullWithdrawalRequest(starkKey, vaultId);\n\n        // Burn gas to prevent denial of service (too many requests per block).\n        for (uint256 i = 0; i \u003c 22231; i++) {}\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    function getFullWithdrawalRequest(\n        uint256 starkKey,\n        uint256 vaultId\n    )\n        external view\n        returns (uint256 res)\n    {\n        // Return request value. Expect zero if the request doesn\u0027t exist or has been serviced, and\n        // a non-zero value otherwise.\n        res = fullWithdrawalRequests[starkKey][vaultId];\n    }\n\n    function freezeRequest(\n        uint256 vaultId\n    )\n        external\n        notFrozen()\n    {\n        // Fetch user and key.\n        address user = msg.sender;\n        uint256 starkKey = getStarkKey(user);\n\n        // Verify vaultId in range.\n        require(vaultId \u003c= MAX_VAULT_ID, \"OUT_OF_RANGE_VAULT_ID\");\n\n        // Load request time.\n        uint256 requestTime = fullWithdrawalRequests[starkKey][vaultId];\n        require(requestTime != 0, \"FULL_WITHDRAWAL_UNREQUESTED\");\n\n        // Verify timer on escape request.\n        uint256 freezeTime = requestTime + FREEZE_GRACE_PERIOD;\n        assert(freezeTime \u003e= FREEZE_GRACE_PERIOD);\n        // solium-disable-next-line security/no-block-members\n        require(now \u003e= freezeTime, \"FULL_WITHDRAWAL_PENDING\");\n\n        // The only place this function is called.\n        freeze();\n    }\n\n    /*\n      Handle full withdrawal requests through regular operators (canceling the pending freeze).\n      Called after request was serviced or proven to be invalid.\n    */\n    function clearFullWithdrawalRequest(\n        uint256 starkKey,\n        uint256 vaultId\n    )\n        internal\n    {\n        // Reset escape request.\n        fullWithdrawalRequests[starkKey][vaultId] = 0;\n    }\n}\n"},"Governance.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"GovernanceStorage.sol\";\nimport \"MGovernance.sol\";\n\n/*\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\n  Notes:\n  1. This class is virtual (getGovernanceTag is not implemented).\n  2. The use of the same function names by both the Proxy and a delegated implementation\n     is not possible since calling the implementation functions is done via the default function\n     of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\n     exposes mainIsGovernor, which calls the internal isGovernor method.\n*/\ncontract Governance is GovernanceStorage, MGovernance {\n    event LogNominatedGovernor(address nominatedGovernor);\n    event LogNewGovernorAccepted(address acceptedGovernor);\n    event LogRemovedGovernor(address removedGovernor);\n    event LogNominationCancelled();\n\n    address internal constant ZERO_ADDRESS = address(0x0);\n\n    /*\n      Returns a string which uniquely identifies the type of the governance mechanism.\n    */\n    function getGovernanceTag()\n        internal\n        view\n        returns (string memory);\n\n    /*\n      Returns the GovernanceInfoStruct associated with the governance tag.\n    */\n    function contractGovernanceInfo()\n        internal\n        view\n        returns (GovernanceInfoStruct storage) {\n        string memory tag = getGovernanceTag();\n        GovernanceInfoStruct storage gub = governanceInfo[tag];\n        require(gub.initialized, \"NOT_INITIALIZED\");\n        return gub;\n    }\n\n    function initGovernance()\n        internal\n    {\n        string memory tag = getGovernanceTag();\n        GovernanceInfoStruct storage gub = governanceInfo[tag];\n        require(!gub.initialized, \"ALREADY_INITIALIZED\");\n        gub.initialized = true;  // to ensure addGovernor() won\u0027t fail.\n        // Add the initial governer.\n        addGovernor(msg.sender);\n    }\n\n    modifier onlyGovernance()\n    {\n        require(isGovernor(msg.sender), \"ONLY_GOVERNANCE\");\n        _;\n    }\n\n    function isGovernor(address testGovernor)\n        internal view\n        returns (bool addressIsGovernor){\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n        addressIsGovernor = gub.effectiveGovernors[testGovernor];\n    }\n\n    /*\n      Cancels the nomination of a governor condidate.\n    */\n    function cancelNomination() internal onlyGovernance() {\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n        gub.candidateGovernor = ZERO_ADDRESS;\n        emit LogNominationCancelled();\n    }\n\n    function nominateNewGovernor(address newGovernor) internal onlyGovernance() {\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n        require(!isGovernor(newGovernor), \"ALREADY_GOVERNOR\");\n        gub.candidateGovernor = newGovernor;\n        emit LogNominatedGovernor(newGovernor);\n    }\n\n    /*\n      The addGovernor is called in two cases:\n      1. by acceptGovernance when a new governor accepts its role.\n      2. by initGovernance to add the initial governor.\n      The difference is that the init path skips the nominate step\n      that would fail because of the onlyGovernance modifier.\n    */\n    function addGovernor(address newGovernor) private {\n        require(!isGovernor(newGovernor), \"ALREADY_GOVERNOR\");\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n        gub.effectiveGovernors[newGovernor] = true;\n    }\n\n    function acceptGovernance()\n        internal\n    {\n        // The new governor was proposed as a candidate by the current governor.\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n        require(msg.sender == gub.candidateGovernor, \"ONLY_CANDIDATE_GOVERNOR\");\n\n        // Update state.\n        addGovernor(gub.candidateGovernor);\n        gub.candidateGovernor = ZERO_ADDRESS;\n\n        // Send a notification about the change of governor.\n        emit LogNewGovernorAccepted(msg.sender);\n    }\n\n    /*\n      Remove a governor from office.\n    */\n    function removeGovernor(address governorForRemoval) internal onlyGovernance() {\n        require(msg.sender != governorForRemoval, \"GOVERNOR_SELF_REMOVE\");\n        GovernanceInfoStruct storage gub = contractGovernanceInfo();\n        require (isGovernor(governorForRemoval), \"NOT_GOVERNOR\");\n        gub.effectiveGovernors[governorForRemoval] = false;\n        emit LogRemovedGovernor(governorForRemoval);\n    }\n}\n"},"GovernanceStorage.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n/*\n  Holds the governance slots for ALL entities, including proxy and the main contract.\n*/\ncontract GovernanceStorage {\n\n    struct GovernanceInfoStruct {\n        mapping (address =\u003e bool) effectiveGovernors;\n        address candidateGovernor;\n        bool initialized;\n    }\n\n    // A map from a Governor tag to its own GovernanceInfoStruct.\n    mapping (string =\u003e GovernanceInfoStruct) internal governanceInfo;\n}\n"},"Identity.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract Identity {\n\n    /*\n      Allows a caller, typically another contract,\n      to ensure that the provided address is of the expected type and version.\n    */\n    function identify()\n        external pure\n        returns(string memory);\n}\n"},"IDexStatementVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n\ncontract IDexStatementVerifier {\n\n    /**\n      Verifies that a STARK proof for an exchange state update is valid\n      (see :sol:mod:`UpdateState`).\n\n      The state update with respect to a batch of transactions is defined by a transition from a\n      previous Merkle root to a new Merkle root as calculated over a series of off-chain vaults.\n      It is considered to be valid as long as:\n\n      - The transactions in the batch result in an update of the vault and order Merkle roots as they appear in the `publicInput`.\n      - The transactions are valid.\n      - For ramping transactions (deposits, withdrawals, full withdrawals), the proof is consistent with the transaction parameters that appear in the `publicInput`\n      - The submitted STARK proof is accepted based on a set of valid proof parameters.\n\n      The transactions currently supported include ramping transactions, token transfers (from one\n      off-chain vault to another) and exchange settlements pairing two valid orders.\n\n      If a state update is accepted, this is registered under the following claim hash that may\n      later be queried for validity:\n\n      `claimHash = keccak256(abi.encodePacked(publicInput))`\n\n      For a high level overview of the system state, see\n      this `StarkWare blog post \u003chttps://medium.com/starkware/starkdex-deep-dive-contracts-statement-3b500cf143c9\u003e`_.\n\n      @param proofParams In the format as follows (each row represents a 256-bit word):\n\n          +-------------------------------------------------------------------+\n          | Blowup factor                                                     |\n          +-------------------------------------------------------------------+\n          | Number of PoW bits                                                |\n          +-------------------------------------------------------------------+\n          | Log last FRI layer degree bound                                   |\n          +-------------------------------------------------------------------+\n          | Number of FRI steps (S)                                           |\n          +-------------------------------------------------------------------+\n          | FRI step 0 size                                                   |\n          +-------------------------------------------------------------------+\n          | ...                                                               |\n          +-------------------------------------------------------------------+\n          | FRI step S-1 size                                                 |\n          +-------------------------------------------------------------------+\n\n          - The number of queries to meet the verifier\u0027s security parameter will be derived from the blowup factor and number of PoW bits.\n          - The sum of the FRI steps and the log of the last layer degree should equal the log of the expected STARK proof trace length.\n          - Additional restrictions on the FRI step sizes may also be enforced by the verifier.\n\n      @param publicInput In the format as follows (each row represents a 256-bit word):\n\n          +-------------------------------------------------------------------+\n          | Batch size                                                        |\n          +-------------------------------------------------------------------+\n          | Number of transactions                                            |\n          +-------------------------------------------------------------------+\n          | Global expiration timestamp                                       |\n          +-------------------------------------------------------------------+\n          | Intial vault root                                                 |\n          +-------------------------------------------------------------------+\n          | Final vault root                                                  |\n          +-------------------------------------------------------------------+\n          | Intial order root                                                 |\n          +-------------------------------------------------------------------+\n          | Final order root                                                  |\n          +-------------------------------------------------------------------+\n          | Vault Merkle tree height                                          |\n          +-------------------------------------------------------------------+\n          | Order Merkle tree height                                          |\n          +-------------------------------------------------------------------+\n          | Ramping operation 0 Stark Key                                     |\n          +-------------------------------------------------------------------+\n          | Ramping operation 0 Token ID                                      |\n          +-------------------------------------------------------------------+\n          | Ramping operation 0 Additional Info                               |\n          +-------------------------------------------------------------------+\n          | ...                                                               |\n          +-------------------------------------------------------------------+\n          | Ramping operation N Stark Key                                     |\n          +-------------------------------------------------------------------+\n          | Ramping operation N Token ID                                      |\n          +-------------------------------------------------------------------+\n          | Ramping operation N Additional Info                               |\n          +-------------------------------------------------------------------+\n\n          Three words per ramping operation should be provided where Additional Info has the\n          following format (numbers indicate field sizes in bits):\n\n          +-------------+------------+---------------+----------+---------------+\n          | Amount      | Amount     | Vault ID (32) | Row (16) | Reserved (80) |\n          |             |            |               |          |               |\n          | before (64) | after (64) |               |          |               |\n          +-------------+------------+---------------+----------+---------------+\n\n          The Row parameter refers to the index of the ramping operation within the batch.\n\n      @param proof The binary STARK proof. It\u0027s exact description is beyond the scope of this\n        documentation.\n    */\n    function verifyProofAndRegister(\n        uint256[] calldata proofParams,\n        uint256[] calldata proof,\n        uint256[] calldata publicInput\n    )\n        external;\n\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"IECDSA.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract IECDSA {\n    function verify(uint256 msgHash, uint256 r, uint256 s, uint256 pubX, uint256 pubY)\n        external;\n}\n"},"IERC20.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n/*\n  Interface of the ERC20 standard as defined in the EIP. Does not include\n  the optional functions; to access them see {ERC20Detailed}.\n*/\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount)\n     external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post \u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\u003e`_.\n*/\ncontract IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"IQueryableFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IFactRegistry.sol\";\n\n/*\n  Extends the IFactRegistry interface with a query method that indicates\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\n*/\ncontract IQueryableFactRegistry is IFactRegistry {\n\n    /*\n      Returns true if at least one fact has been registered.\n    */\n    function hasRegisteredFact()\n        external view\n        returns(bool);\n\n}\n"},"IVerifierActions.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\n/*\n  Interface containing actions a verifier can invoke on the state.\n  The contract containing the state should implement these and verify correctness.\n*/\ncontract IVerifierActions {\n\n    function updateState(\n        uint256[] calldata publicInput,\n        uint256[] calldata applicationData\n    )\n        external;\n    /*\n      Update state roots\n      Verify that the old roots match.\n      Implemented in the StateRoot contract.\n    */\n    function rootUpdate(\n        uint256 oldVaultRoot,\n        uint256 newVaultRoot,\n        uint256 oldOrderRoot,\n        uint256 newOrderRoot,\n        uint256 vaultTreeHeightSent,\n        uint256 orderTreeHeightSent,\n        uint256 batchId\n    )\n        internal;\n\n\n    /*\n      Transfers funds from the on-chain deposit area to the off-chain area.\n      Implemented in the Deposits contracts.\n    */\n    function acceptDeposit(\n        uint256 starkKey,\n        uint256 vaultId,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal;\n\n    /*\n      Transfers funds from the off-chain area to the on-chain withdrawal area.\n      Implemented in the Withdrawals contracts.\n    */\n    function acceptWithdrawal(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal;\n\n    /*\n      Implemented in the FullWithdrawal contracts.\n    */\n    function clearFullWithdrawalRequest(\n        uint256 starkKey,\n        uint256 vaultId\n    )\n        internal;\n}\n"},"LibConstants.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract LibConstants {\n    // Durations for time locked mechanisms (in seconds).\n    // Note that it is known that miners can manipulate block timestamps\n    // up to a deviation of a few seconds.\n    // This mechanism should not be used for fine grained timing.\n\n    // The time required to cancel a deposit, in the case the operator does not move the funds\n    // to the off-chain storage.\n    uint256 public constant DEPOSIT_CANCEL_DELAY = 1 days;\n\n    // The time required to freeze the exchange, in the case the operator does not execute a\n    // requested full withdrawal.\n    uint256 public constant FREEZE_GRACE_PERIOD = 7 days;\n\n    // The time after which the exchange may be unfrozen after it froze. This should be enough time\n    // for users to perform escape hatches to get back their funds.\n    uint256 public constant UNFREEZE_DELAY = 365 days;\n\n    // Maximal number of verifiers which may co-exist.\n    uint256 public constant MAX_VERIFIER_COUNT = uint256(64);\n\n    // The time required to remove a verifier in case of a verifier upgrade.\n    uint256 public constant VERIFIER_REMOVAL_DELAY = FREEZE_GRACE_PERIOD + (21 days);\n\n    uint256 constant MAX_VAULT_ID = 2**31 - 1;\n    uint256 constant MAX_QUANTUM = 2**128 - 1;\n\n    address constant ZERO_ADDRESS = address(0x0);\n\n    uint256 constant K_MODULUS =\n    0x800000000000011000000000000000000000000000000000000000000000001;\n    uint256 constant K_BETA =\n    0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\n}\n"},"MainGovernance.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"Governance.sol\";\n\n/**\n  The StarkEx contract is governed by one or more Governors of which the initial one is the\n  deployer of the contract.\n\n  A governor has the sole authority to perform the following operations:\n\n  1. Nominate additional governors (:sol:func:`mainNominateNewGovernor`)\n  2. Remove other governors (:sol:func:`mainRemoveGovernor`)\n  3. Add new :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers`\n  4. Remove :sol:mod:`Verifiers` and :sol:mod:`AvailabilityVerifiers` after a timelock allows it\n  5. Nominate Operators (see :sol:mod:`Operator`) and Token Administrators (see :sol:mod:`Tokens`)\n\n  Adding governors is performed in a two step procedure:\n\n  1. First, an existing governor nominates a new governor (:sol:func:`mainNominateNewGovernor`)\n  2. Then, the new governor must accept governance to become a governor (:sol:func:`mainAcceptGovernance`)\n\n  This two step procedure ensures that a governor public key cannot be nominated unless there is an\n  entity that has the corresponding private key. This is intended to prevent errors in the addition\n  process.\n\n  The governor private key should typically be held in a secure cold wallet.\n*/\n/*\n  Implements Governance for the StarkDex main contract.\n  The wrapper methods (e.g. mainIsGovernor wrapping isGovernor) are needed to give\n  the method unique names.\n  Both Proxy and StarkExchange inherit from Governance. Thus, the logical contract method names\n  must have unique names in order for the proxy to successfully delegate to them.\n*/\ncontract MainGovernance is Governance {\n\n    // The tag is the sting key that is used in the Governance storage mapping.\n    string public constant MAIN_GOVERNANCE_INFO_TAG = \"StarkEx.Main.2019.GovernorsInformation\";\n\n    function getGovernanceTag()\n        internal\n        view\n        returns (string memory tag) {\n        tag = MAIN_GOVERNANCE_INFO_TAG;\n    }\n\n    function mainIsGovernor(address testGovernor) external view returns (bool) {\n        return isGovernor(testGovernor);\n    }\n\n    function mainNominateNewGovernor(address newGovernor) external {\n        nominateNewGovernor(newGovernor);\n    }\n\n    function mainRemoveGovernor(address governorForRemoval) external {\n        removeGovernor(governorForRemoval);\n    }\n\n    function mainAcceptGovernance()\n        external\n    {\n        acceptGovernance();\n    }\n\n    function mainCancelNomination() external {\n        cancelNomination();\n    }\n\n}\n"},"MainStorage.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IECDSA.sol\";\nimport \"IFactRegistry.sol\";\nimport \"ProxyStorage.sol\";\n\n/*\n  Holds ALL the main contract state (storage) variables.\n*/\ncontract MainStorage is ProxyStorage {\n\n    // Structure representing a list of verifiers (validity/availability).\n    // A statement is valid only if all the verifiers in the list agree on it.\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\n    // any soundness issues.\n    // Removing from the list is time-locked, to ensure that any user of the system\n    // not content with the announced removal has ample time to leave the system before it is\n    // removed.\n    struct ApprovalChainData {\n        address[] list;\n        // Represents the time after which the verifier with the given address can be removed.\n        // Removal of the verifier with address A is allowed only in the case the value\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] \u003c (current time).\n        mapping (address =\u003e uint256) unlockedForRemovalTime;\n    }\n\n    IFactRegistry escapeVerifier_;\n\n    IECDSA ecdsaContract_;\n\n    // Global dex-frozen flag.\n    bool stateFrozen;\n\n    // Time when unFreeze can be successfully called (UNFREEZE_DELAY after freeze).\n    uint256 unFreezeTime;\n\n    // Pending deposits.\n    // A map STARK key =\u003e token id =\u003e vault id =\u003e quantized amount.\n    mapping (uint256 =\u003e mapping (uint256 =\u003e mapping (uint256 =\u003e uint256))) pendingDeposits;\n\n    // Cancellation requests.\n    // A map STARK key =\u003e token id =\u003e vault id =\u003e request timestamp.\n    mapping (uint256 =\u003e mapping (uint256 =\u003e mapping (uint256 =\u003e uint256))) cancellationRequests;\n\n    // Pending withdrawals.\n    // A map STARK key =\u003e token id =\u003e quantized amount.\n    mapping (uint256 =\u003e mapping (uint256 =\u003e uint256)) pendingWithdrawals;\n\n    // vault_id =\u003e escape used boolean.\n    mapping (uint256 =\u003e bool) escapesUsed;\n\n    // Number of escapes that were performed when frozen.\n    uint256 escapesUsedCount;\n\n    // Full withdrawal requests: stark key =\u003e vaultId =\u003e requestTime.\n    // stark key =\u003e vaultId =\u003e requestTime.\n    mapping (uint256 =\u003e mapping (uint256 =\u003e uint256)) fullWithdrawalRequests;\n\n    // State sequence number.\n    uint256 sequenceNumber;\n\n    // Vaults Tree Root \u0026 Height.\n    uint256 vaultRoot;\n    uint256 vaultTreeHeight;\n\n    // Order Tree Root \u0026 Height.\n    uint256 orderRoot;\n    uint256 orderTreeHeight;\n\n    // True if and only if the address is allowed to add tokens.\n    mapping (address =\u003e bool) tokenAdmins;\n\n    // True if and only if the address is allowed to register users.\n    mapping (address =\u003e bool) userAdmins;\n\n    // True if and only if the address is an operator (allowed to update state).\n    mapping (address =\u003e bool) operators;\n\n    // Mapping of token ID to asset data.\n    mapping (uint256 =\u003e bytes) tokenIdToAssetData;\n\n    // Mapping of registered token IDs.\n    mapping (uint256 =\u003e bool) registeredTokenId;\n\n    // Mapping from token ID to quantum.\n    mapping (uint256 =\u003e uint256) tokenIdToQuantum;\n\n    // Correspondence between addresses and STARK public keys.\n    mapping (address =\u003e uint256) starkKeys;\n    mapping (uint256 =\u003e address) etherKeys;\n\n    // Timelocked state transition and availability verification chain.\n    ApprovalChainData verifiersChain;\n    ApprovalChainData availabilityVerifiersChain;\n\n    // Batch id of last accepted proof.\n    uint256 lastBatchId;\n}\n"},"MApprovalChain.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MainStorage.sol\";\n\n/*\n  Implements a data structure that supports instant registration\n  and slow time-locked removal of entries.\n*/\ncontract MApprovalChain is MainStorage {\n    uint256 constant ENTRY_NOT_FOUND = uint256(~0);\n\n    /*\n      Adds the given verifier (entry) to the chain.\n      Fails if the size of the chain is already \u003e= maxLength.\n      Fails if identifier is not identical to the value returned from entry.identify().\n    */\n    function addEntry(\n        ApprovalChainData storage chain, address entry, uint256 maxLength, string memory identifier)\n        internal;\n\n    /*\n      Returns the index of the verifier in the list if it exists and returns ENTRY_NOT_FOUND\n      otherwise.\n    */\n    function findEntry(address[] storage list, address entry)\n        internal view returns (uint256);\n\n    /*\n      Same as findEntry(), except that it reverts if the verifier is not found.\n    */\n    function safeFindEntry(address[] storage list, address entry)\n        internal view returns (uint256 idx);\n\n    /*\n      Updates the unlockedForRemovalTime field of the given verifier to\n        current time + removalDelay.\n      Reverts if the verifier is not found.\n    */\n    function announceRemovalIntent(\n        ApprovalChainData storage chain, address entry, uint256 removalDelay)\n        internal;\n\n    /*\n      Removes a verifier assuming the expected time has passed.\n    */\n    function removeEntry(ApprovalChainData storage chain, address entry)\n        internal;\n\n    /*\n      Verifies a given fact on all existing verifiers.\n      Reverts if the fact is not accepted by one or more verifiers.\n    */\n    function verifyFact(\n        ApprovalChainData storage chain, bytes32 fact, string memory noVerifiersErrorMessage,\n        string memory invalidFactErrorMessage)\n        internal view;\n}\n"},"MFreezable.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MFreezable {\n    /*\n      Forbids calling the function if the exchange is frozen.\n    */\n    modifier notFrozen()\n    {\n        // Pure modifier declarations are not supported. Instead we provide\n        // a dummy definition.\n        revert(\"UNIMPLEMENTED\");\n        _;\n    }\n\n    /*\n      Allows calling the function only if the exchange is frozen.\n    */\n    modifier onlyFrozen()\n    {\n        // Pure modifier declarations are not supported. Instead we provide\n        // a dummy definition.\n        revert(\"UNIMPLEMENTED\");\n        _;\n    }\n\n    /*\n      Freezes the exchange.\n    */\n    function freeze()\n        internal;\n\n    /*\n      Returns true if the exchange is frozen.\n    */\n    function isFrozen()\n        external view\n        returns (bool);\n\n}\n"},"MGovernance.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MGovernance {\n    /*\n      Allows calling the function only by a Governor.\n    */\n    modifier onlyGovernance()\n    {\n        // Pure modifier declarations are not supported. Instead we provide\n        // a dummy definition.\n        revert(\"UNIMPLEMENTED\");\n        _;\n    }\n}\n"},"MOperator.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MOperator {\n\n    modifier onlyOperator()\n    {\n        // Pure modifier declarations are not supported. Instead we provide\n        // a dummy definition.\n        revert(\"UNIMPLEMENTED\");\n        _;\n    }\n\n    function registerOperator(address newOperator)\n        external;\n\n    function unregisterOperator(address removedOperator)\n        external;\n\n}\n"},"MStateRoot.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MStateRoot {\n    function getVaultRoot()\n        public view\n        returns (uint256 root);\n\n    function getVaultTreeHeight()\n        public view\n        returns (uint256 height);\n}\n"},"MTokens.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MTokens {\n    function toQuantized(\n        uint256 tokenId,\n        uint256 amount\n    )\n        internal view\n        returns (uint256 quantizedAmount);\n\n    function fromQuantized(\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal view\n        returns (uint256 amount);\n\n    function isEther(\n        uint256 tokenId)\n        internal view returns (bool);\n\n    function transferIn(\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal;\n\n    function transferOut(\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal;\n}\n"},"MUsers.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MUsers {\n    function getStarkKey(\n        address etherKey\n    )\n        public view\n        returns (uint256 starkKey);\n\n    function getEtherKey(\n        uint256 starkKey\n    )\n        external view\n        returns (address etherKey);\n}\n"},"MWithdrawal.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract MWithdrawal {\n    function allowWithdrawal(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal;\n\n}\n"},"Operator.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"MOperator.sol\";\nimport \"MGovernance.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  The Operator of the contract is the entity entitled to submit state update requests\n  by calling :sol:func:`updateState`.\n\n  An Operator may be instantly appointed or removed by the contract Governor\n  (see :sol:mod:`MainGovernance`). Typically, the Operator is the hot wallet of the StarkEx service\n  submitting proofs for state updates.\n*/\ncontract Operator is MainStorage, MGovernance, MOperator {\n    event LogOperatorAdded(address operator);\n    event LogOperatorRemoved(address operator);\n\n    function initialize()\n        internal\n    {\n        operators[msg.sender] = true;\n        emit LogOperatorAdded(msg.sender);\n    }\n\n    modifier onlyOperator()\n    {\n        require(operators[msg.sender], \"ONLY_OPERATOR\");\n        _;\n    }\n\n    function registerOperator(address newOperator)\n        external\n        onlyGovernance\n    {\n        operators[newOperator] = true;\n        emit LogOperatorAdded(newOperator);\n    }\n\n    function unregisterOperator(address removedOperator)\n        external\n        onlyGovernance\n    {\n        operators[removedOperator] = false;\n        emit LogOperatorRemoved(removedOperator);\n    }\n\n    function isOperator(address testedOperator) external view returns (bool) {\n        return operators[testedOperator];\n    }\n}\n"},"ProxyStorage.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"GovernanceStorage.sol\";\n\n/*\n  Holds the Proxy-specific state variables.\n  This contract is inherited by the GovernanceStorage (and indirectly by MainStorage)\n  to prevent collision hazard.\n*/\ncontract ProxyStorage is GovernanceStorage {\n\n    // Stores the hash of the initialization vector of the added implementation.\n    // Upon upgradeTo the implementation, the initialization vector is verified\n    // to be identical to the one submitted when adding the implementaion.\n    mapping (address =\u003e bytes32) internal initializationHash;\n\n    // The time after which we can switch to the implementation.\n    mapping (address =\u003e uint256) internal enabledTime;\n\n    // A central storage of the flags whether implementation has been initialized.\n    // Note - it can be used flexibly enough to accomodate multiple level of initialization\n    // (i.e. using different key salting schemes for different initialization levels).\n    mapping (bytes32 =\u003e bool) internal initialized;\n}\n"},"PublicInputOffsets.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\ncontract PublicInputOffsets {\n    // The following constants are offsets of data expected in the public input.\n    uint256 internal constant OFFSET_LOG_BATCH_SIZE = 0;\n    uint256 internal constant OFFSET_N_TRANSACTIONS = 1;\n    uint256 internal constant OFFSET_GLOBAL_EXPIRATION_TIMESTAMP = 2;\n    uint256 internal constant OFFSET_VAULT_INITIAL_ROOT = 3;\n    uint256 internal constant OFFSET_VAULT_FINAL_ROOT = 4;\n    uint256 internal constant OFFSET_ORDER_INITIAL_ROOT = 5;\n    uint256 internal constant OFFSET_ORDER_FINAL_ROOT = 6;\n    uint256 internal constant OFFSET_VAULT_TREE_HEIGHT = 7;\n    uint256 internal constant OFFSET_ORDER_TREE_HEIGHT = 8;\n    uint256 internal constant OFFSET_MODIFICATION_DATA = 9;\n    uint256 internal constant APPLICATION_DATA_BATCH_ID_OFFSET = 0;\n    uint256 internal constant APPLICATION_DATA_PREVIOUS_BATCH_ID_OFFSET = 1;\n    uint256 internal constant APPLICATION_DATA_N_MODIFICATIONS_OFFSET = 2;\n    uint256 internal constant APPLICATION_DATA_MODIFICATIONS_OFFSET = 3;\n\n    uint256 internal constant N_WORDS_PER_MODIFICATION = 3;\n}\n"},"StarkExchange.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"ApprovalChain.sol\";\nimport \"AvailabilityVerifiers.sol\";\nimport \"Freezable.sol\";\nimport \"MainGovernance.sol\";\nimport \"Operator.sol\";\nimport \"Tokens.sol\";\nimport \"Users.sol\";\nimport \"Verifiers.sol\";\nimport \"Deposits.sol\";\nimport \"Escapes.sol\";\nimport \"FullWithdrawals.sol\";\nimport \"StateRoot.sol\";\nimport \"UpdateState.sol\";\nimport \"Withdrawals.sol\";\nimport \"IECDSA.sol\";\nimport \"IFactRegistry.sol\";\n\ncontract StarkExchange is\n    IVerifierActions,\n    MainGovernance,\n    ApprovalChain,\n    AvailabilityVerifiers,\n    Operator,\n    Freezable,\n    Tokens,\n    Users,\n    StateRoot,\n    Deposits,\n    Verifiers,\n    Withdrawals,\n    FullWithdrawals,\n    Escapes,\n    UpdateState\n{\n    string constant public VERSION = \"1.0.1\";\n    string constant INIT_TAG = \"INIT_TAG_Starkware.StarkExchange.2020\";\n\n    /*\n      Determines the key to the intialized mapping.\n    */\n    function initKey() internal pure returns(bytes32 key){\n        key = keccak256(abi.encode(INIT_TAG, VERSION));\n    }\n\n    function internalInitialize(\n        IFactRegistry escapeVerifier,\n        IECDSA ecdsaContract,\n        uint256 initialSequenceNumber,\n        uint256 initialVaultRoot,\n        uint256 initialOrderRoot,\n        uint256 initialVaultTreeHeight,\n        uint256 initialOrderTreeHeight\n    )\n    internal\n    {\n        initGovernance();\n        Operator.initialize();\n        StateRoot.initialize(initialSequenceNumber, initialVaultRoot,\n            initialOrderRoot, initialVaultTreeHeight, initialOrderTreeHeight);\n        Escapes.initialize(escapeVerifier);\n        Users.initialize(ecdsaContract);\n    }\n\n    /*\n      Called from the proxy, upon upgradeTo.\n      If already initialized (determinted by the initKey) - will skip altogether.\n      If not init yet \u0026\u0026 init data is not empty:\n      1. extract data to init parameters.\n      2. call internalInitializer with those params.\n    */\n    function initialize(bytes calldata data)\n        external\n    {\n        bytes32 key = initKey();\n\n        // Skip initialize if already been initialized.\n        if (!initialized[key]){\n            // If data is empty - skip internalInitializer.\n            if (data.length \u003e 0){\n                // Ensure data length is exactly the correct size.\n                // 224 = 2 * sizeof(address) + 5 * sizeof(uint256).\n                require(data.length == 224, \"INCORRECT_INIT_DATA_SIZE\");\n                IFactRegistry escapeVerifier;\n                IECDSA ecdsaContract;\n                uint256 initialSequenceNumber;\n                uint256 initialVaultRoot;\n                uint256 initialOrderRoot;\n                uint256 initialVaultTreeHeight;\n                uint256 initialOrderTreeHeight;\n                (\n                    escapeVerifier,\n                    ecdsaContract,\n                    initialSequenceNumber,\n                    initialVaultRoot,\n                    initialOrderRoot,\n                    initialVaultTreeHeight,\n                    initialOrderTreeHeight\n                ) = abi.decode(data,\n                    (IFactRegistry, IECDSA, uint256, uint256, uint256, uint256, uint256));\n\n                internalInitialize(\n                    escapeVerifier,\n                    ecdsaContract,\n                    initialSequenceNumber,\n                    initialVaultRoot,\n                    initialOrderRoot,\n                    initialVaultTreeHeight,\n                    initialOrderTreeHeight\n                );\n            }\n            initialized[key] = true;\n        }\n    }\n}\n"},"StateRoot.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IFactRegistry.sol\";\nimport \"MFreezable.sol\";\nimport \"FullWithdrawals.sol\";\nimport \"MStateRoot.sol\";\nimport \"MainStorage.sol\";\n\n/*\n  Implements IVerifierActions.rootUpdate\n  Uses MFreezable.\n*/\ncontract StateRoot is MainStorage, MFreezable, MStateRoot\n{\n    event LogRootUpdate(\n        uint256 sequenceNumber,\n        uint256 batchId,\n        uint256 vaultRoot,\n        uint256 orderRoot\n    );\n\n    function initialize (\n        uint256 initialSequenceNumber,\n        uint256 initialVaultRoot,\n        uint256 initialOrderRoot,\n        uint256 initialVaultTreeHeight,\n        uint256 initialOrderTreeHeight\n    )\n        internal\n    {\n        sequenceNumber = initialSequenceNumber;\n        vaultRoot = initialVaultRoot;\n        orderRoot = initialOrderRoot;\n        vaultTreeHeight = initialVaultTreeHeight;\n        orderTreeHeight = initialOrderTreeHeight;\n    }\n\n    function getVaultRoot()\n        public view\n        returns (uint256 root)\n    {\n        root = vaultRoot;\n    }\n\n    function getVaultTreeHeight()\n        public view\n        returns (uint256 height) {\n        height = vaultTreeHeight;\n    }\n\n    function getOrderRoot()\n        external view\n        returns (uint256 root)\n    {\n        root = orderRoot;\n    }\n\n    function getOrderTreeHeight()\n        external view\n        returns (uint256 height) {\n        height = orderTreeHeight;\n    }\n\n    function getSequenceNumber()\n        external view\n        returns (uint256 seq)\n    {\n        seq = sequenceNumber;\n    }\n\n    function getLastBatchId()\n        external view\n        returns (uint256 batchId)\n    {\n        batchId = lastBatchId;\n    }\n\n    /*\n      Update state roots. Verify that the old roots and heights match.\n    */\n    function rootUpdate(\n        uint256 oldVaultRoot,\n        uint256 newVaultRoot,\n        uint256 oldOrderRoot,\n        uint256 newOrderRoot,\n        uint256 vaultTreeHeightSent,\n        uint256 orderTreeHeightSent,\n        uint256 batchId\n    )\n        internal\n        notFrozen()\n    {\n        // Assert that the old state is correct.\n        require(oldVaultRoot == vaultRoot, \"VAULT_ROOT_INCORRECT\");\n        require(oldOrderRoot == orderRoot, \"ORDER_ROOT_INCORRECT\");\n\n        // Assert that heights are correct.\n        require(vaultTreeHeight == vaultTreeHeightSent, \"VAULT_HEIGHT_INCORRECT\");\n        require(orderTreeHeight == orderTreeHeightSent, \"ORDER_HEIGHT_INCORRECT\");\n\n        // Update state.\n        vaultRoot = newVaultRoot;\n        orderRoot = newOrderRoot;\n        sequenceNumber = sequenceNumber + 1;\n        lastBatchId = batchId;\n\n        // Log update.\n        emit LogRootUpdate(sequenceNumber, batchId, vaultRoot, orderRoot);\n    }\n}\n"},"Tokens.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"Common.sol\";\nimport \"LibConstants.sol\";\nimport \"MTokens.sol\";\nimport \"MGovernance.sol\";\nimport \"IERC20.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  Registration of a new token (:sol:func:`registerToken`) entails defining a new token ID\n  identifying the token within the system, and associating it with an `assetData` array of bytes and\n  a quantization factor (`quantum`).\n\n  The `assetData` array defines the token type (ERC20 or Eth) encoded as a 4-byte `selector` and in\n  the case of ERC20, followed by the 32-byte address of the ERC20 contract.\n\n  The `selector` arrays are defined as follows:\n\n  `ERC20_SELECTOR = bytes4(keccak256(\"ERC20Token(address)\"));`\n\n  `ETH_SELECTOR = bytes4(keccak256(\"ETH()\"));`\n\n  The `quantum` quantization factor defines the multiplicative transformation from the native token\n  denomination as a 256b unsigned integer to a 63b unsigned integer representation as used by the\n  Stark exchange. Only amounts in the native representation that represent an integer number of\n  quanta are allowed in the system.\n\n  The token ID is restricted to be the result of a hash of the `assetData` and the `quantum` masked\n  to 250 bits (to be less than the prime used) according to the following formula:\n\n  ``uint256 tokenID = uint256(keccak256(abi.encodePacked(assetData, quantum))) \u0026 0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;``\n\n  Once registered, tokens cannot be removed from the system, as their IDs may be used by off-chain\n  accounts.\n\n  New tokens may only be registered by a Token Administrator. A Token Administrator may be instantly\n  appointed or removed by the contract Governor (see :sol:mod:`MainGovernance`). Typically, the\n  Token Administrator\u0027s private key should be kept in a cold wallet.\n*/\n/*\n  Implements MTokens.\n  Uses MGovernance.\n*/\ncontract Tokens is MainStorage, LibConstants, MGovernance, MTokens {\n    bytes4 constant internal ERC20_SELECTOR = bytes4(keccak256(\"ERC20Token(address)\"));\n    bytes4 constant internal ETH_SELECTOR = bytes4(keccak256(\"ETH()\"));\n\n    // The selector follows the 0x20 bytes assetData.length field.\n    uint256 constant internal SELECTOR_OFFSET = 0x20;\n    uint256 constant internal SELECTOR_SIZE = 4;\n    uint256 constant internal ERC20_ADDRESS_OFFSET = SELECTOR_OFFSET + SELECTOR_SIZE;\n\n\n    event LogTokenRegistered(uint256 tokenId, bytes assetData);\n    event LogTokenAdminAdded(address tokenAdmin);\n    event LogTokenAdminRemoved(address tokenAdmin);\n\n    using Addresses for address;\n\n    modifier onlyTokensAdmin()\n    {\n        require(tokenAdmins[msg.sender], \"ONLY_TOKENS_ADMIN\");\n        _;\n    }\n\n    function registerTokenAdmin(address newAdmin)\n        external\n        onlyGovernance()\n    {\n        tokenAdmins[newAdmin] = true;\n        emit LogTokenAdminAdded(newAdmin);\n    }\n\n    function unregisterTokenAdmin(address oldAdmin)\n        external\n        onlyGovernance()\n    {\n        tokenAdmins[oldAdmin] = false;\n        emit LogTokenAdminRemoved(oldAdmin);\n    }\n\n    function isTokenAdmin(address testedAdmin) external view returns (bool) {\n        return tokenAdmins[testedAdmin];\n    }\n\n    /*\n      Safe wrapper around ERC20 calls.\n      This is required because many deployed ERC20 contracts don\u0027t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeERC20Call(address tokenAddress, bytes memory callData) internal {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory returndata) = address(tokenAddress).call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length \u003e 0) {\n            require(abi.decode(returndata, (bool)), \"ERC20_OPERATION_FAILED\");\n        }\n    }\n\n\n    function extractUint256(bytes memory assetData, uint256 offset)\n        internal pure returns (uint256 res)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n           res := mload(add(assetData, offset))\n        }\n    }\n\n    /*\n      Extract the tokenSelector from assetData.\n\n      Works like bytes4 tokenSelector = abi.decode(assetData, (bytes4))\n      but does not revert when assetData.length \u003c 0x20.\n    */\n    function extractSelector(bytes memory assetData)\n        internal pure returns (bytes4 selector)\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n           selector := and(0xffffffff00000000000000000000000000000000000000000000000000000000,\n                           mload(add(assetData, 0x20)))\n        }\n    }\n\n    /*\n      Registers a new asset to the system.\n      Once added, it can not be removed and there is a limited number\n      of slots available.\n    */\n    function registerToken(\n        uint256 tokenId,\n        bytes calldata assetData,\n        uint256 quantum\n    )\n        external\n        onlyTokensAdmin()\n    {\n        // Make sure it is not invalid or already registered.\n        require(!registeredTokenId[tokenId], \"TOKEN_REGISTERED\");\n        require(tokenId \u003c K_MODULUS, \"INVALID_TOKEN_ID\");\n        require(quantum \u003e 0, \"INVALID_QUANTUM\");\n        require(quantum \u003c= MAX_QUANTUM, \"INVALID_QUANTUM\");\n        require(assetData.length \u003e= SELECTOR_SIZE, \"INVALID_ASSET_STRING\");\n\n        // Require that the tokenId is the hash of the assetData and quantum truncated to 250 bits.\n        uint256 enforcedId = uint256(keccak256(abi.encodePacked(assetData, quantum))) \u0026\n            0x03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        require(tokenId == enforcedId, \"INVALID_TOKEN_ID\");\n\n        // Add token to the in-storage structures.\n        registeredTokenId[tokenId] = true;\n        tokenIdToAssetData[tokenId] = assetData;\n        tokenIdToQuantum[tokenId] = quantum;\n\n        bytes4 tokenSelector = extractSelector(assetData);\n        if (tokenSelector == ERC20_SELECTOR) {\n            require(assetData.length == 0x24, \"INVALID_ASSET_STRING\");\n            address tokenAddress = address(extractUint256(assetData, ERC20_ADDRESS_OFFSET));\n            require(tokenAddress.isContract(), \"BAD_ERC20_ADDRESS\");\n        } else if (tokenSelector == ETH_SELECTOR) {\n            require(assetData.length == 4, \"INVALID_ASSET_STRING\");\n        } else {\n            revert(\"UNSUPPORTED_TOKEN_TYPE\");\n        }\n\n        // Log the registration of a new token.\n        emit LogTokenRegistered(tokenId, assetData);\n    }\n\n    function getQuantum(uint256 tokenId)\n        public view\n        returns (uint256 quantum)\n    {\n        // Verify that the registration is set and valid.\n        require(registeredTokenId[tokenId], \"TOKEN_UNREGISTERED\");\n\n        // Retrieve registration.\n        quantum = tokenIdToQuantum[tokenId];\n    }\n\n    function getAssetData(uint256 tokenId)\n        public view\n        returns (bytes memory assetData)\n    {\n        // Verify that the registration is set and valid.\n        require(registeredTokenId[tokenId], \"TOKEN_UNREGISTERED\");\n\n        // Retrieve registration.\n        assetData = tokenIdToAssetData[tokenId];\n    }\n\n    function toQuantized(\n        uint256 tokenId,\n        uint256 amount\n    )\n        internal view\n        returns (uint256 quantizedAmount)\n    {\n        uint256 quantum = getQuantum(tokenId);\n        require(amount % quantum == 0, \"INVALID_AMOUNT\");\n        quantizedAmount = amount / quantum;\n    }\n\n    function fromQuantized(\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal view\n        returns (uint256 amount)\n    {\n        uint256 quantum = getQuantum(tokenId);\n        amount = quantizedAmount * quantum;\n        require(amount / quantum == quantizedAmount, \"DEQUANTIZATION_OVERFLOW\");\n    }\n\n    function isEther(\n        uint256 tokenId)\n        internal view returns (bool)\n    {\n        bytes memory assetData = getAssetData(tokenId);\n        bytes4 tokenSelector = extractSelector(assetData);\n\n        return tokenSelector == ETH_SELECTOR;\n    }\n\n    /*\n      Transfers funds from msg.sender to the exchange.\n    */\n    function transferIn(\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal\n    {\n        bytes memory assetData = getAssetData(tokenId);\n        uint256 amount = fromQuantized(tokenId, quantizedAmount);\n\n        bytes4 tokenSelector = extractSelector(assetData);\n        if (tokenSelector == ERC20_SELECTOR) {\n            uint256 tokenAddress = extractUint256(assetData, ERC20_ADDRESS_OFFSET);\n            safeERC20Call(\n                address(tokenAddress),\n                abi.encodeWithSelector(\n                IERC20(0).transferFrom.selector, msg.sender, address(this), amount));\n        } else if (tokenSelector == ETH_SELECTOR) {\n            require(msg.value == amount, \"INCORRECT_DEPOSIT_AMOUNT\");\n        } else {\n            revert(\"UNSUPPORTED_TOKEN_TYPE\");\n        }\n    }\n\n    /*\n      Transfers funds from the exchange to msg.sender.\n    */\n    function transferOut(\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal\n    {\n        bytes memory assetData = getAssetData(tokenId);\n        uint256 amount = fromQuantized(tokenId, quantizedAmount);\n\n        bytes4 tokenSelector = extractSelector(assetData);\n        if (tokenSelector == ERC20_SELECTOR) {\n            uint256 tokenAddress = extractUint256(assetData, ERC20_ADDRESS_OFFSET);\n            safeERC20Call(\n                address(tokenAddress),\n                abi.encodeWithSelector(IERC20(0).transfer.selector, msg.sender, amount));\n        } else if (tokenSelector == ETH_SELECTOR) {\n            msg.sender.transfer(amount);\n        } else {\n            revert(\"UNSUPPORTED_TOKEN_TYPE\");\n        }\n    }\n}\n"},"UpdateState.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IDexStatementVerifier.sol\";\nimport \"IVerifierActions.sol\";\nimport \"MApprovalChain.sol\";\nimport \"MFreezable.sol\";\nimport \"MOperator.sol\";\nimport \"LibConstants.sol\";\nimport \"PublicInputOffsets.sol\";\n\n/**\n  The StarkEx contract tracks the state of the off-chain exchange service by storing Merkle roots\n  of the vault state (off-chain account state) and the order state (including fully executed and\n  partially fulfilled orders).\n\n  The :sol:mod:`Operator` is the only entity entitled to submit state updates by\n  calling :sol:func:`updateState` and this is only allowed if the contract is not in the `frozen`\n  state (see :sol:mod:`FullWithdrawals`). The call includes the public input of a STARK proof, and\n  additional data (`applicationData`) that includes information not attested to by the proof.\n\n  The public input includes the current (initial) and next (final) Merkle roots as mentioned above,\n  the heights of the Merkle trees and for each ramping operation (deposit, withdraw, full withdraw)\n  the following information:\n\n  1. ID of the vault (off-chain account)\n  2. Stark Key of the vault owner\n  3. Token ID of the currency in the vault\n  4. Vault balance before the operation\n  5. Vault balance after the operation\n\n  The above information is used by the exchange contract in order to update the pending accounts\n  used for deposits (see :sol:mod:`Deposits`) and withdrawals (see :sol:mod:`Withdrawals`).\n\n  The `applicationData` holds the number of ramping operations included in the batch as well as the\n  key of the entity requesting each full withdrawal (see :sol:mod:`FullWithdrawals`). The latter is\n  required in case an entity that isn\u0027t the owner of a vault requests a full withdrawal for that\n  vault. In such a case the exchange contract marks the request as serviced but without performing\n  the withdrawal.\n\n  The STARK proof attesting to the validity of the state update is submitted separately by the\n  exchange service to (one or more) STARK integrity verifier contract(s)\n  (see :sol:mod:`IDexStatementVerifier`). Likewise, the signatures of committee members attesting to\n  the availability of the vault and order data is submitted separately by the exchange service to\n  (one or more) availability verifier contract(s) (see :sol:mod:`Committee`).\n\n  The state update is only accepted by the exchange contract if the integrity verifier and\n  availability verifier contracts have indeed received such proof of soundness and data\n  availability.\n*/\ncontract UpdateState is\n    MApprovalChain,\n    LibConstants,\n    IVerifierActions,\n    MFreezable,\n    MOperator,\n    PublicInputOffsets\n{\n    event VerifiedFact(bytes32 factHash);\n\n    function updateState(\n        uint256[] calldata publicInput,\n        uint256[] calldata applicationData\n    )\n        external\n        notFrozen()\n        onlyOperator()\n    {\n        require(\n            publicInput.length \u003e= OFFSET_MODIFICATION_DATA,\n            \"publicInput does not contain all required fields.\");\n        require(publicInput[OFFSET_VAULT_FINAL_ROOT] \u003c K_MODULUS, \"New vault root \u003e= PRIME.\");\n        require(publicInput[OFFSET_ORDER_FINAL_ROOT] \u003c K_MODULUS, \"New order root \u003e= PRIME.\");\n        require(\n            lastBatchId == 0 ||\n            applicationData[APPLICATION_DATA_PREVIOUS_BATCH_ID_OFFSET] == lastBatchId,\n            \"WRONG_PREVIOUS_BATCH_ID\");\n\n        bytes32 publicInputFact = keccak256(abi.encodePacked(publicInput));\n        verifyFact(\n            verifiersChain, publicInputFact, \"NO_STATE_TRANSITION_VERIFIERS\",\n            \"NO_STATE_TRANSITION_PROOF\");\n        emit VerifiedFact(publicInputFact);\n\n        bytes32 availabilityFact = keccak256(\n            abi.encodePacked(\n            publicInput[OFFSET_VAULT_FINAL_ROOT], publicInput[OFFSET_VAULT_TREE_HEIGHT],\n            publicInput[OFFSET_ORDER_FINAL_ROOT], publicInput[OFFSET_ORDER_TREE_HEIGHT],\n            sequenceNumber + 1));\n        verifyFact(\n            availabilityVerifiersChain, availabilityFact, \"NO_AVAILABILITY_VERIFIERS\",\n            \"NO_AVAILABILITY_PROOF\");\n\n        performUpdateState(publicInput, applicationData);\n    }\n\n    function performUpdateState(\n        uint256[] memory publicInput,\n        uint256[] memory applicationData\n    )\n        internal\n    {\n        rootUpdate(\n            publicInput[OFFSET_VAULT_INITIAL_ROOT],\n            publicInput[OFFSET_VAULT_FINAL_ROOT],\n            publicInput[OFFSET_ORDER_INITIAL_ROOT],\n            publicInput[OFFSET_ORDER_FINAL_ROOT],\n            publicInput[OFFSET_VAULT_TREE_HEIGHT],\n            publicInput[OFFSET_ORDER_TREE_HEIGHT],\n            applicationData[APPLICATION_DATA_BATCH_ID_OFFSET]\n        );\n        sendModifications(publicInput, applicationData);\n    }\n\n    function sendModifications(\n        uint256[] memory publicInput,\n        uint256[] memory applicationData\n    ) private {\n        require(\n            applicationData.length \u003e= APPLICATION_DATA_MODIFICATIONS_OFFSET,\n            \"applicationData does not contain all required fields.\");\n        uint256 nModifications = applicationData[APPLICATION_DATA_N_MODIFICATIONS_OFFSET];\n        require(\n            nModifications == (publicInput.length - OFFSET_MODIFICATION_DATA) / N_WORDS_PER_MODIFICATION,\n            \"Inconsistent number of modifications.\");\n        require(\n            applicationData.length == nModifications + APPLICATION_DATA_MODIFICATIONS_OFFSET,\n            \"Inconsistent number of modifications in applicationData and publicInput.\");\n\n        for (uint256 i = 0; i \u003c nModifications; i++) {\n            uint256 modificationOffset = OFFSET_MODIFICATION_DATA + i * N_WORDS_PER_MODIFICATION;\n            uint256 starkKey = publicInput[modificationOffset];\n            uint256 requestingKey = applicationData[i + APPLICATION_DATA_MODIFICATIONS_OFFSET];\n            uint256 tokenId = publicInput[modificationOffset + 1];\n\n            require(starkKey \u003c K_MODULUS, \"Stark key \u003e= PRIME\");\n            require(requestingKey \u003c K_MODULUS, \"Requesting key \u003e= PRIME\");\n            require(tokenId \u003c K_MODULUS, \"Token id \u003e= PRIME\");\n\n            uint256 actionParams = publicInput[modificationOffset + 2];\n            uint256 amountBefore = (actionParams \u003e\u003e 192) \u0026 ((1 \u003c\u003c 63) - 1);\n            uint256 amountAfter = (actionParams \u003e\u003e 128) \u0026 ((1 \u003c\u003c 63) - 1);\n            uint256 vaultId = (actionParams \u003e\u003e 96) \u0026 ((1 \u003c\u003c 31) - 1);\n\n            if (requestingKey != 0) {\n                // This is a false full withdrawal.\n                require(\n                    starkKey != requestingKey,\n                    \"False full withdrawal requesting_key should differ from the vault owner key.\");\n                require(amountBefore == amountAfter, \"Amounts differ in false full withdrawal.\");\n                // The verified publicInput implies that the vaultId is currently owned by the\n                // starkKey. Hence, any full withdrawal request coming from a different key for this\n                // vaultId is false and may be cleared.\n                clearFullWithdrawalRequest(requestingKey, vaultId);\n                continue;\n            }\n\n            // This is a deposit.\n            if (amountAfter \u003e amountBefore) {\n                uint256 quantizedAmount = amountAfter - amountBefore;\n                acceptDeposit(starkKey, vaultId, tokenId, quantizedAmount);\n            } else {\n                // This is a withdrawal, in case the final amount is zero,\n                // handled as a full withdrawal.\n                if (amountBefore \u003e amountAfter) {\n                    uint256 quantizedAmount = amountBefore - amountAfter;\n                    acceptWithdrawal(starkKey, tokenId, quantizedAmount);\n                }\n                if (amountAfter == 0) {\n                    clearFullWithdrawalRequest(starkKey, vaultId);\n                }\n            }\n        }\n    }\n}\n"},"Users.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"MUsers.sol\";\nimport \"MGovernance.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  Users of the Stark Exchange are identified within the exchange by their Stark Key which is a\n  public key defined over a Stark-friendly elliptic curve that is different from the standard\n  Ethereum elliptic curve. These keys may be generated using the same private key used by the user\n  on Ethereum.\n\n  The Stark-friendly elliptic curve used is defined as follows:\n\n  .. math:: y^2 = (x^3 + \\alpha \\cdot x + \\beta) \\% p\n\n  where:\n\n  .. math:: \\alpha = 1\n  .. math:: \\beta = 3141592653589793238462643383279502884197169399375105820974944592307816406665\n  .. math:: p = 3618502788666131213697322783095070105623107215331596699973092056135872020481\n\n  In order to associate exchange users with Ethereum account addresses, a user must register the\n  Stark Key on the exchange contract before any other user operation can take place.\n  User registration is performed by calling :sol:func:`register` with the selected Stark Key,\n  representing an `x` coordinate on the Stark-friendly elliptic curve, and the `y` coordinate of\n  the key on the curve (due to the nature of the curve, only two such possible `y` coordinates\n  exist).\n\n  The registration is accepted if the following holds:\n\n  1. The key registered is not zero and has not been registered in the past by the user or anyone else.\n  2. The key provided represents a valid point on the Stark-friendly elliptic curve.\n  3. The linkage between the Ethereum key of the caller and the selected Stark Key is signed by the User Admin (typically the exchange operator).\n\n  If the above holds, the Stark Key is registered by the contract mapping it to the Ethereum key\n  of the registering entity and vice versa. This mapping is later used to ensure that withdrawals\n  from accounts mapped to the Stark Key can only be performed by a user authenticated with the\n  associated Ethereum public key (see :sol:mod:`Withdrawals`).\n*/\n/*\n  Implements MUsers.\n*/\ncontract Users is MainStorage, LibConstants, MGovernance, MUsers {\n    event LogUserRegistered(address etherKey, uint256 starkKey);\n    event LogUserAdminAdded(address userAdmin);\n    event LogUserAdminRemoved(address userAdmin);\n\n    function initialize (\n        IECDSA ecdsaContract\n    ) internal\n    {\n        ecdsaContract_ = ecdsaContract;\n    }\n\n    function isOnCurve(uint256 starkKey) private view returns (bool) {\n        uint256 xCubed = mulmod(mulmod(starkKey, starkKey, K_MODULUS), starkKey, K_MODULUS);\n        return isQuadraticResidue(addmod(addmod(xCubed, starkKey, K_MODULUS), K_BETA, K_MODULUS));\n    }\n\n    function registerUserAdmin(address newAdmin) external onlyGovernance() {\n        userAdmins[newAdmin] = true;\n        emit LogUserAdminAdded(newAdmin);\n    }\n\n    function unregisterUserAdmin(address oldAdmin) external onlyGovernance() {\n        userAdmins[oldAdmin] = false;\n        emit LogUserAdminRemoved(oldAdmin);\n    }\n\n    function isUserAdmin(address testedAdmin) public view returns (bool) {\n        return userAdmins[testedAdmin];\n    }\n\n    function register(\n        uint256 starkKey, bytes calldata userAdminSignature,\n        bytes calldata starkSignature) external {\n        // Validate keys and availability.\n        address etherKey = msg.sender;\n        require(starkKey != 0, \"INVALID_STARK_KEY\");\n        require(starkKeys[etherKey] == 0, \"ETHER_KEY_UNAVAILABLE\");\n        require(etherKeys[starkKey] == ZERO_ADDRESS, \"STARK_KEY_UNAVAILABLE\");\n        require(starkKey \u003c K_MODULUS, \"INVALID_STARK_KEY\");\n        require(isOnCurve(starkKey), \"INVALID_STARK_KEY\");\n        require(userAdminSignature.length == 65, \"INVALID_SIGNATURE\");\n        require(starkSignature.length == 32*3, \"INVALID_STARK_SIGNATURE\");\n\n        bytes32 keyPairHash = keccak256(abi.encodePacked(etherKey, starkKey));\n\n        // Validate eth signature.\n        {\n            bytes memory sig = userAdminSignature;\n            uint8 v = uint8(sig[64]);\n            bytes32 r;\n            bytes32 s;\n\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                r := mload(add(sig, 32))\n                s := mload(add(sig, 64))\n            }\n\n            address signer = ecrecover(keyPairHash, v, r, s);\n            require(isUserAdmin(signer), \"INVALID_SIGNATURE\");\n        }\n\n        // Verify stark signature.\n        bytes32 hashed_message = keccak256(\n            abi.encodePacked(\"\\x10starkex_register\", etherKey));\n\n        uint256 y;\n        uint256 r;\n        uint256 s;\n\n        {\n            bytes memory sig = starkSignature;\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                r := mload(add(sig, 32))\n                s := mload(add(sig, 64))\n                y := mload(add(sig, 96))\n            }\n        }\n\n        ecdsaContract_.verify(uint256(hashed_message), r, s, starkKey, y);\n\n        // Update state.\n        starkKeys[etherKey] = starkKey;\n        etherKeys[starkKey] = etherKey;\n\n        // Log new user.\n        emit LogUserRegistered(etherKey, starkKey);\n    }\n\n    function getStarkKey(address etherKey) public view returns (uint256 starkKey) {\n        // Fetch the user\u0027s STARK key.\n        starkKey = starkKeys[etherKey];\n        require(starkKey != 0, \"USER_UNREGISTERED\");\n    }\n\n    function getEtherKey(uint256 starkKey) external view returns (address etherKey) {\n        // Fetch the user\u0027s Ether key.\n        etherKey = etherKeys[starkKey];\n        require(etherKey != ZERO_ADDRESS, \"USER_UNREGISTERED\");\n    }\n\n    function fieldPow(uint256 base, uint256 exponent) internal view returns (uint256) {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory returndata) = address(5).staticcall(\n            abi.encode(0x20, 0x20, 0x20, base, exponent, K_MODULUS)\n        );\n        require(success, string(returndata));\n        return abi.decode(returndata, (uint256));\n    }\n\n    function isQuadraticResidue(uint256 fieldElement) private view returns (bool) {\n        return 1 == fieldPow(fieldElement, ((K_MODULUS - 1) / 2));\n    }\n}\n"},"Verifiers.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"LibConstants.sol\";\nimport \"MApprovalChain.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  A Verifier contract is an implementation of a STARK verifier that the exchange service sends\n  STARK proofs to (see :sol:mod:`IDexStatementVerifier`). In addition, the exchange contract can\n  call a verifier to check if a valid proof has been accepted for a given state transition\n  (typically described as a hash on the public input of the assumed proof).\n\n  The exchange contract will normally query only one verifier contract for proof validity checks.\n  However, in the event that the verifier algorithm needs to updated, additional verifiers may be\n  registered with the exchange contract by the contract :sol:mod:`MainGovernance`. Such new\n  verifiers are then also be required to attest to the validity of state transitions and only if all\n  the verifiers attest to the validity the state transition is accepted.\n\n  Removal of verifiers is also the responsibility of the :sol:mod:`MainGovernance`. The removal\n  process is more sensitive than verifier registration as it may affect the soundness of the system.\n  Hence, this is performed in two steps:\n\n  1. The :sol:mod:`MainGovernance` first announces the intent to remove a verifier by calling :sol:func:`announceVerifierRemovalIntent`\n  2. After the expiration of a `VERIFIER_REMOVAL_DELAY` time lock, actual removal may be performed by calling :sol:func:`removeVerifier`\n\n  The removal delay ensures that a user concerned about the soundness of the system has ample time\n  to leave the exchange.\n*/\ncontract Verifiers is MainStorage, MApprovalChain, LibConstants {\n    function getRegisteredVerifiers()\n        external view\n        returns (address[] memory _verifers)\n    {\n        return verifiersChain.list;\n    }\n\n    function isVerifier(address verifierAddress)\n        external view\n        returns (bool)\n    {\n        return findEntry(verifiersChain.list, verifierAddress) != ENTRY_NOT_FOUND;\n    }\n\n    function registerVerifier(address verifier, string calldata identifier)\n        external\n    {\n        addEntry(verifiersChain, verifier, MAX_VERIFIER_COUNT, identifier);\n    }\n\n    function announceVerifierRemovalIntent(address verifier)\n        external\n    {\n        announceRemovalIntent(verifiersChain, verifier, VERIFIER_REMOVAL_DELAY);\n    }\n\n    function removeVerifier(address verifier)\n        external\n    {\n        removeEntry(verifiersChain, verifier);\n    }\n}\n"},"Withdrawals.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.5.2;\n\nimport \"IVerifierActions.sol\";\nimport \"MFreezable.sol\";\nimport \"MOperator.sol\";\nimport \"MUsers.sol\";\nimport \"MTokens.sol\";\nimport \"MWithdrawal.sol\";\nimport \"MainStorage.sol\";\n\n/**\n  For a user to perform a withdrawal operation from the Stark Exchange during normal operation\n  two calls are required:\n\n  1. A call to an offchain exchange API, requesting a withdrawal from a user account (vault).\n  2. A call to the on-chain :sol:func:`withdraw` function to perform the actual withdrawal of funds transfering them to the users Eth or ERC20 account (depending on the token type).\n\n  For simplicity, hereafter it is assumed that all tokens are ERC20 tokens but the text below\n  applies to Eth in the same manner.\n\n  In the first call mentioned above, anyone can call the API to request the withdrawal of an\n  amount from a given vault. Following the request, the exchange may include the withdrawal in a\n  STARK proof. The submission of a proof then results in the addition of the amount(s) withdrawn to\n  an on-chain pending withdrawals account under the stark key of the vault owner and the appropriate\n  token ID. At the same time, this also implies that this amount is deducted from the off-chain\n  vault.\n\n  Once the amount to be withdrawn has been transfered to the on-chain pending withdrawals account,\n  the user may perform the second call mentioned above to complete the transfer of funds from the\n  Stark Exchange contract to the appropriate ERC20 account. Only a user holding the Eth key\n  corresponding to the Stark Key of a pending withdrawals account may perform this operation.\n\n  It is possible that for multiple withdrawal calls to the API, a single withdrawal call to the\n  contract may retrieve all funds, as long as they are all for the same token ID.\n\n  The result of the operation, assuming all requirements are met, is that an amount of ERC20 tokens\n  in the pending withdrawal account times the quantization factor is transferred to the ERC20\n  account of the user.\n\n  A withdrawal request cannot be cancelled. Once funds reach the pending withdrawals account\n  on-chain, they cannot be moved back into an off-chain vault before completion of the withdrawal\n  to the ERC20 account of the user.\n\n  In the event that the exchange reaches a frozen state the user may perform a withdrawal operation\n  via an alternative flow, known as the \"Escape\" flow. In this flow, the API call above is replaced\n  with an :sol:func:`escape` call to the on-chain contract (see :sol:mod:`Escapes`) proving the\n  ownership of off-chain funds. If such proof is accepted, the user may proceed as above with\n  the :sol:func:`withdraw` call to the contract to complete the operation.\n\n  Implements IVerifierActions.acceptWithdrawal.\n  Uses MFreezable, MOperator, MVerifiers, MUsers and MTokens.\n*/\ncontract Withdrawals is MainStorage, IVerifierActions, MFreezable, MOperator,\n                        MUsers, MTokens, MWithdrawal {\n    event LogWithdrawal(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 nonQuantizedAmount,\n        uint256 quantizedAmount\n    );\n\n    event LogUserWithdrawal(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 nonQuantizedAmount,\n        uint256 quantizedAmount\n    );\n\n    function getWithdrawalBalance(\n        uint256 starkKey,\n        uint256 tokenId\n    )\n        external view\n        returns (uint256 balance)\n    {\n        balance = fromQuantized(tokenId, pendingWithdrawals[starkKey][tokenId]);\n    }\n\n    /*\n      Allows a user to withdraw accepted funds.\n      This function can be called normally while frozen.\n    */\n    function withdraw(\n        uint256 tokenId\n    )\n        external\n        // Can be called normally and while frozen.\n    {\n        // Fetch user and key.\n        address etherKey = msg.sender;\n        uint256 starkKey = getStarkKey(etherKey);\n\n        // Fetch and clear quantized amount.\n        uint256 quantizedAmount = pendingWithdrawals[starkKey][tokenId];\n        pendingWithdrawals[starkKey][tokenId] = 0;\n\n        // Transfer funds.\n        transferOut(tokenId, quantizedAmount);\n        emit LogUserWithdrawal(\n            starkKey, tokenId, fromQuantized(tokenId, quantizedAmount), quantizedAmount);\n    }\n\n    /*\n      Allows a verifier to authorize a withdrawal.\n    */\n    function allowWithdrawal(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal\n    {\n        // Fetch withdrawal.\n        uint256 withdrawal = pendingWithdrawals[starkKey][tokenId];\n\n        // Add accepted quantized amount.\n        withdrawal += quantizedAmount;\n        require(withdrawal \u003e= quantizedAmount, \"WITHDRAWAL_OVERFLOW\");\n\n        // Store withdrawal.\n        pendingWithdrawals[starkKey][tokenId] = withdrawal;\n\n        // Log event.\n        emit LogWithdrawal(\n            starkKey, tokenId, fromQuantized(tokenId, quantizedAmount), quantizedAmount);\n    }\n\n\n    // Verifier authorizes withdrawal.\n    function acceptWithdrawal(\n        uint256 starkKey,\n        uint256 tokenId,\n        uint256 quantizedAmount\n    )\n        internal\n    {\n        allowWithdrawal(starkKey, tokenId, quantizedAmount);\n    }\n}\n"}}