{"ABDKMath64x64.sol":{"content":"// SPDX-License-Identifier: BSD-4-Clause\t\r\n\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov \u003cmikhail.vladimirov@gmail.com\u003e\r\n */\r\npragma solidity ^0.5.0 || ^0.6.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n  /**\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n  /**\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n  /**\r\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromInt (int256 x) internal pure returns (int128) {\r\n    require (x \u003e= -0x8000000000000000 \u0026\u0026 x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x \u003c\u003c 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n   * rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64-bit integer number\r\n   */\r\n  function toInt (int128 x) internal pure returns (int64) {\r\n    return int64 (x \u003e\u003e 64);\r\n  }\r\n\r\n  /**\r\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n   * number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function fromUInt (uint256 x) internal pure returns (int128) {\r\n    require (x \u003c= 0x7FFFFFFFFFFFFFFF);\r\n    return int128 (x \u003c\u003c 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n   * number rounding down.  Revert on underflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return unsigned 64-bit integer number\r\n   */\r\n  function toUInt (int128 x) internal pure returns (uint64) {\r\n    require (x \u003e= 0);\r\n    return uint64 (x \u003e\u003e 64);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n   * number rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 128.128-bin fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function from128x128 (int256 x) internal pure returns (int128) {\r\n    int256 result = x \u003e\u003e 64;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n   * number.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 128.128 fixed point number\r\n   */\r\n  function to128x128 (int128 x) internal pure returns (int256) {\r\n    return int256 (x) \u003c\u003c 64;\r\n  }\r\n\r\n  /**\r\n   * Calculate x + y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function add (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) + y;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x - y.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sub (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) - y;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function mul (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 result = int256(x) * y \u003e\u003e 64;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n   * number and y is signed 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 256-bit integer number\r\n   */\r\n  function muli (int128 x, int256 y) internal pure returns (int256) {\r\n    if (x == MIN_64x64) {\r\n      require (y \u003e= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF \u0026\u0026\r\n        y \u003c= 0x1000000000000000000000000000000000000000000000000);\r\n      return -y \u003c\u003c 63;\r\n    } else {\r\n      bool negativeResult = false;\r\n      if (x \u003c 0) {\r\n        x = -x;\r\n        negativeResult = true;\r\n      }\r\n      if (y \u003c 0) {\r\n        y = -y; // We rely on overflow behavior here\r\n        negativeResult = !negativeResult;\r\n      }\r\n      uint256 absoluteResult = mulu (x, uint256 (y));\r\n      if (negativeResult) {\r\n        require (absoluteResult \u003c=\r\n          0x8000000000000000000000000000000000000000000000000000000000000000);\r\n        return -int256 (absoluteResult); // We rely on overflow behavior here\r\n      } else {\r\n        require (absoluteResult \u003c=\r\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return int256 (absoluteResult);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64 fixed point number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 256-bit integer number\r\n   */\r\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\r\n    if (y == 0) return 0;\r\n\r\n    require (x \u003e= 0);\r\n\r\n    uint256 lo = (uint256 (x) * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) \u003e\u003e 64;\r\n    uint256 hi = uint256 (x) * (y \u003e\u003e 128);\r\n\r\n    require (hi \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    hi \u003c\u003c= 64;\r\n\r\n    require (hi \u003c=\r\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n    return hi + lo;\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function div (int128 x, int128 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    int256 result = (int256 (x) \u003c\u003c 64) / y;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x signed 256-bit integer number\r\n   * @param y signed 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divi (int256 x, int256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n\r\n    bool negativeResult = false;\r\n    if (x \u003c 0) {\r\n      x = -x; // We rely on overflow behavior here\r\n      negativeResult = true;\r\n    }\r\n    if (y \u003c 0) {\r\n      y = -y; // We rely on overflow behavior here\r\n      negativeResult = !negativeResult;\r\n    }\r\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\r\n    if (negativeResult) {\r\n      require (absoluteResult \u003c= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\r\n    require (y != 0);\r\n    uint128 result = divuu (x, y);\r\n    require (result \u003c= uint128 (MAX_64x64));\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate -x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function neg (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return -x;\r\n  }\r\n\r\n  /**\r\n   * Calculate |x|.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function abs (int128 x) internal pure returns (int128) {\r\n    require (x != MIN_64x64);\r\n    return x \u003c 0 ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n   * zero.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function inv (int128 x) internal pure returns (int128) {\r\n    require (x != 0);\r\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\r\n    require (result \u003e= MIN_64x64 \u0026\u0026 result \u003c= MAX_64x64);\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function avg (int128 x, int128 y) internal pure returns (int128) {\r\n    return int128 ((int256 (x) + int256 (y)) \u003e\u003e 1);\r\n  }\r\n\r\n  /**\r\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n   * Revert on overflow or in case x * y is negative.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\r\n    int256 m = int256 (x) * int256 (y);\r\n    require (m \u003e= 0);\r\n    require (m \u003c\r\n        0x4000000000000000000000000000000000000000000000000000000000000000);\r\n    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) \u003e\u003e 1));\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\r\n    uint256 absoluteResult;\r\n    bool negativeResult = false;\r\n    if (x \u003e= 0) {\r\n      absoluteResult = powu (uint256 (x) \u003c\u003c 63, y);\r\n    } else {\r\n      // We rely on overflow behavior here\r\n      absoluteResult = powu (uint256 (uint128 (-x)) \u003c\u003c 63, y);\r\n      negativeResult = y \u0026 1 \u003e 0;\r\n    }\r\n\r\n    absoluteResult \u003e\u003e= 63;\r\n\r\n    if (negativeResult) {\r\n      require (absoluteResult \u003c= 0x80000000000000000000000000000000);\r\n      return -int128 (absoluteResult); // We rely on overflow behavior here\r\n    } else {\r\n      require (absoluteResult \u003c= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n      return int128 (absoluteResult); // We rely on overflow behavior here\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down.  Revert if x \u003c 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function sqrt (int128 x) internal pure returns (int128) {\r\n    require (x \u003e= 0);\r\n    return int128 (sqrtu (uint256 (x) \u003c\u003c 64, 0x10000000000000000));\r\n  }\r\n\r\n  /**\r\n   * Calculate binary logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function log_2 (int128 x) internal pure returns (int128) {\r\n    require (x \u003e 0);\r\n\r\n    int256 msb = 0;\r\n    int256 xc = x;\r\n    if (xc \u003e= 0x10000000000000000) { xc \u003e\u003e= 64; msb += 64; }\r\n    if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n    if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n    if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n    if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n    if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n    if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n    int256 result = msb - 64 \u003c\u003c 64;\r\n    uint256 ux = uint256 (x) \u003c\u003c 127 - msb;\r\n    for (int256 bit = 0x8000000000000000; bit \u003e 0; bit \u003e\u003e= 1) {\r\n      ux *= ux;\r\n      uint256 b = ux \u003e\u003e 255;\r\n      ux \u003e\u003e= 127 + b;\r\n      result += bit * int256 (b);\r\n    }\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural logarithm of x.  Revert if x \u003c= 0.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function ln (int128 x) internal pure returns (int128) {\r\n    require (x \u003e 0);\r\n\r\n    return int128 (\r\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF \u003e\u003e 128);\r\n  }\r\n\r\n  /**\r\n   * Calculate binary exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp_2 (int128 x) internal pure returns (int128) {\r\n    require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n    if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n    uint256 result = 0x80000000000000000000000000000000;\r\n\r\n    if (x \u0026 0x8000000000000000 \u003e 0)\r\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E \u003e\u003e 128;\r\n    if (x \u0026 0x4000000000000000 \u003e 0)\r\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC \u003e\u003e 128;\r\n    if (x \u0026 0x2000000000000000 \u003e 0)\r\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F \u003e\u003e 128;\r\n    if (x \u0026 0x1000000000000000 \u003e 0)\r\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 \u003e\u003e 128;\r\n    if (x \u0026 0x800000000000000 \u003e 0)\r\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD \u003e\u003e 128;\r\n    if (x \u0026 0x400000000000000 \u003e 0)\r\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 \u003e\u003e 128;\r\n    if (x \u0026 0x200000000000000 \u003e 0)\r\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F \u003e\u003e 128;\r\n    if (x \u0026 0x100000000000000 \u003e 0)\r\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 \u003e\u003e 128;\r\n    if (x \u0026 0x80000000000000 \u003e 0)\r\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B \u003e\u003e 128;\r\n    if (x \u0026 0x40000000000000 \u003e 0)\r\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F \u003e\u003e 128;\r\n    if (x \u0026 0x20000000000000 \u003e 0)\r\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF \u003e\u003e 128;\r\n    if (x \u0026 0x10000000000000 \u003e 0)\r\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 \u003e\u003e 128;\r\n    if (x \u0026 0x8000000000000 \u003e 0)\r\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D \u003e\u003e 128;\r\n    if (x \u0026 0x4000000000000 \u003e 0)\r\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 \u003e\u003e 128;\r\n    if (x \u0026 0x2000000000000 \u003e 0)\r\n      result = result * 0x1000162E525EE054754457D5995292026 \u003e\u003e 128;\r\n    if (x \u0026 0x1000000000000 \u003e 0)\r\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC \u003e\u003e 128;\r\n    if (x \u0026 0x800000000000 \u003e 0)\r\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB \u003e\u003e 128;\r\n    if (x \u0026 0x400000000000 \u003e 0)\r\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 \u003e\u003e 128;\r\n    if (x \u0026 0x200000000000 \u003e 0)\r\n      result = result * 0x10000162E43F4F831060E02D839A9D16D \u003e\u003e 128;\r\n    if (x \u0026 0x100000000000 \u003e 0)\r\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 \u003e\u003e 128;\r\n    if (x \u0026 0x80000000000 \u003e 0)\r\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 \u003e\u003e 128;\r\n    if (x \u0026 0x40000000000 \u003e 0)\r\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B \u003e\u003e 128;\r\n    if (x \u0026 0x20000000000 \u003e 0)\r\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 \u003e\u003e 128;\r\n    if (x \u0026 0x10000000000 \u003e 0)\r\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE \u003e\u003e 128;\r\n    if (x \u0026 0x8000000000 \u003e 0)\r\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF \u003e\u003e 128;\r\n    if (x \u0026 0x4000000000 \u003e 0)\r\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A \u003e\u003e 128;\r\n    if (x \u0026 0x2000000000 \u003e 0)\r\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 \u003e\u003e 128;\r\n    if (x \u0026 0x1000000000 \u003e 0)\r\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 \u003e\u003e 128;\r\n    if (x \u0026 0x800000000 \u003e 0)\r\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 \u003e\u003e 128;\r\n    if (x \u0026 0x400000000 \u003e 0)\r\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 \u003e\u003e 128;\r\n    if (x \u0026 0x200000000 \u003e 0)\r\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF \u003e\u003e 128;\r\n    if (x \u0026 0x100000000 \u003e 0)\r\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 \u003e\u003e 128;\r\n    if (x \u0026 0x80000000 \u003e 0)\r\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD \u003e\u003e 128;\r\n    if (x \u0026 0x40000000 \u003e 0)\r\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC \u003e\u003e 128;\r\n    if (x \u0026 0x20000000 \u003e 0)\r\n      result = result * 0x100000000162E42FEFB2FED257559BDAA \u003e\u003e 128;\r\n    if (x \u0026 0x10000000 \u003e 0)\r\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE \u003e\u003e 128;\r\n    if (x \u0026 0x8000000 \u003e 0)\r\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE \u003e\u003e 128;\r\n    if (x \u0026 0x4000000 \u003e 0)\r\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D \u003e\u003e 128;\r\n    if (x \u0026 0x2000000 \u003e 0)\r\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 \u003e\u003e 128;\r\n    if (x \u0026 0x1000000 \u003e 0)\r\n      result = result * 0x10000000000B17217F7D20CF927C8E94C \u003e\u003e 128;\r\n    if (x \u0026 0x800000 \u003e 0)\r\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D \u003e\u003e 128;\r\n    if (x \u0026 0x400000 \u003e 0)\r\n      result = result * 0x100000000002C5C85FDF477B662B26945 \u003e\u003e 128;\r\n    if (x \u0026 0x200000 \u003e 0)\r\n      result = result * 0x10000000000162E42FEFA3AE53369388C \u003e\u003e 128;\r\n    if (x \u0026 0x100000 \u003e 0)\r\n      result = result * 0x100000000000B17217F7D1D351A389D40 \u003e\u003e 128;\r\n    if (x \u0026 0x80000 \u003e 0)\r\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE \u003e\u003e 128;\r\n    if (x \u0026 0x40000 \u003e 0)\r\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E \u003e\u003e 128;\r\n    if (x \u0026 0x20000 \u003e 0)\r\n      result = result * 0x100000000000162E42FEFA39FE95583C2 \u003e\u003e 128;\r\n    if (x \u0026 0x10000 \u003e 0)\r\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 \u003e\u003e 128;\r\n    if (x \u0026 0x8000 \u003e 0)\r\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 \u003e\u003e 128;\r\n    if (x \u0026 0x4000 \u003e 0)\r\n      result = result * 0x10000000000002C5C85FDF473E242EA38 \u003e\u003e 128;\r\n    if (x \u0026 0x2000 \u003e 0)\r\n      result = result * 0x1000000000000162E42FEFA39F02B772C \u003e\u003e 128;\r\n    if (x \u0026 0x1000 \u003e 0)\r\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A \u003e\u003e 128;\r\n    if (x \u0026 0x800 \u003e 0)\r\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E \u003e\u003e 128;\r\n    if (x \u0026 0x400 \u003e 0)\r\n      result = result * 0x100000000000002C5C85FDF473DEA871F \u003e\u003e 128;\r\n    if (x \u0026 0x200 \u003e 0)\r\n      result = result * 0x10000000000000162E42FEFA39EF44D91 \u003e\u003e 128;\r\n    if (x \u0026 0x100 \u003e 0)\r\n      result = result * 0x100000000000000B17217F7D1CF79E949 \u003e\u003e 128;\r\n    if (x \u0026 0x80 \u003e 0)\r\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 \u003e\u003e 128;\r\n    if (x \u0026 0x40 \u003e 0)\r\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA \u003e\u003e 128;\r\n    if (x \u0026 0x20 \u003e 0)\r\n      result = result * 0x100000000000000162E42FEFA39EF366F \u003e\u003e 128;\r\n    if (x \u0026 0x10 \u003e 0)\r\n      result = result * 0x1000000000000000B17217F7D1CF79AFA \u003e\u003e 128;\r\n    if (x \u0026 0x8 \u003e 0)\r\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D \u003e\u003e 128;\r\n    if (x \u0026 0x4 \u003e 0)\r\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 \u003e\u003e 128;\r\n    if (x \u0026 0x2 \u003e 0)\r\n      result = result * 0x1000000000000000162E42FEFA39EF358 \u003e\u003e 128;\r\n    if (x \u0026 0x1 \u003e 0)\r\n      result = result * 0x10000000000000000B17217F7D1CF79AB \u003e\u003e 128;\r\n\r\n    result \u003e\u003e= 63 - (x \u003e\u003e 64);\r\n    require (result \u003c= uint256 (MAX_64x64));\r\n\r\n    return int128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate natural exponent of x.  Revert on overflow.\r\n   *\r\n   * @param x signed 64.64-bit fixed point number\r\n   * @return signed 64.64-bit fixed point number\r\n   */\r\n  function exp (int128 x) internal pure returns (int128) {\r\n    require (x \u003c 0x400000000000000000); // Overflow\r\n\r\n    if (x \u003c -0x400000000000000000) return 0; // Underflow\r\n\r\n    return exp_2 (\r\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 \u003e\u003e 128));\r\n  }\r\n\r\n  /**\r\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n   * integer numbers.  Revert on overflow or when y is zero.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @param y unsigned 256-bit integer number\r\n   * @return unsigned 64.64-bit fixed point number\r\n   */\r\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\r\n    require (y != 0);\r\n\r\n    uint256 result;\r\n\r\n    if (x \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n      result = (x \u003c\u003c 64) / y;\r\n    else {\r\n      uint256 msb = 192;\r\n      uint256 xc = x \u003e\u003e 192;\r\n      if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n      if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n      if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n      if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n      if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n      if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      result = (x \u003c\u003c 255 - msb) / ((y - 1 \u003e\u003e msb - 191) + 1);\r\n      require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 hi = result * (y \u003e\u003e 128);\r\n      uint256 lo = result * (y \u0026 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n      uint256 xh = x \u003e\u003e 192;\r\n      uint256 xl = x \u003c\u003c 64;\r\n\r\n      if (xl \u003c lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n      lo = hi \u003c\u003c 128;\r\n      if (xl \u003c lo) xh -= 1;\r\n      xl -= lo; // We rely on overflow behavior here\r\n\r\n      assert (xh == hi \u003e\u003e 128);\r\n\r\n      result += xl / y;\r\n    }\r\n\r\n    require (result \u003c= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n    return uint128 (result);\r\n  }\r\n\r\n  /**\r\n   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\r\n   * number and y is unsigned 256-bit integer number.  Revert on overflow.\r\n   *\r\n   * @param x unsigned 129.127-bit fixed point number\r\n   * @param y uint256 value\r\n   * @return unsigned 129.127-bit fixed point number\r\n   */\r\n  function powu (uint256 x, uint256 y) private pure returns (uint256) {\r\n    if (y == 0) return 0x80000000000000000000000000000000;\r\n    else if (x == 0) return 0;\r\n    else {\r\n      int256 msb = 0;\r\n      uint256 xc = x;\r\n      if (xc \u003e= 0x100000000000000000000000000000000) { xc \u003e\u003e= 128; msb += 128; }\r\n      if (xc \u003e= 0x10000000000000000) { xc \u003e\u003e= 64; msb += 64; }\r\n      if (xc \u003e= 0x100000000) { xc \u003e\u003e= 32; msb += 32; }\r\n      if (xc \u003e= 0x10000) { xc \u003e\u003e= 16; msb += 16; }\r\n      if (xc \u003e= 0x100) { xc \u003e\u003e= 8; msb += 8; }\r\n      if (xc \u003e= 0x10) { xc \u003e\u003e= 4; msb += 4; }\r\n      if (xc \u003e= 0x4) { xc \u003e\u003e= 2; msb += 2; }\r\n      if (xc \u003e= 0x2) msb += 1;  // No need to shift xc anymore\r\n\r\n      int256 xe = msb - 127;\r\n      if (xe \u003e 0) x \u003e\u003e= xe;\r\n      else x \u003c\u003c= -xe;\r\n\r\n      uint256 result = 0x80000000000000000000000000000000;\r\n      int256 re = 0;\r\n\r\n      while (y \u003e 0) {\r\n        if (y \u0026 1 \u003e 0) {\r\n          result = result * x;\r\n          y -= 1;\r\n          re += xe;\r\n          if (result \u003e=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            result \u003e\u003e= 128;\r\n            re += 1;\r\n          } else result \u003e\u003e= 127;\r\n          if (re \u003c -127) return 0; // Underflow\r\n          require (re \u003c 128); // Overflow\r\n        } else {\r\n          x = x * x;\r\n          y \u003e\u003e= 1;\r\n          xe \u003c\u003c= 1;\r\n          if (x \u003e=\r\n            0x8000000000000000000000000000000000000000000000000000000000000000) {\r\n            x \u003e\u003e= 128;\r\n            xe += 1;\r\n          } else x \u003e\u003e= 127;\r\n          if (xe \u003c -127) return 0; // Underflow\r\n          require (xe \u003c 128); // Overflow\r\n        }\r\n      }\r\n\r\n      if (re \u003e 0) result \u003c\u003c= re;\r\n      else if (re \u003c 0) result \u003e\u003e= -re;\r\n\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n   * number.\r\n   *\r\n   * @param x unsigned 256-bit integer number\r\n   * @return unsigned 128-bit integer number\r\n   */\r\n  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\r\n    if (x == 0) return 0;\r\n    else {\r\n      require (r \u003e 0);\r\n      while (true) {\r\n        uint256 rr = x / r;\r\n        if (r == rr || r + 1 == rr) return uint128 (r);\r\n        else if (r == rr + 1) return uint128 (rr);\r\n        r = r + rr + 1 \u003e\u003e 1;\r\n      }\r\n    }\r\n  }\r\n}\r\n"},"BaseToken.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\n// This is modified StandardToken contract from https://github.com/ConsenSys/Tokens\n// Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.6.0;\n\nimport \"./Token.sol\";\n\ncontract BaseToken is Token {\n\n    function transfer(address _to, uint256 _value) override virtual external returns (bool success) {\n        require(balances[msg.sender] \u003e= _value \u0026\u0026 balances[_to] + _value \u003e balances[_to]);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) override virtual external returns (bool success) {\n        require(balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e= _value \u0026\u0026 balances[_to] + _value \u003e balances[_to]);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) view override virtual external returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) override virtual external returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) override virtual external view returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address =\u003e uint256) public balances;\n    mapping (address =\u003e mapping (address =\u003e uint256)) public allowed;\n}\n"},"Files.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./BaseToken.sol\u0027;\nimport \u0027./ABDKMath64x64.sol\u0027;\n\ncontract Files is BaseToken {\n\n    using ABDKMath64x64 for int128;\n\n    enum EntryKind { NONE, DOWNLOADS, LINK, CATEGORY }\n\n    uint256 constant LINK_KIND_LINK = 0;\n    uint256 constant LINK_KIND_MESSAGE = 1;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n\n    // 64.64 fixed point number\n    int128 public salesOwnersShare = int128(1).divi(int128(10)); // 10%\n    int128 public upvotesOwnersShare = int128(1).divi(int128(2)); // 50%\n    int128 public uploadOwnersShare = int128(15).divi(int128(100)); // 15%\n    int128 public buyerAffiliateShare = int128(1).divi(int128(10)); // 10%\n    int128 public sellerAffiliateShare = int128(15).divi(int128(100)); // 15%\n\n    uint maxId = 0;\n\n    mapping (uint =\u003e EntryKind) entries;\n\n    // to avoid categories with duplicate titles:\n    mapping (string =\u003e mapping (string =\u003e uint)) categoryTitles; // locale =\u003e (title =\u003e id)\n\n    mapping (string =\u003e address payable) nickAddresses;\n    mapping (address =\u003e string) addressNicks;\n\n    event SetOwner(address payable owner); // share is 64.64 fixed point number\n    event SetSalesOwnerShare(int128 share); // share is 64.64 fixed point number\n    event SetUpvotesOwnerShare(int128 share); // share is 64.64 fixed point number\n    event SetUploadOwnerShare(int128 share); // share is 64.64 fixed point number\n    event SetBuyerAffiliateShare(int128 share); // share is 64.64 fixed point number\n    event SetSellerAffiliateShare(int128 share); // share is 64.64 fixed point number\n    event SetNick(address payable indexed owner, string nick);\n    event SetARWallet(address payable indexed owner, string arWallet);\n    event SetAuthorInfo(address payable indexed owner, string link, string shortDescription, string description, string locale);\n    event ItemCreated(uint indexed itemId);\n    event SetItemOwner(uint indexed itemId, address payable indexed owner);\n    event ItemUpdated(uint indexed itemId, ItemInfo info);\n    event LinkUpdated(uint indexed linkId,\n                      string link,\n                      string title,\n                      string shortDescription,\n                      string description,\n                      string locale,\n                      uint256 indexed linkKind);\n    event ItemCoverUpdated(uint indexed itemId, uint indexed version, bytes cover, uint width, uint height);\n    event ItemFilesUpdated(uint indexed itemId, string format, uint indexed version, bytes hash);\n    event SetLastItemVersion(uint indexed itemId, uint version);\n    event CategoryCreated(uint256 indexed categoryId, address indexed owner); // zero owner - no owner\n    event CategoryUpdated(uint256 indexed categoryId, string title, string locale);\n    event OwnedCategoryUpdated(uint256 indexed categoryId,\n                               string title, string shortDescription,\n                               string description,\n                               string locale,\n                               address indexed owner);\n    event ChildParentVote(uint child,\n                          uint parent,\n                          int256 value,\n                          int256 featureLevel,\n                          bool primary); // Vote is primary if it\u0027s an owner\u0027s vote.\n    event Pay(address indexed payer, address indexed payee, uint indexed itemId, uint256 value);\n    event Donate(address indexed payer, address indexed payee, uint indexed itemId, uint256 value);\n\n    address payable public founder;\n    mapping (uint =\u003e address payable) public itemOwners;\n    mapping (uint =\u003e mapping (uint =\u003e int256)) private childParentVotes;\n    mapping (uint =\u003e uint256) public pricesETH;\n    mapping (uint =\u003e uint256) public pricesAR;\n\n    constructor(address payable _founder, uint256 _initialBalance) public {\n        founder = _founder;\n        name = \"Zon Directory PST Token (ETH)\";\n        decimals = 18;\n        symbol = \"ZDPSTE\";\n        balances[_founder] = _initialBalance;\n        totalSupply = _initialBalance;\n    }\n\n// Owners //\n\n    function setOwner(address payable _founder) external {\n        require(msg.sender == founder, \"Access denied.\");\n        require(_founder != address(0), \"Zero address.\"); // also prevents makeing owned categories unowned (spam)\n        founder = _founder;\n        emit SetOwner(_founder);\n    }\n\n    // _share is 64.64 fixed point number\n    function setSalesOwnersShare(int128 _share) external {\n        require(msg.sender == founder, \"Access denied.\");\n        salesOwnersShare = _share;\n        emit SetSalesOwnerShare(_share);\n    }\n\n    function setUpvotesOwnersShare(int128 _share) external {\n        require(msg.sender == founder, \"Access denied.\");\n        upvotesOwnersShare = _share;\n        emit SetUpvotesOwnerShare(_share);\n    }\n\n    function setUploadOwnersShare(int128 _share) external {\n        require(msg.sender == founder, \"Access denied.\");\n        uploadOwnersShare = _share;\n        emit SetUploadOwnerShare(_share);\n    }\n\n    function setBuyerAffiliateShare(int128 _share) external {\n        require(msg.sender == founder, \"Access denied.\");\n        buyerAffiliateShare = _share;\n        emit SetBuyerAffiliateShare(_share);\n    }\n\n    function setSellerAffiliateShare(int128 _share) external {\n        require(msg.sender == founder, \"Access denied.\");\n        sellerAffiliateShare = _share;\n        emit SetSellerAffiliateShare(_share);\n    }\n\n    function setItemOwner(uint _itemId, address payable _owner) external {\n        require(itemOwners[_itemId] == msg.sender, \"Access denied.\");\n        itemOwners[_itemId] = _owner;\n        emit SetItemOwner(_itemId, _owner);\n    }\n\n// Wallets //\n\n    function setARWallet(string calldata _arWallet) external {\n        emit SetARWallet(msg.sender, _arWallet);\n    }\n\n    // TODO: Test.\n    function setNick(string calldata _nick) external {\n        require(nickAddresses[_nick] == address(0), \"Nick taken.\");\n        nickAddresses[addressNicks[msg.sender]] = address(0);\n        nickAddresses[_nick] = msg.sender;\n        addressNicks[msg.sender] = _nick;\n        emit SetNick(msg.sender, _nick);\n    }\n\n    function setAuthorInfo(string calldata _link,\n                           string calldata _shortDescription,\n                           string calldata _description,\n                           string calldata _locale) external {\n        emit SetAuthorInfo(msg.sender, _link, _shortDescription, _description, _locale);\n    }\n\n// Items //\n\n    struct ItemInfo {\n        string title;\n        string shortDescription;\n        string description;\n        uint256 priceETH;\n        uint256 priceAR;\n        string locale;\n        string license;\n    }\n\n    function createItem(ItemInfo calldata _info, address payable _affiliate) external returns (uint)\n    {\n        require(bytes(_info.title).length != 0, \"Empty title.\");\n        setAffiliate(_affiliate);\n        itemOwners[++maxId] = msg.sender;\n        pricesETH[maxId] = _info.priceETH;\n        pricesAR[maxId] = _info.priceAR;\n        entries[maxId] = EntryKind.DOWNLOADS;\n        emit ItemCreated(maxId);\n        emit SetItemOwner(maxId, msg.sender);\n        emit ItemUpdated(maxId, _info);\n        return maxId;\n    }\n\n    function updateItem(uint _itemId, ItemInfo calldata _info) external\n    {\n        require(itemOwners[_itemId] == msg.sender, \"Attempt to modify other\u0027s item.\");\n        require(entries[_itemId] == EntryKind.DOWNLOADS, \"Item does not exist.\");\n        require(bytes(_info.title).length != 0, \"Empty title.\");\n        pricesETH[_itemId] = _info.priceETH;\n        pricesAR[_itemId] = _info.priceAR;\n        emit ItemUpdated(_itemId, _info);\n    }\n\n    struct LinkInfo {\n        string link;\n        string title;\n        string shortDescription;\n        string description;\n        string locale;\n        uint256 linkKind;\n    }\n\n    function createLink(LinkInfo calldata _info, bool _owned, address payable _affiliate) external returns (uint)\n    {\n        require(bytes(_info.title).length != 0, \"Empty title.\");\n        setAffiliate(_affiliate);\n        address payable _owner = _owned ? msg.sender : address(0);\n        itemOwners[++maxId] = _owner;\n        entries[maxId] = EntryKind.LINK;\n        emit ItemCreated(maxId);\n        if (_owned) emit SetItemOwner(maxId, _owner);\n        emit LinkUpdated(maxId, _info.link, _info.title, _info.shortDescription, _info.description, _info.locale, _info.linkKind);\n        return maxId;\n    }\n\n    // Can be used for spam.\n    function updateLink(uint _linkId, LinkInfo calldata _info) external\n    {\n        require(itemOwners[_linkId] == msg.sender, \"Attempt to modify other\u0027s link.\"); // only owned links\n        require(bytes(_info.title).length != 0, \"Empty title.\");\n        require(entries[_linkId] == EntryKind.LINK, \"Link does not exist.\");\n        emit LinkUpdated(_linkId,\n                         _info.link,\n                         _info.title,\n                         _info.shortDescription,\n                         _info.description,\n                         _info.locale,\n                         _info.linkKind);\n    }\n\n    function updateItemCover(uint _itemId, uint _version, bytes calldata _cover, uint _width, uint _height) external {\n        require(itemOwners[_itemId] == msg.sender, \"Access denied.\"); // only owned entries\n        EntryKind kind = entries[_itemId];\n        require(kind != EntryKind.NONE, \"Entry does not exist.\");\n        emit ItemCoverUpdated(_itemId, _version, _cover, _width, _height);\n    }\n\n    function uploadFile(uint _itemId, uint _version, string calldata _format, bytes calldata _hash) external {\n        require(_hash.length == 32, \"Wrong hash length.\");\n        require(itemOwners[_itemId] == msg.sender, \"Attempt to modify other\u0027s item.\");\n        require(entries[_itemId] == EntryKind.DOWNLOADS, \"Item does not exist.\");\n        emit ItemFilesUpdated(_itemId, _format, _version, _hash);\n    }\n\n    function setLastItemVersion(uint _itemId, uint _version) external {\n        require(itemOwners[_itemId] == msg.sender, \"Attempt to modify other\u0027s item.\");\n        require(entries[_itemId] == EntryKind.DOWNLOADS, \"Item does not exist.\");\n        emit SetLastItemVersion(_itemId, _version);\n    }\n\n    function pay(uint _itemId, address payable _affiliate) external payable returns (bytes memory) {\n        require(pricesETH[_itemId] \u003c= msg.value, \"Paid too little.\");\n        require(entries[_itemId] == EntryKind.DOWNLOADS, \"Item does not exist.\");\n        setAffiliate(_affiliate);\n        uint256 _shareholdersShare = uint256(salesOwnersShare.muli(int256(msg.value)));\n        address payable _author = itemOwners[_itemId];\n        payToShareholders(_shareholdersShare, _author);\n        uint256 toAuthor = msg.value - _shareholdersShare;\n        _author.transfer(toAuthor);\n        emit Pay(msg.sender, itemOwners[_itemId], _itemId, toAuthor);\n    }\n\n    function donate(uint _itemId, address payable _affiliate) external payable returns (bytes memory) {\n        require(entries[_itemId] == EntryKind.DOWNLOADS, \"Item does not exist.\");\n        setAffiliate(_affiliate);\n        uint256 _shareholdersShare = uint256(salesOwnersShare.muli(int256(msg.value)));\n        address payable _author = itemOwners[_itemId];\n        payToShareholders(_shareholdersShare, _author);\n        uint256 toAuthor = msg.value - _shareholdersShare;\n        _author.transfer(toAuthor);\n        emit Donate(msg.sender, itemOwners[_itemId], _itemId, toAuthor);\n    }\n\n// Categories //\n\n    function createCategory(string calldata _title, string calldata _locale, address payable _affiliate) external returns (uint) {\n        require(bytes(_title).length != 0, \"Empty title.\");\n        setAffiliate(_affiliate);\n        ++maxId;\n        uint _id = categoryTitles[_locale][_title];\n        if(_id != 0)\n            return _id;\n        else\n            categoryTitles[_locale][_title] = maxId;\n        entries[maxId] = EntryKind.CATEGORY;\n        // Yes, issue _owner two times, for faster information retrieval\n        emit CategoryCreated(maxId, address(0));\n        emit CategoryUpdated(maxId, _title, _locale);\n        return maxId;\n    }\n\n    struct OwnedCategoryInfo {\n        string title;\n        string shortDescription;\n        string description;\n        string locale;\n    }\n\n    function createOwnedCategory(OwnedCategoryInfo calldata _info, address payable _affiliate) external returns (uint) {\n        require(bytes(_info.title).length != 0, \"Empty title.\");\n        setAffiliate(_affiliate);\n        ++maxId;\n        entries[maxId] = EntryKind.CATEGORY;\n        itemOwners[maxId] = msg.sender;\n        // Yes, issue _owner two times, for faster information retrieval\n        emit CategoryCreated(maxId, msg.sender);\n        emit SetItemOwner(maxId, msg.sender);\n        emit OwnedCategoryUpdated(maxId, _info.title, _info.shortDescription, _info.description, _info.locale, msg.sender);\n        return maxId;\n    }\n\n    function updateOwnedCategory(uint _categoryId, OwnedCategoryInfo calldata _info) external {\n        require(itemOwners[_categoryId] == msg.sender, \"Access denied.\");\n        require(entries[_categoryId] == EntryKind.CATEGORY, \"Must be a category.\");\n        emit OwnedCategoryUpdated(_categoryId, _info.title, _info.shortDescription, _info.description, _info.locale, msg.sender);\n    }\n\n// Voting //\n\n    function voteChildParent(uint _child, uint _parent, bool _yes, address payable _affiliate) external payable {\n        require(entries[_child] != EntryKind.NONE, \"Child does not exist.\");\n        require(entries[_parent] == EntryKind.CATEGORY, \"Must be a category.\");\n        setAffiliate(_affiliate);\n        int256 _value = _yes ? int256(msg.value) : -int256(msg.value);\n        if(_value == 0) return; // We don\u0027t want to pollute the events with zero votes.\n        int256 _newValue = childParentVotes[_child][_parent] + _value;\n        childParentVotes[_child][_parent] = _newValue;\n        address payable _owner = itemOwners[_child];\n        if(_yes \u0026\u0026 _owner != address(0)) {\n            uint256 _shareholdersShare = uint256(upvotesOwnersShare.muli(int256(msg.value)));\n            payToShareholders(_shareholdersShare, _owner);\n            _owner.transfer(msg.value - _shareholdersShare);\n        } else\n            payToShareholders(msg.value, address(0));\n        emit ChildParentVote(_child, _parent, _newValue, 0, false);\n    }\n\n    function voteForOwnChild(uint _child, uint _parent) external payable {\n        require(entries[_child] != EntryKind.NONE, \"Child does not exist.\");\n        require(entries[_parent] == EntryKind.CATEGORY, \"Must be a category.\");\n        address _owner = itemOwners[_child];\n        require(_owner == msg.sender, \"Must be owner.\");\n        if(msg.value == 0) return; // We don\u0027t want to pollute the events with zero votes.\n        int256 _value = upvotesOwnersShare.inv().muli(int256(msg.value));\n        int256 _newValue = childParentVotes[_child][_parent] + _value;\n        childParentVotes[_child][_parent] = _newValue;\n        payToShareholders(msg.value, address(0));\n        emit ChildParentVote(_child, _parent, _newValue, 0, false);\n    }\n\n    // _value \u003e 0 - present\n    function setMyChildParent(uint _child, uint _parent, int256 _value, int256 _featureLevel) external {\n        require(entries[_child] != EntryKind.NONE, \"Child does not exist.\");\n        require(entries[_parent] == EntryKind.CATEGORY, \"Must be a category.\");\n        require(itemOwners[_parent] == msg.sender, \"Access denied.\");\n        emit ChildParentVote(_child, _parent, _value, _featureLevel, true);\n    }\n\n    function getChildParentVotes(uint _child, uint _parent) external view returns (int256) {\n        return childParentVotes[_child][_parent];\n    }\n\n// PST //\n\n    uint256 totalDividends = 0;\n    uint256 totalDividendsPaid = 0; // actually paid sum\n    mapping(address =\u003e uint256) lastTotalDivedends; // the value of totalDividends after the last payment to an address\n\n    function _dividendsOwing(address _account) internal view returns(uint256) {\n        uint256 _newDividends = totalDividends - lastTotalDivedends[_account];\n        return (balances[_account] * _newDividends) / totalSupply; // rounding down\n    }\n\n    function dividendsOwing(address _account) external view returns(uint256) {\n        return _dividendsOwing(_account);\n    }\n\n    function withdrawProfit() external {\n        uint256 _owing = _dividendsOwing(msg.sender);\n\n        // Against rounding errors. Not necessary because of rounding down.\n        // if(_owing \u003e address(this).balance) _owing = address(this).balance;\n\n        if(_owing \u003e 0) {\n            msg.sender.transfer(_owing);\n            totalDividendsPaid += _owing;\n            lastTotalDivedends[msg.sender] = totalDividends;\n        }\n    }\n\n    function payToShareholders(uint256 _amount, address _author) internal {\n        address payable _affiliate = affiliates[msg.sender];\n        uint256 _shareHoldersAmount = _amount;\n        if(uint(_affiliate) \u003e 1) {\n            uint256 _buyerAffiliateAmount = uint256(buyerAffiliateShare.muli(int256(_amount)));\n            _affiliate.transfer(_buyerAffiliateAmount);\n            require(_shareHoldersAmount \u003e= _buyerAffiliateAmount, \"Attempt to pay negative amount.\");\n            _shareHoldersAmount -= _buyerAffiliateAmount;\n        }\n        if(uint(_author) \u003e 1) {\n            uint256 _sellerAffiliateAmount = uint256(sellerAffiliateShare.muli(int256(_amount)));\n            payable(_author).transfer(_sellerAffiliateAmount);\n            require(_shareHoldersAmount \u003e= _sellerAffiliateAmount, \"Attempt to pay negative amount.\");\n            _shareHoldersAmount -= _sellerAffiliateAmount;\n        }\n        totalDividends += _shareHoldersAmount;\n    }\n\n// Affiliates //\n\n    mapping (address =\u003e address payable) affiliates;\n\n    // Last affiliate wins.\n    function setAffiliate(address payable _affiliate) internal {\n        // if(affiliates[_affiliate] == address(0))\n        //     affiliates[_affiliate] = _affiliate;\n        if(uint256(_affiliate) \u003e 1)\n            affiliates[_affiliate] = _affiliate;\n    }\n}\n"},"Migrations.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity \u003e=0.4.21 \u003c0.7.0;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n"},"Token.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\n// Example get from https://github.com/ConsenSys/Tokens\npragma solidity ^0.6.0;\n\nabstract contract Token {\n\n    /// total amount of tokens\n    uint256 public totalSupply;\n\n    function balanceOf(address _owner) virtual external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) virtual external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value) virtual external returns (bool success);\n\n    function approve(address _spender, uint256 _value) virtual external returns (bool success);\n\n    function allowance(address _owner, address _spender) virtual external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"}}