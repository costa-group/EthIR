{"IERC20.sol":{"content":"pragma solidity 0.5.16;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"IMorpherToken.sol":{"content":"pragma solidity 0.5.16;\r\n\r\ninterface IMorpherToken {\r\n    /**\r\n     * Emits a {Transfer} event in ERC-20 token contract.\r\n     */\r\n    function emitTransfer(address _from, address _to, uint256 _amount) external;\r\n}"},"MorpherState.sol":{"content":"pragma solidity 0.5.16;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./IMorpherToken.sol\";\r\n\r\n// ----------------------------------------------------------------------------------\r\n// Data and token balance storage of the Morpher platform\r\n// Writing access is only granted to platform contracts. The contract can be paused\r\n// by an elected platform administrator (see MorpherGovernance) to perform protocol updates.\r\n// ----------------------------------------------------------------------------------\r\n\r\ncontract MorpherState is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    bool public mainChain;\r\n    uint256 public totalSupply;\r\n    uint256 public totalToken;\r\n    uint256 public totalInPositions;\r\n    uint256 public totalOnOtherChain;\r\n    uint256 public maximumLeverage = 10**9; // Leverage precision is 1e8, maximum leverage set to 10 initially\r\n    uint256 constant PRECISION = 10**8;\r\n    uint256 constant DECIMALS = 18;\r\n    uint256 constant REWARDPERIOD = 1 days;\r\n    bool public paused = false;\r\n\r\n    address public morpherGovernance;\r\n    address public morpherRewards;\r\n    address public administrator;\r\n    address public oracleContract;\r\n    address public sideChainOperator;\r\n    address public morpherBridge;\r\n    address public morpherToken;\r\n\r\n    uint256 public rewardBasisPoints;\r\n    uint256 public lastRewardTime;\r\n\r\n    bytes32 public sideChainMerkleRoot;\r\n    uint256 public sideChainMerkleRootWrittenAtTime;\r\n\r\n    // Set initial withdraw limit from sidechain to 20m token or 2% of initial supply\r\n    uint256 public mainChainWithdrawLimit24 = 2 * 10**25;\r\n\r\n    mapping(address =\u003e bool) private stateAccess;\r\n    mapping(address =\u003e bool) private transferAllowed;\r\n\r\n    mapping(address =\u003e uint256) private balances;\r\n    mapping(address =\u003e mapping(address =\u003e uint256)) private allowed;\r\n\r\n    mapping(bytes32 =\u003e bool) private marketActive;\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Position struct records virtual futures\r\n    // ----------------------------------------------------------------------------\r\n    struct position {\r\n        uint256 lastUpdated;\r\n        uint256 longShares;\r\n        uint256 shortShares;\r\n        uint256 meanEntryPrice;\r\n        uint256 meanEntrySpread;\r\n        uint256 meanEntryLeverage;\r\n        uint256 liquidationPrice;\r\n        bytes32 positionHash;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // A portfolio is an address specific collection of postions\r\n    // ----------------------------------------------------------------------------\r\n    mapping(address =\u003e mapping(bytes32 =\u003e position)) private portfolio;\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Record all addresses that hold a position of a market, needed for clean stock splits\r\n    // ----------------------------------------------------------------------------\r\n    struct hasExposure {\r\n        uint256 maxMappingIndex;\r\n        mapping(address =\u003e uint256) index;\r\n        mapping(uint256 =\u003e address) addy;\r\n    }\r\n\r\n    mapping(bytes32 =\u003e hasExposure) private exposureByMarket;\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Bridge Variables\r\n    // ----------------------------------------------------------------------------\r\n    mapping (address =\u003e uint256) private tokenClaimedOnThisChain;\r\n    mapping (address =\u003e uint256) private tokenSentToLinkedChain;\r\n    mapping (address =\u003e uint256) private tokenSentToLinkedChainTime;\r\n    mapping (bytes32 =\u003e bool) private positionClaimedOnMainChain;\r\n\r\n    uint256 public lastWithdrawLimitReductionTime;\r\n    uint256 public last24HoursAmountWithdrawn;\r\n    uint256 public withdrawLimit24Hours;\r\n    uint256 public inactivityPeriod = 3 days;\r\n    uint256 public transferNonce;\r\n    bool public fastTransfersEnabled;\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Sidechain spam protection\r\n    // ----------------------------------------------------------------------------\r\n\r\n    mapping(address =\u003e uint256) private lastRequestBlock;\r\n    mapping(address =\u003e uint256) private numberOfRequests;\r\n    uint256 public numberOfRequestsLimit;\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Events\r\n    // ----------------------------------------------------------------------------\r\n    event StateAccessGranted(address indexed whiteList, uint256 indexed blockNumber);\r\n    event StateAccessDenied(address indexed blackList, uint256 indexed blockNumber);\r\n\r\n    event TransfersEnabled(address indexed whiteList);\r\n    event TransfersDisabled(address indexed blackList);\r\n\r\n    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\r\n    event Mint(address indexed recipient, uint256 amount, uint256 totalToken);\r\n    event Burn(address indexed recipient, uint256 amount, uint256 totalToken);\r\n    event NewTotalSupply(uint256 newTotalSupply);\r\n    event NewTotalOnOtherChain(uint256 newTotalOnOtherChain);\r\n    event NewTotalInPositions(uint256 newTotalOnOtherChain);\r\n    event OperatingRewardMinted(address indexed recipient, uint256 amount);\r\n\r\n    event RewardsChange(address indexed rewardsAddress, uint256 indexed rewardsBasisPoints);\r\n    event LastRewardTime(uint256 indexed rewardsTime);\r\n    event GovernanceChange(address indexed governanceAddress);\r\n    event TokenChange(address indexed tokenAddress);\r\n    event AdministratorChange(address indexed administratorAddress);\r\n    event OracleChange(address indexed oracleContract);\r\n    event MaximumLeverageChange(uint256 maxLeverage);\r\n    event MarketActivated(bytes32 indexed activateMarket);\r\n    event MarketDeActivated(bytes32 indexed deActivateMarket);\r\n    event BridgeChange(address _bridgeAddress);\r\n    event SideChainMerkleRootUpdate(bytes32 indexed sideChainMerkleRoot);\r\n    event NewSideChainOperator(address indexed sideChainOperator);\r\n    event NumberOfRequestsLimitUpdate(uint256 _numberOfRequests);\r\n\r\n    event MainChainWithdrawLimitUpdate(uint256 indexed mainChainWithdrawLimit24);\r\n    event TokenSentToLinkedChain(address _address, uint256 _token, uint256 _totalTokenSent, bytes32 indexed _tokenSentToLinkedChainHash);\r\n    event TransferredTokenClaimed(address _address, uint256 _token);\r\n    event LastWithdrawAt();\r\n    event RollingWithdrawnAmountUpdated(uint256 _last24HoursAmountWithdrawn, uint256 _lastWithdrawLimitReductionTime);\r\n    event WithdrawLimitUpdated(uint256 _amount);\r\n    event InactivityPeriodUpdated(uint256 _periodLength);\r\n    event FastWithdrawsDisabled();\r\n    event NewBridgeNonce(uint256 _transferNonce);\r\n    event Last24HoursAmountWithdrawnReset();\r\n\r\n    event StatePaused(address administrator, bool _paused);\r\n\r\n    event SetAllowance(address indexed sender, address indexed spender, uint256 tokens);\r\n    event SetPosition(bytes32 indexed positionHash,\r\n        address indexed sender,\r\n        bytes32 indexed marketId,\r\n        uint256 timeStamp,\r\n        uint256 longShares,\r\n        uint256 shortShares,\r\n        uint256 meanEntryPrice,\r\n        uint256 meanEntrySpread,\r\n        uint256 meanEntryLeverage,\r\n        uint256 liquidationPrice\r\n    );\r\n    event SetBalance(address indexed account, uint256 balance, bytes32 indexed balanceHash);\r\n    event TokenTransferredToOtherChain(address indexed account, uint256 tokenTransferredToOtherChain, bytes32 indexed transferHash);\r\n\r\n    modifier notPaused {\r\n        require(paused == false, \"MorpherState: Contract paused, aborting\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPlatform {\r\n        require(stateAccess[msg.sender] == true, \"MorpherState: Only Platform is allowed to execute operation.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernance {\r\n        require(msg.sender == getGovernance(), \"MorpherState: Calling contract not the Governance Contract. Aborting.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdministrator {\r\n        require(msg.sender == getAdministrator(), \"MorpherState: Caller is not the Administrator. Aborting.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySideChainOperator {\r\n        require(msg.sender == sideChainOperator, \"MorpherState: Caller is not the Sidechain Operator. Aborting.\");\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer {\r\n        require(getCanTransfer(msg.sender), \"MorpherState: Caller may not transfer token. Aborting.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyBridge {\r\n        require(msg.sender == getMorpherBridge(), \"MorpherState: Caller is not the Bridge. Aborting.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyMainChain {\r\n        require(mainChain == true, \"MorpherState: Can only be called on mainchain.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySideChain {\r\n        require(mainChain == false, \"MorpherState: Can only be called on mainchain.\");\r\n        _;\r\n    }\r\n\r\n    constructor(bool _mainChain, address _sideChainOperator, address _morpherTreasury) public {\r\n        // @Deployer: Transfer State Ownership to cold storage address after deploying protocol\r\n        mainChain = _mainChain; // true for Ethereum, false for Morpher PoA sidechain\r\n        setLastRewardTime(now);\r\n        uint256 _sideChainMint = 575000000 * 10**(DECIMALS);\r\n        uint256 _mainChainMint = 425000000 * 10**(DECIMALS);\r\n        grantAccess(owner());\r\n        setSideChainOperator(owner());\r\n        if (mainChain == false) { // Create token only on sidechain\r\n            balances[owner()] = _sideChainMint; // Create airdrop and team token on sidechain\r\n            totalToken = _sideChainMint;\r\n            emit Mint(owner(), balanceOf(owner()), _sideChainMint);\r\n            setRewardBasisPoints(0); // Reward is minted on mainchain\r\n            setRewardAddress(address(0));\r\n            setTotalOnOtherChain(_mainChainMint);\r\n        } else {\r\n            balances[owner()] = _mainChainMint; // Create treasury and investor token on mainchain\r\n            totalToken = _mainChainMint;\r\n            emit Mint(owner(), balanceOf(owner()), _mainChainMint);\r\n            setRewardBasisPoints(15000); // 15000 / PRECISION = 0.00015\r\n            setRewardAddress(_morpherTreasury);\r\n            setTotalOnOtherChain(_sideChainMint);\r\n        }\r\n        fastTransfersEnabled = true;\r\n        setNumberOfRequestsLimit(3);\r\n        setMainChainWithdrawLimit(totalSupply / 50);\r\n        setSideChainOperator(_sideChainOperator);\r\n        denyAccess(owner());\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for market wise exposure\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function getMaxMappingIndex(bytes32 _marketId) public view returns(uint256 _maxMappingIndex) {\r\n        return exposureByMarket[_marketId].maxMappingIndex;\r\n    }\r\n\r\n    function getExposureMappingIndex(bytes32 _marketId, address _address) public view returns(uint256 _mappingIndex) {\r\n        return exposureByMarket[_marketId].index[_address];\r\n    }\r\n\r\n    function getExposureMappingAddress(bytes32 _marketId, uint256 _mappingIndex) public view returns(address _address) {\r\n        return exposureByMarket[_marketId].addy[_mappingIndex];\r\n    }\r\n\r\n    function setMaxMappingIndex(bytes32 _marketId, uint256 _maxMappingIndex) public onlyPlatform {\r\n        exposureByMarket[_marketId].maxMappingIndex = _maxMappingIndex;\r\n    }\r\n\r\n    function setExposureMapping(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform  {\r\n        setExposureMappingIndex(_marketId, _address, _index);\r\n        setExposureMappingAddress(_marketId, _address, _index);\r\n    }\r\n\r\n    function setExposureMappingIndex(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\r\n        exposureByMarket[_marketId].index[_address] = _index;\r\n    }\r\n\r\n    function setExposureMappingAddress(bytes32 _marketId, address _address, uint256 _index) public onlyPlatform {\r\n        exposureByMarket[_marketId].addy[_index] = _address;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for bridge variables\r\n    // ----------------------------------------------------------------------------\r\n    function setTokenClaimedOnThisChain(address _address, uint256 _token) public onlyBridge {\r\n        tokenClaimedOnThisChain[_address] = _token;\r\n        emit TransferredTokenClaimed(_address, _token);\r\n    }\r\n\r\n    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token) {\r\n        return tokenClaimedOnThisChain[_address];\r\n    }\r\n\r\n    function setTokenSentToLinkedChain(address _address, uint256 _token) public onlyBridge {\r\n        tokenSentToLinkedChain[_address] = _token;\r\n        tokenSentToLinkedChainTime[_address] = now;\r\n        emit TokenSentToLinkedChain(_address, _token, tokenSentToLinkedChain[_address], getBalanceHash(_address, tokenSentToLinkedChain[_address]));\r\n    }\r\n\r\n    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\r\n        return tokenSentToLinkedChain[_address];\r\n    }\r\n\r\n    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _timeStamp) {\r\n        return tokenSentToLinkedChainTime[_address];\r\n    }\r\n\r\n    function add24HoursWithdrawn(uint256 _amount) public onlyBridge {\r\n        last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.add(_amount);\r\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\r\n    }\r\n\r\n    function update24HoursWithdrawLimit(uint256 _amount) public onlyBridge {\r\n        if (last24HoursAmountWithdrawn \u003e _amount) {\r\n            last24HoursAmountWithdrawn = last24HoursAmountWithdrawn.sub(_amount);\r\n        } else {\r\n            last24HoursAmountWithdrawn = 0;\r\n        }\r\n        lastWithdrawLimitReductionTime = now;\r\n        emit RollingWithdrawnAmountUpdated(last24HoursAmountWithdrawn, lastWithdrawLimitReductionTime);\r\n    }\r\n\r\n    function set24HourWithdrawLimit(uint256 _limit) public onlyBridge {\r\n        withdrawLimit24Hours = _limit;\r\n        emit WithdrawLimitUpdated(_limit);\r\n    }\r\n\r\n    function resetLast24HoursAmountWithdrawn() public onlyBridge {\r\n        last24HoursAmountWithdrawn = 0;\r\n        emit Last24HoursAmountWithdrawnReset();\r\n    }\r\n\r\n    function setInactivityPeriod(uint256 _periodLength) public onlyBridge {\r\n        inactivityPeriod = _periodLength;\r\n        emit InactivityPeriodUpdated(_periodLength);\r\n    }\r\n\r\n    function getBridgeNonce() public onlyBridge returns (uint256 _nonce) {\r\n        transferNonce++;\r\n        emit NewBridgeNonce(transferNonce);\r\n        return transferNonce;\r\n    }\r\n\r\n    function disableFastWithdraws() public onlyBridge {\r\n        fastTransfersEnabled = false;\r\n        emit FastWithdrawsDisabled();\r\n    }\r\n\r\n    function setPositionClaimedOnMainChain(bytes32 _positionHash) public onlyBridge {\r\n        positionClaimedOnMainChain[_positionHash] = true;\r\n    }\r\n\r\n    function getPositionClaimedOnMainChain(bytes32 _positionHash) public view returns (bool _alreadyClaimed) {\r\n        return positionClaimedOnMainChain[_positionHash];\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for spam protection\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function setLastRequestBlock(address _address) public onlyPlatform {\r\n        lastRequestBlock[_address] = block.number;\r\n    }\r\n\r\n    function getLastRequestBlock(address _address) public view returns(uint256 _lastRequestBlock) {\r\n        return lastRequestBlock[_address];\r\n    }\r\n\r\n    function setNumberOfRequests(address _address, uint256 _numberOfRequests) public onlyPlatform {\r\n        numberOfRequests[_address] = _numberOfRequests;\r\n    }\r\n\r\n    function increaseNumberOfRequests(address _address) public onlyPlatform{\r\n        numberOfRequests[_address]++;\r\n    }\r\n\r\n    function getNumberOfRequests(address _address) public view returns(uint256 _numberOfRequests) {\r\n        return numberOfRequests[_address];\r\n    }\r\n\r\n    function setNumberOfRequestsLimit(uint256 _numberOfRequestsLimit) public onlyPlatform {\r\n        numberOfRequestsLimit = _numberOfRequestsLimit;\r\n        emit NumberOfRequestsLimitUpdate(_numberOfRequestsLimit);\r\n    }\r\n\r\n    function getNumberOfRequestsLimit() public view returns (uint256 _numberOfRequestsLimit) {\r\n        return numberOfRequestsLimit;\r\n    }\r\n\r\n    function setMainChainWithdrawLimit(uint256 _mainChainWithdrawLimit24) public onlyOwner {\r\n        mainChainWithdrawLimit24 = _mainChainWithdrawLimit24;\r\n        emit MainChainWithdrawLimitUpdate(_mainChainWithdrawLimit24);\r\n    }\r\n\r\n    function getMainChainWithdrawLimit() public view returns (uint256 _mainChainWithdrawLimit24) {\r\n        return mainChainWithdrawLimit24;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for state access\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function grantAccess(address _address) public onlyOwner {\r\n        stateAccess[_address] = true;\r\n        emit StateAccessGranted(_address, block.number);\r\n    }\r\n\r\n    function denyAccess(address _address) public onlyOwner {\r\n        stateAccess[_address] = false;\r\n        emit StateAccessDenied(_address, block.number);\r\n    }\r\n\r\n    function getStateAccess(address _address) public view returns(bool _hasAccess) {\r\n        return stateAccess[_address];\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for addresses that can transfer tokens (sidechain only)\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function enableTransfers(address _address) public onlyOwner {\r\n        transferAllowed[_address] = true;\r\n        emit TransfersEnabled(_address);\r\n    }\r\n\r\n    function disableTransfers(address _address) public onlyOwner {\r\n        transferAllowed[_address] = false;\r\n        emit TransfersDisabled(_address);\r\n    }\r\n\r\n    function getCanTransfer(address _address) public view returns(bool _hasAccess) {\r\n        return transferAllowed[_address];\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Minting/burning/transfer of token\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function transfer(address _from, address _to, uint256 _token) public onlyPlatform notPaused {\r\n        require(balances[_from] \u003e= _token, \"MorpherState: Not enough token.\");\r\n        balances[_from] = balances[_from].sub(_token);\r\n        balances[_to] = balances[_to].add(_token);\r\n        IMorpherToken(morpherToken).emitTransfer(_from, _to, _token);\r\n        emit Transfer(_from, _to, _token);\r\n        emit SetBalance(_from, balances[_from], getBalanceHash(_from, balances[_from]));\r\n        emit SetBalance(_to, balances[_to], getBalanceHash(_to, balances[_to]));\r\n    }\r\n\r\n    function mint(address _address, uint256 _token) public onlyPlatform notPaused {\r\n        balances[_address] = balances[_address].add(_token);\r\n        totalToken = totalToken.add(_token);\r\n        updateTotalSupply();\r\n        IMorpherToken(morpherToken).emitTransfer(address(0), _address, _token);\r\n        emit Mint(_address, _token, totalToken);\r\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\r\n    }\r\n\r\n    function burn(address _address, uint256 _token) public onlyPlatform notPaused {\r\n        require(balances[_address] \u003e= _token, \"MorpherState: Not enough token.\");\r\n        balances[_address] = balances[_address].sub(_token);\r\n        totalToken = totalToken.sub(_token);\r\n        updateTotalSupply();\r\n        IMorpherToken(morpherToken).emitTransfer(_address, address(0), _token);\r\n        emit Burn(_address, _token, totalToken);\r\n        emit SetBalance(_address, balances[_address], getBalanceHash(_address, balances[_address]));\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for balance and token functions (ERC20)\r\n    // ----------------------------------------------------------------------------\r\n    function updateTotalSupply() private {\r\n        totalSupply = totalToken.add(totalInPositions).add(totalOnOtherChain);\r\n        emit NewTotalSupply(totalSupply);\r\n    }\r\n\r\n    function setTotalInPositions(uint256 _totalInPositions) public onlyAdministrator {\r\n        totalInPositions = _totalInPositions;\r\n        updateTotalSupply();\r\n        emit NewTotalInPositions(_totalInPositions);\r\n    }\r\n\r\n    function setTotalOnOtherChain(uint256 _newTotalOnOtherChain) public onlySideChainOperator {\r\n        totalOnOtherChain = _newTotalOnOtherChain;\r\n        updateTotalSupply();\r\n        emit NewTotalOnOtherChain(_newTotalOnOtherChain);\r\n    }\r\n\r\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\r\n        return balances[_tokenOwner];\r\n    }\r\n\r\n    function setAllowance(address _from, address _spender, uint256 _tokens) public onlyPlatform {\r\n        allowed[_from][_spender] = _tokens;\r\n        emit SetAllowance(_from, _spender, _tokens);\r\n    }\r\n\r\n    function getAllowance(address _tokenOwner, address spender) public view returns (uint256 remaining) {\r\n        return allowed[_tokenOwner][spender];\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for platform roles\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function setGovernanceContract(address _newGovernanceContractAddress) public onlyOwner {\r\n        morpherGovernance = _newGovernanceContractAddress;\r\n        emit GovernanceChange(_newGovernanceContractAddress);\r\n    }\r\n\r\n    function getGovernance() public view returns (address _governanceContract) {\r\n        return morpherGovernance;\r\n    }\r\n\r\n    function setMorpherBridge(address _newBridge) public onlyOwner {\r\n        morpherBridge = _newBridge;\r\n        emit BridgeChange(_newBridge);\r\n    }\r\n\r\n    function getMorpherBridge() public view returns (address _currentBridge) {\r\n        return morpherBridge;\r\n    }\r\n\r\n    function setOracleContract(address _newOracleContract) public onlyGovernance {\r\n        oracleContract = _newOracleContract;\r\n        emit OracleChange(_newOracleContract);\r\n    }\r\n\r\n    function getOracleContract() public view returns(address) {\r\n        return oracleContract;\r\n    }\r\n\r\n    function setTokenContract(address _newTokenContract) public onlyOwner {\r\n        morpherToken = _newTokenContract;\r\n        emit TokenChange(_newTokenContract);\r\n    }\r\n\r\n    function getTokenContract() public view returns(address) {\r\n        return morpherToken;\r\n    }\r\n\r\n    function setAdministrator(address _newAdministrator) public onlyGovernance {\r\n        administrator = _newAdministrator;\r\n        emit AdministratorChange(_newAdministrator);\r\n    }\r\n\r\n    function getAdministrator() public view returns(address) {\r\n        return administrator;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for platform operating rewards\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function setRewardAddress(address _newRewardsAddress) public onlyOwner {\r\n        morpherRewards = _newRewardsAddress;\r\n        emit RewardsChange(_newRewardsAddress, rewardBasisPoints);\r\n    }\r\n\r\n    function setRewardBasisPoints(uint256 _newRewardBasisPoints) public onlyOwner {\r\n        if (mainChain == true) {\r\n            require(_newRewardBasisPoints \u003c= 15000, \"MorpherState: Reward basis points need to be less or equal to 15000.\");\r\n        } else {\r\n            require(_newRewardBasisPoints == 0, \"MorpherState: Reward basis points can only be set on Ethereum.\");\r\n        }\r\n        rewardBasisPoints = _newRewardBasisPoints;\r\n        emit RewardsChange(morpherRewards, _newRewardBasisPoints);\r\n    }\r\n\r\n    function setLastRewardTime(uint256 _lastRewardTime) private {\r\n        lastRewardTime = _lastRewardTime;\r\n        emit LastRewardTime(_lastRewardTime);\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for platform administration\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function activateMarket(bytes32 _activateMarket) public onlyAdministrator {\r\n        marketActive[_activateMarket] = true;\r\n        emit MarketActivated(_activateMarket);\r\n    }\r\n\r\n    function deActivateMarket(bytes32 _deActivateMarket) public onlyAdministrator {\r\n        marketActive[_deActivateMarket] = false;\r\n        emit MarketDeActivated(_deActivateMarket);\r\n    }\r\n\r\n    function getMarketActive(bytes32 _marketId) public view returns(bool _active) {\r\n        return marketActive[_marketId];\r\n    }\r\n\r\n    function setMaximumLeverage(uint256 _newMaximumLeverage) public onlyAdministrator {\r\n        require(_newMaximumLeverage \u003e PRECISION, \"MorpherState: Leverage precision is 1e8\");\r\n        maximumLeverage = _newMaximumLeverage;\r\n        emit MaximumLeverageChange(_newMaximumLeverage);\r\n    }\r\n\r\n    function getMaximumLeverage() public view returns(uint256 _maxLeverage) {\r\n        return maximumLeverage;\r\n    }\r\n\r\n    function pauseState() public onlyAdministrator {\r\n        paused = true;\r\n        emit StatePaused(msg.sender, true);\r\n    }\r\n\r\n    function unPauseState() public onlyAdministrator {\r\n        paused = false;\r\n        emit StatePaused(msg.sender, false);\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter for side chain state\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function setSideChainMerkleRoot(bytes32 _sideChainMerkleRoot) public onlyBridge {\r\n        sideChainMerkleRoot = _sideChainMerkleRoot;\r\n        sideChainMerkleRootWrittenAtTime = now;\r\n        payOperatingReward;\r\n        emit SideChainMerkleRootUpdate(_sideChainMerkleRoot);\r\n    }\r\n\r\n    function getSideChainMerkleRoot() public view returns(bytes32 _sideChainMerkleRoot) {\r\n        return sideChainMerkleRoot;\r\n    }\r\n\r\n    function setSideChainOperator(address _address) public onlyOwner {\r\n        sideChainOperator = _address;\r\n        emit NewSideChainOperator(_address);\r\n    }\r\n\r\n    function getSideChainOperator() public view returns (address _address) {\r\n        return sideChainOperator;\r\n    }\r\n\r\n    function getSideChainMerkleRootWrittenAtTime() public view returns(uint256 _sideChainMerkleRoot) {\r\n        return sideChainMerkleRootWrittenAtTime;\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Setter/Getter functions for portfolio\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function setPosition(\r\n        address _address,\r\n        bytes32 _marketId,\r\n        uint256 _timeStamp,\r\n        uint256 _longShares,\r\n        uint256 _shortShares,\r\n        uint256 _meanEntryPrice,\r\n        uint256 _meanEntrySpread,\r\n        uint256 _meanEntryLeverage,\r\n        uint256 _liquidationPrice\r\n    ) public onlyPlatform {\r\n        portfolio[_address][_marketId].lastUpdated = _timeStamp;\r\n        portfolio[_address][_marketId].longShares = _longShares;\r\n        portfolio[_address][_marketId].shortShares = _shortShares;\r\n        portfolio[_address][_marketId].meanEntryPrice = _meanEntryPrice;\r\n        portfolio[_address][_marketId].meanEntrySpread = _meanEntrySpread;\r\n        portfolio[_address][_marketId].meanEntryLeverage = _meanEntryLeverage;\r\n        portfolio[_address][_marketId].liquidationPrice = _liquidationPrice;\r\n        portfolio[_address][_marketId].positionHash = getPositionHash(\r\n            _address,\r\n            _marketId,\r\n            _timeStamp,\r\n            _longShares,\r\n            _shortShares,\r\n            _meanEntryPrice,\r\n            _meanEntrySpread,\r\n            _meanEntryLeverage,\r\n            _liquidationPrice\r\n        );\r\n        if (_longShares \u003e 0 || _shortShares \u003e 0) {\r\n            addExposureByMarket(_marketId, _address);\r\n        } else {\r\n            deleteExposureByMarket(_marketId, _address);\r\n        }\r\n        emit SetPosition(\r\n            portfolio[_address][_marketId].positionHash,\r\n            _address,\r\n            _marketId,\r\n            _timeStamp,\r\n            _longShares,\r\n            _shortShares,\r\n            _meanEntryPrice,\r\n            _meanEntrySpread,\r\n            _meanEntryLeverage,\r\n            _liquidationPrice\r\n        );\r\n    }\r\n\r\n    function getPosition(\r\n        address _address,\r\n        bytes32 _marketId\r\n    ) public view returns (\r\n        uint256 _longShares,\r\n        uint256 _shortShares,\r\n        uint256 _meanEntryPrice,\r\n        uint256 _meanEntrySpread,\r\n        uint256 _meanEntryLeverage,\r\n        uint256 _liquidationPrice\r\n    ) {\r\n        return(\r\n        portfolio[_address][_marketId].longShares,\r\n        portfolio[_address][_marketId].shortShares,\r\n        portfolio[_address][_marketId].meanEntryPrice,\r\n        portfolio[_address][_marketId].meanEntrySpread,\r\n        portfolio[_address][_marketId].meanEntryLeverage,\r\n        portfolio[_address][_marketId].liquidationPrice\r\n        );\r\n    }\r\n\r\n    function getPositionHash(\r\n        address _address,\r\n        bytes32 _marketId,\r\n        uint256 _timeStamp,\r\n        uint256 _longShares,\r\n        uint256 _shortShares,\r\n        uint256 _meanEntryPrice,\r\n        uint256 _meanEntrySpread,\r\n        uint256 _meanEntryLeverage,\r\n        uint256 _liquidationPrice\r\n    ) public pure returns (bytes32 _hash) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                _address,\r\n                _marketId,\r\n                _timeStamp,\r\n                _longShares,\r\n                _shortShares,\r\n                _meanEntryPrice,\r\n                _meanEntrySpread,\r\n                _meanEntryLeverage,\r\n                _liquidationPrice\r\n            )\r\n        );\r\n    }\r\n\r\n    function getBalanceHash(address _address, uint256 _balance) public pure returns (bytes32 _hash) {\r\n        return keccak256(abi.encodePacked(_address, _balance));\r\n    }\r\n\r\n    function getLastUpdated(address _address, bytes32 _marketId) public view returns (uint256 _lastUpdated) {\r\n        return(portfolio[_address][_marketId].lastUpdated);\r\n    }\r\n\r\n    function getLongShares(address _address, bytes32 _marketId) public view returns (uint256 _longShares) {\r\n        return(portfolio[_address][_marketId].longShares);\r\n    }\r\n\r\n    function getShortShares(address _address, bytes32 _marketId) public view returns (uint256 _shortShares) {\r\n        return(portfolio[_address][_marketId].shortShares);\r\n    }\r\n\r\n    function getMeanEntryPrice(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryPrice) {\r\n        return(portfolio[_address][_marketId].meanEntryPrice);\r\n    }\r\n\r\n    function getMeanEntrySpread(address _address, bytes32 _marketId) public view returns (uint256 _meanEntrySpread) {\r\n        return(portfolio[_address][_marketId].meanEntrySpread);\r\n    }\r\n\r\n    function getMeanEntryLeverage(address _address, bytes32 _marketId) public view returns (uint256 _meanEntryLeverage) {\r\n        return(portfolio[_address][_marketId].meanEntryLeverage);\r\n    }\r\n\r\n    function getLiquidationPrice(address _address, bytes32 _marketId) public view returns (uint256 _liquidationPrice) {\r\n        return(portfolio[_address][_marketId].liquidationPrice);\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Record positions by market by address. Needed for exposure aggregations\r\n    // and spits and dividends.\r\n    // ----------------------------------------------------------------------------\r\n    function addExposureByMarket(bytes32 _symbol, address _address) private {\r\n        // Address must not be already recored\r\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\r\n        if (_myExposureIndex == 0) {\r\n            uint256 _maxMappingIndex = getMaxMappingIndex(_symbol).add(1);\r\n            setMaxMappingIndex(_symbol, _maxMappingIndex);\r\n            setExposureMapping(_symbol, _address, _maxMappingIndex);\r\n        }\r\n    }\r\n\r\n    function deleteExposureByMarket(bytes32 _symbol, address _address) private {\r\n        // Get my index in mapping\r\n        uint256 _myExposureIndex = getExposureMappingIndex(_symbol, _address);\r\n        // Get last element of mapping\r\n        uint256 _lastIndex = getMaxMappingIndex(_symbol);\r\n        address _lastAddress = getExposureMappingAddress(_symbol, _lastIndex);\r\n        // If _myExposureIndex is greater than 0 (i.e. there is an exposure of that address on that market) delete it\r\n        if (_myExposureIndex \u003e 0) {\r\n            // If _myExposureIndex is less than _lastIndex overwrite element at _myExposureIndex with element at _lastIndex in\r\n            // deleted elements position.\r\n            if (_myExposureIndex \u003c _lastIndex) {\r\n                setExposureMappingAddress(_symbol, _lastAddress, _myExposureIndex);\r\n                setExposureMappingIndex(_symbol, _lastAddress, _myExposureIndex);\r\n            }\r\n            // Delete _lastIndex and _lastAddress element and reduce maxExposureIndex\r\n            setExposureMappingAddress(_symbol, address(0), _lastIndex);\r\n            setExposureMappingIndex(_symbol, _address, 0);\r\n            // Shouldn\u0027t happen, but check that not empty\r\n            if (_lastIndex \u003e 0) {\r\n                setMaxMappingIndex(_symbol, _lastIndex.sub(1));\r\n            }\r\n        }\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    // Calculate and send operating reward\r\n    // Every 24 hours the protocol mints rewardBasisPoints/(PRECISION) percent of the total\r\n    // supply as reward for the protocol operator. The amount can not exceed 0.015% per\r\n    // day.\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function payOperatingReward() public onlyMainChain {\r\n        if (now \u003e lastRewardTime.add(REWARDPERIOD)) {\r\n            uint256 _reward = totalSupply.mul(rewardBasisPoints).div(PRECISION);\r\n            setLastRewardTime(lastRewardTime.add(REWARDPERIOD));\r\n            mint(morpherRewards, _reward);\r\n            emit OperatingRewardMinted(morpherRewards, _reward);\r\n        }\r\n    }\r\n}"},"MorpherToken.sol":{"content":"pragma solidity 0.5.16;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./Ownable.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./MorpherState.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20Mintable}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract MorpherToken is IERC20, Ownable {\r\n\r\n    MorpherState state;\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name     = \"Morpher\";\r\n    string public constant symbol   = \"MPH\";\r\n    uint8  public constant decimals = 18;\r\n    \r\n    modifier onlyState {\r\n        require(msg.sender == address(state), \"ERC20: caller must be MorpherState contract.\");\r\n        _;\r\n    }\r\n\r\n    modifier canTransfer {\r\n        require(state.mainChain() == true || state.getCanTransfer(msg.sender), \"ERC20: token transfers disabled on sidechain.\");\r\n        _;\r\n    }\r\n    \r\n    event LinkState(address _address);\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\r\n        setMorpherState(_stateAddress);\r\n        transferOwnership(_coldStorageOwnerAddress);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Links Token Contract with State\r\n    // ------------------------------------------------------------------------\r\n    function setMorpherState(address _stateAddress) public onlyOwner {\r\n        state = MorpherState(_stateAddress);\r\n        emit LinkState(_stateAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return state.totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address _account) public view returns (uint256) {\r\n        return state.balanceOf(_account);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     * \r\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\r\n     */\r\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\r\n        _transfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return state.getAllowance(_owner, _spender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        _approve(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20};\r\n     *\r\n     * Requirements:\r\n     * - `_sender` and `_recipient` cannot be the zero address.\r\n     * - `_sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `_sender`\u0027s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address _sender, address _recipient, uint256 amount) public returns (bool) {\r\n        _transfer(_sender, _recipient, amount);\r\n        _approve(_sender, msg.sender, state.getAllowance(_sender, msg.sender).sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\r\n        _approve(msg.sender, _spender, state.getAllowance(msg.sender, _spender).add(_addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, _spender,  state.getAllowance(msg.sender, _spender).sub(_subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Caller destroys `_amount` tokens permanently\r\n     *\r\n     * Emits a {Transfer} event to zero address called by MorpherState via emitTransfer.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Caller must have token balance of at least `_amount`\r\n     * \r\n     */\r\n     function burn(uint256 _amount) public returns (bool) {\r\n        state.burn(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Emits a {Transfer} event\r\n     *\r\n     * MorpherState emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Caller must be MorpherState\r\n     * \r\n     */\r\n     function emitTransfer(address _from, address _to, uint256 _amount) public onlyState {\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Moves tokens `_amount` from `sender` to `_recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event via emitTransfer called by MorpherState\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_sender` cannot be the zero address.\r\n     * - `_recipient` cannot be the zero address.\r\n     * - `_sender` must have a balance of at least `_amount`.\r\n     */\r\n    function _transfer(address _sender, address _recipient, uint256 _amount) canTransfer internal {\r\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(state.balanceOf(_sender) \u003e= _amount, \"ERC20: transfer amount exceeds balance\");\r\n        state.transfer(_sender, _recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `_amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\r\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n        state.setAllowance(_owner, _spender, _amount);\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don\u0027t accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () external payable {\r\n        revert(\"ERC20: You can\u0027t deposit Ether here\");\r\n    }\r\n}"},"Ownable.sol":{"content":"pragma solidity 0.5.16;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller should be owner.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: use renounce ownership instead.\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address _tokenAddress, uint256 _tokens) public onlyOwner returns (bool _success) {\r\n        return IERC20(_tokenAddress).transfer(owner(), _tokens);\r\n    }\r\n}"},"SafeMath.sol":{"content":"pragma solidity 0.5.16;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}