{"EBitcoin.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./ERC20Detailed.sol\";\r\nimport \"./ERC20Pow.sol\";\r\nimport \"./Ownable.sol\";\r\n\r\n/**\r\n* @dev EBitcoin Token (EBT)\r\n*/\r\ncontract EBitcoin is IERC20, ERC20, ERC20Detailed, ERC20Pow, Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct BankAccount {\r\n        uint256 balance;\r\n        uint256 interestSettled;\r\n        uint256 lastBlockNumber;\r\n    }\r\n\r\n    mapping (address =\u003e BankAccount) private _bankAccounts;\r\n\r\n    //Suppose one block in 10 minutes, one day is 144\r\n    uint256 private _interestInterval = 144;\r\n\r\n    /**\r\n    * @dev Init\r\n    */\r\n    constructor ()\r\n        ERC20Detailed(\"EBitcoin Token\", \"EBT\", 8)\r\n        ERC20Pow(2**16, 2**232, 210000, 5000000000, 504, 60, 144)\r\n    public {}\r\n\r\n    /**\r\n    * @dev Returns the amount of bank balance owned by `account`\r\n    */\r\n    function bankBalanceOf(address account) public view returns (uint256) {\r\n        return _bankAccounts[account].balance;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the amount of bank interes owned by `account`\r\n    */\r\n    function bankInterestOf(address account) public view returns (uint256) {\r\n\r\n        // No interest without deposit\r\n        BankAccount storage item = _bankAccounts[account];\r\n        if(0 == item.balance)  return 0;\r\n\r\n        // balance * day / 365 * 0.01\r\n        uint256 blockNumber = getBlockCount();\r\n        uint256 intervalCount = blockNumber.sub(item.lastBlockNumber).div(_interestInterval);\r\n        uint256 interest = item.balance.mul(intervalCount).div(365).div(100);\r\n        return interest.add(item.interestSettled);\r\n    }\r\n\r\n    /**\r\n    * @dev Deposit `amount` tokens in the bank\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function bankDeposit(uint256 amount) public returns (bool) {\r\n\r\n        // Deducting balance\r\n        uint256 balance = _getBalance(msg.sender);\r\n        _setBalance(msg.sender, balance.sub(amount, \"Token: bank deposit amount exceeds balance\"));\r\n\r\n        // If have a bank balance, need to calculate interest first\r\n        BankAccount storage item = _bankAccounts[msg.sender];\r\n        if (0 != item.balance) {\r\n\r\n            // balance * day / 365 * 0.01\r\n            uint256 blockNumber = getBlockCount();\r\n            uint256 intervalCount = blockNumber.sub(item.lastBlockNumber).div(_interestInterval);\r\n            uint256 interest = item.balance.mul(intervalCount).div(365).div(100);\r\n\r\n            // Append\r\n            item.balance = item.balance.add(amount);\r\n            item.interestSettled = item.interestSettled.add(interest);\r\n            item.lastBlockNumber = blockNumber;\r\n        }\r\n        else {\r\n\r\n            // Init\r\n            item.balance = amount;\r\n            item.interestSettled = 0;\r\n            item.lastBlockNumber = getBlockCount();\r\n        }\r\n\r\n        emit Transfer(msg.sender, address(0), amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdrawal `amount` tokens in the bank\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function bankWithdrawal(uint256 amount) public returns (bool) {\r\n\r\n        // Bank balance greater than or equal amount\r\n        BankAccount storage item = _bankAccounts[msg.sender];\r\n        require(0 == amount || 0 != item.balance, \"Token: withdrawal amount exceeds bank balance\");\r\n\r\n        // balance * day / 365 * 0.01\r\n        uint256 blockNumber = getBlockCount();\r\n        uint256 intervalCount = blockNumber.sub(item.lastBlockNumber).div(_interestInterval);\r\n        uint256 interest = item.balance.mul(intervalCount).div(365).div(100);\r\n        interest = interest.add(item.interestSettled);\r\n\r\n        // Interest is enough to pay\r\n        if (interest \u003e= amount) {\r\n\r\n            // Deducting interest\r\n            item.lastBlockNumber = blockNumber;\r\n            item.interestSettled = interest.sub(amount);\r\n\r\n            // Transfer balance and increase total supply\r\n            _setBalance(msg.sender, _getBalance(msg.sender).add(amount));\r\n            _setTotalSupply(_getTotalSupply().add(amount));\r\n        }\r\n        else {\r\n\r\n            // Deducting interest and bank balance\r\n            uint256 remainAmount = amount.sub(interest);\r\n            item.balance = item.balance.sub(remainAmount, \"Token: withdrawal amount exceeds bank balance\");\r\n            item.lastBlockNumber = blockNumber;\r\n            item.interestSettled = 0;\r\n\r\n            // Transfer balance and increase total supply\r\n            _setBalance(msg.sender, _getBalance(msg.sender).add(amount));\r\n            _setTotalSupply(_getTotalSupply().add(interest));\r\n        }\r\n\r\n        emit Transfer(address(0), msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner can transfer out any accidentally sent ERC20 tokens\r\n    */\r\n    function transferAnyERC20Token(address tokenAddress, uint256 amount) public onlyOwner returns (bool) {\r\n        return IERC20(tokenAddress).transfer(getOwner(), amount);\r\n    }\r\n}"},"ERC20.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n* @dev ERC20.\r\n*/\r\ncontract ERC20 is IERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    mapping (address =\u003e uint256) private _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    /**\r\n    * @dev See {IERC20-totalSupply}.\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-balanceOf}.\r\n    */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-transfer}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `recipient` cannot be the zero address.\r\n    * - the caller must have a balance of at least `amount`.\r\n    */\r\n    function transfer(address recipient, uint256 amount) public returns (bool){\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-allowance}.\r\n    */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-approve}.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev See {IERC20-transferFrom}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance. This is not\r\n    * required by the EIP. See the note at the beginning of {ERC20};\r\n    *\r\n    * Requirements:\r\n    * - `sender` and `recipient` cannot be the zero address.\r\n    * - `sender` must have a balance of at least `amount`.\r\n    * - the caller must have allowance for `sender`\u0027s tokens of at least\r\n    * `amount`.\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    *\r\n    * This is an alternative to {approve} that can be used as a mitigation for\r\n    * problems described in {IERC20-approve}.\r\n    *\r\n    * Emits an {Approval} event indicating the updated allowance.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `spender` cannot be the zero address.\r\n    * - `spender` must have allowance for the caller of at least\r\n    * `subtractedValue`.\r\n    */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n    *\r\n    * This is internal function is equivalent to {transfer}, and can be used to\r\n    * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `sender` cannot be the zero address.\r\n    * - `recipient` cannot be the zero address.\r\n    * - `sender` must have a balance of at least `amount`.\r\n    */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n    *\r\n    * This is internal function is equivalent to `approve`, and can be used to\r\n    * e.g. set automatic allowances for certain subsystems, etc.\r\n    *\r\n    * Emits an {Approval} event.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `owner` cannot be the zero address.\r\n    * - `spender` cannot be the zero address.\r\n    */\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n    * the total supply.\r\n    *\r\n    * Emits a {Transfer} event with `from` set to the zero address.\r\n    *\r\n    * Requirements\r\n    *\r\n    * - `to` cannot be the zero address.\r\n    */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Destroys `amount` tokens from `account`, reducing the\r\n    * total supply.\r\n    *\r\n    * Emits a {Transfer} event with `to` set to the zero address.\r\n    *\r\n    * Requirements\r\n    *\r\n    * - `account` cannot be the zero address.\r\n    * - `account` must have at least `amount` tokens.\r\n    */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n    * from the caller\u0027s allowance.\r\n    *\r\n    * See {_burn} and {_approve}.\r\n    */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    /**\r\n    * @dev Internal method\r\n    */\r\n    function _getTotalSupply() internal view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal method\r\n    */\r\n    function _setTotalSupply(uint256 value) internal {\r\n        _totalSupply = value;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal method\r\n    */\r\n    function _getBalance(address account) internal view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n    * @dev Internal method\r\n    */\r\n    function _setBalance(address account, uint256 value) internal {\r\n        _balances[account] = value;\r\n    }\r\n}"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./ERC20.sol\";\r\n\r\n/**\r\n* @dev Optional functions from the ERC20 standard.\r\n*/\r\ncontract ERC20Detailed is ERC20 {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n    * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\r\n    * these values are immutable: they can only be set once during\r\n    * construction.\r\n    */\r\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the name of the token.\r\n    */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the symbol of the token, usually a shorter version of the\r\n    * name.\r\n    */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the number of decimals used to get its user representation.\r\n    * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n    * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n    *\r\n    * Tokens usually opt for a value of 18, imitating the relationship between\r\n    * Ether and Wei.\r\n    *\r\n    * NOTE: This information is only used for _display_ purposes: it in\r\n    * no way affects any of the arithmetic of the contract, including\r\n    * {IERC20-balanceOf} and {IERC20-transfer}.\r\n    */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}"},"ERC20Pow.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./SafeMath.sol\";\r\nimport \"./ERC20.sol\";\r\n\r\n/**\r\n* @dev ERC20Pow\r\n*/\r\ncontract ERC20Pow is ERC20 {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // recommended value is 2**16\r\n    uint256 private _MINIMUM_TARGET;\r\n\r\n    // a big number is easier, bitcoin uses 2**224\r\n    uint256 private _MAXIMUM_TARGET;\r\n\r\n    // Reward halving interval, bitcoin uses 210000\r\n    uint256 private _REWARD_INTERVAL;\r\n\r\n    // Difficulty adjustment interval, bitcoin uses 2016\r\n    uint256 private _BLOCKS_PER_READJUSTMENT;\r\n\r\n    // Suppose the block is 10 minutes, the ETH block is 10 seconds, then the value is 600/10=60\r\n    uint256 private _ETHBLOCK_EXCHANGERATE;\r\n\r\n    // Urgent adjustment threshold\r\n    uint256 private _URGENTADJUST_THRESHOLD;\r\n\r\n    // Block count\r\n    uint256 private _blockCount;\r\n\r\n    // Block reward, bitcoin uses 5000000000\r\n    uint256 private _blockReward;\r\n\r\n    // Mining related\r\n    uint256 private _miningTarget;\r\n    bytes32 private _challengeNumber;\r\n\r\n    // Prevent duplication\r\n    mapping(bytes32 =\u003e bytes32) private _solutionForChallenge;\r\n\r\n    // Calculate the time interval\r\n    uint256 private _latestDifficultyPeriodStarted;\r\n\r\n    /**\r\n    * @dev Init\r\n    */\r\n    constructor (\r\n        uint256 minimumTarget,\r\n        uint256 maximumTarget,\r\n        uint256 rewardInterval,\r\n        uint256 blockReward,\r\n        uint256 blocksPerReadjustment,\r\n        uint256 ethBlockExchangeRate,\r\n        uint256 urgentAdjustThreshold\r\n    ) public {\r\n        _MINIMUM_TARGET = minimumTarget;\r\n        _MAXIMUM_TARGET = maximumTarget;\r\n        _REWARD_INTERVAL = rewardInterval;\r\n        _BLOCKS_PER_READJUSTMENT = blocksPerReadjustment;\r\n        _ETHBLOCK_EXCHANGERATE = ethBlockExchangeRate;\r\n        _URGENTADJUST_THRESHOLD = urgentAdjustThreshold;\r\n        _blockReward = blockReward;\r\n        _miningTarget = _MAXIMUM_TARGET;\r\n        _latestDifficultyPeriodStarted = uint256(block.number);\r\n        _newMiningBlock();\r\n    }\r\n\r\n    /**\r\n    * @dev Current block number\r\n    */\r\n    function getBlockCount() public view returns (uint256) {\r\n        return _blockCount;\r\n    }\r\n\r\n    /**\r\n    * @dev Current challenge number\r\n    */\r\n    function getChallengeNumber() public view returns (bytes32) {\r\n        return _challengeNumber;\r\n    }\r\n\r\n    /**\r\n    * @dev Current mining difficulty\r\n    */\r\n    function getMiningDifficulty() public view returns (uint256) {\r\n        return _MAXIMUM_TARGET.div(_miningTarget);\r\n    }\r\n\r\n    /**\r\n    * @dev Current mining target\r\n    */\r\n    function getMiningTarget() public view returns (uint256) {\r\n        return _miningTarget;\r\n    }\r\n\r\n    /**\r\n    * @dev Current mining reward\r\n    */\r\n    function getMiningReward() public view returns (uint256) {\r\n        return _blockReward;\r\n    }\r\n\r\n    /**\r\n    * @dev Submit proof\r\n    * Emits a {SubmitProof} event\r\n    */\r\n    function submitProof(uint256 nonce, bytes32 challengeDigest) public returns (bool) {\r\n\r\n        // Calculated hash\r\n        bytes32 digest = keccak256(abi.encodePacked(_challengeNumber, msg.sender, nonce));\r\n\r\n        // Verify digest\r\n        require(digest == challengeDigest, \"ERC20Pow: invalid params\");\r\n        require(uint256(digest) \u003c= _miningTarget, \"ERC20Pow: invalid nonce\");\r\n\r\n        // Prevent duplication\r\n        bytes32 solution = _solutionForChallenge[_challengeNumber];\r\n        _solutionForChallenge[_challengeNumber] = digest;\r\n        require(solution == bytes32(0), \"ERC20Pow: already exists\");\r\n\r\n        // Mint\r\n        if (0 != _blockReward) {\r\n            _mint(msg.sender, _blockReward);\r\n        }\r\n\r\n        // Next round of challenges\r\n        _newMiningBlock();\r\n\r\n        emit SubmitProof(msg.sender, _miningTarget, _challengeNumber);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Urgent adjust difficulty\r\n    * When the hash power suddenly drops sharply, the difficulty can be reduced\r\n    * Emits a {UrgentAdjustDifficulty} event\r\n    */\r\n    function urgentAdjustDifficulty() public returns (bool) {\r\n\r\n        // Must greatly exceed expectations\r\n        uint256 targetEthBlocksPerDiffPeriod = _BLOCKS_PER_READJUSTMENT.mul(_ETHBLOCK_EXCHANGERATE);\r\n        uint256 ethBlocksSinceLastDifficultyPeriod = uint256(block.number).sub(_latestDifficultyPeriodStarted);\r\n        require(ethBlocksSinceLastDifficultyPeriod.div(targetEthBlocksPerDiffPeriod) \u003e _URGENTADJUST_THRESHOLD, \"ERC20Pow: invalid operation\");\r\n\r\n        _reAdjustDifficulty();\r\n        _newChallengeNumber();\r\n\r\n        emit UrgentAdjustDifficulty(msg.sender, _miningTarget, _challengeNumber);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev internal\r\n    */\r\n    function _newChallengeNumber() internal {\r\n        _challengeNumber = keccak256(abi.encodePacked(blockhash(block.number - 1), msg.sender));\r\n    }\r\n\r\n    /**\r\n    * @dev internal\r\n    */\r\n    function _newMiningBlock() internal {\r\n\r\n        // Block number + 1\r\n        _blockCount = _blockCount.add(1);\r\n\r\n        // Block reward is cut in half\r\n        if (0 == _blockCount.mod(_REWARD_INTERVAL)) {\r\n            _blockReward = _blockReward.div(2);\r\n        }\r\n\r\n        // Re-Adjust difficulty\r\n        if(0 == _blockCount.mod(_BLOCKS_PER_READJUSTMENT)) {\r\n            _reAdjustDifficulty();\r\n        }\r\n\r\n        // Generate challenge number\r\n        _newChallengeNumber();\r\n    }\r\n\r\n    /**\r\n    * @dev internal\r\n    */\r\n    function _reAdjustDifficulty() internal {\r\n\r\n        uint256 targetEthBlocksPerDiffPeriod = _BLOCKS_PER_READJUSTMENT.mul(_ETHBLOCK_EXCHANGERATE);\r\n        uint256 ethBlocksSinceLastDifficultyPeriod = uint256(block.number).sub(_latestDifficultyPeriodStarted);\r\n\r\n        // If there were less eth blocks passed in time than expected\r\n        if (ethBlocksSinceLastDifficultyPeriod \u003c targetEthBlocksPerDiffPeriod) {\r\n\r\n            // Increase difficulty\r\n            uint256 excessBlockPct = targetEthBlocksPerDiffPeriod.mul(100).div(ethBlocksSinceLastDifficultyPeriod);\r\n\r\n            // Range 0 - 1000\r\n            uint256 excessBlockPctExtra = excessBlockPct.sub(100);\r\n            if(excessBlockPctExtra \u003e 1000) excessBlockPctExtra = 1000;\r\n\r\n            // Up to 50%\r\n            _miningTarget = _miningTarget.sub(_miningTarget.div(2000).mul(excessBlockPctExtra));\r\n        }\r\n        else if(ethBlocksSinceLastDifficultyPeriod \u003e targetEthBlocksPerDiffPeriod) {\r\n\r\n            // Reduce difficulty\r\n            uint256 shortageBlockPct = ethBlocksSinceLastDifficultyPeriod.mul(100).div(targetEthBlocksPerDiffPeriod);\r\n\r\n            // Range 0 - 1000\r\n            uint256 shortageBlockPctExtra = shortageBlockPct.sub(100);\r\n            if(shortageBlockPctExtra \u003e 1000) shortageBlockPctExtra = 1000;\r\n\r\n            // Up to 50%\r\n            _miningTarget = _miningTarget.add(_miningTarget.div(2000).mul(shortageBlockPctExtra));\r\n        }\r\n\r\n        if(_miningTarget \u003c _MINIMUM_TARGET) _miningTarget = _MINIMUM_TARGET;\r\n        if(_miningTarget \u003e _MAXIMUM_TARGET) _miningTarget = _MAXIMUM_TARGET;\r\n        _latestDifficultyPeriodStarted = block.number;\r\n    }\r\n\r\n    /**\r\n    * @dev Emitted when new challenge number\r\n    */\r\n    event SubmitProof(address indexed miner, uint256 newMiningTarget, bytes32 newChallengeNumber);\r\n    event UrgentAdjustDifficulty(address indexed miner, uint256 newMiningTarget, bytes32 newChallengeNumber);\r\n}"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n* @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n* the optional functions; to access them see {ERC20Detailed}.\r\n*/\r\ninterface IERC20 {\r\n\r\n    /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Returns the remaining number of tokens that `spender` will be\r\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n    * zero by default.\r\n    *\r\n    * This value changes when {approve} or {transferFrom} are called.\r\n    */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    * that someone may use both the old and the new allowance by unfortunate\r\n    * transaction ordering. One possible solution to mitigate this race\r\n    * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n    * desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    *\r\n    * Emits an {Approval} event.\r\n    */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n    * another (`to`).\r\n    *\r\n    * Note that `value` may be zero.\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n    * a call to {approve}. `value` is the new allowance.\r\n    */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n* @dev Ownable authentication.\r\n*/\r\ncontract Ownable {\r\n\r\n    /**\r\n    * @dev Owner account.\r\n    */\r\n    address private _owner;\r\n\r\n    /**\r\n    * @dev Init owner as the contract creator.\r\n    */\r\n    constructor() public {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Owner authentication.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Ownable: authentication failed\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Get current owner.\r\n    */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer owner.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(_owner != newOwner, \"Ownable: transfer ownership new owner and old owner are the same\");\r\n        address oldOwner = _owner; _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Event transfer owner.\r\n    */\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n* @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n* checks.\r\n*\r\n* Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n* in bugs, because programmers usually assume that an overflow raises an\r\n* error, which is the standard behavior in high level programming languages.\r\n* `SafeMath` restores this intuition by reverting the transaction when an\r\n* operation overflows.\r\n*\r\n* Using this library instead of the unchecked operations eliminates an entire\r\n* class of bugs, so it\u0027s recommended to use it always.\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity\u0027s `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity\u0027s `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity\u0027s `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    *\r\n    * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n    * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n    */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity\u0027s `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0)  return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n    * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n    */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts with custom message when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    *\r\n    * NOTE: This is a feature of the next version of OpenZeppelin Contracts.\r\n    * @dev Get it via `npm install @openzeppelin/contracts@next`.\r\n    */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}