{{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "ROOT=/home/achapman/augur/packages/augur-core/src/contracts//"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "Augur.sol": {
      "content": "pragma experimental ABIEncoderV2;\npragma solidity 0.5.15;\n\ncontract IAugur {\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool);\n    function isTrustedSender(address _address) public returns (bool);\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool);\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool);\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool);\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool);\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool);\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool);\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool);\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool);\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool);\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool);\n    function logParticipationTokensRedeemed(IUniverse universe, address _sender, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool);\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool);\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool);\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\n    function lookup(bytes32 _key) public view returns (address);\n    function getTimestamp() public view returns (uint256);\n    function getMaximumMarketEndDate() public returns (uint256);\n    function isKnownMarket(IMarket _market) public view returns (bool);\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 numOutcomes) public view returns (bytes32);\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool);\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool);\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool);\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256);\n}\n\ncontract IAugurCreationDataGetter {\n    struct MarketCreationData {\n        string extraInfo;\n        address marketCreator;\n        bytes32[] outcomes;\n        int256[] displayPrices;\n        IMarket.MarketType marketType;\n        uint256 recommendedTradeInterval;\n    }\n\n    function getMarketCreationData(IMarket _market) public view returns (MarketCreationData memory);\n}\n\ncontract IUniverseFactory {\n    function createUniverse(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash, uint256[] memory _payoutNumerators) public returns (IUniverse);\n}\n\nlibrary ContractExists {\n    function exists(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_address) }\n        return size > 0;\n    }\n}\n\ncontract IOwnable {\n    function getOwner() public view returns (address);\n    function transferOwnership(address _newOwner) public returns (bool);\n}\n\ncontract ITyped {\n    function getTypeName() public view returns (bytes32);\n}\n\ncontract ITime is ITyped {\n    function getTimestamp() external view returns (uint256);\n}\n\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n\ninterface IERC1155 {\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    /// Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    ///Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /// @dev MUST emit when an approval is updated.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /// @dev MUST emit when the URI is updated for a token ID.\n    /// URIs are defined in RFC 3986.\n    /// The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\".\n    event URI(\n        string value,\n        uint256 indexed id\n    );\n\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\n    /// @dev MUST emit TransferSingle event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\n    /// @param from    Source address\n    /// @param to      Target address\n    /// @param id      ID of the token type\n    /// @param value   Transfer amount\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\n    /// @dev MUST emit TransferBatch event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\n    /// @param from    Source addresses\n    /// @param to      Target addresses\n    /// @param ids     IDs of each token type\n    /// @param values  Transfer amounts per token type\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param operator  Address to add to the set of authorized operators\n    /// @param approved  True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param owner     The owner of the Tokens\n    /// @param operator  Address of authorized operator\n    /// @return           True if the operator is approved, false if not\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Get the balance of an account's Tokens.\n    /// @param owner  The address of the token holder\n    /// @param id     ID of the Token\n    /// @return        The _owner's balance of the Token type requested\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @notice Get the total supply of a Token.\n    /// @param id     ID of the Token\n    /// @return        The total supply of the Token type requested\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param owners The addresses of the token holders\n    /// @param ids    ID of the Tokens\n    /// @return        The _owner's balance of the Token types requested\n    function balanceOfBatch(\n        address[] calldata owners,\n        uint256[] calldata ids\n    )\n        external\n        view\n        returns (uint256[] memory balances_);\n}\n\ncontract IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) public view returns (uint256);\n    function transfer(address to, uint256 amount) public returns (bool);\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ICash is IERC20 {\n}\n\ncontract IAffiliateValidator {\n    function validateReference(address _account, address _referrer) external view returns (bool);\n}\n\ncontract IAffiliates {\n    function setFingerprint(bytes32 _fingerprint) external;\n    function setReferrer(address _referrer) external;\n    function getAccountFingerprint(address _account) external returns (bytes32);\n    function getReferrer(address _account) external returns (address);\n    function getAndValidateReferrer(address _account, IAffiliateValidator affiliateValidator) external returns (address);\n    function affiliateValidators(address _affiliateValidator) external returns (bool);\n}\n\ncontract IDisputeWindow is ITyped, IERC20 {\n    function invalidMarketsTotal() external view returns (uint256);\n    function validityBondTotal() external view returns (uint256);\n\n    function incorrectDesignatedReportTotal() external view returns (uint256);\n    function initialReportBondTotal() external view returns (uint256);\n\n    function designatedReportNoShowsTotal() external view returns (uint256);\n    function designatedReporterNoShowBondTotal() external view returns (uint256);\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _disputeWindowId, bool _participationTokensEnabled, uint256 _duration, uint256 _startTime) public;\n    function trustedBuy(address _buyer, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getReputationToken() public view returns (IReputationToken);\n    function getStartTime() public view returns (uint256);\n    function getEndTime() public view returns (uint256);\n    function getWindowId() public view returns (uint256);\n    function isActive() public view returns (bool);\n    function isOver() public view returns (bool);\n    function onMarketFinalized() public;\n    function redeem(address _account) public returns (bool);\n}\n\ncontract IMarket is IOwnable {\n    enum MarketType {\n        YES_NO,\n        CATEGORICAL,\n        SCALAR\n    }\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public;\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32);\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getDisputeWindow() public view returns (IDisputeWindow);\n    function getNumberOfOutcomes() public view returns (uint256);\n    function getNumTicks() public view returns (uint256);\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n    function getForkingMarket() public view returns (IMarket _market);\n    function getEndTime() public view returns (uint256);\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningReportingParticipant() public view returns (IReportingParticipant);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getFinalizationTime() public view returns (uint256);\n    function getInitialReporter() public view returns (IInitialReporter);\n    function getDesignatedReportingEndTime() public view returns (uint256);\n    function getValidityBondAttoCash() public view returns (uint256);\n    function affiliateFeeDivisor() external view returns (uint256);\n    function getNumParticipants() public view returns (uint256);\n    function getDisputePacingOn() public view returns (bool);\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function isFinalizedAsInvalid() public view returns (bool);\n    function finalize() public returns (bool);\n    function isFinalized() public view returns (bool);\n    function getOpenInterest() public view returns (uint256);\n}\n\ncontract IReportingParticipant {\n    function getStake() public view returns (uint256);\n    function getPayoutDistributionHash() public view returns (bytes32);\n    function liquidateLosing() public;\n    function redeem(address _redeemer) public returns (bool);\n    function isDisavowed() public view returns (bool);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getMarket() public view returns (IMarket);\n    function getSize() public view returns (uint256);\n}\n\ncontract IDisputeCrowdsourcer is IReportingParticipant, IERC20 {\n    function initialize(IAugur _augur, IMarket market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _crowdsourcerGeneration) public;\n    function contribute(address _participant, uint256 _amount, bool _overload) public returns (uint256);\n    function setSize(uint256 _size) public;\n    function getRemainingToFill() public view returns (uint256);\n    function correctSize() public returns (bool);\n    function getCrowdsourcerGeneration() public view returns (uint256);\n}\n\ncontract IInitialReporter is IReportingParticipant, IOwnable {\n    function initialize(IAugur _augur, IMarket _market, address _designatedReporter) public;\n    function report(address _reporter, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _initialReportStake) public;\n    function designatedReporterShowed() public view returns (bool);\n    function initialReporterWasCorrect() public view returns (bool);\n    function getDesignatedReporter() public view returns (address);\n    function getReportTimestamp() public view returns (uint256);\n    function migrateToNewUniverse(address _designatedReporter) public;\n    function returnRepFromDisavow() public;\n}\n\ncontract IReputationToken is IERC20 {\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool);\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getTotalMigrated() public view returns (uint256);\n    function getTotalTheoreticalSupply() public view returns (uint256);\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\n\ncontract IShareToken is ITyped, IERC1155 {\n    function initialize(IAugur _augur) external;\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public;\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external returns (uint256[] memory _outcomeFees);\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId);\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds);\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool);\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool);\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256);\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256);\n}\n\ncontract IUniverse {\n    function creationTime() external view returns (uint256);\n    function marketBalance(address) external view returns (uint256);\n\n    function fork() public returns (bool);\n    function updateForkValues() public returns (bool);\n    function getParentUniverse() public view returns (IUniverse);\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getForkingMarket() public view returns (IMarket);\n    function getForkEndTime() public view returns (uint256);\n    function getForkReputationGoal() public view returns (uint256);\n    function getParentPayoutDistributionHash() public view returns (bytes32);\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256);\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow);\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOpenInterestInAttoCash() public view returns (uint256);\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\n    function getOrCacheValidityBond() public returns (uint256);\n    function getOrCacheDesignatedReportStake() public returns (uint256);\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n    function getOrCacheMarketRepBond() public returns (uint256);\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\n    function getDisputeThresholdForFork() public view returns (uint256);\n    function getDisputeThresholdForDisputePacing() public view returns (uint256);\n    function getInitialReportMinValue() public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getReportingFeeDivisor() public view returns (uint256);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningChildPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function isOpenInterestCash(address) public view returns (bool);\n    function isForkingMarket() public view returns (bool);\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow);\n    function getDisputeWindowStartTimeAndDuration(uint256 _timestamp, bool _initial) public view returns (uint256, uint256);\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget) public view returns (bool);\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function migrateMarketOut(IUniverse _destinationUniverse) public returns (bool);\n    function migrateMarketIn(IMarket _market, uint256 _cashBalance, uint256 _marketOI) public returns (bool);\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\n    function decrementOpenInterestFromMarket(IMarket _market) public returns (bool);\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\n    function getWinningChildUniverse() public view returns (IUniverse);\n    function isForking() public view returns (bool);\n    function deposit(address _sender, uint256 _amount, address _market) public returns (bool);\n    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool);\n    function createScalarMarket(uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, int256[] memory _prices, uint256 _numTicks, string memory _extraInfo) public returns (IMarket _newMarket);\n}\n\ncontract IV2ReputationToken is IReputationToken {\n    function parentUniverse() external returns (IUniverse);\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool);\n}\n\nlibrary Reporting {\n    uint256 private constant DESIGNATED_REPORTING_DURATION_SECONDS = 1 days;\n    uint256 private constant DISPUTE_ROUND_DURATION_SECONDS = 7 days;\n    uint256 private constant INITIAL_DISPUTE_ROUND_DURATION_SECONDS = 1 days;\n    uint256 private constant DISPUTE_WINDOW_BUFFER_SECONDS = 1 hours;\n    uint256 private constant FORK_DURATION_SECONDS = 60 days;\n\n    uint256 private constant BASE_MARKET_DURATION_MAXIMUM = 30 days; // A market of 30 day length can always be created\n    uint256 private constant UPGRADE_CADENCE = 365 days;\n    uint256 private constant INITIAL_UPGRADE_TIMESTAMP = 1627776000; // Aug 1st 2021\n\n    uint256 private constant INITIAL_REP_SUPPLY = 11 * 10 ** 6 * 10 ** 18; // 11 Million REP\n\n    uint256 private constant AFFILIATE_SOURCE_CUT_DIVISOR = 5; // The trader gets 20% of the affiliate fee when an affiliate fee is taken\n\n    uint256 private constant DEFAULT_VALIDITY_BOND = 10 ether; // 10 Cash (Dai)\n    uint256 private constant VALIDITY_BOND_FLOOR = 10 ether; // 10 Cash (Dai)\n    uint256 private constant DEFAULT_REPORTING_FEE_DIVISOR = 10000; // .01% fees\n    uint256 private constant MAXIMUM_REPORTING_FEE_DIVISOR = 10000; // Minimum .01% fees\n    uint256 private constant MINIMUM_REPORTING_FEE_DIVISOR = 3; // Maximum 33.3~% fees. Note than anything less than a value of 2 here will likely result in bugs such as divide by 0 cases.\n\n    uint256 private constant TARGET_INVALID_MARKETS_DIVISOR = 100; // 1% of markets are expected to be invalid\n    uint256 private constant TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR = 100; // 1% of markets are expected to have an incorrect designate report\n    uint256 private constant TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR = 20; // 5% of markets are expected to have a no show\n    uint256 private constant TARGET_REP_MARKET_CAP_MULTIPLIER = 5; // We multiply and divide by constants since we may want to multiply by a fractional amount\n\n    uint256 private constant FORK_THRESHOLD_DIVISOR = 40; // 2.5% of the total REP supply being filled in a single dispute bond will trigger a fork\n    uint256 private constant MAXIMUM_DISPUTE_ROUNDS = 20; // We ensure that after 20 rounds of disputes a fork will occur\n    uint256 private constant MINIMUM_SLOW_ROUNDS = 8; // We ensure that at least 8 dispute rounds take DISPUTE_ROUND_DURATION_SECONDS+ seconds to complete until the next round begins\n\n    function getDesignatedReportingDurationSeconds() internal pure returns (uint256) { return DESIGNATED_REPORTING_DURATION_SECONDS; }\n    function getInitialDisputeRoundDurationSeconds() internal pure returns (uint256) { return INITIAL_DISPUTE_ROUND_DURATION_SECONDS; }\n    function getDisputeWindowBufferSeconds() internal pure returns (uint256) { return DISPUTE_WINDOW_BUFFER_SECONDS; }\n    function getDisputeRoundDurationSeconds() internal pure returns (uint256) { return DISPUTE_ROUND_DURATION_SECONDS; }\n    function getForkDurationSeconds() internal pure returns (uint256) { return FORK_DURATION_SECONDS; }\n    function getBaseMarketDurationMaximum() internal pure returns (uint256) { return BASE_MARKET_DURATION_MAXIMUM; }\n    function getUpgradeCadence() internal pure returns (uint256) { return UPGRADE_CADENCE; }\n    function getInitialUpgradeTimestamp() internal pure returns (uint256) { return INITIAL_UPGRADE_TIMESTAMP; }\n    function getDefaultValidityBond() internal pure returns (uint256) { return DEFAULT_VALIDITY_BOND; }\n    function getValidityBondFloor() internal pure returns (uint256) { return VALIDITY_BOND_FLOOR; }\n    function getTargetInvalidMarketsDivisor() internal pure returns (uint256) { return TARGET_INVALID_MARKETS_DIVISOR; }\n    function getTargetIncorrectDesignatedReportMarketsDivisor() internal pure returns (uint256) { return TARGET_INCORRECT_DESIGNATED_REPORT_MARKETS_DIVISOR; }\n    function getTargetDesignatedReportNoShowsDivisor() internal pure returns (uint256) { return TARGET_DESIGNATED_REPORT_NO_SHOWS_DIVISOR; }\n    function getTargetRepMarketCapMultiplier() internal pure returns (uint256) { return TARGET_REP_MARKET_CAP_MULTIPLIER; }\n    function getMaximumReportingFeeDivisor() internal pure returns (uint256) { return MAXIMUM_REPORTING_FEE_DIVISOR; }\n    function getMinimumReportingFeeDivisor() internal pure returns (uint256) { return MINIMUM_REPORTING_FEE_DIVISOR; }\n    function getDefaultReportingFeeDivisor() internal pure returns (uint256) { return DEFAULT_REPORTING_FEE_DIVISOR; }\n    function getInitialREPSupply() internal pure returns (uint256) { return INITIAL_REP_SUPPLY; }\n    function getAffiliateSourceCutDivisor() internal pure returns (uint256) { return AFFILIATE_SOURCE_CUT_DIVISOR; }\n    function getForkThresholdDivisor() internal pure returns (uint256) { return FORK_THRESHOLD_DIVISOR; }\n    function getMaximumDisputeRounds() internal pure returns (uint256) { return MAXIMUM_DISPUTE_ROUNDS; }\n    function getMinimumSlowRounds() internal pure returns (uint256) { return MINIMUM_SLOW_ROUNDS; }\n}\n\ncontract IAugurTrading {\n    function lookup(bytes32 _key) public view returns (address);\n    function logProfitLossChanged(IMarket _market, address _account, uint256 _outcome, int256 _netPosition, uint256 _avgPrice, int256 _realizedProfit, int256 _frozenFunds, int256 _realizedCost) public returns (bool);\n    function logOrderCreated(IUniverse _universe, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logOrderCanceled(IUniverse _universe, IMarket _market, address _creator, uint256 _tokenRefund, uint256 _sharesRefund, bytes32 _orderId) public returns (bool);\n    function logOrderFilled(IUniverse _universe, address _creator, address _filler, uint256 _price, uint256 _fees, uint256 _amountFilled, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logMarketVolumeChanged(IUniverse _universe, address _market, uint256 _volume, uint256[] memory _outcomeVolumes, uint256 _totalTrades) public returns (bool);\n    function logZeroXOrderFilled(IUniverse _universe, IMarket _market, bytes32 _orderHash, bytes32 _tradeGroupId, uint8 _orderType, address[] memory _addressData, uint256[] memory _uint256Data) public returns (bool);\n    function logZeroXOrderCanceled(address _universe, address _market, address _account, uint256 _outcome, uint256 _price, uint256 _amount, uint8 _type, bytes32 _orderHash) public;\n}\n\ncontract IOrders {\n    function saveOrder(uint256[] calldata _uints, bytes32[] calldata _bytes32s, Order.Types _type, IMarket _market, address _sender) external returns (bytes32 _orderId);\n    function removeOrder(bytes32 _orderId) external returns (bool);\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\n    function getAmount(bytes32 _orderId) public view returns (uint256);\n    function getPrice(bytes32 _orderId) public view returns (uint256);\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderDataForCancel(bytes32 _orderId) public view returns (uint256, uint256, Order.Types, IMarket, uint256, address);\n    function getOrderDataForLogs(bytes32 _orderId) public view returns (Order.Types, address[] memory _addressData, uint256[] memory _uint256Data);\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled, uint256 _fill) external returns (bool);\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n}\n\nlibrary Order {\n    using SafeMathUint256 for uint256;\n\n    enum Types {\n        Bid, Ask\n    }\n\n    enum TradeDirections {\n        Long, Short\n    }\n\n    struct Data {\n        // Contracts\n        IMarket market;\n        IAugur augur;\n        IAugurTrading augurTrading;\n        IShareToken shareToken;\n        ICash cash;\n\n        // Order\n        bytes32 id;\n        address creator;\n        uint256 outcome;\n        Order.Types orderType;\n        uint256 amount;\n        uint256 price;\n        uint256 sharesEscrowed;\n        uint256 moneyEscrowed;\n        bytes32 betterOrderId;\n        bytes32 worseOrderId;\n    }\n\n    function create(IAugur _augur, IAugurTrading _augurTrading, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data memory) {\n        require(_outcome < _market.getNumberOfOutcomes(), \"Order.create: Outcome is not within market range\");\n        require(_price != 0, \"Order.create: Price may not be 0\");\n        require(_price < _market.getNumTicks(), \"Order.create: Price is outside of market range\");\n        require(_attoshares > 0, \"Order.create: Cannot use amount of 0\");\n        require(_creator != address(0), \"Order.create: Creator is 0x0\");\n\n        IShareToken _shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n\n        return Data({\n            market: _market,\n            augur: _augur,\n            augurTrading: _augurTrading,\n            shareToken: _shareToken,\n            cash: ICash(_augur.lookup(\"Cash\")),\n            id: 0,\n            creator: _creator,\n            outcome: _outcome,\n            orderType: _type,\n            amount: _attoshares,\n            price: _price,\n            sharesEscrowed: 0,\n            moneyEscrowed: 0,\n            betterOrderId: _betterOrderId,\n            worseOrderId: _worseOrderId\n        });\n    }\n\n    //\n    // \"public\" functions\n    //\n\n    function getOrderId(Order.Data memory _orderData, IOrders _orders) internal view returns (bytes32) {\n        if (_orderData.id == bytes32(0)) {\n            bytes32 _orderId = calculateOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n            require(_orders.getAmount(_orderId) == 0, \"Order.getOrderId: New order had amount. This should not be possible\");\n            _orderData.id = _orderId;\n        }\n        return _orderData.id;\n    }\n\n    function calculateOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(_type, _market, _amount, _price, _sender, _blockNumber, _outcome, _moneyEscrowed, _sharesEscrowed));\n    }\n\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n    }\n\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n    }\n\n    function saveOrder(Order.Data memory _orderData, bytes32 _tradeGroupId, IOrders _orders) internal returns (bytes32) {\n        getOrderId(_orderData, _orders);\n        uint256[] memory _uints = new uint256[](5);\n        _uints[0] = _orderData.amount;\n        _uints[1] = _orderData.price;\n        _uints[2] = _orderData.outcome;\n        _uints[3] = _orderData.moneyEscrowed;\n        _uints[4] = _orderData.sharesEscrowed;\n        bytes32[] memory _bytes32s = new bytes32[](4);\n        _bytes32s[0] = _orderData.betterOrderId;\n        _bytes32s[1] = _orderData.worseOrderId;\n        _bytes32s[2] = _tradeGroupId;\n        _bytes32s[3] = _orderData.id;\n        return _orders.saveOrder(_uints, _bytes32s, _orderData.orderType, _orderData.market, _orderData.creator);\n    }\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ncontract Augur is IAugur, IAugurCreationDataGetter {\n    using SafeMathUint256 for uint256;\n    using ContractExists for address;\n\n    enum TokenType {\n        ReputationToken,\n        DisputeCrowdsourcer,\n        ParticipationToken\n    }\n\n    event MarketCreated(IUniverse indexed universe, uint256 endTime, string extraInfo, IMarket market, address indexed marketCreator, address designatedReporter, uint256 feePerCashInAttoCash, int256[] prices, IMarket.MarketType marketType, uint256 numTicks, bytes32[] outcomes, uint256 noShowBond, uint256 timestamp);\n    event InitialReportSubmitted(address indexed universe, address indexed reporter, address indexed market, address initialReporter, uint256 amountStaked, bool isDesignatedReporter, uint256[] payoutNumerators, string description, uint256 nextWindowStartTime, uint256 nextWindowEndTime, uint256 timestamp);\n    event DisputeCrowdsourcerCreated(address indexed universe, address indexed market, address disputeCrowdsourcer, uint256[] payoutNumerators, uint256 size, uint256 disputeRound);\n    event DisputeCrowdsourcerContribution(address indexed universe, address indexed reporter, address indexed market, address disputeCrowdsourcer, uint256 amountStaked, string description, uint256[] payoutNumerators, uint256 currentStake, uint256 stakeRemaining, uint256 disputeRound, uint256 timestamp);\n    event DisputeCrowdsourcerCompleted(address indexed universe, address indexed market, address disputeCrowdsourcer, uint256[] payoutNumerators, uint256 nextWindowStartTime, uint256 nextWindowEndTime, bool pacingOn, uint256 totalRepStakedInPayout, uint256 totalRepStakedInMarket, uint256 disputeRound, uint256 timestamp);\n    event InitialReporterRedeemed(address indexed universe, address indexed reporter, address indexed market, address initialReporter, uint256 amountRedeemed, uint256 repReceived, uint256[] payoutNumerators, uint256 timestamp);\n    event DisputeCrowdsourcerRedeemed(address indexed universe, address indexed reporter, address indexed market, address disputeCrowdsourcer, uint256 amountRedeemed, uint256 repReceived, uint256[] payoutNumerators, uint256 timestamp);\n    event ReportingParticipantDisavowed(address indexed universe, address indexed market, address reportingParticipant);\n    event MarketParticipantsDisavowed(address indexed universe, address indexed market);\n    event MarketFinalized(address indexed universe, address indexed market, uint256 timestamp, uint256[] winningPayoutNumerators);\n    event MarketMigrated(address indexed market, address indexed originalUniverse, address indexed newUniverse);\n    event UniverseForked(address indexed universe, IMarket forkingMarket);\n    event UniverseCreated(address indexed parentUniverse, address indexed childUniverse, uint256[] payoutNumerators, uint256 creationTimestamp);\n    event CompleteSetsPurchased(address indexed universe, address indexed market, address indexed account, uint256 numCompleteSets, uint256 timestamp);\n    event CompleteSetsSold(address indexed universe, address indexed market, address indexed account, uint256 numCompleteSets, uint256 fees, uint256 timestamp);\n    event TradingProceedsClaimed(address indexed universe, address indexed sender, address market, uint256 outcome, uint256 numShares, uint256 numPayoutTokens, uint256 fees, uint256 timestamp);\n    event TokensTransferred(address indexed universe, address token, address indexed from, address indexed to, uint256 value, TokenType tokenType, address market);\n    event TokensMinted(address indexed universe, address indexed token, address indexed target, uint256 amount, TokenType tokenType, address market, uint256 totalSupply);\n    event TokensBurned(address indexed universe, address indexed token, address indexed target, uint256 amount, TokenType tokenType, address market, uint256 totalSupply);\n    event TokenBalanceChanged(address indexed universe, address indexed owner, address token, TokenType tokenType, address market, uint256 balance, uint256 outcome);\n    event DisputeWindowCreated(address indexed universe, address disputeWindow, uint256 startTime, uint256 endTime, uint256 id, bool initial);\n    event InitialReporterTransferred(address indexed universe, address indexed market, address from, address to);\n    event MarketTransferred(address indexed universe, address indexed market, address from, address to);\n    event MarketOIChanged(address indexed universe, address indexed market, uint256 marketOI);\n    event ParticipationTokensRedeemed(address indexed universe, address indexed disputeWindow, address indexed account, uint256 attoParticipationTokens, uint256 feePayoutShare, uint256 timestamp);\n    event TimestampSet(uint256 newTimestamp);\n    event ValidityBondChanged(address indexed universe, uint256 validityBond);\n    event DesignatedReportStakeChanged(address indexed universe, uint256 designatedReportStake);\n    event NoShowBondChanged(address indexed universe, uint256 noShowBond);\n    event ReportingFeeChanged(address indexed universe, uint256 reportingFee);\n    event ShareTokenBalanceChanged(address indexed universe, address indexed account, address indexed market, uint256 outcome, uint256 balance);\n    event MarketRepBondTransferred(address indexed universe, address market, address from, address to);\n    event WarpSyncDataUpdated(address indexed universe, uint256 warpSyncHash, uint256 marketEndTime);\n\n    event RegisterContract(address contractAddress, bytes32 key);\n    event FinishDeployment();\n\n    mapping(address => bool) private markets;\n    mapping(address => bool) private universes;\n    mapping(address => bool) private crowdsourcers;\n    mapping(address => bool) private trustedSender;\n\n    mapping(address => MarketCreationData) private marketCreationData;\n\n    address public uploader;\n    mapping(bytes32 => address) private registry;\n\n    ITime public time;\n    IUniverse public genesisUniverse;\n\n    uint256 public forkCounter;\n    mapping (address => uint256) universeForkIndex;\n\n    uint256 public upgradeTimestamp = Reporting.getInitialUpgradeTimestamp();\n\n    int256 private constant DEFAULT_MIN_PRICE = 0;\n    int256 private constant DEFAULT_MAX_PRICE = 1 ether;\n\n    uint256 constant public TRADE_INTERVAL_VALUE = 10 ** 19; // Trade value of 10 DAI\n    uint256 constant public MIN_TRADE_INTERVAL = 10**14; // We ignore \"dust\" portions of the min interval and for huge scalars have a larger min value\n    uint256 constant public DEFAULT_RECOMMENDED_TRADE_INTERVAL = 10**17;\n    uint256 private constant MAX_NUM_TICKS = 2 ** 256 - 2;\n\n    ICash public cash;\n\n    modifier onlyUploader() {\n        require(msg.sender == uploader);\n        _;\n    }\n\n    constructor() public {\n        uploader = msg.sender;\n    }\n\n    //\n    // Registry\n    //\n\n    function registerContract(bytes32 _key, address _address) public onlyUploader returns (bool) {\n        require(registry[_key] == address(0), \"Augur.registerContract: key has already been used in registry\");\n        require(_address.exists());\n        registry[_key] = _address;\n        if (_key == \"ShareToken\" || _key == \"MarketFactory\" || _key == \"EthExchange\") {\n            trustedSender[_address] = true;\n        } else if (_key == \"Time\") {\n            time = ITime(_address);\n        } else if (_key == \"Cash\") {\n            cash = ICash(_address);\n        }\n        emit RegisterContract(_address, _key);\n        return true;\n    }\n\n    /**\n     * @notice Find the contract address for a particular key\n     * @param _key The key to lookup\n     * @return the address of the registered contract if one exists for the given key\n     */\n    function lookup(bytes32 _key) public view returns (address) {\n        return registry[_key];\n    }\n\n    function finishDeployment() public onlyUploader returns (bool) {\n        uploader = address(1);\n        emit FinishDeployment();\n        return true;\n    }\n\n    //\n    // Universe\n    //\n\n    function createGenesisUniverse() public onlyUploader returns (IUniverse) {\n        require(genesisUniverse == IUniverse(0));\n        genesisUniverse = createUniverse(IUniverse(0), bytes32(0), new uint256[](0));\n        return genesisUniverse;\n    }\n\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse) {\n        IUniverse _parentUniverse = getAndValidateUniverse(msg.sender);\n        return createUniverse(_parentUniverse, _parentPayoutDistributionHash, _parentPayoutNumerators);\n    }\n\n    function createUniverse(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) private returns (IUniverse) {\n        IUniverseFactory _universeFactory = IUniverseFactory(registry[\"UniverseFactory\"]);\n        IUniverse _newUniverse = _universeFactory.createUniverse(_parentUniverse, _parentPayoutDistributionHash, _parentPayoutNumerators);\n        universes[address(_newUniverse)] = true;\n        trustedSender[address(_newUniverse)] = true;\n        emit UniverseCreated(address(_parentUniverse), address(_newUniverse), _parentPayoutNumerators, getTimestamp());\n        return _newUniverse;\n    }\n\n    function isKnownUniverse(IUniverse _universe) public view returns (bool) {\n        return universes[address(_universe)];\n    }\n\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256) {\n        return universeForkIndex[address(_universe)];\n    }\n\n    //\n    // Crowdsourcers\n    //\n\n    function isKnownCrowdsourcer(IDisputeCrowdsourcer _crowdsourcer) public view returns (bool) {\n        return crowdsourcers[address(_crowdsourcer)];\n    }\n\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForMarket(IMarket(msg.sender)));\n        crowdsourcers[_disputeCrowdsourcer] = true;\n        emit DisputeCrowdsourcerCreated(address(_universe), _market, _disputeCrowdsourcer, _payoutNumerators, _size, _disputeRound);\n        return true;\n    }\n\n    function isKnownFeeSender(address _feeSender) public view returns (bool) {\n        return _feeSender == registry[\"ShareToken\"] || markets[_feeSender];\n    }\n\n    //\n    // Transfer\n    //\n\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool) {\n        require(trustedSender[msg.sender]);\n        require(cash.transferFrom(_from, _to, _amount));\n        return true;\n    }\n\n    function isTrustedSender(address _address) public returns (bool) {\n        return trustedSender[_address];\n    }\n\n    //\n    // Time\n    //\n\n    /// @notice Returns Augur’s internal Unix timestamp.\n    /// @return (uint256) Augur’s internal Unix timestamp\n    function getTimestamp() public view returns (uint256) {\n        return time.getTimestamp();\n    }\n\n    //\n    // Markets\n    //\n\n    function isKnownMarket(IMarket _market) public view returns (bool) {\n        return markets[address(_market)];\n    }\n\n    function getMaximumMarketEndDate() public returns (uint256) {\n        uint256 _now = getTimestamp();\n        while (_now > upgradeTimestamp) {\n            upgradeTimestamp = upgradeTimestamp.add(Reporting.getUpgradeCadence());\n        }\n        uint256 _upgradeCadenceDurationEndTime = upgradeTimestamp;\n        uint256 _baseDurationEndTime = _now + Reporting.getBaseMarketDurationMaximum();\n        return _baseDurationEndTime.max(_upgradeCadenceDurationEndTime);\n    }\n\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 _numOutcomes) public view returns (bytes32) {\n        uint256 _sum = 0;\n        // This is to force an Invalid report to be entirely payed out to Invalid\n        require(_payoutNumerators[0] == 0 || _payoutNumerators[0] == _numTicks);\n        require(_payoutNumerators.length == _numOutcomes, \"Augur.derivePayoutDistributionHash: Malformed payout length\");\n        for (uint256 i = 0; i < _payoutNumerators.length; i++) {\n            uint256 _value = _payoutNumerators[i];\n            _sum = _sum.add(_value);\n        }\n        require(_sum == _numTicks, \"Augur.derivePayoutDistributionHash: Malformed payout sum\");\n        return keccak256(abi.encodePacked(_payoutNumerators));\n    }\n\n    function getMarketCreationData(IMarket _market) public view returns (MarketCreationData memory) {\n        return marketCreationData[address(_market)];\n    }\n\n    function getMarketType(IMarket _market) public view returns (IMarket.MarketType _marketType) {\n        return marketCreationData[address(_market)].marketType;\n    }\n\n    function getMarketOutcomes(IMarket _market) public view returns (bytes32[] memory _outcomes) {\n        return marketCreationData[address(_market)].outcomes;\n    }\n\n    function getMarketRecommendedTradeInterval(IMarket _market) public view returns (uint256) {\n        return marketCreationData[address(_market)].recommendedTradeInterval;\n    }\n\n    //\n    // Logging\n    //\n\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        markets[address(_market)] = true;\n        int256[] memory _prices = new int256[](2);\n        _prices[0] = DEFAULT_MIN_PRICE;\n        _prices[1] = DEFAULT_MAX_PRICE;\n        marketCreationData[address(_market)].extraInfo = _extraInfo;\n        marketCreationData[address(_market)].marketCreator = _marketCreator;\n        marketCreationData[address(_market)].outcomes = _outcomes;\n        marketCreationData[address(_market)].marketType = IMarket.MarketType.CATEGORICAL;\n        marketCreationData[address(_market)].recommendedTradeInterval = DEFAULT_RECOMMENDED_TRADE_INTERVAL;\n        emit MarketCreated(_universe, _endTime, _extraInfo, _market, _marketCreator, _designatedReporter, _feePerCashInAttoCash, _prices, IMarket.MarketType.CATEGORICAL, 100, _outcomes, _universe.getOrCacheMarketRepBond(), getTimestamp());\n        return true;\n    }\n\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        markets[address(_market)] = true;\n        int256[] memory _prices = new int256[](2);\n        _prices[0] = DEFAULT_MIN_PRICE;\n        _prices[1] = DEFAULT_MAX_PRICE;\n        marketCreationData[address(_market)].extraInfo = _extraInfo;\n        marketCreationData[address(_market)].marketCreator = _marketCreator;\n        marketCreationData[address(_market)].marketType = IMarket.MarketType.YES_NO;\n        marketCreationData[address(_market)].recommendedTradeInterval = DEFAULT_RECOMMENDED_TRADE_INTERVAL;\n        emit MarketCreated(_universe, _endTime, _extraInfo, _market, _marketCreator, _designatedReporter, _feePerCashInAttoCash, _prices, IMarket.MarketType.YES_NO, 100, new bytes32[](0), _universe.getOrCacheMarketRepBond(), getTimestamp());\n        return true;\n    }\n\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        require(_prices.length == 2);\n        require(_prices[0] < _prices[1]);\n        uint256 _priceRange = uint256(_prices[1] - _prices[0]);\n        require(_priceRange > _numTicks);\n        markets[address(_market)] = true;\n        marketCreationData[address(_market)].extraInfo = _extraInfo;\n        marketCreationData[address(_market)].marketCreator = _marketCreator;\n        marketCreationData[address(_market)].displayPrices = _prices;\n        marketCreationData[address(_market)].marketType = IMarket.MarketType.SCALAR;\n        marketCreationData[address(_market)].recommendedTradeInterval = getTradeInterval(_priceRange, _numTicks);\n        emit MarketCreated(_universe, _endTime, _extraInfo, _market, _marketCreator, _designatedReporter, _feePerCashInAttoCash, _prices, IMarket.MarketType.SCALAR, _numTicks, new bytes32[](0), _universe.getOrCacheMarketRepBond(), getTimestamp());\n        return true;\n    }\n\n    function getTradeInterval(uint256 _displayRange, uint256 _numTicks) public pure returns (uint256) {\n        // Handle Warp Sync Market\n        if (_numTicks == MAX_NUM_TICKS) {\n            return MIN_TRADE_INTERVAL;\n        }\n        uint256 _displayAmount = TRADE_INTERVAL_VALUE.mul(10**18).div(_displayRange);\n        uint256 _displayInterval = MIN_TRADE_INTERVAL;\n        while (_displayInterval < _displayAmount) {\n            _displayInterval = _displayInterval.mul(10);\n        }\n        _displayAmount = _displayInterval;\n        return _displayInterval.mul(_displayRange).div(_numTicks).div(10**18);\n    }\n\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForMarket(IMarket(msg.sender)));\n        emit InitialReportSubmitted(address(_universe), _reporter, _market, _initialReporter, _amountStaked, _isDesignatedReporter, _payoutNumerators, _description, _nextWindowStartTime, _nextWindowEndTime, getTimestamp());\n        return true;\n    }\n\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory _description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForMarket(IMarket(msg.sender)));\n        emit DisputeCrowdsourcerContribution(address(_universe), _reporter, _market, _disputeCrowdsourcer, _amountStaked, _description, _payoutNumerators, _currentStake, _stakeRemaining, _disputeRound, getTimestamp());\n        return true;\n    }\n\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForMarket(IMarket(msg.sender)));\n        emit DisputeCrowdsourcerCompleted(address(_universe), _market, _disputeCrowdsourcer, _payoutNumerators, _nextWindowStartTime, _nextWindowEndTime, _pacingOn, _totalRepStakedInPayout, _totalRepStakedInMarket, _disputeRound, getTimestamp());\n        return true;\n    }\n\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        emit InitialReporterRedeemed(address(_universe), _reporter, _market, msg.sender, _amountRedeemed, _repReceived, _payoutNumerators, getTimestamp());\n        return true;\n    }\n\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool) {\n        IDisputeCrowdsourcer _disputeCrowdsourcer = IDisputeCrowdsourcer(msg.sender);\n        require(isKnownCrowdsourcer(_disputeCrowdsourcer));\n        emit DisputeCrowdsourcerRedeemed(address(_universe), _reporter, _market, address(_disputeCrowdsourcer), _amountRedeemed, _repReceived, _payoutNumerators, getTimestamp());\n        return true;\n    }\n\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForReportingParticipant(IReportingParticipant(msg.sender)));\n        emit ReportingParticipantDisavowed(address(_universe), address(_market), msg.sender);\n        return true;\n    }\n\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        IMarket _market = IMarket(msg.sender);\n        require(_universe.isContainerForMarket(_market));\n        emit MarketParticipantsDisavowed(address(_universe), address(_market));\n        return true;\n    }\n\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        IMarket _market = IMarket(msg.sender);\n        require(_universe.isContainerForMarket(_market));\n        emit MarketFinalized(address(_universe), address(_market), getTimestamp(), _winningPayoutNumerators);\n        return true;\n    }\n\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool) {\n        IUniverse _newUniverse = IUniverse(msg.sender);\n        require(isKnownUniverse(_newUniverse));\n        emit MarketMigrated(address(_market), address(_originalUniverse), address(_newUniverse));\n        return true;\n    }\n\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool) {\n        require(msg.sender == registry[\"ShareToken\"] || (isKnownUniverse(_universe) && _universe.isOpenInterestCash(msg.sender)));\n        emit CompleteSetsPurchased(address(_universe), address(_market), _account, _numCompleteSets, getTimestamp());\n        return true;\n    }\n\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool) {\n        require(msg.sender == registry[\"ShareToken\"]);\n        emit CompleteSetsSold(address(_universe), address(_market), _account, _numCompleteSets, _fees, getTimestamp());\n        return true;\n    }\n\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool) {\n        require(msg.sender == registry[\"ShareToken\"]);\n        emit MarketOIChanged(address(_universe), address(_market), _market.getOpenInterest());\n        return true;\n    }\n\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool) {\n        require(msg.sender == registry[\"ShareToken\"]);\n        emit TradingProceedsClaimed(address(_universe), _sender, _market, _outcome, _numShares, _numPayoutTokens, _fees, getTimestamp());\n        return true;\n    }\n\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool) {\n        require(isKnownUniverse(IUniverse(msg.sender)));\n        forkCounter += 1;\n        universeForkIndex[msg.sender] = forkCounter;\n        emit UniverseForked(msg.sender, _forkingMarket);\n        return true;\n    }\n\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.getReputationToken() == IReputationToken(msg.sender));\n        logTokensTransferred(address(_universe), msg.sender, _from, _to, _value, TokenType.ReputationToken, address(0), _fromBalance, _toBalance, 0);\n        return true;\n    }\n\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool) {\n        IDisputeCrowdsourcer _disputeCrowdsourcer = IDisputeCrowdsourcer(msg.sender);\n        require(isKnownCrowdsourcer(_disputeCrowdsourcer));\n        logTokensTransferred(address(_universe), msg.sender, _from, _to, _value, TokenType.DisputeCrowdsourcer, address(_disputeCrowdsourcer.getMarket()), _fromBalance, _toBalance, 0);\n        return true;\n    }\n\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.getReputationToken() == IReputationToken(msg.sender));\n        logTokensBurned(address(_universe), msg.sender, _target, _amount, TokenType.ReputationToken, address(0), _totalSupply, _balance, 0);\n        return true;\n    }\n\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.getReputationToken() == IReputationToken(msg.sender));\n        logTokensMinted(address(_universe), msg.sender, _target, _amount, TokenType.ReputationToken, address(0), _totalSupply, _balance, 0);\n        return true;\n    }\n\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool) {\n        require(msg.sender == registry[\"ShareToken\"]);\n        emit ShareTokenBalanceChanged(address(_market.getUniverse()), _account, address(_market), _outcome, _balance);\n        return true;\n    }\n\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool) {\n        IDisputeCrowdsourcer _disputeCrowdsourcer = IDisputeCrowdsourcer(msg.sender);\n        require(isKnownCrowdsourcer(_disputeCrowdsourcer));\n        logTokensBurned(address(_universe), msg.sender, _target, _amount, TokenType.DisputeCrowdsourcer, address(_disputeCrowdsourcer.getMarket()), _totalSupply, _balance, 0);\n        return true;\n    }\n\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool) {\n        IDisputeCrowdsourcer _disputeCrowdsourcer = IDisputeCrowdsourcer(msg.sender);\n        require(isKnownCrowdsourcer(_disputeCrowdsourcer));\n        logTokensMinted(address(_universe), msg.sender, _target, _amount, TokenType.DisputeCrowdsourcer, address(_disputeCrowdsourcer.getMarket()), _totalSupply, _balance, 0);\n        return true;\n    }\n\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool) {\n        require(isKnownUniverse(IUniverse(msg.sender)));\n        emit DisputeWindowCreated(msg.sender, address(_disputeWindow), _disputeWindow.getStartTime(), _disputeWindow.getEndTime(), _id, _initial);\n        return true;\n    }\n\n    function logParticipationTokensRedeemed(IUniverse _universe, address _account, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        emit ParticipationTokensRedeemed(address(_universe), msg.sender, _account, _attoParticipationTokens, _feePayoutShare, getTimestamp());\n        return true;\n    }\n\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool) {\n        require(msg.sender == registry[\"Time\"]);\n        emit TimestampSet(_newTimestamp);\n        return true;\n    }\n\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForMarket(_market));\n        require(msg.sender == address(_market.getInitialReporter()));\n        emit InitialReporterTransferred(address(_universe), address(_market), _from, _to);\n        return true;\n    }\n\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        IMarket _market = IMarket(msg.sender);\n        require(_universe.isContainerForMarket(_market));\n        emit MarketTransferred(address(_universe), address(_market), _from, _to);\n        return true;\n    }\n\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        logTokensTransferred(address(_universe), msg.sender, _from, _to, _value, TokenType.ParticipationToken, address(0), _fromBalance, _toBalance, 0);\n        return true;\n    }\n\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        logTokensBurned(address(_universe), msg.sender, _target, _amount, TokenType.ParticipationToken, address(0), _totalSupply, _balance, 0);\n        return true;\n    }\n\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool) {\n        require(isKnownUniverse(_universe));\n        require(_universe.isContainerForDisputeWindow(IDisputeWindow(msg.sender)));\n        logTokensMinted(address(_universe), msg.sender, _target, _amount, TokenType.ParticipationToken, address(0), _totalSupply, _balance, 0);\n        return true;\n    }\n\n    function logTokensTransferred(address _universe, address _token, address _from, address _to, uint256 _amount, TokenType _tokenType, address _market, uint256 _fromBalance, uint256 _toBalance, uint256 _outcome) private returns (bool) {\n        emit TokensTransferred(_universe, _token, _from, _to, _amount, _tokenType, _market);\n        emit TokenBalanceChanged(_universe, _from, _token, _tokenType, _market, _fromBalance, _outcome);\n        emit TokenBalanceChanged(_universe, _to, _token, _tokenType, _market, _toBalance, _outcome);\n        return true;\n    }\n\n    function logTokensBurned(address _universe, address _token, address _target, uint256 _amount, TokenType _tokenType, address _market, uint256 _totalSupply, uint256 _balance, uint256 _outcome) private returns (bool) {\n        emit TokensBurned(_universe, _token, _target, _amount, _tokenType, _market, _totalSupply);\n        emit TokenBalanceChanged(_universe, _target, _token, _tokenType, _market, _balance, _outcome);\n        return true;\n    }\n\n    function logTokensMinted(address _universe, address _token, address _target, uint256 _amount, TokenType _tokenType, address _market, uint256 _totalSupply, uint256 _balance, uint256 _outcome) private returns (bool) {\n        emit TokensMinted(_universe, _token, _target, _amount, _tokenType, _market, _totalSupply);\n        emit TokenBalanceChanged(_universe, _target, _token, _tokenType, _market, _balance, _outcome);\n        return true;\n    }\n\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        emit ValidityBondChanged(address(_universe), _validityBond);\n        return true;\n    }\n\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        emit DesignatedReportStakeChanged(address(_universe), _designatedReportStake);\n        return true;\n    }\n\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        emit NoShowBondChanged(address(_universe), _noShowBond);\n        return true;\n    }\n\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool) {\n        IUniverse _universe = getAndValidateUniverse(msg.sender);\n        emit ReportingFeeChanged(address(_universe), _reportingFee);\n        return true;\n    }\n\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool) {\n        require(isKnownMarket(IMarket(msg.sender)));\n        emit MarketRepBondTransferred(_universe, msg.sender, _from, _to);\n    }\n\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool) {\n        require(msg.sender == registry[\"WarpSync\"]);\n        emit WarpSyncDataUpdated(_universe, _warpSyncHash, _marketEndTime);\n    }\n\n    function getAndValidateUniverse(address _untrustedUniverse) internal view returns (IUniverse) {\n        IUniverse _universe = IUniverse(_untrustedUniverse);\n        require(isKnownUniverse(_universe));\n        return _universe;\n    }\n}\n\n"
    },
    "trading/ZeroXTrade.sol": {
      "content": "pragma experimental ABIEncoderV2;\npragma solidity 0.5.15;\n\ncontract IAugur {\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool);\n    function isTrustedSender(address _address) public returns (bool);\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool);\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool);\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool);\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool);\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool);\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool);\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool);\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool);\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool);\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool);\n    function logParticipationTokensRedeemed(IUniverse universe, address _sender, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool);\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool);\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool);\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\n    function lookup(bytes32 _key) public view returns (address);\n    function getTimestamp() public view returns (uint256);\n    function getMaximumMarketEndDate() public returns (uint256);\n    function isKnownMarket(IMarket _market) public view returns (bool);\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 numOutcomes) public view returns (bytes32);\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool);\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool);\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool);\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256);\n}\n\ncontract IAugurCreationDataGetter {\n    struct MarketCreationData {\n        string extraInfo;\n        address marketCreator;\n        bytes32[] outcomes;\n        int256[] displayPrices;\n        IMarket.MarketType marketType;\n        uint256 recommendedTradeInterval;\n    }\n\n    function getMarketCreationData(IMarket _market) public view returns (MarketCreationData memory);\n}\n\ncontract IAugurMarketDataGetter {\n    function getMarketType(IMarket _market) public view returns (IMarket.MarketType _marketType);\n    function getMarketOutcomes(IMarket _market) public view returns (bytes32[] memory _outcomes);\n    function getMarketRecommendedTradeInterval(IMarket _market) public view returns (uint256);\n}\n\ncontract IExchange {\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n        uint256 makerFeePaid;            // Total amount of fees paid by maker(s) to feeRecipient(s).\n        uint256 takerFeePaid;            // Total amount of fees paid by taker to feeRecipients(s).\n        uint256 protocolFeePaid;         // Total amount of fees paid by taker to the staking contract.\n    }\n\n    struct OrderInfo {\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n    // solhint-disable max-line-length\n    struct Order {\n        address makerAddress;           // Address that created the order.\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\n        uint256 makerFee;               // Fee paid to feeRecipient by maker when order is filled.\n        uint256 takerFee;               // Fee paid to feeRecipient by taker when order is filled.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The leading bytes4 references the id of the asset proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The leading bytes4 references the id of the asset proxy.\n        bytes makerFeeAssetData;        // Encoded data that can be decoded by a specified proxy contract when transferring makerFeeAsset. The leading bytes4 references the id of the asset proxy.\n        bytes takerFeeAssetData;        // Encoded data that can be decoded by a specified proxy contract when transferring takerFeeAsset. The leading bytes4 references the id of the asset proxy.\n    }\n    // solhint-enable max-line-length\n\n    function protocolFeeMultiplier() external view returns (uint256);\n\n    /// @dev Gets information about an order: status, hash, and amount filled.\n    /// @param order Order to gather information on.\n    /// @return OrderInfo Information about the order and its state.\n    ///         See LibOrder.OrderInfo for a complete description.\n    function getOrderInfo(Order memory order) public view returns (OrderInfo memory orderInfo);\n\n    /// @dev Fills the input order.\n    /// @param order Order struct containing order specifications.\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\n    /// @param signature Proof that order has been created by maker.\n    /// @return Amounts filled and fees paid by maker and taker.\n    function fillOrder(Order memory order, uint256 takerAssetFillAmount, bytes memory signature) public payable returns (FillResults memory fillResults);\n}\n\nlibrary ContractExists {\n    function exists(address _address) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(_address) }\n        return size > 0;\n    }\n}\n\ncontract IOwnable {\n    function getOwner() public view returns (address);\n    function transferOwnership(address _newOwner) public returns (bool);\n}\n\ncontract ITyped {\n    function getTypeName() public view returns (bytes32);\n}\n\ncontract Initializable {\n    bool private initialized = false;\n\n    modifier beforeInitialized {\n        require(!initialized);\n        _;\n    }\n\n    function endInitialization() internal beforeInitialized {\n        initialized = true;\n    }\n\n    function getInitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\nlibrary LibBytes {\n\n    using LibBytes for bytes;\n\n    /// @dev Tests equality of two byte arrays.\n    /// @param lhs First byte array to compare.\n    /// @param rhs Second byte array to compare.\n    /// @return True if arrays are the same. False otherwise.\n    function equals(\n        bytes memory lhs,\n        bytes memory rhs\n    )\n        internal\n        pure\n        returns (bool equal)\n    {\n        // Keccak gas cost is 30 + numWords * 6. This is a cheap way to compare.\n        // We early exit on unequal lengths, but keccak would also correctly\n        // handle this.\n        return lhs.length == rhs.length && keccak256(lhs) == keccak256(rhs);\n    }\n\n    /// @dev Gets the memory address for the contents of a byte array.\n    /// @param input Byte array to lookup.\n    /// @return memoryAddress Memory address of the contents of the byte array.\n    function contentAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := add(input, 32)\n        }\n        return memoryAddress;\n    }\n\n    /// @dev Copies `length` bytes from memory location `source` to `dest`.\n    /// @param dest memory address to copy bytes to.\n    /// @param source memory address to copy bytes from.\n    /// @param length number of bytes to copy.\n    function memCopy(\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        internal\n        pure\n    {\n        if (length < 32) {\n            // Handle a partial word by reading destination and masking\n            // off the bits we are interested in.\n            // This correctly handles overlap, zero lengths and source == dest\n            assembly {\n                let mask := sub(exp(256, sub(32, length)), 1)\n                let s := and(mload(source), not(mask))\n                let d := and(mload(dest), mask)\n                mstore(dest, or(s, d))\n            }\n        } else {\n            // Skip the O(length) loop when source == dest.\n            if (source == dest) {\n                return;\n            }\n\n            // For large copies we copy whole words at a time. The final\n            // word is aligned to the end of the range (instead of after the\n            // previous) to handle partial words. So a copy will look like this:\n            //\n            //  ####\n            //      ####\n            //          ####\n            //            ####\n            //\n            // We handle overlap in the source and destination range by\n            // changing the copying direction. This prevents us from\n            // overwriting parts of source that we still need to copy.\n            //\n            // This correctly handles source == dest\n            //\n            if (source > dest) {\n                assembly {\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n                    // is easier to compare with in the loop, and these\n                    // are also the addresses we need for copying the\n                    // last bytes.\n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    // Remember the last 32 bytes of source\n                    // This needs to be done here and not after the loop\n                    // because we may have overwritten the last bytes in\n                    // source already due to overlap.\n                    let last := mload(sEnd)\n\n                    // Copy whole words front to back\n                    // Note: the first check is always true,\n                    // this could have been a do-while loop.\n                    // solhint-disable-next-line no-empty-blocks\n                    for {} lt(source, sEnd) {} {\n                        mstore(dest, mload(source))\n                        source := add(source, 32)\n                        dest := add(dest, 32)\n                    }\n\n                    // Write the last 32 bytes\n                    mstore(dEnd, last)\n                }\n            } else {\n                assembly {\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n                    // are the starting points when copying a word at the end.\n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    // Remember the first 32 bytes of source\n                    // This needs to be done here and not after the loop\n                    // because we may have overwritten the first bytes in\n                    // source already due to overlap.\n                    let first := mload(source)\n\n                    // Copy whole words back to front\n                    // We use a signed comparisson here to allow dEnd to become\n                    // negative (happens when source and dest < 32). Valid\n                    // addresses in local memory will never be larger than\n                    // 2**255, so they can be safely re-interpreted as signed.\n                    // Note: the first check is always true,\n                    // this could have been a do-while loop.\n                    // solhint-disable-next-line no-empty-blocks\n                    for {} slt(dest, dEnd) {} {\n                        mstore(dEnd, mload(sEnd))\n                        sEnd := sub(sEnd, 32)\n                        dEnd := sub(dEnd, 32)\n                    }\n\n                    // Write the first 32 bytes\n                    mstore(dest, first)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns a slices from a byte array.\n    /// @param b The byte array to take a slice from.\n    /// @param from The starting index for the slice (inclusive).\n    /// @param to The final index for the slice (exclusive).\n    /// @return result The slice containing bytes at indices [from, to)\n    function slice(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        // Ensure that the from and to positions are valid positions for a slice within\n        // the byte array that is being used.\n        if (from > to) {\n            revert();\n        }\n        if (to > b.length) {\n            revert();\n        }\n\n        // Create a new bytes structure and copy contents\n        result = new bytes(to - from);\n        memCopy(\n            result.contentAddress(),\n            b.contentAddress() + from,\n            result.length\n        );\n        return result;\n    }\n\n    /// @dev Returns a slice from a byte array without preserving the input.\n    /// @param b The byte array to take a slice from. Will be destroyed in the process.\n    /// @param from The starting index for the slice (inclusive).\n    /// @param to The final index for the slice (exclusive).\n    /// @return result The slice containing bytes at indices [from, to)\n    /// @dev When `from == 0`, the original array will match the slice. In other cases its state will be corrupted.\n    function sliceDestructive(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        // Ensure that the from and to positions are valid positions for a slice within\n        // the byte array that is being used.\n        if (from > to) {\n            revert();\n        }\n        if (to > b.length) {\n            revert();\n        }\n\n        // Create a new bytes structure around [from, to) in-place.\n        assembly {\n            result := add(b, from)\n            mstore(result, sub(to, from))\n        }\n        return result;\n    }\n\n    /// @dev Pops the last byte off of a byte array by modifying its length.\n    /// @param b Byte array that will be modified.\n    /// @return The byte that was popped off.\n    function popLastByte(bytes memory b)\n        internal\n        pure\n        returns (bytes1 result)\n    {\n        if (b.length == 0) {\n            revert();\n        }\n\n        // Store last byte.\n        result = b[b.length - 1];\n\n        assembly {\n            // Decrement length of byte array.\n            let newLen := sub(mload(b), 1)\n            mstore(b, newLen)\n        }\n        return result;\n    }\n}\n\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n\ninterface IERC1155 {\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    /// Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    ///Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /// @dev MUST emit when an approval is updated.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /// @dev MUST emit when the URI is updated for a token ID.\n    /// URIs are defined in RFC 3986.\n    /// The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\".\n    event URI(\n        string value,\n        uint256 indexed id\n    );\n\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\n    /// @dev MUST emit TransferSingle event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\n    /// @param from    Source address\n    /// @param to      Target address\n    /// @param id      ID of the token type\n    /// @param value   Transfer amount\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\n    /// @dev MUST emit TransferBatch event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\n    /// @param from    Source addresses\n    /// @param to      Target addresses\n    /// @param ids     IDs of each token type\n    /// @param values  Transfer amounts per token type\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param operator  Address to add to the set of authorized operators\n    /// @param approved  True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param owner     The owner of the Tokens\n    /// @param operator  Address of authorized operator\n    /// @return           True if the operator is approved, false if not\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Get the balance of an account's Tokens.\n    /// @param owner  The address of the token holder\n    /// @param id     ID of the Token\n    /// @return        The _owner's balance of the Token type requested\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @notice Get the total supply of a Token.\n    /// @param id     ID of the Token\n    /// @return        The total supply of the Token type requested\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param owners The addresses of the token holders\n    /// @param ids    ID of the Tokens\n    /// @return        The _owner's balance of the Token types requested\n    function balanceOfBatch(\n        address[] calldata owners,\n        uint256[] calldata ids\n    )\n        external\n        view\n        returns (uint256[] memory balances_);\n}\n\ncontract IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) public view returns (uint256);\n    function transfer(address to, uint256 amount) public returns (bool);\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ICash is IERC20 {\n}\n\ncontract IAffiliateValidator {\n    function validateReference(address _account, address _referrer) external view returns (bool);\n}\n\ncontract IDisputeWindow is ITyped, IERC20 {\n    function invalidMarketsTotal() external view returns (uint256);\n    function validityBondTotal() external view returns (uint256);\n\n    function incorrectDesignatedReportTotal() external view returns (uint256);\n    function initialReportBondTotal() external view returns (uint256);\n\n    function designatedReportNoShowsTotal() external view returns (uint256);\n    function designatedReporterNoShowBondTotal() external view returns (uint256);\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _disputeWindowId, bool _participationTokensEnabled, uint256 _duration, uint256 _startTime) public;\n    function trustedBuy(address _buyer, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getReputationToken() public view returns (IReputationToken);\n    function getStartTime() public view returns (uint256);\n    function getEndTime() public view returns (uint256);\n    function getWindowId() public view returns (uint256);\n    function isActive() public view returns (bool);\n    function isOver() public view returns (bool);\n    function onMarketFinalized() public;\n    function redeem(address _account) public returns (bool);\n}\n\ncontract IMarket is IOwnable {\n    enum MarketType {\n        YES_NO,\n        CATEGORICAL,\n        SCALAR\n    }\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public;\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32);\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getDisputeWindow() public view returns (IDisputeWindow);\n    function getNumberOfOutcomes() public view returns (uint256);\n    function getNumTicks() public view returns (uint256);\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n    function getForkingMarket() public view returns (IMarket _market);\n    function getEndTime() public view returns (uint256);\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningReportingParticipant() public view returns (IReportingParticipant);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getFinalizationTime() public view returns (uint256);\n    function getInitialReporter() public view returns (IInitialReporter);\n    function getDesignatedReportingEndTime() public view returns (uint256);\n    function getValidityBondAttoCash() public view returns (uint256);\n    function affiliateFeeDivisor() external view returns (uint256);\n    function getNumParticipants() public view returns (uint256);\n    function getDisputePacingOn() public view returns (bool);\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function isFinalizedAsInvalid() public view returns (bool);\n    function finalize() public returns (bool);\n    function isFinalized() public view returns (bool);\n    function getOpenInterest() public view returns (uint256);\n}\n\ncontract IReportingParticipant {\n    function getStake() public view returns (uint256);\n    function getPayoutDistributionHash() public view returns (bytes32);\n    function liquidateLosing() public;\n    function redeem(address _redeemer) public returns (bool);\n    function isDisavowed() public view returns (bool);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getMarket() public view returns (IMarket);\n    function getSize() public view returns (uint256);\n}\n\ncontract IInitialReporter is IReportingParticipant, IOwnable {\n    function initialize(IAugur _augur, IMarket _market, address _designatedReporter) public;\n    function report(address _reporter, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _initialReportStake) public;\n    function designatedReporterShowed() public view returns (bool);\n    function initialReporterWasCorrect() public view returns (bool);\n    function getDesignatedReporter() public view returns (address);\n    function getReportTimestamp() public view returns (uint256);\n    function migrateToNewUniverse(address _designatedReporter) public;\n    function returnRepFromDisavow() public;\n}\n\ncontract IReputationToken is IERC20 {\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool);\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getTotalMigrated() public view returns (uint256);\n    function getTotalTheoreticalSupply() public view returns (uint256);\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\n\ncontract IShareToken is ITyped, IERC1155 {\n    function initialize(IAugur _augur) external;\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public;\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external returns (uint256[] memory _outcomeFees);\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId);\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds);\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool);\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool);\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256);\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256);\n}\n\ncontract IUniverse {\n    function creationTime() external view returns (uint256);\n    function marketBalance(address) external view returns (uint256);\n\n    function fork() public returns (bool);\n    function updateForkValues() public returns (bool);\n    function getParentUniverse() public view returns (IUniverse);\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getForkingMarket() public view returns (IMarket);\n    function getForkEndTime() public view returns (uint256);\n    function getForkReputationGoal() public view returns (uint256);\n    function getParentPayoutDistributionHash() public view returns (bytes32);\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256);\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow);\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOpenInterestInAttoCash() public view returns (uint256);\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\n    function getOrCacheValidityBond() public returns (uint256);\n    function getOrCacheDesignatedReportStake() public returns (uint256);\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n    function getOrCacheMarketRepBond() public returns (uint256);\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\n    function getDisputeThresholdForFork() public view returns (uint256);\n    function getDisputeThresholdForDisputePacing() public view returns (uint256);\n    function getInitialReportMinValue() public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getReportingFeeDivisor() public view returns (uint256);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningChildPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function isOpenInterestCash(address) public view returns (bool);\n    function isForkingMarket() public view returns (bool);\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow);\n    function getDisputeWindowStartTimeAndDuration(uint256 _timestamp, bool _initial) public view returns (uint256, uint256);\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget) public view returns (bool);\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function migrateMarketOut(IUniverse _destinationUniverse) public returns (bool);\n    function migrateMarketIn(IMarket _market, uint256 _cashBalance, uint256 _marketOI) public returns (bool);\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\n    function decrementOpenInterestFromMarket(IMarket _market) public returns (bool);\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\n    function getWinningChildUniverse() public view returns (IUniverse);\n    function isForking() public view returns (bool);\n    function deposit(address _sender, uint256 _amount, address _market) public returns (bool);\n    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool);\n    function createScalarMarket(uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, int256[] memory _prices, uint256 _numTicks, string memory _extraInfo) public returns (IMarket _newMarket);\n}\n\ncontract IV2ReputationToken is IReputationToken {\n    function parentUniverse() external returns (IUniverse);\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool);\n}\n\ncontract IAugurTrading {\n    function lookup(bytes32 _key) public view returns (address);\n    function logProfitLossChanged(IMarket _market, address _account, uint256 _outcome, int256 _netPosition, uint256 _avgPrice, int256 _realizedProfit, int256 _frozenFunds, int256 _realizedCost) public returns (bool);\n    function logOrderCreated(IUniverse _universe, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logOrderCanceled(IUniverse _universe, IMarket _market, address _creator, uint256 _tokenRefund, uint256 _sharesRefund, bytes32 _orderId) public returns (bool);\n    function logOrderFilled(IUniverse _universe, address _creator, address _filler, uint256 _price, uint256 _fees, uint256 _amountFilled, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logMarketVolumeChanged(IUniverse _universe, address _market, uint256 _volume, uint256[] memory _outcomeVolumes, uint256 _totalTrades) public returns (bool);\n    function logZeroXOrderFilled(IUniverse _universe, IMarket _market, bytes32 _orderHash, bytes32 _tradeGroupId, uint8 _orderType, address[] memory _addressData, uint256[] memory _uint256Data) public returns (bool);\n    function logZeroXOrderCanceled(address _universe, address _market, address _account, uint256 _outcome, uint256 _price, uint256 _amount, uint8 _type, bytes32 _orderHash) public;\n}\n\ncontract IFillOrder {\n    function publicFillOrder(bytes32 _orderId, uint256 _amountFillerWants, bytes32 _tradeGroupId, bytes32 _fingerprint) external returns (uint256);\n    function fillOrder(address _filler, bytes32 _orderId, uint256 _amountFillerWants, bytes32 tradeGroupId, bytes32 _fingerprint) external returns (uint256);\n    function fillZeroXOrder(IMarket _market, uint256 _outcome, uint256 _price, Order.Types _orderType, address _creator, uint256 _amount, bytes32 _fingerprint, bytes32 _tradeGroupId, address _filler) external returns (uint256, uint256);\n    function getMarketOutcomeValues(IMarket _market) public view returns (uint256[] memory);\n    function getMarketVolume(IMarket _market) public view returns (uint256);\n}\n\ncontract IOrders {\n    function saveOrder(uint256[] calldata _uints, bytes32[] calldata _bytes32s, Order.Types _type, IMarket _market, address _sender) external returns (bytes32 _orderId);\n    function removeOrder(bytes32 _orderId) external returns (bool);\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\n    function getAmount(bytes32 _orderId) public view returns (uint256);\n    function getPrice(bytes32 _orderId) public view returns (uint256);\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderDataForCancel(bytes32 _orderId) public view returns (uint256, uint256, Order.Types, IMarket, uint256, address);\n    function getOrderDataForLogs(bytes32 _orderId) public view returns (Order.Types, address[] memory _addressData, uint256[] memory _uint256Data);\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled, uint256 _fill) external returns (bool);\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n}\n\ncontract IZeroXTrade {\n\n    struct AugurOrderData {\n        address marketAddress;                  // Market Address\n        uint256 price;                          // Price\n        uint8 outcome;                          // Outcome\n        uint8 orderType;                        // Order Type\n    }\n\n    function parseOrderData(IExchange.Order memory _order) public view returns (AugurOrderData memory _data);\n    function unpackTokenId(uint256 _tokenId) public pure returns (address _market, uint256 _price, uint8 _outcome, uint8 _type);\n}\n\nlibrary Order {\n    using SafeMathUint256 for uint256;\n\n    enum Types {\n        Bid, Ask\n    }\n\n    enum TradeDirections {\n        Long, Short\n    }\n\n    struct Data {\n        // Contracts\n        IMarket market;\n        IAugur augur;\n        IAugurTrading augurTrading;\n        IShareToken shareToken;\n        ICash cash;\n\n        // Order\n        bytes32 id;\n        address creator;\n        uint256 outcome;\n        Order.Types orderType;\n        uint256 amount;\n        uint256 price;\n        uint256 sharesEscrowed;\n        uint256 moneyEscrowed;\n        bytes32 betterOrderId;\n        bytes32 worseOrderId;\n    }\n\n    function create(IAugur _augur, IAugurTrading _augurTrading, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data memory) {\n        require(_outcome < _market.getNumberOfOutcomes(), \"Order.create: Outcome is not within market range\");\n        require(_price != 0, \"Order.create: Price may not be 0\");\n        require(_price < _market.getNumTicks(), \"Order.create: Price is outside of market range\");\n        require(_attoshares > 0, \"Order.create: Cannot use amount of 0\");\n        require(_creator != address(0), \"Order.create: Creator is 0x0\");\n\n        IShareToken _shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n\n        return Data({\n            market: _market,\n            augur: _augur,\n            augurTrading: _augurTrading,\n            shareToken: _shareToken,\n            cash: ICash(_augur.lookup(\"Cash\")),\n            id: 0,\n            creator: _creator,\n            outcome: _outcome,\n            orderType: _type,\n            amount: _attoshares,\n            price: _price,\n            sharesEscrowed: 0,\n            moneyEscrowed: 0,\n            betterOrderId: _betterOrderId,\n            worseOrderId: _worseOrderId\n        });\n    }\n\n    //\n    // \"public\" functions\n    //\n\n    function getOrderId(Order.Data memory _orderData, IOrders _orders) internal view returns (bytes32) {\n        if (_orderData.id == bytes32(0)) {\n            bytes32 _orderId = calculateOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n            require(_orders.getAmount(_orderId) == 0, \"Order.getOrderId: New order had amount. This should not be possible\");\n            _orderData.id = _orderId;\n        }\n        return _orderData.id;\n    }\n\n    function calculateOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(_type, _market, _amount, _price, _sender, _blockNumber, _outcome, _moneyEscrowed, _sharesEscrowed));\n    }\n\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n    }\n\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n    }\n\n    function saveOrder(Order.Data memory _orderData, bytes32 _tradeGroupId, IOrders _orders) internal returns (bytes32) {\n        getOrderId(_orderData, _orders);\n        uint256[] memory _uints = new uint256[](5);\n        _uints[0] = _orderData.amount;\n        _uints[1] = _orderData.price;\n        _uints[2] = _orderData.outcome;\n        _uints[3] = _orderData.moneyEscrowed;\n        _uints[4] = _orderData.sharesEscrowed;\n        bytes32[] memory _bytes32s = new bytes32[](4);\n        _bytes32s[0] = _orderData.betterOrderId;\n        _bytes32s[1] = _orderData.worseOrderId;\n        _bytes32s[2] = _tradeGroupId;\n        _bytes32s[3] = _orderData.id;\n        return _orders.saveOrder(_uints, _bytes32s, _orderData.orderType, _orderData.market, _orderData.creator);\n    }\n}\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ninterface IWETH {\n    function deposit() external payable;\n    function balanceOf(address owner) external view returns (uint);\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n\ncontract ZeroXTrade is Initializable, IZeroXTrade, IERC1155 {\n    using SafeMathUint256 for uint256;\n    using LibBytes for bytes;\n\n    bool transferFromAllowed = false;\n\n    // ERC20Token(address)\n    bytes4 constant private ERC20_PROXY_ID = 0xf47261b0;\n\n    // ERC1155Assets(address,uint256[],uint256[],bytes)\n    bytes4 constant private MULTI_ASSET_PROXY_ID = 0x94cfcdd7;\n\n    // ERC1155Assets(address,uint256[],uint256[],bytes)\n    bytes4 constant private ERC1155_PROXY_ID = 0xa7cb5fb7;\n\n    // EIP191 header for EIP712 prefix\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    // EIP712 Domain Name value\n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\n\n    // EIP712 Domain Version value\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\n\n    // EIP1271 Order With Hash Selector\n    bytes4 constant public EIP1271_ORDER_WITH_HASH_SELECTOR = 0x3efe50c8;\n\n    // Hash of the EIP712 Domain Separator Schema\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(\n        abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(\n        abi.encodePacked(\n        \"Order(\",\n        \"address makerAddress,\",\n        \"address takerAddress,\",\n        \"address feeRecipientAddress,\",\n        \"address senderAddress,\",\n        \"uint256 makerAssetAmount,\",\n        \"uint256 takerAssetAmount,\",\n        \"uint256 makerFee,\",\n        \"uint256 takerFee,\",\n        \"uint256 expirationTimeSeconds,\",\n        \"uint256 salt,\",\n        \"bytes makerAssetData,\",\n        \"bytes takerAssetData\",\n        \"bytes makerFeeAssetData,\",\n        \"bytes takerFeeAssetData\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 Domain Separator data\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    IAugur public augur;\n    IAugurTrading public augurTrading;\n    IFillOrder public fillOrder;\n    ICash public cash;\n    IShareToken public shareToken;\n    IExchange public exchange;\n    IUniswapV2Pair public ethExchange;\n    IWETH public WETH;\n    bool public token0IsCash;\n\n    function initialize(IAugur _augur, IAugurTrading _augurTrading) public beforeInitialized {\n        endInitialization();\n        augur = _augur;\n        augurTrading = _augurTrading;\n        cash = ICash(_augur.lookup(\"Cash\"));\n        require(cash != ICash(0));\n        shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n        require(shareToken != IShareToken(0));\n        exchange = IExchange(_augurTrading.lookup(\"ZeroXExchange\"));\n        require(exchange != IExchange(0));\n        fillOrder = IFillOrder(_augurTrading.lookup(\"FillOrder\"));\n        require(fillOrder != IFillOrder(0));\n        WETH = IWETH(_augurTrading.lookup(\"WETH9\"));\n        IUniswapV2Factory _uniswapFactory = IUniswapV2Factory(_augur.lookup(\"UniswapV2Factory\"));\n        address _ethExchangeAddress = _uniswapFactory.getPair(address(WETH), address(cash));\n        if (_ethExchangeAddress == address(0)) {\n            _ethExchangeAddress = _uniswapFactory.createPair(address(WETH), address(cash));\n        }\n        ethExchange = IUniswapV2Pair(_ethExchangeAddress);\n        token0IsCash = ethExchange.token0() == address(cash);\n\n        EIP712_DOMAIN_HASH = keccak256(\n            abi.encodePacked(\n                EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                uint256(address(this))\n            )\n        );\n    }\n\n    // ERC1155 Implementation\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\n    /// @dev MUST emit TransferSingle event on success.\n    /// @param from    Source address\n    /// @param to      Target address\n    /// @param id      ID of the token type\n    /// @param value   Transfer amount\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external {\n        require(transferFromAllowed);\n        emit TransferSingle(msg.sender, from, to, id, value);\n    }\n\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\n    /// @dev MUST emit TransferBatch event on success.\n    /// @param from    Source addresses\n    /// @param to      Target addresses\n    /// @param ids     IDs of each token type\n    /// @param values  Transfer amounts per token type\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data) external {\n        require(transferFromAllowed);\n        emit TransferBatch(msg.sender, from, to, ids, values);\n    }\n\n    /// @notice Get the balance of an account's Tokens.\n    /// @param owner  The address of the token holder\n    /// @param id     ID of the Token\n    /// @return       The _owner's balance of the Token type requested\n    function balanceOf(address owner, uint256 id) external view returns (uint256) {\n        (address _market, uint256 _price, uint8 _outcome, uint8 _type) = unpackTokenId(id);\n        // NOTE: An invalid order type will cause a failure here. That is malformed input so we don't mind reverting in such a case\n        Order.Types _orderType = Order.Types(_type);\n        if (_orderType == Order.Types.Ask) {\n            return askBalance(owner, IMarket(_market), _outcome, _price);\n        } else if (_orderType == Order.Types.Bid) {\n            return bidBalance(owner, IMarket(_market), _outcome, _price);\n        }\n    }\n\n    function totalSupply(uint256 id) external view returns (uint256) {\n        return 0;\n    }\n\n    function bidBalance(address _owner, IMarket _market, uint8 _outcome, uint256 _price) public view returns (uint256) {\n        uint256 _numberOfOutcomes = _market.getNumberOfOutcomes();\n        // Figure out how many almost-complete-sets (just missing `outcome` share) the creator has\n        uint256[] memory _shortOutcomes = new uint256[](_numberOfOutcomes - 1);\n        uint256 _indexOutcome = 0;\n        for (uint256 _i = 0; _i < _numberOfOutcomes - 1; _i++) {\n            if (_i == _outcome) {\n                _indexOutcome++;\n            }\n            _shortOutcomes[_i] = _indexOutcome;\n            _indexOutcome++;\n        }\n\n        uint256 _attoSharesOwned = shareToken.lowestBalanceOfMarketOutcomes(_market, _shortOutcomes, _owner);\n\n        uint256 _availableCash = cashAvailableForTransferFrom(_owner, address(fillOrder));\n        uint256 _attoSharesPurchasable = _availableCash.div(_price);\n\n        return _attoSharesOwned.add(_attoSharesPurchasable);\n    }\n\n    function askBalance(address _owner, IMarket _market, uint8 _outcome, uint256 _price) public view returns (uint256) {\n        uint256 _attoSharesOwned = shareToken.balanceOfMarketOutcome(_market, _outcome, _owner);\n        uint256 _availableCash = cashAvailableForTransferFrom(_owner, address(fillOrder));\n        uint256 _attoSharesPurchasable = _availableCash.div(_market.getNumTicks().sub(_price));\n\n        return _attoSharesOwned.add(_attoSharesPurchasable);\n    }\n\n    function cashAvailableForTransferFrom(address _owner, address _sender) public view returns (uint256) {\n        uint256 _balance = cash.balanceOf(_owner);\n        uint256 _allowance = cash.allowance(_owner, _sender);\n        return _balance.min(_allowance);\n    }\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param owners The addresses of the token holders\n    /// @param ids    ID of the Tokens\n    /// @return        The _owner's balance of the Token types requested\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances_) {\n        balances_ = new uint256[](owners.length);\n        for (uint256 _i = 0; _i < owners.length; _i++) {\n            balances_[_i] = this.balanceOf(owners[_i], ids[_i]);\n        }\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        revert(\"Not supported\");\n    }\n\n    function isApprovedForAll(address owner, address operator) external view returns (bool) {\n        return true;\n    }\n\n    // Trade functions\n\n    /**\n     * Perform Augur Trades using 0x signed orders\n     *\n     * @param  _requestedFillAmount  Share amount to fill\n     * @param  _fingerprint          Fingerprint of the user to restrict affiliate fees\n     * @param  _tradeGroupId         Random id to correlate these fills as one trade action\n     * @param  _maxProtocolFeeDai    The maximum amount of DAI to spend on covering the 0x protocol fee\n     * @param  _maxTrades            The maximum number of trades to actually take from the provided 0x orders\n     * @param  _orders               Array of encoded Order struct data\n     * @param  _signatures           Array of signature data\n     * @return                       The amount the taker still wants\n     */\n    function trade(\n        uint256 _requestedFillAmount,\n        bytes32 _fingerprint,\n        bytes32 _tradeGroupId,\n        uint256 _maxProtocolFeeDai,\n        uint256 _maxTrades,\n        IExchange.Order[] memory _orders,\n        bytes[] memory _signatures\n    )\n        public\n        payable\n        returns (uint256)\n    {\n        require(_orders.length > 0);\n        uint256 _fillAmountRemaining = _requestedFillAmount;\n\n        transferFromAllowed = true;\n\n        uint256 _protocolFee = exchange.protocolFeeMultiplier().mul(tx.gasprice);\n        coverProtocolFee(_protocolFee.mul(_maxTrades), _maxProtocolFeeDai);\n\n        // Do the actual asset exchanges\n        for (uint256 i = 0; i < _orders.length && _fillAmountRemaining != 0; i++) {\n            IExchange.Order memory _order = _orders[i];\n            validateOrder(_order, _fillAmountRemaining);\n\n            // Update 0x and pay protocol fee. This will also validate signatures and order state for us.\n            IExchange.FillResults memory totalFillResults = fillOrderNoThrow(\n                _order,\n                _fillAmountRemaining,\n                _signatures[i],\n                _protocolFee\n            );\n\n            if (totalFillResults.takerAssetFilledAmount == 0) {\n                continue;\n            }\n\n            uint256 _amountTraded = doTrade(_order, totalFillResults.takerAssetFilledAmount, _fingerprint, _tradeGroupId, msg.sender);\n\n            _fillAmountRemaining = _fillAmountRemaining.sub(_amountTraded);\n            _maxTrades -= 1;\n            if (_maxTrades == 0) {\n                break;\n            }\n        }\n\n        transferFromAllowed = false;\n\n        if (address(this).balance > 0) {\n            (bool _success,) = msg.sender.call.value(address(this).balance)(\"\");\n            require(_success);\n        }\n\n        return _fillAmountRemaining;\n    }\n\n    function fillOrderNoThrow(IExchange.Order memory _order, uint256 _takerAssetFillAmount, bytes memory _signature, uint256 _protocolFee) internal returns (IExchange.FillResults memory fillResults) {\n        bytes memory fillOrderCalldata = abi.encodeWithSelector(\n            IExchange(address(0)).fillOrder.selector,\n            _order,\n            _takerAssetFillAmount,\n            _signature\n        );\n\n        (bool _didSucceed, bytes memory _returnData) = address(exchange).call.value(_protocolFee)(fillOrderCalldata);\n        if (_didSucceed) {\n            assert(_returnData.length == 160);\n            fillResults = abi.decode(_returnData, (IExchange.FillResults));\n        }\n        return fillResults;\n    }\n\n    function coverProtocolFee(uint256 _amountEthRequired, uint256 _maxProtocolFeeDai) internal {\n        if (address(this).balance < _amountEthRequired) {\n            uint256 _ethDeficit = _amountEthRequired - address(this).balance;\n            uint256 _cost = getTokenPurchaseCost(_ethDeficit);\n            require(_cost <= _maxProtocolFeeDai, \"Cost of purchasing ETH to cover protocol Fee on the exchange was too high\");\n            require(cash.transferFrom(msg.sender, address(ethExchange), _cost));\n            ethExchange.swap(token0IsCash ? 0 : _ethDeficit, token0IsCash ? _ethDeficit : 0, address(this), \"\");\n            WETH.withdraw(_ethDeficit);\n        }\n    }\n\n    function estimateProtocolFeeCostInCash(uint256 _numOrders, uint256 _gasPrice) public view returns (uint256) {\n        uint256 _protocolFee = exchange.protocolFeeMultiplier().mul(_gasPrice);\n        uint256 _amountEthRequired = _protocolFee.mul(_numOrders);\n        return getTokenPurchaseCost(_amountEthRequired);\n    }\n\n    function getTokenPurchaseCost(uint256 _ethAmount) private view returns (uint256) {\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = ethExchange.getReserves();\n        return getAmountIn(_ethAmount, token0IsCash ? _reserve0 : _reserve1, token0IsCash ? _reserve1 : _reserve0);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) public pure returns (uint amountIn) {\n        require(amountOut > 0);\n        require(reserveIn > 0 && reserveOut > 0);\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    function validateOrder(IExchange.Order memory _order, uint256 _fillAmountRemaining) internal view {\n        require(_order.takerAssetData.equals(encodeTakerAssetData()));\n        require(_order.takerAssetAmount == _order.makerAssetAmount);\n        (IERC1155 _zeroXTradeTokenMaker, uint256 _tokenIdMaker) = getZeroXTradeTokenData(_order.makerAssetData);\n        (address _market, uint256 _price, uint8 _outcome, uint8 _type) = unpackTokenId(_tokenIdMaker);\n        uint256 _numTicks = IMarket(_market).getNumTicks();\n        require(isOrderAmountValid(IMarket(_market), _fillAmountRemaining), \"Order must be a multiple of the market trade increment\");\n        require(_zeroXTradeTokenMaker == this);\n    }\n\n    function isOrderAmountValid(IMarket _market, uint256 _orderAmount) public view returns (bool) {\n        uint256 _tradeInterval = IAugurMarketDataGetter(address(augur)).getMarketRecommendedTradeInterval(_market);\n        return _orderAmount.isMultipleOf(_tradeInterval);\n    }\n\n    function cancelOrders(IExchange.Order[] memory _orders, bytes[] memory _signatures, uint256 _maxProtocolFeeDai) public returns (bool) {\n        require(_orders.length == _signatures.length);\n        uint256 _protocolFee = exchange.protocolFeeMultiplier().mul(tx.gasprice);\n        coverProtocolFee(_protocolFee.mul(_orders.length), _maxProtocolFeeDai);\n        transferFromAllowed = true;\n        for (uint256 i = 0; i < _orders.length; i++) {\n            IExchange.Order memory _order = _orders[i];\n            bytes memory _signature = _signatures[i];\n            require(msg.sender == _order.makerAddress);\n            IExchange.OrderInfo memory _orderInfo = exchange.getOrderInfo(_order);\n            uint256 _amountRemaining = _order.takerAssetAmount.sub(_orderInfo.orderTakerAssetFilledAmount);\n            exchange.fillOrder.value(_protocolFee)(_order, _amountRemaining, _signature);\n            AugurOrderData memory _orderData = parseOrderData(_order);\n            IUniverse _universe = IMarket(_orderData.marketAddress).getUniverse();\n            augurTrading.logZeroXOrderCanceled(address(_universe), _orderData.marketAddress, _order.makerAddress, _orderData.outcome, _orderData.price, _amountRemaining, uint8(_orderData.orderType), _orderInfo.orderHash);\n        }\n        transferFromAllowed = false;\n        if (address(this).balance > 0) {\n            (bool _success,) = msg.sender.call.value(address(this).balance)(\"\");\n            require(_success);\n        }\n        return true;\n    }\n\n    function doTrade(IExchange.Order memory _order, uint256 _amount, bytes32 _fingerprint, bytes32 _tradeGroupId, address _taker) private returns (uint256 _amountFilled) {\n        // parseOrderData will validate that the token being traded is the leigitmate one for the market\n        AugurOrderData memory _augurOrderData = parseOrderData(_order);\n        // If the signed order creator doesnt have enough funds we still want to continue and take their order out of the list\n        // If the filler doesn't have funds this will just fail, which is fine\n        if (!creatorHasFundsForTrade(_order, _amount)) {\n            return 0;\n        }\n        // If the maker is also the taker we also just skip the trade but treat it as filled for amount remaining purposes\n        if (_order.makerAddress == _taker) {\n            return _amount;\n        }\n        (uint256 _amountRemaining, uint256 _fees) = fillOrder.fillZeroXOrder(IMarket(_augurOrderData.marketAddress), _augurOrderData.outcome, _augurOrderData.price, Order.Types(_augurOrderData.orderType), _order.makerAddress, _amount, _fingerprint, _tradeGroupId, _taker);\n        _amountFilled = _amount.sub(_amountRemaining);\n        logOrderFilled(_order, _augurOrderData, _taker, _tradeGroupId, _amountFilled, _fees);\n        return _amountFilled;\n    }\n\n    function logOrderFilled(IExchange.Order memory _order, AugurOrderData memory _augurOrderData, address _taker, bytes32 _tradeGroupId, uint256 _amountFilled, uint256 _fees) private {\n        bytes32 _orderHash = exchange.getOrderInfo(_order).orderHash;\n        address[] memory _addressData = new address[](2);\n        uint256[] memory _uint256Data = new uint256[](10);\n        Order.Types _orderType = Order.Types(_augurOrderData.orderType);\n        _addressData[0] = _order.makerAddress;\n        _addressData[1] = _taker;\n        _uint256Data[0] = _augurOrderData.price;\n        _uint256Data[1] = 0;\n        _uint256Data[2] = _augurOrderData.outcome;\n        _uint256Data[5] = _fees;\n        _uint256Data[6] = _amountFilled;\n        _uint256Data[8] = 0;\n        _uint256Data[9] = 0;\n        augurTrading.logZeroXOrderFilled(IMarket(_augurOrderData.marketAddress).getUniverse(), IMarket(_augurOrderData.marketAddress), _orderHash, _tradeGroupId, uint8(_orderType), _addressData, _uint256Data);\n    }\n\n    function creatorHasFundsForTrade(IExchange.Order memory _order, uint256 _amount) public view returns (bool) {\n        uint256 _tokenId = getTokenIdFromOrder(_order);\n        return _amount <= this.balanceOf(_order.makerAddress, _tokenId);\n    }\n\n    function getTransferFromAllowed() public view returns (bool) {\n        return transferFromAllowed;\n    }\n\n    /// @dev Encode MultiAsset proxy asset data into the format described in the AssetProxy contract specification.\n    /// @param _market The address of the market to trade on\n    /// @param _price The price used to trade\n    /// @param _outcome The outcome to trade on\n    /// @param _type Either BID == 0 or ASK == 1\n    /// @return AssetProxy-compliant asset data describing the set of assets.\n    function encodeAssetData(\n        IMarket _market,\n        uint256 _price,\n        uint8 _outcome,\n        uint8 _type\n    )\n        public\n        view\n        returns (bytes memory _assetData)\n    {\n        bytes[] memory _nestedAssetData = new bytes[](3);\n        uint256[] memory _multiAssetValues = new uint256[](3);\n        _nestedAssetData[0] = encodeTradeAssetData(_market, _price, _outcome, _type);\n        _nestedAssetData[1] = encodeCashAssetData();\n        _nestedAssetData[2] = encodeShareAssetData();\n        _multiAssetValues[0] = 1;\n        _multiAssetValues[1] = 0;\n        _multiAssetValues[2] = 0;\n        bytes memory _data = abi.encodeWithSelector(\n            MULTI_ASSET_PROXY_ID,\n            _multiAssetValues,\n            _nestedAssetData\n        );\n        return _data;\n    }\n\n    /// @dev Encode ERC-1155 asset data into the format described in the AssetProxy contract specification.\n    /// @param _market The address of the market to trade on\n    /// @param _price The price used to trade\n    /// @param _outcome The outcome to trade on\n    /// @param _type Either BID == 0 or ASK == 1\n    /// @return AssetProxy-compliant asset data describing the set of assets.\n    function encodeTradeAssetData(\n        IMarket _market,\n        uint256 _price,\n        uint8 _outcome,\n        uint8 _type\n    )\n        private\n        view\n        returns (bytes memory _assetData)\n    {\n        uint256[] memory _tokenIds = new uint256[](1);\n        uint256[] memory _tokenValues = new uint256[](1);\n\n        uint256 _tokenId = getTokenId(address(_market), _price, _outcome, _type);\n        _tokenIds[0] = _tokenId;\n        _tokenValues[0] = 1;\n        bytes memory _callbackData = new bytes(0);\n        _assetData = abi.encodeWithSelector(\n            ERC1155_PROXY_ID,\n            address(this),\n            _tokenIds,\n            _tokenValues,\n            _callbackData\n        );\n\n        return _assetData;\n    }\n\n    /// @dev Encode ERC-20 asset data into the format described in the AssetProxy contract specification.\n    /// @return AssetProxy-compliant asset data describing the set of assets.\n    function encodeCashAssetData()\n        private\n        view\n        returns (bytes memory _assetData)\n    {\n        _assetData = abi.encodeWithSelector(\n            ERC20_PROXY_ID,\n            address(cash)\n        );\n\n        return _assetData;\n    }\n\n    /// @dev Encode ERC-1155 asset data into the format described in the AssetProxy contract specification.\n    /// @return AssetProxy-compliant asset data describing the set of assets.\n    function encodeShareAssetData()\n        private\n        view\n        returns (bytes memory _assetData)\n    {\n        uint256[] memory _tokenIds = new uint256[](0);\n        uint256[] memory _tokenValues = new uint256[](0);\n        bytes memory _callbackData = new bytes(0);\n        _assetData = abi.encodeWithSelector(\n            ERC1155_PROXY_ID,\n            address(shareToken),\n            _tokenIds,\n            _tokenValues,\n            _callbackData\n        );\n\n        return _assetData;\n    }\n\n    /// @dev Encode ERC-1155 asset data into the format described in the AssetProxy contract specification.\n    /// @return AssetProxy-compliant asset data describing the set of assets.\n    function encodeTakerAssetData()\n        private\n        view\n        returns (bytes memory _assetData)\n    {\n        uint256[] memory _tokenIds = new uint256[](0);\n        uint256[] memory _tokenValues = new uint256[](0);\n        bytes memory _callbackData = new bytes(0);\n        _assetData = abi.encodeWithSelector(\n            ERC1155_PROXY_ID,\n            address(this),\n            _tokenIds,\n            _tokenValues,\n            _callbackData\n        );\n\n        return _assetData;\n    }\n\n    function getTokenId(address _market, uint256 _price, uint8 _outcome, uint8 _type) public pure returns (uint256 _tokenId) {\n        // NOTE: we're assuming no one needs a full uint256 for the price value here and cutting to uint80 so we can pack this in a uint256.\n        bytes memory _tokenIdBytes = abi.encodePacked(_market, uint80(_price), _outcome, _type);\n        assembly {\n            _tokenId := mload(add(_tokenIdBytes, add(0x20, 0)))\n        }\n    }\n\n    function unpackTokenId(uint256 _tokenId) public pure returns (address _market, uint256 _price, uint8 _outcome, uint8 _type) {\n        assembly {\n            _market := shr(96, and(_tokenId, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000))\n            _price := shr(16,  and(_tokenId, 0x0000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFF0000))\n            _outcome := shr(8, and(_tokenId, 0x000000000000000000000000000000000000000000000000000000000000FF00))\n            _type :=           and(_tokenId, 0x00000000000000000000000000000000000000000000000000000000000000FF)\n        }\n    }\n\n    /// @dev Decode MultiAsset asset data from the format described in the AssetProxy contract specification.\n    /// @param _assetData AssetProxy-compliant asset data describing an ERC-1155 set of assets.\n    /// @return The ERC-1155 AssetProxy identifier, the address of this ERC-1155\n    /// contract hosting the assets, an array of the identifiers of the\n    /// assets to be traded, an array of asset amounts to be traded, and\n    /// callback data.  Each element of the arrays corresponds to the\n    /// same-indexed element of the other array.  Return values specified as\n    /// `memory` are returned as pointers to locations within the memory of\n    /// the input parameter `assetData`.\n    function decodeAssetData(bytes memory _assetData)\n        public\n        view\n        returns (\n            bytes4 _assetProxyId,\n            address _tokenAddress,\n            uint256[] memory _tokenIds,\n            uint256[] memory _tokenValues,\n            bytes memory _callbackData\n        )\n    {\n         // Read the bytes4 from array memory\n        assembly {\n            _assetProxyId := mload(add(_assetData, 32))\n            // Solidity does not require us to clean the trailing bytes. We do it anyway\n            _assetProxyId := and(_assetProxyId, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n\n        require(_assetProxyId == MULTI_ASSET_PROXY_ID, \"WRONG_PROXY_ID\");\n\n        uint256[] memory _amounts;\n        bytes[] memory _nestedAssetData;\n\n        // Slice the selector off the asset data\n        bytes memory _noSelectorAssetData = _assetData.slice(4, _assetData.length);\n\n        (_amounts, _nestedAssetData) = abi.decode(_noSelectorAssetData, (uint256[], bytes[]));\n        \n        // Validate storage refs against the decoded values.\n        {\n            require(_amounts.length == 3);\n            require(_amounts[0] == 1);\n            require(_amounts[1] == 0);\n            require(_amounts[2] == 0);\n            require(_nestedAssetData[1].equals(encodeCashAssetData()));\n            require(_nestedAssetData[2].equals(encodeShareAssetData()));\n        }\n\n        return decodeTradeAssetData(_nestedAssetData[0]);\n    }\n\n    /// @dev Decode ERC-1155 asset data from the format described in the AssetProxy contract specification.\n    /// @param _assetData AssetProxy-compliant asset data describing an ERC-1155 set of assets.\n    /// @return The ERC-1155 AssetProxy identifier, the address of this ERC-1155\n    /// contract hosting the assets, an array of the identifiers of the\n    /// assets to be traded, an array of asset amounts to be traded, and\n    /// callback data.  Each element of the arrays corresponds to the\n    /// same-indexed element of the other array.  Return values specified as\n    /// `memory` are returned as pointers to locations within the memory of\n    /// the input parameter `assetData`.\n    function decodeTradeAssetData(bytes memory _assetData)\n        public\n        pure\n        returns (\n            bytes4 _assetProxyId,\n            address _tokenAddress,\n            uint256[] memory _tokenIds,\n            uint256[] memory _tokenValues,\n            bytes memory _callbackData\n        )\n    {\n         // Read the bytes4 from array memory\n        assembly {\n            _assetProxyId := mload(add(_assetData, 32))\n            // Solidity does not require us to clean the trailing bytes. We do it anyway\n            _assetProxyId := and(_assetProxyId, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n\n        require(_assetProxyId == ERC1155_PROXY_ID, \"WRONG_PROXY_ID\");\n\n        assembly {\n            let _length := mload(_assetData)\n            // Skip the length (of bytes variable) and the selector to get to the first parameter.\n            _assetData := add(_assetData, 36)\n            // Read the value of the first parameter:\n            _tokenAddress := mload(_assetData)\n            _tokenIds := add(_assetData, mload(add(_assetData, 32)))\n            _tokenValues := add(_assetData, mload(add(_assetData, 64)))\n            _callbackData := add(_assetData, mload(add(_assetData, 96)))\n        }\n\n        return (\n            _assetProxyId,\n            _tokenAddress,\n            _tokenIds,\n            _tokenValues,\n            _callbackData\n        );\n    }\n\n    function parseOrderData(IExchange.Order memory _order) public view returns (AugurOrderData memory _data) {\n        (bytes4 _assetProxyId, address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _tokenValues, bytes memory _callbackData) = decodeAssetData(_order.makerAssetData);\n        (address _market, uint256 _price, uint8 _outcome, uint8 _type) = unpackTokenId(_tokenIds[0]);\n        _data.marketAddress = _market;\n        _data.price = _price;\n        _data.orderType = _type;\n        _data.outcome = _outcome;\n    }\n\n    function getZeroXTradeTokenData(bytes memory _assetData) public view returns (IERC1155 _token, uint256 _tokenId) {\n        (bytes4 _assetProxyId, address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _tokenValues, bytes memory _callbackData) = decodeAssetData(_assetData);\n        _tokenId = _tokenIds[0];\n        _token = IERC1155(_tokenAddress);\n    }\n\n    function getTokenIdFromOrder(IExchange.Order memory _order) public view returns (uint256 _tokenId) {\n        (bytes4 _assetProxyId, address _tokenAddress, uint256[] memory _tokenIds, uint256[] memory _tokenValues, bytes memory _callbackData) = decodeAssetData(_order.makerAssetData);\n        _tokenId = _tokenIds[0];\n    }\n\n    function createZeroXOrder(uint8 _type, uint256 _attoshares, uint256 _price, address _market, uint8 _outcome, uint256 _expirationTimeSeconds, uint256 _salt) public view returns (IExchange.Order memory _zeroXOrder, bytes32 _orderHash) {\n        return createZeroXOrderFor(msg.sender, _type, _attoshares, _price, _market, _outcome, _expirationTimeSeconds, _salt);\n    }\n\n    function createZeroXOrderFor(address _maker, uint8 _type, uint256 _attoshares, uint256 _price, address _market, uint8 _outcome, uint256 _expirationTimeSeconds, uint256 _salt) public view returns (IExchange.Order memory _zeroXOrder, bytes32 _orderHash) {\n        bytes memory _assetData = encodeAssetData(IMarket(_market), _price, _outcome, _type);\n        require(isOrderAmountValid(IMarket(_market), _attoshares), \"Order must be a multiple of the market trade increment\");\n        _zeroXOrder.makerAddress = _maker;\n        _zeroXOrder.makerAssetAmount = _attoshares;\n        _zeroXOrder.takerAssetAmount = _attoshares;\n        _zeroXOrder.expirationTimeSeconds = _expirationTimeSeconds;\n        _zeroXOrder.salt = _salt;\n        _zeroXOrder.makerAssetData = _assetData;\n        _zeroXOrder.takerAssetData = encodeTakerAssetData();\n        _orderHash = exchange.getOrderInfo(_zeroXOrder).orderHash;\n    }\n\n    function encodeEIP1271OrderWithHash(\n        IExchange.Order memory _zeroXOrder,\n        bytes32 _orderHash\n    )\n        public\n        pure\n        returns (bytes memory encoded)\n    {\n        return abi.encodeWithSelector(\n            EIP1271_ORDER_WITH_HASH_SELECTOR,\n            _zeroXOrder,\n            _orderHash\n        );\n    }\n\n    function () external payable {}\n}\n\n"
    }
  }
}}