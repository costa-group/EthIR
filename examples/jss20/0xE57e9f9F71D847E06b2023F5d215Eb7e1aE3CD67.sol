{"EnumerableSet.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * As of v2.5.0, only `address` sets are supported.\n *\n * Include with `using EnumerableSet for EnumerableSet.AddressSet;`.\n *\n * _Available since v2.5.0._\n *\n * @author Alberto Cuesta Ca√±ada\n */\nlibrary EnumerableSet {\n\n    struct AddressSet {\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (address =\u003e uint256) index;\n        address[] values;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     * Returns false if the value was already in the set.\n     */\n    function add(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        if (!contains(set, value)){\n            set.index[value] = set.values.push(value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     * Returns false if the value was not present in the set.\n     */\n    function remove(AddressSet storage set, address value)\n        internal\n        returns (bool)\n    {\n        if (contains(set, value)){\n            uint256 toDeleteIndex = set.index[value] - 1;\n            uint256 lastIndex = set.values.length - 1;\n\n            // If the element we\u0027re deleting is the last one, we can just remove it without doing a swap\n            if (lastIndex != toDeleteIndex) {\n                address lastValue = set.values[lastIndex];\n\n                // Move the last value to the index where the deleted value is\n                set.values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set.index[lastValue] = toDeleteIndex + 1; // All indexes are 1-based\n            }\n\n            // Delete the index entry for the deleted value\n            delete set.index[value];\n\n            // Delete the old entry for the moved value\n            set.values.pop();\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value)\n        internal\n        view\n        returns (bool)\n    {\n        return set.index[value] != 0;\n    }\n\n    /**\n     * @dev Returns an array with all values in the set. O(N).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n\n     * WARNING: This function may run out of gas on large sets: use {length} and\n     * {get} instead in these cases.\n     */\n    function enumerate(AddressSet storage set)\n        internal\n        view\n        returns (address[] memory)\n    {\n        address[] memory output = new address[](set.values.length);\n        for (uint256 i; i \u003c set.values.length; i++){\n            output[i] = set.values[i];\n        }\n        return output;\n    }\n\n    /**\n     * @dev Returns the number of elements on the set. O(1).\n     */\n    function length(AddressSet storage set)\n        internal\n        view\n        returns (uint256)\n    {\n        return set.values.length;\n    }\n\n   /** @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function get(AddressSet storage set, uint256 index)\n        internal\n        view\n        returns (address)\n    {\n        return set.values[index];\n    }\n}\n"},"Math.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"Registry.sol":{"content":"pragma solidity 0.5.12;\n\nimport \"Math.sol\";\nimport \"SafeMath.sol\";\nimport \"EnumerableSet.sol\";\n\ninterface IBPool {\n    function getDenormalizedWeight(address token) external view returns(uint256);\n    function getBalance(address token) external view returns(uint256);\n    function getSwapFee() external view returns(uint256);\n}\n\ninterface IBFactory {\n    function isBPool(address b) external view returns (bool);\n}\n\n\ncontract BRegistry {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    struct PoolPairInfo {\n        uint80 weight1;\n        uint80 weight2;\n        uint80 swapFee;\n    }\n\n    struct SortedPools {\n        EnumerableSet.AddressSet pools;\n        bytes32 indices;\n    }\n\n    event PoolTokenPairAdded(\n        address indexed pool,\n        address indexed token1,\n        address indexed token2\n    );\n\n    event IndicesUpdated(\n        address indexed token1,\n        address indexed token2,\n        bytes32 oldIndices,\n        bytes32 newIndices\n    );\n\n    uint private constant BONE = 10**18;\n    uint private constant MIN_SWAP_FEE = (3 * BONE) / 100;\n\n    mapping(bytes32 =\u003e SortedPools) private _pools;\n    mapping(address =\u003e mapping(bytes32 =\u003e PoolPairInfo)) private _infos;\n\n    IBFactory bfactory;\n\n    constructor(address _bfactory) public {\n        bfactory = IBFactory(_bfactory);\n    }\n\n    function getPairInfo(address pool, address fromToken, address destToken)\n        external view returns(uint256 weight1, uint256 weight2, uint256 swapFee)\n    {\n        bytes32 key = _createKey(fromToken, destToken);\n        PoolPairInfo memory info = _infos[pool][key];\n        return (info.weight1, info.weight2, info.swapFee);\n    }\n\n    function getPoolsWithLimit(address fromToken, address destToken, uint256 offset, uint256 limit)\n        public view returns(address[] memory result)\n    {\n        bytes32 key = _createKey(fromToken, destToken);\n        result = new address[](Math.min(limit, _pools[key].pools.values.length - offset));\n        for (uint i = 0; i \u003c result.length; i++) {\n            result[i] = _pools[key].pools.values[offset + i];\n        }\n    }\n\n    function getBestPools(address fromToken, address destToken)\n        external view returns(address[] memory pools)\n    {\n        return getBestPoolsWithLimit(fromToken, destToken, 32);\n    }\n\n    function getBestPoolsWithLimit(address fromToken, address destToken, uint256 limit)\n        public view returns(address[] memory pools)\n    {\n        bytes32 key = _createKey(fromToken, destToken);\n        bytes32 indices = _pools[key].indices;\n        uint256 len = 0;\n        while (indices[len] \u003e 0 \u0026\u0026 len \u003c Math.min(limit, indices.length)) {\n            len++;\n        }\n\n        pools = new address[](len);\n        for (uint i = 0; i \u003c len; i++) {\n            uint256 index = uint256(uint8(indices[i])).sub(1);\n            pools[i] = _pools[key].pools.values[index];\n        }\n    }\n\n    // Add and update registry\n\n    function addPoolPair(address pool, address token1, address token2) public returns(uint256 listed) {\n\n        require(bfactory.isBPool(pool), \"ERR_NOT_BPOOL\");\n\n        uint256 swapFee = IBPool(pool).getSwapFee();\n        require(swapFee \u003c= MIN_SWAP_FEE, \"ERR_FEE_TOO_HIGH\");\n\n        bytes32 key = _createKey(token1, token2);\n        _pools[key].pools.add(pool);\n\n         if (token1 \u003c token2) {\n            _infos[pool][key] = PoolPairInfo({\n                weight1: uint80(IBPool(pool).getDenormalizedWeight(token1)),\n                weight2: uint80(IBPool(pool).getDenormalizedWeight(token2)),\n                swapFee: uint80(swapFee)\n            });\n        } else {\n            _infos[pool][key] = PoolPairInfo({\n                weight1: uint80(IBPool(pool).getDenormalizedWeight(token2)),\n                weight2: uint80(IBPool(pool).getDenormalizedWeight(token1)),\n                swapFee: uint80(swapFee)\n            });\n        }\n\n        emit PoolTokenPairAdded(\n            pool,\n            token1,\n            token2\n        );\n\n        listed++;\n\n    }\n\n    function addPools(address[] calldata pools, address token1, address token2) external returns(uint256[] memory listed) {\n        listed = new uint256[](pools.length);\n        for (uint i = 0; i \u003c pools.length; i++) {\n            listed[i] = addPoolPair(pools[i], token1, token2);\n        }\n    }\n\n    function sortPools(address[] calldata tokens, uint256 lengthLimit) external {\n        for (uint i = 0; i \u003c tokens.length; i++) {\n            for (uint j = i + 1; j \u003c tokens.length; j++) {\n                bytes32 key = _createKey(tokens[i], tokens[j]);\n                address[] memory pools = getPoolsWithLimit(tokens[i], tokens[j], 0, Math.min(256, lengthLimit));\n                uint256[] memory effectiveLiquidity = _getEffectiveLiquidityForPools(tokens[i], tokens[j], pools);\n\n                bytes32 indices = _buildSortIndices(effectiveLiquidity);\n\n                // console.logBytes32(indices);\n\n                if (indices != _pools[key].indices) {\n                    emit IndicesUpdated(\n                        tokens[i] \u003c tokens[j] ? tokens[i] : tokens[j],\n                        tokens[i] \u003c tokens[j] ? tokens[j] : tokens[i],\n                        _pools[key].indices,\n                        indices\n                    );\n                    _pools[key].indices = indices;\n                }\n            }\n        }\n    }\n\n    // Internal\n\n    function _createKey(address token1, address token2)\n        internal pure returns(bytes32)\n    {\n        return bytes32(\n            (uint256(uint128((token1 \u003c token2) ? token1 : token2)) \u003c\u003c 128) |\n            (uint256(uint128((token1 \u003c token2) ? token2 : token1)))\n        );\n    }\n\n    function _getEffectiveLiquidityForPools(address token1, address token2, address[] memory pools)\n        internal view returns(uint256[] memory effectiveLiquidity)\n    {\n        effectiveLiquidity = new uint256[](pools.length);\n        for (uint i = 0; i \u003c pools.length; i++) {\n            bytes32 key = _createKey(token1, token2);\n            PoolPairInfo memory info = _infos[pools[i]][key];\n            if (token1 \u003c token2) {\n                // we define effective liquidity as b2 * w1 / (w1 + w2)\n                effectiveLiquidity[i] = bdiv(uint256(info.weight1),uint256(info.weight1).add(uint256(info.weight2)));\n                effectiveLiquidity[i] = effectiveLiquidity[i].mul(IBPool(pools[i]).getBalance(token2));\n            } else {\n                effectiveLiquidity[i] = bdiv(uint256(info.weight2),uint256(info.weight1).add(uint256(info.weight2)));\n                effectiveLiquidity[i] = effectiveLiquidity[i].mul(IBPool(pools[i]).getBalance(token1));\n            }\n        }\n    }\n\n    function bdiv(uint a, uint b)\n        internal pure\n        returns (uint)\n    {\n        require(b != 0, \"ERR_DIV_ZERO\");\n        uint c0 = a * BONE;\n        require(a == 0 || c0 / a == BONE, \"ERR_DIV_INTERNAL\"); // bdiv overflow\n        uint c1 = c0 + (b / 2);\n        require(c1 \u003e= c0, \"ERR_DIV_INTERNAL\"); //  badd require\n        uint c2 = c1 / b;\n        return c2;\n    }\n\n    function _buildSortIndices(uint256[] memory effectiveLiquidity)\n        internal pure returns(bytes32)\n    {\n        uint256 result = 0;\n        uint256 prevEffectiveLiquidity = uint256(-1);\n        for (uint i = 0; i \u003c Math.min(effectiveLiquidity.length, 32); i++) {\n            uint256 bestIndex = 0;\n            for (uint j = 0; j \u003c effectiveLiquidity.length; j++) {\n                if ((effectiveLiquidity[j] \u003e effectiveLiquidity[bestIndex] \u0026\u0026 effectiveLiquidity[j] \u003c prevEffectiveLiquidity) || effectiveLiquidity[bestIndex] \u003e= prevEffectiveLiquidity) {\n                    bestIndex = j;\n                }\n            }\n            prevEffectiveLiquidity = effectiveLiquidity[bestIndex];\n            result |= (bestIndex + 1) \u003c\u003c (248 - i * 8);\n        }\n        return bytes32(result);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}