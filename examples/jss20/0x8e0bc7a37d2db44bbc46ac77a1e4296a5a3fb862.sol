{"provableAPI_0.5.sol":{"content":"// \u003cprovableAPI\u003e\r\n/*\r\n\r\n\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016-2019 Oraclize LTD\r\nCopyright (c) 2019 Provable Things Limited\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\n*/\r\npragma solidity \u003e= 0.5.0 \u003c 0.6.0; // Incompatible compiler version - please select a compiler within the stated pragma range, or use a different version of the provableAPI!\r\n\r\n// Dummy contract only used to emit to end-user they are using wrong solc\r\ncontract solcChecker {\r\n/* INCOMPATIBLE SOLC: import the following instead: \"github.com/oraclize/ethereum-api/oraclizeAPI_0.4.sol\" */ function f(bytes calldata x) external;\r\n}\r\n\r\ncontract ProvableI {\r\n\r\n    address public cbAddress;\r\n\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function getPrice(string memory _datasource) public returns (uint _dsprice);\r\n    function randomDS_getSessionPubKeyHash() external view returns (bytes32 _sessionKeyHash);\r\n    function getPrice(string memory _datasource, uint _gasLimit) public returns (uint _dsprice);\r\n    function queryN(uint _timestamp, string memory _datasource, bytes memory _argN) public payable returns (bytes32 _id);\r\n    function query(uint _timestamp, string calldata _datasource, string calldata _arg) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) public payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string calldata _datasource, bytes calldata _argN, uint _gasLimit) external payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string calldata _datasource, string calldata _arg1, string calldata _arg2, uint _gasLimit) external payable returns (bytes32 _id);\r\n}\r\n\r\ncontract OracleAddrResolverI {\r\n    function getAddress() public returns (address _address);\r\n}\r\n/*\r\n\r\nBegin solidity-cborutils\r\n\r\nhttps://github.com/smartcontractkit/solidity-cborutils\r\n\r\nMIT License\r\n\r\nCopyright (c) 2018 SmartContract ChainLink, Ltd.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n\r\n*/\r\nlibrary Buffer {\r\n\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    function init(buffer memory _buf, uint _capacity) internal pure {\r\n        uint capacity = _capacity;\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        _buf.capacity = capacity; // Allocate space for the buffer data\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(_buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n    }\r\n\r\n    function resize(buffer memory _buf, uint _capacity) private pure {\r\n        bytes memory oldbuf = _buf.buf;\r\n        init(_buf, _capacity);\r\n        append(_buf, oldbuf);\r\n    }\r\n\r\n    function max(uint _a, uint _b) private pure returns (uint _max) {\r\n        if (_a \u003e _b) {\r\n            return _a;\r\n        }\r\n        return _b;\r\n    }\r\n    /**\r\n      * @dev Appends a byte array to the end of the buffer. Resizes if doing so\r\n      *      would exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, bytes memory _data) internal pure returns (buffer memory _buffer) {\r\n        if (_data.length + _buf.buf.length \u003e _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _data.length) * 2);\r\n        }\r\n        uint dest;\r\n        uint src;\r\n        uint len = _data.length;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            dest := add(add(bufptr, buflen), 32) // Start address = buffer address + buffer length + sizeof(buffer length)\r\n            mstore(bufptr, add(buflen, mload(_data))) // Update buffer length\r\n            src := add(_data, 32)\r\n        }\r\n        for(; len \u003e= 32; len -= 32) { // Copy word-length chunks while possible\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n        uint mask = 256 ** (32 - len) - 1; // Copy remaining bytes\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n        return _buf;\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function append(buffer memory _buf, uint8 _data) internal pure {\r\n        if (_buf.buf.length + 1 \u003e _buf.capacity) {\r\n            resize(_buf, _buf.capacity * 2);\r\n        }\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), 32) // Address = buffer address + buffer length + sizeof(buffer length)\r\n            mstore8(dest, _data)\r\n            mstore(bufptr, add(buflen, 1)) // Update buffer length\r\n        }\r\n    }\r\n    /**\r\n      *\r\n      * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n      * exceed the capacity of the buffer.\r\n      * @param _buf The buffer to append to.\r\n      * @param _data The data to append.\r\n      * @return The original buffer.\r\n      *\r\n      */\r\n    function appendInt(buffer memory _buf, uint _data, uint _len) internal pure returns (buffer memory _buffer) {\r\n        if (_len + _buf.buf.length \u003e _buf.capacity) {\r\n            resize(_buf, max(_buf.capacity, _len) * 2);\r\n        }\r\n        uint mask = 256 ** _len - 1;\r\n        assembly {\r\n            let bufptr := mload(_buf) // Memory address of the buffer data\r\n            let buflen := mload(bufptr) // Length of existing buffer data\r\n            let dest := add(add(bufptr, buflen), _len) // Address = buffer address + buffer length + sizeof(buffer length) + len\r\n            mstore(dest, or(and(mload(dest), not(mask)), _data))\r\n            mstore(bufptr, add(buflen, _len)) // Update buffer length\r\n        }\r\n        return _buf;\r\n    }\r\n}\r\n\r\nlibrary CBOR {\r\n\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function encodeType(Buffer.buffer memory _buf, uint8 _major, uint _value) private pure {\r\n        if (_value \u003c= 23) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | _value));\r\n        } else if (_value \u003c= 0xFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 24));\r\n            _buf.appendInt(_value, 1);\r\n        } else if (_value \u003c= 0xFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 25));\r\n            _buf.appendInt(_value, 2);\r\n        } else if (_value \u003c= 0xFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 26));\r\n            _buf.appendInt(_value, 4);\r\n        } else if (_value \u003c= 0xFFFFFFFFFFFFFFFF) {\r\n            _buf.append(uint8((_major \u003c\u003c 5) | 27));\r\n            _buf.appendInt(_value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory _buf, uint8 _major) private pure {\r\n        _buf.append(uint8((_major \u003c\u003c 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory _buf, uint _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_INT, _value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory _buf, int _value) internal pure {\r\n        if (_value \u003e= 0) {\r\n            encodeType(_buf, MAJOR_TYPE_INT, uint(_value));\r\n        } else {\r\n            encodeType(_buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - _value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory _buf, bytes memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_BYTES, _value.length);\r\n        _buf.append(_value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory _buf, string memory _value) internal pure {\r\n        encodeType(_buf, MAJOR_TYPE_STRING, bytes(_value).length);\r\n        _buf.append(bytes(_value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory _buf) internal pure {\r\n        encodeIndefiniteLengthType(_buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n/*\r\n\r\nEnd solidity-cborutils\r\n\r\n*/\r\ncontract usingProvable {\r\n\r\n    using CBOR for Buffer.buffer;\r\n\r\n    ProvableI provable;\r\n    OracleAddrResolverI OAR;\r\n\r\n    uint constant day = 60 * 60 * 24;\r\n    uint constant week = 60 * 60 * 24 * 7;\r\n    uint constant month = 60 * 60 * 24 * 30;\r\n\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    byte constant proofType_Android = 0x40;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n\r\n    string provable_network_name;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    mapping(bytes32 =\u003e bytes32) provable_randomDS_args;\r\n    mapping(bytes32 =\u003e bool) provable_randomDS_sessionKeysHashVerified;\r\n\r\n    modifier provableAPI {\r\n        if ((address(OAR) == address(0)) || (getCodeSize(address(OAR)) == 0)) {\r\n            provable_setNetwork(networkID_auto);\r\n        }\r\n        if (address(provable) != OAR.getAddress()) {\r\n            provable = ProvableI(OAR.getAddress());\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier provable_randomDS_proofVerify(bytes32 _queryId, string memory _result, bytes memory _proof) {\r\n        // RandomDS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        require((_proof[0] == \"L\") \u0026\u0026 (_proof[1] == \"P\") \u0026\u0026 (uint8(_proof[2]) == uint8(1)));\r\n        bool proofVerified = provable_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), provable_getNetworkName());\r\n        require(proofVerified);\r\n        _;\r\n    }\r\n\r\n    function provable_setNetwork(uint8 _networkID) internal returns (bool _networkSet) {\r\n      _networkID; // NOTE: Silence the warning and remain backwards compatible\r\n      return provable_setNetwork();\r\n    }\r\n\r\n    function provable_setNetworkName(string memory _network_name) internal {\r\n        provable_network_name = _network_name;\r\n    }\r\n\r\n    function provable_getNetworkName() internal view returns (string memory _networkName) {\r\n        return provable_network_name;\r\n    }\r\n\r\n    function provable_setNetwork() internal returns (bool _networkSet) {\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) \u003e 0) { //mainnet\r\n            OAR = OracleAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            provable_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) \u003e 0) { //ropsten testnet\r\n            OAR = OracleAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            provable_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) \u003e 0) { //kovan testnet\r\n            OAR = OracleAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            provable_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) \u003e 0) { //rinkeby testnet\r\n            OAR = OracleAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            provable_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41) \u003e 0) { //goerli testnet\r\n            OAR = OracleAddrResolverI(0xa2998EFD205FB9D4B4963aFb70778D6354ad3A41);\r\n            provable_setNetworkName(\"eth_goerli\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) \u003e 0) { //ethereum-bridge\r\n            OAR = OracleAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) \u003e 0) { //ether.camp ide\r\n            OAR = OracleAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) \u003e 0) { //browser-solidity\r\n            OAR = OracleAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * @dev The following `__callback` functions are just placeholders ideally\r\n     *      meant to be defined in child contract when proofs are used.\r\n     *      The function bodies simply silence compiler warnings.\r\n     */\r\n    function __callback(bytes32 _myid, string memory _result) public {\r\n        __callback(_myid, _result, new bytes(0));\r\n    }\r\n\r\n    function __callback(bytes32 _myid, string memory _result, bytes memory _proof) public {\r\n      _myid; _result; _proof;\r\n      provable_randomDS_args[bytes32(0)] = bytes32(0);\r\n    }\r\n\r\n    function provable_getPrice(string memory _datasource) provableAPI internal returns (uint _queryPrice) {\r\n        return provable.getPrice(_datasource);\r\n    }\r\n\r\n    function provable_getPrice(string memory _datasource, uint _gasLimit) provableAPI internal returns (uint _queryPrice) {\r\n        return provable.getPrice(_datasource, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query.value(price)(0, _datasource, _arg);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query.value(price)(_timestamp, _datasource, _arg);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource,_gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query_withGasLimit.value(price)(_timestamp, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n           return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query_withGasLimit.value(price)(0, _datasource, _arg, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg1, string memory _arg2) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2.value(price)(0, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2.value(price)(_timestamp, _datasource, _arg1, _arg2);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2_withGasLimit.value(price)(_timestamp, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string memory _arg1, string memory _arg2, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        return provable.query2_withGasLimit.value(price)(0, _datasource, _arg1, _arg2, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN.value(price)(0, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN.value(price)(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = stra2cbor(_argN);\r\n        return provable.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, string[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, string[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN.value(price)(0, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[] memory _argN) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource);\r\n        if (price \u003e 1 ether + tx.gasprice * 200000) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN.value(price)(_timestamp, _datasource, args);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN_withGasLimit.value(price)(_timestamp, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[] memory _argN, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        uint price = provable.getPrice(_datasource, _gasLimit);\r\n        if (price \u003e 1 ether + tx.gasprice * _gasLimit) {\r\n            return 0; // Unexpectedly high price\r\n        }\r\n        bytes memory args = ba2cbor(_argN);\r\n        return provable.queryN_withGasLimit.value(price)(0, _datasource, args, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[1] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[1] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = _args[0];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[2] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[2] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[3] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[3] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[4] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[4] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[5] memory _args) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs);\r\n    }\r\n\r\n    function provable_query(uint _timestamp, string memory _datasource, bytes[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_timestamp, _datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_query(string memory _datasource, bytes[5] memory _args, uint _gasLimit) provableAPI internal returns (bytes32 _id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = _args[0];\r\n        dynargs[1] = _args[1];\r\n        dynargs[2] = _args[2];\r\n        dynargs[3] = _args[3];\r\n        dynargs[4] = _args[4];\r\n        return provable_query(_datasource, dynargs, _gasLimit);\r\n    }\r\n\r\n    function provable_setProof(byte _proofP) provableAPI internal {\r\n        return provable.setProofType(_proofP);\r\n    }\r\n\r\n\r\n    function provable_cbAddress() provableAPI internal returns (address _callbackAddress) {\r\n        return provable.cbAddress();\r\n    }\r\n\r\n    function getCodeSize(address _addr) view internal returns (uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function provable_setCustomGasPrice(uint _gasPrice) provableAPI internal {\r\n        return provable.setCustomGasPrice(_gasPrice);\r\n    }\r\n\r\n    function provable_randomDS_getSessionPubKeyHash() provableAPI internal returns (bytes32 _sessionKeyHash) {\r\n        return provable.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i = 2; i \u003c 2 + 2 * 20; i += 2) {\r\n            iaddr *= 256;\r\n            b1 = uint160(uint8(tmp[i]));\r\n            b2 = uint160(uint8(tmp[i + 1]));\r\n            if ((b1 \u003e= 97) \u0026\u0026 (b1 \u003c= 102)) {\r\n                b1 -= 87;\r\n            } else if ((b1 \u003e= 65) \u0026\u0026 (b1 \u003c= 70)) {\r\n                b1 -= 55;\r\n            } else if ((b1 \u003e= 48) \u0026\u0026 (b1 \u003c= 57)) {\r\n                b1 -= 48;\r\n            }\r\n            if ((b2 \u003e= 97) \u0026\u0026 (b2 \u003c= 102)) {\r\n                b2 -= 87;\r\n            } else if ((b2 \u003e= 65) \u0026\u0026 (b2 \u003c= 70)) {\r\n                b2 -= 55;\r\n            } else if ((b2 \u003e= 48) \u0026\u0026 (b2 \u003c= 57)) {\r\n                b2 -= 48;\r\n            }\r\n            iaddr += (b1 * 16 + b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string memory _a, string memory _b) internal pure returns (int _returnCode) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length \u003c minLength) {\r\n            minLength = b.length;\r\n        }\r\n        for (uint i = 0; i \u003c minLength; i ++) {\r\n            if (a[i] \u003c b[i]) {\r\n                return -1;\r\n            } else if (a[i] \u003e b[i]) {\r\n                return 1;\r\n            }\r\n        }\r\n        if (a.length \u003c b.length) {\r\n            return -1;\r\n        } else if (a.length \u003e b.length) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function indexOf(string memory _haystack, string memory _needle) internal pure returns (int _returnCode) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if (h.length \u003c 1 || n.length \u003c 1 || (n.length \u003e h.length)) {\r\n            return -1;\r\n        } else if (h.length \u003e (2 ** 128 - 1)) {\r\n            return -1;\r\n        } else {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i \u003c h.length; i++) {\r\n                if (h[i] == n[0]) {\r\n                    subindex = 1;\r\n                    while(subindex \u003c n.length \u0026\u0026 (i + subindex) \u003c h.length \u0026\u0026 h[i + subindex] == n[subindex]) {\r\n                        subindex++;\r\n                    }\r\n                    if (subindex == n.length) {\r\n                        return int(i);\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory _concatenatedString) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory _concatenatedString) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        uint i = 0;\r\n        for (i = 0; i \u003c _ba.length; i++) {\r\n            babcde[k++] = _ba[i];\r\n        }\r\n        for (i = 0; i \u003c _bb.length; i++) {\r\n            babcde[k++] = _bb[i];\r\n        }\r\n        for (i = 0; i \u003c _bc.length; i++) {\r\n            babcde[k++] = _bc[i];\r\n        }\r\n        for (i = 0; i \u003c _bd.length; i++) {\r\n            babcde[k++] = _bd[i];\r\n        }\r\n        for (i = 0; i \u003c _be.length; i++) {\r\n            babcde[k++] = _be[i];\r\n        }\r\n        return string(babcde);\r\n    }\r\n\r\n    function safeParseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return safeParseInt(_a, 0);\r\n    }\r\n\r\n    function safeParseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003c bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) \u003e= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003c= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                require(!decimals, \u0027More than one decimal encountered in string!\u0027);\r\n                decimals = true;\r\n            } else {\r\n                revert(\"Non-numeral character encountered in string!\");\r\n            }\r\n        }\r\n        if (_b \u003e 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function parseInt(string memory _a) internal pure returns (uint _parsedInt) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    function parseInt(string memory _a, uint _b) internal pure returns (uint _parsedInt) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i = 0; i \u003c bresult.length; i++) {\r\n            if ((uint(uint8(bresult[i])) \u003e= 48) \u0026\u0026 (uint(uint8(bresult[i])) \u003c= 57)) {\r\n                if (decimals) {\r\n                   if (_b == 0) {\r\n                       break;\r\n                   } else {\r\n                       _b--;\r\n                   }\r\n                }\r\n                mint *= 10;\r\n                mint += uint(uint8(bresult[i])) - 48;\r\n            } else if (uint(uint8(bresult[i])) == 46) {\r\n                decimals = true;\r\n            }\r\n        }\r\n        if (_b \u003e 0) {\r\n            mint *= 10 ** _b;\r\n        }\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (_i != 0) {\r\n            bstr[k--] = byte(uint8(48 + _i % 10));\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003c _arr.length; i++) {\r\n            buf.encodeString(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function ba2cbor(bytes[] memory _arr) internal pure returns (bytes memory _cborEncoding) {\r\n        safeMemoryCleaner();\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i \u003c _arr.length; i++) {\r\n            buf.encodeBytes(_arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function provable_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32 _queryId) {\r\n        require((_nbytes \u003e 0) \u0026\u0026 (_nbytes \u003c= 32));\r\n        _delay *= 10; // Convert from seconds to ledger timer ticks\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(uint8(_nbytes));\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = provable_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            /*\r\n             The following variables can be relaxed.\r\n             Check the relaxed random contract at https://github.com/oraclize/ethereum-examples\r\n             for an idea on how to override and replace commit hash variables.\r\n            */\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = provable_query(\"random\", args, _customGasLimit);\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n        }\r\n        provable_randomDS_setCommitment(queryId, keccak256(abi.encodePacked(delay_bytes8_left, args[1], sha256(args[0]), args[2])));\r\n        return queryId;\r\n    }\r\n\r\n    function provable_randomDS_setCommitment(bytes32 _queryId, bytes32 _commitment) internal {\r\n        provable_randomDS_args[_queryId] = _commitment;\r\n    }\r\n\r\n    function verifySig(bytes32 _tosignh, bytes memory _dersig, bytes memory _pubkey) internal returns (bool _sigVerified) {\r\n        bool sigok;\r\n        address signer;\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4 + (uint(uint8(_dersig[3])) - 0x20);\r\n        sigr_ = copyBytes(_dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(_dersig, offset + (uint(uint8(_dersig[offset - 1])) - 0x20), 32, sigs_, 0);\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n        (sigok, signer) = safer_ecrecover(_tosignh, 27, sigr, sigs);\r\n        if (address(uint160(uint256(keccak256(_pubkey)))) == signer) {\r\n            return true;\r\n        } else {\r\n            (sigok, signer) = safer_ecrecover(_tosignh, 28, sigr, sigs);\r\n            return (address(uint160(uint256(keccak256(_pubkey)))) == signer);\r\n        }\r\n    }\r\n\r\n    function provable_randomDS_proofVerify__sessionKeyValidity(bytes memory _proof, uint _sig2offset) internal returns (bool _proofVerified) {\r\n        bool sigok;\r\n        // Random DS Proof Step 6: Verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(uint8(_proof[_sig2offset + 1])) + 2);\r\n        copyBytes(_proof, _sig2offset, sig2.length, sig2, 0);\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(_proof, 3 + 1, 64, appkey1_pubkey, 0);\r\n        bytes memory tosign2 = new bytes(1 + 65 + 32);\r\n        tosign2[0] = byte(uint8(1)); //role\r\n        copyBytes(_proof, _sig2offset - 65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1 + 65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n        if (!sigok) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 7: Verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n        bytes memory tosign3 = new bytes(1 + 65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(_proof, 3, 65, tosign3, 1);\r\n        bytes memory sig3 = new bytes(uint(uint8(_proof[3 + 65 + 1])) + 2);\r\n        copyBytes(_proof, 3 + 65, sig3.length, sig3, 0);\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n        return sigok;\r\n    }\r\n\r\n    function provable_randomDS_proofVerify__returnCode(bytes32 _queryId, string memory _result, bytes memory _proof) internal returns (uint8 _returnCode) {\r\n        // Random DS Proof Step 1: The prefix has to match \u0027LP\\x01\u0027 (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\") || (_proof[1] != \"P\") || (uint8(_proof[2]) != uint8(1))) {\r\n            return 1;\r\n        }\r\n        bool proofVerified = provable_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), provable_getNetworkName());\r\n        if (!proofVerified) {\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 _content, bytes memory _prefix, uint _nRandomBytes) internal pure returns (bool _matchesPrefix) {\r\n        bool match_ = true;\r\n        require(_prefix.length == _nRandomBytes);\r\n        for (uint256 i = 0; i\u003c _nRandomBytes; i++) {\r\n            if (_content[i] != _prefix[i]) {\r\n                match_ = false;\r\n            }\r\n        }\r\n        return match_;\r\n    }\r\n\r\n    function provable_randomDS_proofVerify__main(bytes memory _proof, bytes32 _queryId, bytes memory _result, string memory _contextName) internal returns (bool _proofVerified) {\r\n        // Random DS Proof Step 2: The unique keyhash has to match with the sha256 of (context name + _queryId)\r\n        uint ledgerProofLength = 3 + 65 + (uint(uint8(_proof[3 + 65 + 1])) + 2) + 32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(_proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(keccak256(keyhash) == keccak256(abi.encodePacked(sha256(abi.encodePacked(_contextName, _queryId)))))) {\r\n            return false;\r\n        }\r\n        bytes memory sig1 = new bytes(uint(uint8(_proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1])) + 2);\r\n        copyBytes(_proof, ledgerProofLength + (32 + 8 + 1 + 32), sig1.length, sig1, 0);\r\n        // Random DS Proof Step 3: We assume sig1 is valid (it will be verified during step 5) and we verify if \u0027_result\u0027 is the _prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), _result, uint(uint8(_proof[ledgerProofLength + 32 + 8])))) {\r\n            return false;\r\n        }\r\n        // Random DS Proof Step 4: Commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8 + 1 + 32);\r\n        copyBytes(_proof, ledgerProofLength + 32, 8 + 1 + 32, commitmentSlice1, 0);\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65;\r\n        copyBytes(_proof, sig2offset - 64, 64, sessionPubkey, 0);\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (provable_randomDS_args[_queryId] == keccak256(abi.encodePacked(commitmentSlice1, sessionPubkeyHash))) { //unonce, nbytes and sessionKeyHash match\r\n            delete provable_randomDS_args[_queryId];\r\n        } else return false;\r\n        // Random DS Proof Step 5: Validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32 + 8 + 1 + 32);\r\n        copyBytes(_proof, ledgerProofLength, 32 + 8 + 1 + 32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) {\r\n            return false;\r\n        }\r\n        // Verify if sessionPubkeyHash was verified already, if not.. let\u0027s do it!\r\n        if (!provable_randomDS_sessionKeysHashVerified[sessionPubkeyHash]) {\r\n            provable_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = provable_randomDS_proofVerify__sessionKeyValidity(_proof, sig2offset);\r\n        }\r\n        return provable_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    */\r\n    function copyBytes(bytes memory _from, uint _fromOffset, uint _length, bytes memory _to, uint _toOffset) internal pure returns (bytes memory _copiedBytes) {\r\n        uint minLength = _length + _toOffset;\r\n        require(_to.length \u003e= minLength); // Buffer too small. Should be a better way?\r\n        uint i = 32 + _fromOffset; // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint j = 32 + _toOffset;\r\n        while (i \u003c (32 + _fromOffset + _length)) {\r\n            assembly {\r\n                let tmp := mload(add(_from, i))\r\n                mstore(add(_to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n        return _to;\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n     Duplicate Solidity\u0027s ecrecover, but catching the CALL return value\r\n    */\r\n    function safer_ecrecover(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool _success, address _recoveredAddress) {\r\n        /*\r\n         We do our own memory management here. Solidity uses memory offset\r\n         0x40 to store the current end of memory. We write past it (as\r\n         writes are memory extensions), but don\u0027t update the offset so\r\n         Solidity will reuse it. The memory used here is only needed for\r\n         this context.\r\n         FIXME: inline assembly can\u0027t access return values\r\n        */\r\n        bool ret;\r\n        address addr;\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, _hash)\r\n            mstore(add(size, 32), _v)\r\n            mstore(add(size, 64), _r)\r\n            mstore(add(size, 96), _s)\r\n            ret := call(3000, 1, 0, size, 128, size, 32) // NOTE: we can reuse the request memory because we deal with the return code.\r\n            addr := mload(size)\r\n        }\r\n        return (ret, addr);\r\n    }\r\n    /*\r\n     The following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    */\r\n    function ecrecovery(bytes32 _hash, bytes memory _sig) internal returns (bool _success, address _recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (_sig.length != 65) {\r\n            return (false, address(0));\r\n        }\r\n        /*\r\n         The signature format is a compact form of:\r\n           {bytes32 r}{bytes32 s}{uint8 v}\r\n         Compact means, uint8 is not padded to 32 bytes.\r\n        */\r\n        assembly {\r\n            r := mload(add(_sig, 32))\r\n            s := mload(add(_sig, 64))\r\n            /*\r\n             Here we are loading the last 32 bytes. We exploit the fact that\r\n             \u0027mload\u0027 will pad with zeroes if we overread.\r\n             There is no \u0027mload8\u0027 to do this, but that would be nicer.\r\n            */\r\n            v := byte(0, mload(add(_sig, 96)))\r\n            /*\r\n              Alternative solution:\r\n              \u0027byte\u0027 is not working due to the Solidity parser, so lets\r\n              use the second best option, \u0027and\u0027\r\n              v := and(mload(add(_sig, 65)), 255)\r\n            */\r\n        }\r\n        /*\r\n         albeit non-transactional signatures are not specified by the YP, one would expect it\r\n         to match the YP range of [27, 28]\r\n         geth uses [0, 1] and some clients have followed. This might change, see:\r\n         https://github.com/ethereum/go-ethereum/issues/2053\r\n        */\r\n        if (v \u003c 27) {\r\n            v += 27;\r\n        }\r\n        if (v != 27 \u0026\u0026 v != 28) {\r\n            return (false, address(0));\r\n        }\r\n        return safer_ecrecover(_hash, v, r, s);\r\n    }\r\n\r\n    function safeMemoryCleaner() internal pure {\r\n        assembly {\r\n            let fmem := mload(0x40)\r\n            codecopy(fmem, codesize, sub(msize, fmem))\r\n        }\r\n    }\r\n}\r\n// \u003c/provableAPI\u003e\r\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SquareQueue_one_dice.sol":{"content":"// \u003cSquareQueue\u003e\n\n/*\nMIT License\n\nCopyright (c) 2020 SquareQueue\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\npragma solidity ^0.5.16;\n\n/**\n * @title one of the contracts in the Square Queue - One-dice ver pre-release 0.1. Continuous updates will be developed. Updating to a new version does not delete the legacy contract.\n *\n * @notice Please read the white paper. The comments and CODE of this smart contract are written in plain language and easy CODE for those who are not familiar with programming languages.\n * @author SquareQueue - SquareQueue@gmail.com https://github.com/squarequeue\n *\n * @notice Players can join the game either by using the SquareQueue webpage or by generating transactions directly SquareQueue smart-contract inner function.\n * @dev Join the game with the \u0027playSubmit\u0027 function and receive the result of the game with the __callback function. These two functions have separate tx / block.number but this.smartContract controls everything automatically.\n * SquareQueue is an impartial space that takes advantage of https://provable.xyz/ (Oraclize)\u0027s a random data source to provide end-users with untampered entropy.\n */\n\nimport \"SafeMath.sol\";\nimport \"provableAPI_0.5.sol\";\n\ncontract SquareQueue is usingProvable {\n    using SafeMath for uint;\n    uint public playerCount;\n    uint public callbackCount;\n    uint public minEntryGas;\n    uint public minEntryGasCallBack;\n    \n    constructor () public {\n        provable_setProof(proofType_Ledger); // The proof type of the (RNG) random number generator is ledger\n        owner = msg.sender;\n        ECDSASigner = 0xbFd38732F3bD7Cd3e761ce578386d7E3B091ad24; // ECDSA (ecRecover) will be assigned to the new address.\n        minEntryGas = 500000;\n        maximumProfit = 5000000000000000000;\n        provablelimitBlock = 15;\n        provablelimitTime = 5 minutes;\n        checkedTime = now;\n        preJamCount = 0;\n    }\n    /**\n     * @notice struct Play is used as a database for each game.\n     * @param amount - Amount of Ethereum sent by a player to a game.\n     * @param modulo - The type of game the player participated in is assigned.\n     * @param rollUnder - The variable that will be used in the inverse proportion for the winning rate and prize Ether.\n     * @param playBlockNumber - Stores the block number of a game in which the player participates, and is the baseline start block for automatic refunds if the processing is delayed due to unexpected EVM or Ethereum network or Provable(Oraclize) callback issues.\n     * @param resultBlockNumber - The block number from which the result of the game is derived.\n     * @param mask - It assigns a number or a combination of numbers chosen by the player and will be used to determine the game win or loss using random numbers and Bitwise operations. Details are described in the function contractDetermineExecute inside this contract.\n     * @param possibleWinAmount - It is used to lock the contract\u0027s funds by pre-calculating ether that the player can obtain.\n     * @param trophyIncreaseFee - Deducted by \u0027trophyFee\u0027% of the player\u0027s game amount, and add to the trophy weight.\n     * @param playCount - Represents the sequence number of the game.\n     * @param player - Assign the player address(msg_sender).\n     */\n    struct Play {\n        uint amount;\n        uint modulo;\n        uint rollUnder;\n        uint playBlockNumber;\n        uint resultBlockNumber;\n        uint mask;\n        uint possibleWinAmount;\n        uint trophyIncreaseFee;\n        uint playCount;\n        uint Tpayment;\n        uint Payment;\n        address payable player;\n    }\n\n    /**\n     * @notice a struct that calls a function that guarantees an automatic refund when the player\u0027s game state is deadlocked.\n     * @notice function __callback, function checkNcleanJam - check if the callback arrived too late, and did not arrive completely, and failed the Random proof Verify test.\n     * @param play_number - Game Counting. Same as struct Play @ playCount.\n     * @param play_amount - True if the result of the game is derived; false if no result is obtained.\n     * @param play_queryId - Individual gameplay unique identifier and a query id for callBack.\n     */\n    struct CheckJam {\n        uint play_number;\n        bool play_amount;\n        bytes32 play_queryId;\n    }\n    \n    mapping (uint =\u003e Play) public playTable;\n    mapping (uint =\u003e CheckJam) public checkJamDB;\n\n    modifier onlyOwner {\n        require (msg.sender == owner, \"This function can only create Tx by the owner of the contract.\");\n        _;\n    }\n\n    event submitGameParams(uint playCount, uint eventCode, address indexed player, uint playMask, uint playModulo, uint rollUnder, bytes32 indexed queryId);\n\n    uint public minimumParticipateAmount = 0.1 ether; // a game minimum entry-amount\n    uint public maximumParticipateAmount = 10 ether; // a game maximum entry-amount\n    uint public playAmountLockedInAccount; // \u0027playAmountLockedInAccount\u0027 is a guarantee that the contract will be able to pay when the player wins.\n    uint criticalPlayNumber = 62/*0xFFFFFFFFF*/; // The threshold that prevents the game from overflow.\n\n    /**\n     * @notice The owner can adjust entry-amount due to future changes in Ethereum value or any hard fork or gas rate change. \n     * @notice No matter how the owner change these values, the entry-amount variables are declared public, so you can call the value of the Contract at any time, such as through BlockExplorer, and so on.\n     */ \n    function SetParticipateAmount(uint _minimumParticipateAmount, uint _maximumParticipateAmount) external onlyOwner {\n        minimumParticipateAmount = _minimumParticipateAmount;\n        maximumParticipateAmount = _maximumParticipateAmount;\n    }\n\n    /**\n     * @notice The Provable(Oraclize) Random Data Source leverages the Ledger Proof and a custom application to generate unbiased random numbers. \n     * Parameters of queryId to request a random number.\n     * @param numberOfBytes - This value returns a 2^(bit-bytes) entropy value. For example, a value of 4 would result in 2^32.\n     * @param delay - Set 0 to run without delay.\n     * @param callbackGas - The gasprice of the callback.\n     * @param callbackGasAmplify - When the automatic refund loop operation occurs, it temporarily boosts the gas price. This price is supported by the contract, not the player.\n     * @dev The values may be changed to optimize the performance of the contract. No matter how the owner change these values, variables are declared public, so you can call the value of the Contract at any time, such as through BlockExplorer, and so on.\n     */\n    uint public numberOfBytes = 7;\n    uint public delay = 0;\n    uint public callbackGas = 210000 + 40000;\n    uint public callbackGasAmplify;\n    uint public loopGas = 3500 + 21000;\n    function setRNGqueryParameter(uint _numberOfBytes, uint _delay, uint _callbackGas) external onlyOwner {\n        numberOfBytes = _numberOfBytes;\n        delay = _delay;\n        callbackGas = _callbackGas;\n    }\n    \n    event restPlayAmountLockedInAccount(uint debugCode); // Lines for debugging\n    \n    /**\n     * @notice can modify the variable to check the minimum gas value to ensure that the player has submitted enough gas to play the game.\n     * @dev callback fee will be charged even if out of gas occurs. It must be reverted before an \"out of gas\" occurs.\n     * The default is assigned to the constructor, but it can be modified because may need to consider future EVM environments.\n     */\n    function setMinGasEntry(uint _newGasEntry, uint _loopGas) external onlyOwner {\n        minEntryGas = _newGasEntry;\n        loopGas = _loopGas;\n    }\n\n    function callbackGasCalcul() private {\n        minEntryGasCallBack = (jamCount.sub(preJamCount) * loopGas) + callbackGas;\n        if (now \u003e checkedTime + provablelimitTime \u0026\u0026 jamCount.sub(preJamCount) \u003e= 3) {\n            callbackGasAmplify = minEntryGasCallBack;\n            minEntryGas += minEntryGasCallBack;\n        } else {\n\n        }\n    }\n    \n    event test(uint testcode, uint contractfee, uint throphyfee, uint possiblewinamount); // Lines for debugging\n    function standardNormalDistributionAndSDF () private {\n        \n    }\n    \n    /**\n     * @notice This bitwise operation checks how many cases the player has submitted. The function contractDetermineExecute contains information about bitwise.\n     * @param cntN play_mask\n     * @return Counts how many numbers have selected and return the result. The return value is the ratio of dividends based on the player winning rate.\n     */\n    function calculatePlayQuota (uint cntN) private pure returns (uint _playQuota) {\n        cntN = cntN - ((cntN \u003e\u003e 1) \u0026 1431655765);\n        cntN = (cntN \u0026 0x33333333) + ((cntN \u003e\u003e 2) \u0026 0x33333333);\n        uint baseQ = ((cntN + (cntN \u003e\u003e 4) \u0026 0xF0F0F0F) * 0x1010101) \u003e\u003e 24; \n        /**\n         * Rather than applying the standard normal distribution / SDF / Hypergeometric distribution to values as a function, hard-coding it because there are only six cases.\n         * Please note the Square Queue white paper for more details.\n         */\n        if (baseQ == 1) {return 61400;}if (baseQ == 2) {return 25100;}if (baseQ == 3) {return 17300;}if (baseQ == 4) {return 13900;}if (baseQ == 5) {return 12200;}if (baseQ \u003c 0 || baseQ \u003e 5) {return 0;}\n    }\n    /**\n     * @notice When a transaction occurs in function playSubmit, all the process of game win/loss decision and winning ether transfer or refund will be automatically processed by smart-contracts.\n     * @param _playMask Will be assigned to play_mask of struct Play.\n     * @param _playModulo Will be assigned to play_modulo of struct Play.\n     * @param _submitHash Check the ECDSA (Elliptic Curve Digital Signature Algorithm) signature with param _v, _r, _s. SquareQueue uses Provable (Oraclize) rather than commit-reveal RNGs, so ECDSA is not essential, but it is an effective way to deal with the occurrence of aggressive transactions.    \n     */\n    function playSubmit(uint _playMask, uint _playModulo, bytes32 _submitHash, uint8 _v, bytes32 _r, bytes32 _s) external payable {\n        uint tempMinEntryGas = minEntryGas;\n        callbackGasCalcul();\n        //Make sure player have enough gas to join the game.\n        require(gasleft() \u003e minEntryGas, \"There is not enough gas to play the game.\");\n        minEntryGas = tempMinEntryGas;\n        \n        address payable play_player = msg.sender;\n        uint play_amount = msg.value;\n        uint play_modulo = _playModulo;\n        uint play_playBlockNumber = block.number;\n        uint play_mask = _playMask;\n\n        require (play_modulo == 6 /*|| play_modulo == 72*/, \"Only 6 case games are available.\");\n        require (play_amount \u003e= minimumParticipateAmount \u0026\u0026 play_amount \u003c= maximumParticipateAmount, \"Ehter amount must be within the game playable range.\");\n        require (play_mask \u003e 0 \u0026\u0026 play_mask \u003c= criticalPlayNumber, \"The numbers chosen by the player must be within the gameable range.\");\n        require (ECDSASigner == ecrecover(_submitHash, _v, _r, _s), \"ECDSA signature is not valid. \");\n\n        /** \n        Players can choose a number of cases to increase their winning probability, but in this case, their dividends will be lower.\n        On the contrary to this, dividends can be raised by lowering the winning probability. Everything is up to the player\u0027s choice.\n        rollUnder is a variable used to calculate dividends by interacting with playMask.\n        */\n        uint play_rollUnder = calculatePlayQuota(play_mask);\n        require (0 \u003c play_rollUnder \u0026\u0026 play_rollUnder \u003c= play_modulo.mul(10234), \"The probability does not exist in the range.\");\n\n        uint play_possibleWinAmount;\n        uint play_trophyIncreaseFee;\n\n        //Deducted by \u0027trophyFee\u00271/10% of the player\u0027s game amount, and add to the trophy weight.\n        uint _trophyIncreaseFee = play_amount * trophyFee / 1000;\n        //Deducted by \u0027contractFee\u00271/10% of the player\u0027s game amount, and add to the trophy weight.\n        uint contractFee = play_amount * contractCommissionPercentage / 1000;\n        //It is used to lock the contract\u0027s funds by pre-calculating ether that the player can obtain.\n        uint _possibleWinAmount = ((play_amount * play_rollUnder).div(10000)) - (contractFee + _trophyIncreaseFee);\n\n        emit test (111, contractFee, _trophyIncreaseFee, _possibleWinAmount); // Lines for debugging\n        \n        if (trophyWeight + playAmountLockedInAccount + _possibleWinAmount + _trophyIncreaseFee \u003c= address(this).balance) {\n            require (_possibleWinAmount \u003c= play_amount.add(maximumProfit), \"At this time, it is not possible to play out of the range maximum ether profits of this contract.\");\n\n            //Fetch the player\u0027s possibleWinAmount\u0026trophyIncreaseFee information into the database.\n            play_possibleWinAmount = _possibleWinAmount;\n            play_trophyIncreaseFee = _trophyIncreaseFee;\n\n            //Guarantees that all potentially payable ethers are payable.\n            playAmountLockedInAccount = playAmountLockedInAccount.add(play_possibleWinAmount);\n            trophyWeight = trophyWeight.add(play_trophyIncreaseFee);\n        } else {\n            revert(\"There is not enough funds to play your game on SquareQueue Contract.\");\n        }\n        \n        /*\n         * @dev Note that there is a fee charged for generating queryId even if an error occurs inside the contract after the queryId is generated.\n         * @dev It is recommended to create a queryId that generates a callBack if the player can be sure to complete the game without any errors.\n         */\n        bytes32 queryId = getQueryId();\n\n        // The queryId, which is guaranteed to be unique on the network, is usefully reused as an identifier for each game.\n        Play storage play = playTable[uint(queryId)];\n\n        //Make sure the current gameplay is allocated in the free space of the structure database. \n        if (play.player == address(0)) {\n            //Fetch the player\u0027s current information into the database.\n            play.player = play_player;\n            play.amount = play_amount;\n            play.modulo = play_modulo;\n            play.playBlockNumber = play_playBlockNumber;\n            play.mask = play_mask;\n            play.possibleWinAmount = play_possibleWinAmount;\n            play.trophyIncreaseFee = play_trophyIncreaseFee;\n            play.rollUnder = play_rollUnder;\n        } else {\n            revert (\"Cannot assign a player to the database.\");\n        }\n        \n        //assgin the game play count. Will be used for Function cleanPlayAmountLockedInAccount.\n        playerCount = playerCount.add(1);\n        \n        /*\n         * SquareQueue contract\u0027s automatic refund system works for gameplay that is deadlocked for any reason due to problems with EVM or Network or callBack or else.\n         * To do this and operate a separate DB for easy identification.\n         */\n        storeJam(queryId);\n        \n        /**\n        All data submitted by the player can be seen transparently through the input data item of the transaction.\n        Nevertheless, submitGameParams generates an event to check that the contract\u0027s internal function returns correctly even it consumes a bit more gas.\n        Players can always check for events using the ethereum block explorer. In addition, players can check their rollUnder and queryId value.\n         */\n        emit submitGameParams(play.playCount, 100, play.player, play.mask, play.modulo, play.rollUnder, queryId);\n    }\n\n    bytes32 public queryidToPerformTheCheck; //Variable that determines whether the game is in turn to run checkNcleanJam\n\n    /**\n     * @notice Every time the function provable_query(oraclize_query) is called, it returns a unique ID, hereby referred to as queryId, which is guaranteed to be unique in the given network execution context.\n     */\n    function getQueryId() private returns(bytes32 _Id) {\n        uint _callbackGas = callbackGas;\n        bool checkIdBool;\n\n        if (now \u003e checkedTime + provablelimitTime \u0026\u0026 jamCount.sub(preJamCount) \u003e= 3) {\n            _callbackGas = callbackGasAmplify;\n            checkIdBool = true;\n        }\n        _Id = provable_newRandomDSQuery(delay, numberOfBytes, _callbackGas);\n        \n        if (checkIdBool == true) {\n            checkedTime = now;\n            queryidToPerformTheCheck = _Id;\n            checkIdBool = false;\n        } else {\n            queryidToPerformTheCheck = 0x1111111111111112222222222233333322112222222211111111111111111111;\n        }\n        return(_Id);\n    }\n    \n    /**\n     * provableRandomValue - Declared for Random Number Generator(RNG) by Provable(Oraclize).\n     * provablelimitBlock - SquareQueue will automatically issue a refund if __callback Tx is generated too late due to an unexpected EVM or network or other problem. The criterion is block number.\n     * provablelimitTime - SquareQueue will automatically issue a refund if __callback Tx is generated too late due to an unexpected EVM or network or other problem. The criterion is Time.\n     * As mentioned in the Ethereum Yellow Paper, Contracts can\u0027t get hashes before the latest 256 blocks.(However, 256 blocks are too much time for the user to wait for the game results, so SquareQueue\u0027ll cut that down.)\n     * So in order to eliminate potential risks, the contract will refund if a callback occurs above the limit block.\n     */\n    uint provableRandomValue;\n    uint public provablelimitBlock;\n    uint public provablelimitTime;\n    \n    function setProvablelimitLine(uint _provablelimitBlock, uint _provablelimitTime) external onlyOwner {\n        provablelimitBlock = _provablelimitBlock;\n        provablelimitTime = _provablelimitTime;\n    }\n\n    uint public contractCommissionPercentage = 7; // n= 0.n% Deduct contract service charge. It is calculated as a percentage of the player\u0027s game amount.\n    uint public trophyFee = 3; // n=0.n% Deduct trophy weight charge. It is calculated as a percentage of the player\u0027s game amount.\n\n    /**\n     * @notice The owner can adjust entry-amount due to future changes in Ethereum value or any hard fork or gas rate change. No matter how owner change these values, the entry-amount variables are declared public, so you can call the value of the Contract at any time, such as through BlockExplorer, and so on.\n     * @param trophyWeight Trophy prize. This value cannot be changed by anyone, including the owner.\n     * @param trophyTicketQualification Entry-amount lower than this value will not be accepted for winning the trophy.\n     * @param trophyModulo Chance to win a Trophy 10000 == 0.01%\n     * @param maximumProfit As a \"wei\" unit of \"Ether\". A player cannot take a prize-amount larger than this value. However, whatever the trophy prize-amount is, a player can earn it separately from this variable.\n     * trophyTicketQualification and trophyModulo can be changed by the contract owner (reason for scalability). But, no matter how the owner change these values, variables are declared public, so you can call the value of the Contract at any time, such as through BlockExplorer, and so on.\n     */\n    uint public trophyWeight;\n    uint public trophyTicketQualification = 0.5 ether;\n    uint public trophyModulo = 10000;\n    uint public maximumProfit;\n    bool public trophy_period = false;\n    function SetTrophyVariable(uint _trophyTicketQualification, uint _trophyModulo, bool _trophy_period) external onlyOwner {\n        trophy_period = _trophy_period;\n        trophyTicketQualification = _trophyTicketQualification;\n        trophyModulo = _trophyModulo;\n    }\n\n    address payable public owner;\n    address payable private nextOwner;\n    address public ECDSASigner;\n\n    /**\n     * All events are written as a basis for transparently operating the return values of this smart contract.\n     * Payment - Player Address, amount earned by the player in the game.\n     * Tpayment - Player Address, Trophy prize earned by the player.\n     * gameQueryIdRandomEntropy - Player Address, Provable(Oraclize) queryId, Random entropy.\n     * gameResult - Player Choice(playMask), Game Choice(Random Number Generation Algorithm), The estimated amount of ether acquisition when the player wins.\n     *              A player choice does not have to match the game choice perfectly to win the game. There is a wider winning strategy. Details are described in function contractDetermineExecute.\n     * automaticRefund - The amount of ether refunded to the automatic refund system, queryId.\n     */\n    event Payment(uint eventCode, address indexed recipient, uint dividend);\n    event Tpayment(uint eventCode, address indexed recipient, uint _tAmount);\n    event gameQueryIdRandomEntropy(uint eventCode, address indexed recipient, bytes32 indexed ProvableQueryId, uint entropy);\n    event gameResult(bytes32 indexed queryId, uint playCount, uint eventCode, uint PlayerChoice, uint GameChoice, uint payment, uint trophyPayment);\n    event automaticRefund(uint eventCode, uint amount, bytes32 indexed queryId);\n\n    /**\n     * This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. \n     * It is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via .send() or .transfer()). \n     * If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. \n     * If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through regular transactions and throws an exception.\n     */\n    //receive() external payable { //solidity 0.6.0\n        function() external payable {\n\n    }\n\n    /**\n     * In order to change the owner of this contract, the original owner must send a new owner address(function approveNextOwner), \n     * and then the ownership must be changed only after the new owner approves ownership(function acceptNextOwner).\n     */\n    function approveNextOwner(address payable _nextOwner) external onlyOwner {\n        require (_nextOwner != owner, \"Cannot approve current owner.\");\n        nextOwner = _nextOwner;\n    }\n\n    function acceptNextOwner() external {\n        require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\n        owner = nextOwner;\n    }\n\n    /**\n     * Assign a new ECDSA Address for SquareQueue.\n     * ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):\n     * recover the address associated with the public key from elliptic curve signature or return zero on error. The function parameters correspond to ECDSA values of the signature:\n     * r = first 32 bytes of signature s = second 32 bytes of signature v = final 1 byte of signature.\n     */\n    function setECDSASigner(address _newECDSASigner) external onlyOwner {\n        cleaningBlock = block.number;\n        prePlayerCount = playerCount;\n        ECDSASigner = _newECDSASigner;\n    }\n\n    /**\n     * If an unexpected error occurs after playSubmit and the Contract is reverted, the funds of the PlayAmountLockedInAccount of the corresponding tx will be locked forever.\n     * Funtion contractDetermineExecute, checkNcleanJam solves this problem, but this function is necessary because it doesn\u0027t know what will change in the future EVM environment.\n     * Don\u0027t worry. The send(transfer) statement throws an exception at revert, so all statements such as refunds and payments will be performed.\n     * However, funds in PlayAmountLockedInAccount must be released. This function effectively cut off entrance new gameplay by allocating a new ECDSA and not telling the user \n     * the v, r, s values, and allocates 0 to PlayAmountLockedInAccount when more than a refundable block number has passed(If a refund is required, complete all refunds) and there is certainly no new gameplay.\n     */\n    uint cleaningBlock; // If there is already a game in progress, this variable to wait for the result of games.\n    uint prePlayerCount; // If there is gameplay since the new ECDSA address was assigned, this variable prevents cleanLockedInAccountAndPlayCallcount function from executing.\n    function cleanLockedInAccountAndPlayCallcount() external onlyOwner {\n        require(cleaningBlock + provablelimitBlock \u003c= block.number, \"It can be executed after all automatic refunds have been processed.\");\n        require(prePlayerCount == playerCount, \"There is already a user who played the game.\");\n        \n        //If there is a deadlocked player, all ether will be refunded.\n        checkNcleanJam();\n\n        playAmountLockedInAccount = 0;\n        callbackCount = 0;\n    }\n\n    /**\n     * SquareQueue can set an upper limit on the amount of game entry and winnings. This value can be associated with maximumParticipateAmount to effectively prevent fund depletion.\n     * No matter how the owner changes these values, variables are declared public, so you can call the value of the Contract at any time, such as through BlockExplorer, and so on.\n     * and it will not any affect the game in progress.\n     */\n    function setMaximumProfit(uint _maximumProfit) public onlyOwner {\n        maximumProfit = _maximumProfit;\n    }\n\n    // The owner of SquareQueue can increase the trophy weight. Of course, can\u0027t lower it. Our best wishes go with you.\n    function bumpTrophyWeight(uint _bumpAmount) external onlyOwner {\n        require (trophyWeight + playAmountLockedInAccount + _bumpAmount \u003c= address(this).balance, \"The contract needs to replenish the fund because it is scarce.\");\n        trophyWeight = trophyWeight.add(_bumpAmount);\n    }\n\n    /**\n     * SquareQueue can upgrade the Contract and update the current version of the Contract to upgrade the game, add games, or get better.\n     * In this case, you have to disable the older version of the Contract, but SquareQueue owner can\u0027t break it if there is a game in progress.\n     * Thus, SquareQueue owners can use ECDSA variables to limit new game participation and dismiss Contract only after the results of all the games in progress have been obtained.\n     */\n    function contractDissolution() external onlyOwner {\n        require (playAmountLockedInAccount == 0, \"There is a game in progress.\");\n        selfdestruct(owner);\n    }\n\n    /**\n     * Play_storage_play Call the game and player information via the identifier. \n     * @param _queryId Every time the function provable_query(oraclize_query) is called, it returns a unique ID in the network.\n     * @param _entropy Key entropy of random numbers used to derive game results. The random data of provable(oraclize) is leveraging the Ledger proof to prove that the origin of the generated randomness is really a secure Ledger device.\n     * @dev Run automatically when SquareQueue gets a callBack from Provable (Oraclize). If the Contract does not receive callBack, it will not run in any case.\n     */\n    function contractDetermineExecute(Play storage _play,bytes32 _queryId, uint _entropy) private {\n        //Get the player\u0027s data from the __callback.\n        uint _amount = _play.amount;\n        uint _modulo = _play.modulo;\n        address payable player = _play.player;\n\n        //Check that the player has already participated in the game and is waiting for the result, not a new contract.\n        if (_amount != 0 \u0026\u0026 player != address(0)) {\n            _play.amount = 0;\n            CheckJam storage checkJam = checkJamDB[_play.playCount];\n            checkJam.play_amount = true;\n        } else {\n            revert (\"The player does not exist in the database or is already closed.\");\n        }\n        \n        /**\n         * game - Modular arithmetic of Provable\u0027s random numbers and player game types is used to calculate game base results.\n         * gameWin \u0026 trophyWin - If the player meets the conditions for winning the prize, it will be replaced by the prize value, or else Zero as it is.\n         */\n        uint game = _entropy.mod(_modulo);\n        uint gameWin = 0;\n        uint trophyWin = 0;\n        \n        /**\n         * The SquareQueue SmartContract establishes a foundation that builds on existing Ethereum and Provable(Oraclize) processes while creating transparency and trust with players.\n         * These events make the calculation of \"SquareQueue SmartContract\" more transparent and fair, which is useful for players to check the game result. a player can always check with BlockExplorer or a similar solution, and so on.\n         * Details are described in the event comment.\n         */\n        emit gameQueryIdRandomEntropy(200, _play.player, _queryId, _entropy);\n\n        /**\n         * SquareQueue generates a random number using the Random Data Source at https://provable.xyz/ (Oraclize) and uses this random number to calculate the player\u0027s winning result.\n         * The Provable Random Data Source leverages the Ledger Proof and a custom application to generate unbiased random numbers and provide them on demand to blockchain and non-blockchain based applications.\n         * The end applications can perform verification step to unsure that the randomness provided was truly generated in an secure hardware environment provided by a Ledger Nano S.\n         * \n         * If the result of the game\u0027s random number includes the player\u0027s chosen numbers, the player wins the game and wins the prize. \n         * The player can choose only one number or choose multiple numbers. Everything depends on the choice of the player.\n         * Consequentially, outcomes of the game have in numerous cases, and one of the best ways to calculate it effectively is to use Bitwise operators.\n         * However, it is trouble to explain how the Bitwise operators are applied to the game, so I will explain a complex algorithm very easily.\n         *  (Case to choose only in six figures(6).)\n         * n = player Number, A = array of multiples of 2, B = bit of A\n         *  |  n  |   A   |    B   |     i.e.    || When player select a number, all numbers are substitute by multiples of two starting with one. (inside game algorithms and Tx.)\n         *  |_____|_______|________|_____________|| If player choose the number \"2,3,5\", \"2 (000010), 4 (000100), 16 (010000)\" is selected as the bitmask, and this value is aggregated and 22(010110) will be transmitted.\n         *  |  1 =\u003e   1  =\u003e 000001 |             || a player wins if only one number is matched, even if a player selects multiple numbers. (Of course, choose multiple numbers, a higher chance of winning but the lower prize.)\n         *  |  2 =\u003e   2  =\u003e 000010 |  (2) 000010 || The random number of the game, when 6 numbers are the reference, is one of the numbers 0,1,2,3,4,5 by uint game = uint(_entropy).mod(modulo);\n         *  |  3 =\u003e   4  =\u003e 000100 |  (4)+000100 || When the derived random number is called \"r\", \"2^r\" is used to determine the result of the game. If r is 5, then 2^5 = 32(100000):case1.\n         *  |  4 =\u003e   8  =\u003e 001000 |             ||(case 1:lose)|| (case 2:win)|| 32 (100000) and (22) 010110 Bitwise \"\u0026 AND\" returns 0. A bitwise AND is a binary operation that takes two equal-length binary representations.\n         *  |  5 =\u003e  16  =\u003e 010000 |  (5)+010000 || (22) 010110 || (22) 010110 || Thus, if both bits in the compared position are 1, the bit in the resulting binary representation is 1 (1  1 = 1); otherwise, the result is 0 (1  0 = 0 and 0  0 = 0).\n         *  |  6 =\u003e  32  =\u003e 100000 |=(22) 010110 || (32) 100000 || (16) 010000 || \n         *  |----------------------|-------------||-------------||-------------|| If r is 4, then 2^4 = 16(010000):case2. Bitwise operation results in a nonzero number.\n         *  |                      |             ||   \u0026  000000 ||   \u0026  010000 || This means that the number or one of player choice matches the Game random number, so player winning.\n         * \n         * As mentioned earlier, the comments and CODE of this smart contract are written in plain language for people who do not know the programming language.\n         * This is not an exact description of a Bitmask Using Bitwise Operators. but, it makes it point more accessible because it is expressed as being the very closest analogy. \n         */\n            if ((2 ** game) \u0026 _play.mask != 0) {\n                gameWin = _play.possibleWinAmount;\n            }\n        //contract releases the locked funds to pay ether to the player.\n        playAmountLockedInAccount = playAmountLockedInAccount.sub(_play.possibleWinAmount);\n        uint _playAmountLockedInAccount = playAmountLockedInAccount; // Lines for debugging\n\n        //calculate whether a trophy can be acquired separately from the game result.\n        if (_amount \u003e= trophyTicketQualification) {\n            //The trophy is a process of accumulate 0.03% of Ether amount submitted by users to game.In the ICO period, only the accumulation is made, after which the winner comes out using provable.xyz random.\n            if (trophy_period == true) {\n                uint trophyRandomness = _entropy.mod(trophyModulo);\n                if (trophyRandomness == 1) {\n                    trophyWin = trophyWeight;\n                    trophyWeight = 0;\n                }\n            }\n        }\n        \n        sendFund(player, trophyWin, gameWin, _play);\n        emit gameResult(_queryId, _play.playCount, 300, _play.mask, 2 ** game, gameWin, trophyWin);\n        \n        /* \n         * If there is a problem with callBack, we will automatically refund to the player.\n         * This feature does not run every time, but when the threshold is reached.\n         */\n        if (_queryId == queryidToPerformTheCheck) {\n            checkNcleanJam();\n        } else { }\n        \n        // Lines for debugging\n        if (playAmountLockedInAccount != _playAmountLockedInAccount) {\n            emit restPlayAmountLockedInAccount (1010);\n        }\n    }\n\n    /**\n     * @param recipient Address\n     * @param _tAmount Trophy prizes\n     * @param _gAmount Game prizes\n     * @notice Ether transfer function called from contractDetermineExecute/withDrawFund/refundPlay\n     */\n    function sendFund(address payable recipient, uint _tAmount, uint _gAmount, Play storage _play) private {\n        if (_tAmount !=0 || _gAmount != 0) {\n\n            if (_tAmount != 0 \u0026\u0026 _tAmount \u003e 0) { //Determine if there is a trophy prize.\n                recipient.transfer(_tAmount);\n                emit Tpayment(400, recipient, _tAmount);\n                _play.Tpayment = _tAmount;\n            }\n            \n            if (_gAmount != 0 \u0026\u0026 _gAmount \u003e 0) { //Determine if there is a game prize.\n                recipient.transfer(_gAmount);\n                emit Payment(500, recipient, _gAmount);\n                _play.Payment = _gAmount;\n            }\n        }\n    }\n\n    /**\n     * @param recipient Address\n     * @param _withDrawAmount Ether amount to be sent.\n     * @notice Trophy prizes never withdraws except in the case of winning.\n     */\n    function withDrawFund(address payable recipient, uint _withDrawAmount) external onlyOwner { \n        require (trophyWeight + playAmountLockedInAccount + _withDrawAmount \u003c= address(this).balance, \"The process cannot proceed, the withdrawal amount exceeds the withdrawable amount.\");\n        recipient.transfer(_withDrawAmount);\n    }\n\n    /**\n     * a transaction executing a function of the SquareQueue is broadcasted by a player. The function contains a special instruction which manifest to Provable(Oraclize), who is constantly monitoring the Ethereum for such instruction, a request for data.\n     * According to the parameters of such a request, Provable will fetch or compute a result, build, sign and broadcast the transaction carrying the result. In the default configuration, such a transaction will execute the __callback function which \n     * should be placed in the smart contract by its developer: for this reason, this transaction is referred to in the documentation as the Provable(Oraclize) __callback transaction.\n     * One of the fundamental characteristics of Provable(Oraclize) is the capability of returning data to a smart contract together with one or more proofs of Authenticity of the data.\n     * Authenticity proofs are at the core of Provable\u0027s oracle model. Smart contracts can request authenticity proofs together with their data by calling the provable_setProof function available in the usingProvable contract. \n     * The authenticity proof can be either delivered directly to the smart contract or it can be saved. When a smart contract requests for an authenticity proof, it must define a different callback function with the following arguments: \n     * function __callback(bytes32 queryId, string result, bytes proof) provable_setProof(oraclize_setProof) function of SquareQueue the following format : provable_setProof(proofType_Ledger) in the constructor.\n     */\n    function __callback(bytes32 _queryId, string memory _result, bytes memory _proof) public {\n        require(msg.sender == provable_cbAddress(), \"Must comply with the provable cbAddress.\");\n        Play storage play = playTable[uint(_queryId)];\n        callbackCount = callbackCount.add(1);\n        \n        bool BlockCheck = true; \n        \n        if (block.number \u003e play.playBlockNumber \u0026\u0026 block.number \u003c play.playBlockNumber + provablelimitBlock) {\n            \n        } else {\n            /**\n             * if in extreme cases Tx is generated too late due to an unexpected EVM or network or other problem, player amount will be refunded.\n             * \"Too late callBack tx arrives, SquareQueue automatically refunded except fee.\"\n             */\n            refundPlay(_queryId, 602);\n            BlockCheck = false;\n        }\n        \n        if(provable_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == 0 \u0026\u0026 BlockCheck == true) {\n            /**\n             * @notice The proof verification has passed! Convert the random bytes received from the  query to a `uint256`.\n             * to safely check the authenticity of the data received it is customary to verify the proof included in a Provable answer. Once the verifyProof method succeeds (returning \u0027true\u0027), \n             * the user can be sure that neither Provable(Oraclize) nor other Parties have tampered with the results.\n             */\n            // generate random game values using Provable(Oraclize) Random Data Source.\n            provableRandomValue = uint(keccak256(abi.encodePacked(_result)));\n\n            /**\n             * When the contract is thrown (e.g revert ...), the state is also reverted, so returning a value of zero.\n             * e.g. this case also applies for an automatic refund.\n             */\n            play.resultBlockNumber = block.number;\n            \n            /// @dev Should never be run in any case unless receiving a Provable callBack.\n            contractDetermineExecute(play, _queryId, provableRandomValue);\n        } else {\n            /**\n             * If the proof verification is not passed, refund the player\u0027s ether amount and terminate the tx.\n             * The proof provable_proofVerify has failed, so SquareQueue automatically refunded ether except fee.\n             */\n            if(BlockCheck == true) {\n                refundPlay(_queryId, 611);\n            }\n        }\n        \n    }\n    \n    /**\n     * @notice If the Contract does not work properly, it will revert all processes and refund the player\u0027s amount. However, the amount(e.g. fee,gas) deducted from the trophy and the contract is not refundable.\n     * The whole process takes place automatically, without an owner or any player intervention. \u0027contractCommissionPercentage\u0027 is deducted to prevent malicious transactions.\n     * @dev After this function is executed to eliminate any potential risks, all the contract\u0027s progress should be reverted.\n     */\n    function refundPlay(bytes32 _queryId, uint _id) private {\n        uint _playAmountLockedInAccount = playAmountLockedInAccount; // Lines for debugging\n        Play storage play = playTable[uint(_queryId)];\n        \n        uint _recoverAmount = play.possibleWinAmount;\n        uint _amount = play.amount;\n        \n        if (_amount == 0) {\n            revert(\"Since the player game ether amount is zero or the refund has already been completed.\");\n        } else {\n            // Fetch the player game amount and issue a refund if ever there was one.\n            uint deduct = contractCommissionPercentage + trophyFee;\n            _amount = play.amount - play.amount * deduct / 1000;\n            play.amount = 0;\n            CheckJam storage checkJam = checkJamDB[play.playCount];\n            checkJam.play_amount = true;\n            play.possibleWinAmount = 0;\n        }\n        \n        // Unlock ether to be refunded.\n        playAmountLockedInAccount = playAmountLockedInAccount.sub(_recoverAmount);\n        \n        //Proceed with a refund and write a log.\n        play.player.transfer(_amount);\n        emit automaticRefund(_id, _amount, _queryId);\n        \n        //Lines for debugging\n        if (playAmountLockedInAccount != _playAmountLockedInAccount) {\n            emit restPlayAmountLockedInAccount (2020);\n        }\n    }\n\n    /**\n     * jamCount - Same as playerCount, used as a starting and ending point to check if callBack is correct.\n     * checkedTime - Allocates the block that last checked time.\n     * preJamCount - Allocates the block that last checked jamCount.\n     */\n    uint public jamCount;\n    uint public checkedTime;\n    uint public preJamCount;\n    \n    /**\n     * @notice If callBack does not arrive until after provablelimitBlock, and the outcome of the game cannot be obtained, the ether will be refunded to the player.\n     * @dev When callBack arrives too late, it solves the problem inside the callBack function. This function handles the case of what callBack is not completely.\n     */\n    function storeJam(bytes32 _queryId) private {\n        jamCount = jamCount.add(1);\n        CheckJam storage checkJam = checkJamDB[jamCount];\n        checkJam.play_number = jamCount;\n        checkJam.play_queryId = _queryId;\n        \n        Play storage _play = playTable[uint(checkJam.play_queryId)];\n        _play.playCount = jamCount;\n    }\n    \n    /**\n     * Each provablelimitBlock is reached, it checks to all callback has been reached correctly.\n     * @notice The process of checking for this callBack checks both the callBack arrival time in the __callBack function and the case where callBack does not come at all in the checkNcleanJam function.\n     * All of these features guarantee that automatic refunds will be activated if there is a problem with the gameplay.\n     */\n    function checkNcleanJam() private {\n        uint passCount;\n        for(uint i = jamCount; preJamCount \u003c i; i--) {\n            CheckJam storage checkJam = checkJamDB[i];\n            Play storage _play = playTable[uint(checkJam.play_queryId)];\n            \n            if (block.number == _play.playBlockNumber) {\n                passCount ++;\n                //Only the game tx of the previous block of the current block is processed.\n            } else {\n                if (_play.amount != 0) {\n                    refundPlay(checkJam.play_queryId, 702);\n                } else { }\n            }\n        }\n        preJamCount = jamCount.sub(passCount) - 1;\n    }\n    /**\n    Disclaimers\n\n    Please note, during your use of the SquareQueue that online vehicle, and that it carries with it a certain degree of Ethereum financial risk. \n    Players should be aware of this risk and govern themselves accordingly. SquareQueue is intended as a Smart-Contracts for those who are interested in the pastime of Ethereum space. \n    The content within this smart-contract is designed for informational purposes. Any information posted within this website \u0026 CODE is accurate to the best of our knowledge. \n    All measures are taken to ensure that such information is accurate and up-to-date, but please take note that some of it may become outdated and/or may be subject to change at any time, \n    including descriptions of features at the developer that are reviewed, at the discretion of the said developer.\n    SquareQueue maintains no responsibility for player service issues that are particular to the space that is reviewed, nor does it serve as a clearinghouse for player complaints. \n    SquareQueue does not guarantee the accuracy, adequacy, completeness of any services and shall not be liable for any errors, omissions or other defects in, delays or interruptions \n    in such services, or for any actions taken in reliance thereon or availability of any information and is not responsible for any errors or omissions, regardless of the cause or for \n    the results obtained from the use of such information. SquareQueue, its affiliates and their third party suppliers disclaim any and all express or implied warranties.\n    In no event shall SquareQueue be liable for any direct, indirect, special or consequential damages, costs, expenses, legal fees, or losses (including lost income or lost profit and opportunity profits) \n    in connection with your or others use of the SquareQueue(includes ICO and an exchange market and all services related to SquareQueue.).\n    Players must play on the basis of trusting that SquareQueue Smart-Contract written in Solidity language on the Ethereum Network \u0026 Provable(Oraclize) works as-is code.\n     */\n\n    /**\n    Square Queue designates the beginning of \u0027space\u0027 as a \u0027game but will ultimately develop it towards \u0027virtual society and hope that the impartial laws \u0026 ruls of the virtual society will be projected into the real world.\n     */\n}"}}