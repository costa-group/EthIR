{"HipToken.sol":{"content":"pragma solidity ^0.5.0;\nimport \u0027./SafeMathLib.sol\u0027;\n\n\ncontract HipToken {\n    using SafeMathLib for uint;\n\n    mapping (address =\u003e uint) balances;\n    mapping (address =\u003e mapping (address =\u003e uint)) allowed;\n    mapping (uint =\u003e FrozenTokens) public frozenTokensMap;\n\n    event Transfer(address indexed sender, address indexed receiver, uint value);\n    event Approval(address approver, address spender, uint value);\n    event TokensFrozen(address indexed freezer, uint amount, uint id, uint lengthFreezeDays);\n    event TokensUnfrozen(address indexed unfreezer, uint amount, uint id);\n    event TokensBurned(address burner, uint amount);\n\n    uint8 constant public decimals = 18;\n    string constant public symbol = \"HIP\";\n    string constant public name = \"HiP Token\";\n    uint public totalSupply;\n    uint numFrozenStructs;\n\n    struct FrozenTokens {\n        uint id;\n        uint dateFrozen;\n        uint lengthFreezeDays;\n        uint amount;\n        bool frozen;\n        address owner;\n    }\n\n    // simple initialization, giving complete token supply to one address\n    constructor(address bank, uint initialBalance) public {\n        require(bank != address(0), \u0027Must initialize with nonzero address\u0027);\n        balances[bank] = initialBalance;\n        totalSupply = initialBalance;\n        emit Transfer(address(0), bank, initialBalance);\n    }\n\n    // freeze tokens for a certain number of days\n    function freeze(uint amount, uint freezeDays) public {\n        require(amount \u003e 0, \u0027Cannot freeze 0 tokens\u0027);\n        // move tokens into this contract\u0027s address from sender\n        balances[msg.sender] = balances[msg.sender].minus(amount);\n        balances[address(this)] = balances[address(this)].plus(amount);\n        numFrozenStructs = numFrozenStructs.plus(1);\n        frozenTokensMap[numFrozenStructs] = FrozenTokens(numFrozenStructs, now, freezeDays, amount, true, msg.sender);\n        emit Transfer(msg.sender, address(this), amount);\n        emit TokensFrozen(msg.sender, amount, numFrozenStructs, freezeDays);\n    }\n\n    // unfreeze frozen tokens\n    function unFreeze(uint id) public {\n        FrozenTokens storage f = frozenTokensMap[id];\n        require(f.dateFrozen + (f.lengthFreezeDays * 1 days) \u003c now, \u0027May not unfreeze until freeze time is up\u0027);\n        require(f.frozen, \u0027Can only unfreeze frozen tokens\u0027);\n        f.frozen = false;\n        // move tokens back into owner\u0027s address from this contract\u0027s address\n        balances[f.owner] = balances[f.owner].plus(f.amount);\n        balances[address(this)] = balances[address(this)].minus(f.amount);\n        emit Transfer(address(this), msg.sender, f.amount);\n        emit TokensUnfrozen(f.owner, f.amount, id);\n    }\n\n    // burn tokens, taking them out of supply\n    function burn(uint amount) public {\n        balances[msg.sender] = balances[msg.sender].minus(amount);\n        totalSupply = totalSupply.minus(amount);\n        emit Transfer(msg.sender, address(0), amount);\n        emit TokensBurned(msg.sender, amount);\n    }\n\n    // transfer tokens\n    function transfer(address to, uint value) public returns (bool success)\n    {\n        require(to != address(0), \u0027Cannot send to zero address, please use burn function if that is your intention\u0027);\n        // deduct\n        balances[msg.sender] = balances[msg.sender].minus(value);\n        // add\n        balances[to] = balances[to].plus(value);\n\n        emit Transfer(msg.sender, to, value);\n        return true;\n    }\n\n    // transfer someone else\u0027s tokens, subject to approval\n    function transferFrom(address from, address to, uint value) public returns (bool success)\n    {\n        require(to != address(0), \u0027Cannot send to zero address, please use burn function if that is your intention\u0027);\n        uint allowance = allowed[from][msg.sender];\n\n        // deduct\n        balances[from] = balances[from].minus(value);\n\n        // add\n        balances[to] = balances[to].plus(value);\n\n        // adjust allowance\n        allowed[from][msg.sender] = allowance.minus(value);\n\n        emit Transfer(from, to, value);\n        return true;\n    }\n\n    // retrieve the balance of address\n    function balanceOf(address owner) public view returns (uint balance) {\n        return balances[owner];\n    }\n\n    // approve another address to transfer a specific amount of tokens\n    function approve(address spender, uint value) public returns (bool success) {\n        allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    // incrementally increase approval, see https://github.com/ethereum/EIPs/issues/738\n    function increaseApproval(address spender, uint value) public returns (bool success) {\n        allowed[msg.sender][spender] = allowed[msg.sender][spender].plus(value);\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n        return true;\n    }\n\n    // incrementally decrease approval, see https://github.com/ethereum/EIPs/issues/738\n    function decreaseApproval(address spender, uint decreaseValue) public returns (bool success) {\n        uint oldValue = allowed[msg.sender][spender];\n        // allow decreasing too much, to prevent griefing via front-running\n        if (decreaseValue \u003e= oldValue) {\n            allowed[msg.sender][spender] = 0;\n        } else {\n            allowed[msg.sender][spender] = oldValue.minus(decreaseValue);\n        }\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\n        return true;\n    }\n\n    // retrieve allowance for a given owner, spender pair of addresses\n    function allowance(address owner, address spender) public view returns (uint remaining) {\n        return allowed[owner][spender];\n    }\n\n    function numCoinsFrozen() public view returns (uint) {\n        return balances[address(this)];\n    }\n}\n"},"SafeMathLib.sol":{"content":"pragma solidity ^0.5.0;\n\nlibrary SafeMathLib {\n  function times(uint a, uint b) public pure returns (uint) {\n    uint c = a * b;\n    require(a == 0 || c / a == b, \u0027Overflow detected\u0027);\n    return c;\n  }\n\n  function minus(uint a, uint b) public pure returns (uint) {\n    require(b \u003c= a, \u0027Underflow detected\u0027);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) public pure returns (uint) {\n    uint c = a + b;\n    require(c\u003e=a \u0026\u0026 c\u003e=b, \u0027Overflow detected\u0027);\n    return c;\n  }\n\n}\n"}}