{{
  "language": "Solidity",
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "recoverable-wallet.sol": {
      "content": "pragma solidity 0.5.8;\n\n/// @notice https://eips.ethereum.org/EIPS/eip-1820\ninterface Erc1820Registry {\n\tfunction setInterfaceImplementer(address _target, bytes32 _interfaceHash, address _implementer) external;\n}\n\n/// @notice https://eips.ethereum.org/EIPS/eip-777\ncontract Erc777TokensRecipient {\n\tconstructor() public {\n\t\t// keccak256(abi.encodePacked(\"ERC777TokensRecipient\")) == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\n\t\tErc1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24).setInterfaceImplementer(address(this), 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b, address(this));\n\t}\n\n\t/// @notice called when someone attempts to transfer ERC-777 tokens to this address.  If this function were to throw or doesn't exist, then the token transfer would fail.\n\tfunction tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external { }\n\n\t/// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `_implementer` or not.\n\t/// @param _interfaceHash keccak256 hash of the name of the interface\n\t/// @param _implementer Address for which the contract will implement the interface\n\t/// @return ERC1820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `_implementer`.\n\tfunction canImplementInterfaceForAddress(bytes32 _interfaceHash, address _implementer) external view returns(bytes32) {\n\t\t// keccak256(abi.encodePacked(\"ERC777TokensRecipient\")) == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b\n\t\tif (_implementer == address(this) && _interfaceHash == 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b) {\n\t\t\t// keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\")) == 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4\n\t\t\treturn 0xa2ef4600d742022d532d4747cb3547474667d6f13804902513b2ec01c848f4b4;\n\t\t} else {\n\t\t\treturn bytes32(0);\n\t\t}\n\t}\n}\n\n/// @notice An Ownable contract is one that has a single address that has elevated control over the contract's operations.  Ownership can be transferred between users as a two-step process, one to initiate the transfer and two to receive the transfer.  This two-step process ensures that ownership cannot accidentally be given to an address that cannot operate the contract.\ncontract Ownable {\n\tevent OwnershipTransferStarted(address indexed owner, address indexed pendingOwner);\n\tevent OwnershipTransferCancelled(address indexed owner, address indexed pendingOwner);\n\tevent OwnershipTransferFinished(address indexed oldOwner, address indexed newOwner);\n\n\taddress public owner;\n\taddress public pendingOwner;\n\n\tconstructor(address _owner) public {\n\t\trequire(_owner != address(0), \"Contract must have an owner.\");\n\t\towner = _owner;\n\t}\n\n\t/// @notice a function modifier that ensures the modified function can only be called by the owner of the contract.\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"Only the owner may call this method.\");\n\t\t_;\n\t}\n\n\t/// @notice starts the transfer of ownership to a new owner.\n\t/// @param _pendingOwner the address to which ownership should be transferred.\n\tfunction startOwnershipTransfer(address _pendingOwner) external onlyOwner {\n\t\trequire(_pendingOwner != address(0), \"Contract must have an owner.\");\n\t\t// we want to ensure that we get a cancelled or finished event for every ownership transfer, so if a transfer is in progres we first cancel it\n\t\tif (pendingOwner != address(0)) {\n\t\t\tcancelOwnershipTransfer();\n\t\t}\n\t\tpendingOwner = _pendingOwner;\n\t\temit OwnershipTransferStarted(owner, pendingOwner);\n\t}\n\n\t/// @notice cancel an in progress ownership transfer.\n\t/// @dev cancellation should not be depended on to cancel a transfer to a malicious address.  it's intended purpose is only to cancel transfer to an address that is unable or unwilling to accept the transfer\n\tfunction cancelOwnershipTransfer() public onlyOwner {\n\t\trequire(pendingOwner != address(0), \"There is no pending transfer to be cancelled.\");\n\t\taddress _pendingOwner = pendingOwner;\n\t\tpendingOwner = address(0);\n\t\temit OwnershipTransferCancelled(owner, _pendingOwner);\n\t}\n\n\t/// @notice called by the pending owner as part of the two-step ownership transfer process to accept ownership of the contract.\n\tfunction acceptOwnership() external {\n\t\trequire(msg.sender == pendingOwner, \"Only the pending owner can call this method.\");\n\t\taddress _oldOwner = owner;\n\t\towner = pendingOwner;\n\t\tpendingOwner = address(0);\n\t\temit OwnershipTransferFinished(_oldOwner, owner);\n\t}\n}\n\n/// @notice a smart wallet that is secured against loss of keys by way of backup keys that can be used to recover access with a time delay.\ncontract RecoverableWallet is Ownable, Erc777TokensRecipient {\n\tevent RecoveryAddressAdded(address indexed newRecoverer, uint16 recoveryDelayInDays);\n\tevent RecoveryAddressRemoved(address indexed oldRecoverer);\n\tevent RecoveryStarted(address indexed newOwner);\n\tevent RecoveryCancelled(address indexed oldRecoverer);\n\tevent RecoveryFinished(address indexed newPendingOwner);\n\n\t/// @notice a collection of accounts that are able to recover control of this wallet, mapped to the number of days it takes for each to complete a recovery.\n\t/// @dev the recovery days are also used as a recovery priority, so a recovery address with a lower number of days has a higher recovery priority and can override a lower-priority recovery in progress.\n\tmapping(address => uint16) public recoveryDelaysInDays;\n\taddress public activeRecoveryAddress;\n\tuint256 public activeRecoveryEndTime = uint256(-1);\n\n\t/// @notice the modified function can only be called when the wallet is undergoing recovery.\n\tmodifier onlyDuringRecovery() {\n\t\trequire(activeRecoveryAddress != address(0), \"This method can only be called during a recovery.\");\n\t\t_;\n\t}\n\n\t/// @notice the modified function can only be called when the wallet is not undergoing recovery.\n\tmodifier onlyOutsideRecovery() {\n\t\trequire(activeRecoveryAddress == address(0), \"This method cannot be called during a recovery.\");\n\t\t_;\n\t}\n\n\tconstructor(address _initialOwner) Ownable(_initialOwner) public { }\n\n\t/// @notice accept ETH transfers into this contract\n\tfunction () external payable { }\n\n\t/// @notice add a new recovery address to the wallet with the specified number of day delay\n\t/// @param _newRecoveryAddress the address to be added\n\t/// @param _recoveryDelayInDays the number of days delay between when `_newRecoveryAddress` can initiate a recovery and when it can complete the recovery\n\tfunction addRecoveryAddress(address _newRecoveryAddress, uint16 _recoveryDelayInDays) external onlyOwner onlyOutsideRecovery {\n\t\trequire(_newRecoveryAddress != address(0), \"Recovery address must be supplied.\");\n\t\trequire(_recoveryDelayInDays > 0, \"Recovery delay must be at least 1 day.\");\n\t\trecoveryDelaysInDays[_newRecoveryAddress] = _recoveryDelayInDays;\n\t\temit RecoveryAddressAdded(_newRecoveryAddress, _recoveryDelayInDays);\n\t}\n\n\t/// @notice removes a recovery address from the collection, preventing it from being able to issue recovery operations in the future\n\t/// @param _oldRecoveryAddress the address to remove from the recovery addresses collection\n\tfunction removeRecoveryAddress(address _oldRecoveryAddress) public onlyOwner onlyOutsideRecovery {\n\t\trequire(_oldRecoveryAddress != address(0), \"Recovery address must be supplied.\");\n\t\trecoveryDelaysInDays[_oldRecoveryAddress] = 0;\n\t\temit RecoveryAddressRemoved(_oldRecoveryAddress);\n\t}\n\n\t/// @notice starts the recovery process.  must be called by a previously registered recovery address.  recovery will complete in a number of days dependent on the address that initiated the recovery\n\tfunction startRecovery() external {\n\t\tuint16 _proposedRecoveryDelayInDays = recoveryDelaysInDays[msg.sender];\n\t\trequire(_proposedRecoveryDelayInDays != 0, \"Only designated recovery addresseses can initiate the recovery process.\");\n\n\t\tbool _inRecovery = activeRecoveryAddress != address(0);\n\t\tif (_inRecovery) {\n\t\t\t// NOTE: the delay for a particular recovery address cannot be changed during recovery nor can addresses be removed during recovery, so we can rely on this being != 0\n\t\t\tuint16 _activeRecoveryDelayInDays = recoveryDelaysInDays[activeRecoveryAddress];\n\t\t\trequire(_proposedRecoveryDelayInDays < _activeRecoveryDelayInDays, \"Recovery is already under way and new recovery doesn't have a higher priority.\");\n\t\t\temit RecoveryCancelled(activeRecoveryAddress);\n\t\t}\n\n\t\tactiveRecoveryAddress = msg.sender;\n\t\tactiveRecoveryEndTime = block.timestamp + _proposedRecoveryDelayInDays * 1 days;\n\t\temit RecoveryStarted(msg.sender);\n\t}\n\n\t/// @notice cancels an active recovery.  can only be called by the current contract owner.  used to cancel a recovery in case the owner key is found\n\t/// @dev cancellation is only reliable if the recovery time has not elapsed\n\tfunction cancelRecovery() public onlyOwner onlyDuringRecovery {\n\t\taddress _recoveryAddress = activeRecoveryAddress;\n\t\tresetRecovery();\n\t\temit RecoveryCancelled(_recoveryAddress);\n\t}\n\n\t/// @notice cancels an active recovery and removes the recovery address from the recoverer collection.  used when a recovery key becomes compromised and attempts to initiate a recovery\n\tfunction cancelRecoveryAndRemoveRecoveryAddress() external onlyOwner onlyDuringRecovery {\n\t\taddress _recoveryAddress = activeRecoveryAddress;\n\t\tcancelRecovery();\n\t\tremoveRecoveryAddress(_recoveryAddress);\n\t}\n\n\t/// @notice finishes the recovery process after the necessary delay has elapsed.  callable by anyone in case the keys controlling the active recovery address have been lost, since once this is called a new recovery (with a potentially lower recovery priority) can begin.\n\tfunction finishRecovery() external onlyDuringRecovery {\n\t\trequire(block.timestamp > activeRecoveryEndTime, \"You must wait until the recovery delay is over before finishing the recovery.\");\n\n\t\taddress _oldOwner = owner;\n\t\towner = activeRecoveryAddress;\n\t\tresetRecovery();\n\t\temit RecoveryFinished(pendingOwner);\n\t\temit OwnershipTransferStarted(_oldOwner, owner);\n\t\temit OwnershipTransferFinished(_oldOwner, owner);\n\t}\n\n\t/// @notice deploy a contract from this contract.\n\t/// @dev uses create2, so the address of the deployed contract will be deterministic\n\t/// @param _value the amount of ETH that should be supplied to the contract creation call\n\t/// @param _data the deployment bytecode to execute\n\t/// @param _salt the salt used for deterministic contract creation.  see documentation at https://eips.ethereum.org/EIPS/eip-1014 for details on how the address is computed\n\tfunction deploy(uint256 _value, bytes calldata _data, uint256 _salt) external payable onlyOwner onlyOutsideRecovery returns (address) {\n\t\trequire(address(this).balance >= _value, \"Wallet does not have enough funds available to deploy the contract.\");\n\t\trequire(_data.length != 0, \"Contract deployment must contain bytecode to deploy.\");\n\t\tbytes memory _data2 = _data;\n\t\taddress newContract;\n\t\t/* solium-disable-next-line */\n\t\tassembly { newContract := create2(_value, add(_data2, 32), mload(_data2), _salt) }\n\t\trequire(newContract != address(0), \"Contract creation returned address 0, indicating failure.\");\n\t\treturn newContract;\n\t}\n\n\t/// @notice executes an arbitrary contract call by this wallet.  allows the wallet to send ETH, transfer tokens, use dapps, etc.\n\t/// @param _to contract address to call or send to\n\t/// @param _value the amount of ETH to attach to the call\n\t/// @param _data the calldata to supply to `_to`\n\t/// @dev `_data` is of the same form used to call a contract from the JSON-RPC API, so for Solidity contract calls it is the target function hash followed by the ABI encoded parameters for that function\n\tfunction execute(address payable _to, uint256 _value, bytes calldata _data) external payable onlyOwner onlyOutsideRecovery returns (bytes memory) {\n\t\trequire(_to != address(0), \"Transaction execution must contain a destination.  If you meant to deploy a contract, use deploy instead.\");\n\t\trequire(address(this).balance >= _value, \"Wallet does not have enough funds available to execute the desired transaction.\");\n\t\t(bool _success, bytes memory _result) = _to.call.value(_value)(_data);\n\t\trequire(_success, \"Contract execution failed.\");\n\t\treturn _result;\n\t}\n\n\tfunction resetRecovery() private {\n\t\tactiveRecoveryAddress = address(0);\n\t\tactiveRecoveryEndTime = uint256(-1);\n\t}\n}\n\n/// @notice A factory for creating new recoverable wallets.  this is useful because an event is fired anytime a wallet is created with this factory, so we can track all wallets created by this by monitoring contract events\ncontract RecoverableWalletFactory {\n\tevent WalletCreated(address indexed owner, RecoverableWallet indexed wallet);\n\n\t/// @notice creates a new recoverable wallet that is initially owned by the caller\n\tfunction createWallet() external returns (RecoverableWallet) {\n\t\tRecoverableWallet wallet = new RecoverableWallet(msg.sender);\n\t\temit WalletCreated(msg.sender, wallet);\n\t\treturn wallet;\n\t}\n\n\t/// @notice this function makes it so one can easily identify whether this contract has been deployed or not.  deployment of this factory is done deterministically, so it will live at a well known address on every chain but the user may need to check whether or not this contract has been deployed yet on a given chain\n\tfunction exists() external pure returns (bytes32) {\n\t\treturn 0x0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef;\n\t}\n}\n"
    }
  }
}}