{"ev5_main.sol":{"content":"/**\n *Submitted for verification at Etherscan.io on 2019-11-03\n*/\npragma solidity ^0.5.11;\nimport \u0027./ownable.sol\u0027;\nimport \u0027./safemath.sol\u0027;\n/**\n * @title -EV5.Win- v0.5.11\n * ╔═╗┌─┐┬ ┬┬─┐┌─┐┌─┐┌─┐  ┌─┐┌┐┌┌┬┐  ┬ ┬┬┌─┐┌┬┐┌─┐┌┬┐  ┌─┐┬─┐┌─┐  ┌┬┐┬ ┬┌─┐  ┌┐ ┌─┐┌─┐┌┬┐  ┬ ┬┌─┐┌─┐┬  ┌┬┐┬ ┬\n * ║  │ ││ │├┬┘├─┤│ ┬├┤   ├─┤│││ ││  ││││└─┐ │││ ││││  ├─┤├┬┘├┤    │ ├─┤├┤   ├┴┐├┤ └─┐ │   │││├┤ ├─┤│   │ ├─┤\n * ╚═╝└─┘└─┘┴└─┴ ┴└─┘└─┘  ┴ ┴┘└┘─┴┘  └┴┘┴└─┘─┴┘└─┘┴ ┴  ┴ ┴┴└─└─┘   ┴ ┴ ┴└─┘  └─┘└─┘└─┘ ┴   └┴┘└─┘┴ ┴┴─┘ ┴ ┴ ┴\n *\n * ==(\u0027-.==========(`-. ====================(`\\ .-\u0027) /`===============.-\u0027) _====================================\n * _(  OO)      _(OO  )_                  `.( OO ),\u0027              ( OO ) )\n * (,------. ,--(_/   ,. \\.------.      ,--./  .--.    ,-.-\u0027)  ,--./ ,--,\u0027\n *  |  .---\u0027 \\   \\   /(__/|   ___|      |      |  |    |  |OO) |   \\ |  |\\\n *  |  |      \\   \\ /   / |  \u0027--.       |  |   |  |,   |  |  \\ |    \\|  | )\n * (|  \u0027--.    \\   \u0027   /, `---.  \u0027.     |  |.\u0027.|  |_)  |  |(_/ |  .     |/\n *  |  .--\u0027     \\     /__).-   |  |     |         |   ,|  |_.\u0027 |  |\\    |\n *  |  `---.     \\   /    | `-\u0027   / .-. |   ,\u0027.   |  (_|  |    |  | \\   | \n *  `------\u0027      `-\u0027      `----\u0027\u0027  `-\u0027 \u0027--\u0027   \u0027--\u0027    `--\u0027    `--\u0027  `--\u0027          © New York Jerome Team Inc.\n * =============================================================================================================\n*\n*\n╔═╗╦  ╦ ┬ ┬┬┌┐┌  ╔═╗┌┬┐┌─┐┬─┐┌┬┐┬┌┐┌┌─┐\n║╣ ╚╗╔╝ │││││││  ╚═╗ │ ├─┤├┬┘ │ │││││ ┬\n╚═╝ ╚╝ o└┴┘┴┘└┘  ╚═╝ ┴ ┴ ┴┴└─ ┴ ┴┘└┘└─┘\n*/\ncontract Vendor {\n    function getLevel(uint _value) external view returns(uint);\n    function getLineLevel(uint _value) external view returns(uint);\n    function getWithdrawRoundRo(uint _round) external pure returns (uint);\n}\ncontract DB {\n    function createUser1(address _addr, string memory _code, string memory _pCode) public;\n    function createUser2(address _addr, uint _frozenCoin, uint _lastInTime) public;\n    function setUserToNew(address _addr) public;\n    function createWithdraw(address _addr, uint _amount, uint _ctime) public;\n    function setRePlayInfo(address _addr, uint _type) public;\n    function getWithdrawCoin(address _addr) public returns (uint);\n    function updateCoinLevel(address _addr,uint _frozenCoin, uint _freeCoin, uint _level, uint _linelevel) public;\n    function updateProfit(address _addr, uint _amount) public;\n    function getCodeMapping(string memory _code) public view returns(address);\n    function getUserInfo(address _addr) public view returns (uint, uint, uint, uint, uint, uint);\n    function getUserOut(address _owner) public view returns (string memory,string memory, uint[12] memory uInfo);\n    function getPlatforms() public view returns(uint,uint,uint,uint,uint,uint);\n    function getIndexMapping(uint _uid) public view returns(address);\n    function getWithdrawAccount(address _addr) public view returns (address);\n    \n    function settleIncrease(uint _start, uint _end) public;\n    function settleNewProfit(uint _start, uint _end) public;\n    function settleBonus(uint _start, uint _end, uint _onlyOne) public;\n    function settleRecommend(uint _start, uint _end, uint _onlyOne) public;\n}\n\ncontract Ev5Game is Whitelist {\n    string public EV5_NAME = \"Ev5.win GameFather\";\n    //lib using list\n    using SafeMath for *;\n\n    //Loglist\n    event InvestEvent(address indexed _addr, string _code, string _pCode, uint _value, uint time);\n    event ReInEvent(address indexed _addr, uint _value, uint _value1, uint time);\n    event TransferEvent(address indexed _from, address indexed _to, uint _value, uint time);\n\n    //platform setting\n    bool private _platformPower = true;\n    //include other contract\n    DB db;\n    Vendor env;\n\n    //base param setting\n    uint ethWei = 1 ether;\n    uint maxCoin = 30 ether;\n    uint minSelf = 1;\n    uint maxSelf = 5;\n    uint withdrawRadix = 1;\n    bool private reEntrancyMutex = false;\n    address[5] private _addrs;  //_dAddr0,_envAddr1,feeAddr1,feeAddr2,feeAddr3\n    uint[3] feeRo = [15,10,10]; //div(1000)\n\n    //the content of contract is Beginning\n    constructor (address _dAddr, address _envAddr) public {\n        _addrs = [0x9732D32F4517A0A238441EcA4E45C1584A832fE0, 0x484A88721bD0e0280faC74F6261F9f340555F785, 0x0e8b5fb9673091C5368316595f77c7E3CBe11Bc6, _dAddr, _envAddr];\n    \n        db = DB(_addrs[3]);\n        env = Vendor(_addrs[4]);\n    }\n\n    function deposit() public payable {\n    }\n\n    /**\n    * @dev prevents contracts from interacting with Ev5.win\n    */\n    modifier isOpen() {\n        require(_platformPower == true,\"platform is repairing or wait to starting!\");\n        _;\n    }\n    /**\n    * @dev prevents contracts from interacting with Ev5.win\n    */\n    modifier isHuman() {\n        address _addr = msg.sender;\n        uint256 _codeLength;\n\n        assembly {_codeLength := extcodesize(_addr)}\n        require(_codeLength == 0, \"sorry humans only\");\n        require(tx.origin == msg.sender, \"sorry human only\");\n        _;\n    }\n\n    function invest(string memory _code, string memory _pCode)\n        public\n        payable\n        isHuman()\n    {\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"Coin Must Integer\");\n        require(msg.value \u003e= 1 * ethWei \u0026\u0026 msg.value \u003c= maxCoin, \"Coin Must Between 1 to maxCoin\");\n\n        uint lastInTime = now;\n        (uint uid,uint frozenCoin,uint freeCoin,,uint grantTime,) = db.getUserInfo(msg.sender);\n        if(uid == 0) {\n            //the checking condition\n            require(!compareStr(_code,\"\") \u0026\u0026 bytes(_code).length == 6, \"invalid invite code\");\n            require(db.getCodeMapping(_code) == address(0), \"code must different\");\n            address _parentAddr = db.getCodeMapping(_pCode);\n            require(compareStr(_pCode, \"000000\") || _parentAddr != address(0), \"Parent User not exist\");\n            require(_parentAddr != msg.sender, \"Parent User Is Not Owner\");\n            \n            db.createUser1(msg.sender, _code, _pCode);\n        } else {\n            require(frozenCoin.add(freeCoin).add(msg.value) \u003c= maxCoin, \"Max Coin is maxCoin ETH\");\n            //rechange lastInTime\n            grantTime = grantTime.add(8 hours).div(1 days).mul(1 days);\n            uint addDays = now.add(8 hours).sub(grantTime).div(1 days);\n            if(addDays == 0){\n                lastInTime = lastInTime.add(1 days);\n            }\n        }\n\n        db.createUser2(msg.sender, msg.value, lastInTime);\n        \n        db.setUserToNew(msg.sender);\n        sendFeeToAccount(msg.value);\n        emit InvestEvent(msg.sender, _code, _pCode, msg.value, now);\n    }  \n\n    function rePlayInByWD(uint _type)\n        public\n        payable\n        isHuman()\n        isOpen\n        returns(bool)\n    {\n        (,uint frozenCoin,uint freeCoin,,,uint lockedCoin) = db.getUserInfo(msg.sender);\n        require(frozenCoin.add(freeCoin) \u003c= maxCoin, \"Max Coin is maxCoin ETH\");\n\n        uint rltCoin;\n        //withdraw tennel\n        if(_type == 1){\n            uint wdCoin = db.getWithdrawCoin(msg.sender);\n            if(wdCoin \u003e 0) {\n                require(wdCoin \u003e lockedCoin, \"Nothing To Withdraw\");\n                bool success = false;\n                (success,rltCoin) = isEnough(wdCoin.sub(lockedCoin), 0);\n                if(success == true \u0026\u0026 rltCoin \u003e 0){\n                    transferTo(db.getWithdrawAccount(msg.sender), rltCoin);\n                    db.createWithdraw(msg.sender, rltCoin, now);\n                }else{\n                    setPlatformPower(false); \n                    return false;\n                }\n            }\n        }\n\n        frozenCoin = frozenCoin.add(freeCoin).sub(rltCoin);\n        db.updateCoinLevel(msg.sender, frozenCoin, 0 , env.getLevel(frozenCoin), env.getLineLevel(frozenCoin));\n        db.setRePlayInfo(msg.sender, _type);\n        \n        sendFeeToAccount(frozenCoin);\n        emit ReInEvent(msg.sender, frozenCoin, rltCoin, now);\n        return true;\n    }\n\n    function isEnough(uint _coin, uint _switch)\n        private\n        view\n        returns (bool,uint)\n    {\n        uint needCoin = _coin;\n        if(_switch == 0){\n            (uint trustCoin, uint lockedCoin,,,,) = db.getPlatforms();\n            needCoin = _coin.add(trustCoin).add(lockedCoin); \n        }\n        \n        uint balance = address(this).balance;\n        if(needCoin \u003e= balance){\n            return (false, balance);\n        }else{\n            return (true, _coin);\n        }\n    }\n\n    function sendAwardBySelf(uint _coin)\n        public\n        payable\n        isHuman()\n        isOpen\n        returns(bool)\n    {\n        (, uint frozenCoin, uint freeCoin, uint profit,,) = db.getUserInfo(msg.sender);\n        require(_coin.mul(ethWei) \u003c= profit, \"coin is not enough\");\n        _coin = (_coin == 0) ? profit : _coin.mul(ethWei);\n\n        bool success = false;\n        uint rltCoin = 0;\n        (success,rltCoin) = isEnough(_coin, 0);\n        if(success == true){\n            if(_coin \u003c (ethWei.div(minSelf))){\n                return false;\n            } if(maxSelf \u003e 0  \u0026\u0026 _coin \u003e maxSelf.mul(ethWei)){\n                _coin = maxSelf.mul(ethWei);\n            } if(maxSelf == 0 \u0026\u0026 _coin \u003e (frozenCoin.add(freeCoin)).mul(withdrawRadix)){\n                _coin = (frozenCoin.add(freeCoin)).mul(withdrawRadix);\n            }\n            transferTo(db.getWithdrawAccount(msg.sender), _coin);\n            db.updateProfit(msg.sender, _coin);\n        }else{\n            setPlatformPower(false);\n            return false;\n        }\n        return true;\n    }\n    \n    function initialization(uint _start, uint _end) external onlyOwner{\n        for (uint i = _start; i \u003c= _end; i++) {\n            address addr = db.getIndexMapping(i);\n            (,uint frozenCoin,,,,) = db.getUserInfo(addr);\n            sendFeeToAccount(frozenCoin);\n        }\n    }\n    function sendFeeToAccount(uint amount) public {//private\n        require(!reEntrancyMutex);\n        reEntrancyMutex = true;\n            bool success = false;\n            uint rltCoin;\n            uint allFeeRo = feeRo[0].add(feeRo[1]).add(feeRo[2]);\n            (success,rltCoin) = isEnough(amount.mul(allFeeRo).div(1000), 0);\n            if(success == true){\n                address(uint160(_addrs[0])).transfer(rltCoin.mul(feeRo[0]).div(allFeeRo));\n                address(uint160(_addrs[1])).transfer(rltCoin.mul(feeRo[1]).div(allFeeRo));\n                address(uint160(_addrs[2])).transfer(rltCoin.mul(feeRo[2]).div(allFeeRo));\n            }\n        reEntrancyMutex = false;\n\t}\n\t\n    function transferTo(address _addr,uint _val) private {\n        require(_addr != address(0));\n        require(!reEntrancyMutex);\n        reEntrancyMutex = true;\n            address(uint160(_addr)).transfer(_val);\n            emit TransferEvent(address(this), _addr, _val, now);\n        reEntrancyMutex = false;\n    }\n\n\tfunction transferTo2(address _addr,uint _val)\n        public\n        payable\n        onlyOwner\n    {\n        require(_addr != address(0));\n        require(!reEntrancyMutex);\n        reEntrancyMutex = true;\n            address(uint160(_addr)).transfer(_val);\n            emit TransferEvent(address(this), _addr, _val, now);\n        reEntrancyMutex = false;\n    }\n\n    function settleIncrease(uint _start, uint _end)\n        public\n        onlyIfWhitelisted\n    {\n        db.settleIncrease(_start, _end);\n    }\n    \n    function settleNewProfit(uint _start, uint _end)\n        public\n        onlyIfWhitelisted\n    {\n        db.settleNewProfit(_start, _end);\n    }\n    \n\tfunction settleBonus(uint _start, uint _end, uint _onlyOne)\n        public\n        onlyIfWhitelisted\n    {\n        db.settleBonus(_start, _end, _onlyOne);\n    }\n\n    function settleRecommend(uint _start, uint _end, uint _onlyOne)\n        public\n        onlyIfWhitelisted\n    {\n        db.settleRecommend(_start, _end, _onlyOne);\n    }\n\n   function getUserByCode(string memory _code) public view returns (bool){\n        if (db.getCodeMapping(_code) != address(0)){\n            return true;\n        }\n        return false;\n    }\n    function getUser(address _owner) external view isOpen returns(string memory code,string memory pcode,uint[12] memory data){\n        (uint uid,,,,,) = db.getUserInfo(_owner);\n        if(uid \u003e 0){\n            (code, pcode, data) = db.getUserOut(_owner);\n            return (code, pcode, data);\n        }\n        return (\u0027\u0027, \u0027\u0027, [uint(0),0,0,0,0,0,0,0,0,0,0,0]);\n    }\n    function getPlatforms() external view isOpen returns(uint,uint,uint,uint,uint,uint){\n        return (db.getPlatforms());\n    }\n\n    function getPlatformA() external view onlyOwner returns(bool, address, address, address, address,uint,uint,uint,uint,uint[3] memory,uint){\n        return (_platformPower, _addrs[0], _addrs[1], _addrs[2], _addrs[4],maxCoin,minSelf,maxSelf,withdrawRadix,feeRo, address(this).balance);\n    }\n    function setPlatformPower(bool r) public onlyOwner{\n        _platformPower = r;\n    }\n    function setting(uint _maxCoin, uint _minSelf, uint _maxSelf, uint _withdrawRadix) public onlyOwner {\n        maxCoin = _maxCoin;\n        minSelf = _minSelf;\n        maxSelf = _maxSelf;\n        withdrawRadix = _withdrawRadix;\n    }\n    function changeFeeRo(uint _index, uint _ro) public onlyOwner {\n        feeRo[_index] = _ro;\n    }\n    function setNewAddr(uint _addrId, address _addr) external onlyOwner{\n        _addrs[_addrId] = _addr;\n        if(_addrId == 3){\n            db = DB(_addr);\n        } if(_addrId == 4){\n            env = Vendor(_addr);\n        }\n    }\n}\n"},"ownable.sol":{"content":"pragma solidity ^0.5.11;\n\ncontract Ownable {\n    address private _owner;\n\n    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal {\n        _owner = msg.sender;\n        emit OwnerTransferred(address(0), _owner);\n    }\n    function owner() public view returns(address){\n        return _owner;\n    }\n    function isOwner() public view returns(bool){\n        return msg.sender == _owner;\n    }\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"it is not called by the owner\");\n        _;\n    }\n    function changeOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0),\u0027\u0027);\n        emit OwnerTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n    function compareStr(string memory _str1,string memory _str2) internal pure returns(bool) {\n        bool compareResult = false;\n        if(keccak256(abi.encodePacked(_str1)) == keccak256(abi.encodePacked(_str2))) {\n            compareResult = true;\n        }\n        return compareResult;\n    }\n}\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n  struct Role {\n    mapping (address =\u003e bool) bearer;\n  }\n\n  /**\n   * @dev give an address access to this role\n   */\n  function add(Role storage _role, address _addr)\n    internal\n  {\n     require(!has(_role, _addr), \"addr already has role\");\n      _role.bearer[_addr] = true;\n  }\n\n  /**\n   * @dev remove an address\u0027 access to this role\n   */\n  function remove(Role storage _role, address _addr)\n    internal\n  {\n      require(has(_role, _addr), \"addr do not have role\");\n      _role.bearer[_addr] = false;\n  }\n\n  /**\n   * @dev check if an address has this role\n   * // reverts\n   */\n  function check(Role storage _role, address _addr)\n    internal\n    view\n  {\n    require(has(_role, _addr),\u0027\u0027);\n  }\n\n  /**\n   * @dev check if an address has this role\n   * @return bool\n   */\n  function has(Role storage _role, address _addr)\n    internal\n    view\n    returns (bool)\n  {\n      require(_addr != address(0), \"not the zero address\");\n      return _role.bearer[_addr];\n  }\n}\n\n/**\n * @title RBAC (Role-Based Access Control)\n * @author Matt Condon (@Shrugs)\n * @dev Stores and provides setters and getters for roles and addresses.\n * Supports unlimited numbers of roles and addresses.\n * See //contracts/mocks/RBACMock.sol for an example of usage.\n * This RBAC method uses strings to key roles. It may be beneficial\n * for you to write your own implementation of this interface using Enums or similar.\n */\ncontract RBAC {\n  using Roles for Roles.Role;\n\n  mapping (string =\u003e Roles.Role) private roles;\n\n  event RoleAdded(address indexed operator, string role);\n  event RoleRemoved(address indexed operator, string role);\n\n  /**\n   * @dev reverts if addr does not have role\n   * @param _operator address\n   * @param _role the name of the role\n   * // reverts\n   */\n  function checkRole(address _operator, string memory _role)\n    public\n    view\n  {\n    roles[_role].check(_operator);\n  }\n\n  /**\n   * @dev determine if addr has role\n   * @param _operator address\n   * @param _role the name of the role\n   * @return bool\n   */\n    function hasRole(address _operator, string memory _role)\n    public\n    view\n    returns (bool)\n  {\n    return roles[_role].has(_operator);\n  }\n\n  /**\n   * @dev add a role to an address\n   * @param _operator address\n   * @param _role the name of the role\n   */\n  function addRole(address _operator, string memory _role)\n    internal\n  {\n    roles[_role].add(_operator);\n    emit RoleAdded(_operator, _role);\n  }\n\n  /**\n   * @dev remove a role from an address\n   * @param _operator address\n   * @param _role the name of the role\n   */\n  function removeRole(address _operator, string memory _role)\n    internal\n  {\n    roles[_role].remove(_operator);\n    emit RoleRemoved(_operator, _role);\n  }\n\n  /**\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\n   * @param _role the name of the role\n   * // reverts\n   */\n  modifier onlyRole(string memory _role)\n  {\n    checkRole(msg.sender, _role);\n    _;\n  }\n}\n\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable, RBAC {\n  string public constant ROLE_WHITELISTED = \"whitelist\";\n\n  /**\n   * @dev Throws if operator is not whitelisted.\n   */\n  modifier onlyIfWhitelisted() {\n    require(hasRole(msg.sender, ROLE_WHITELISTED) || isOwner(), \"Throws if operator is not whitelisted\");\n    _;\n  }\n\n  /**\n   * @dev add an address to the whitelist\n   * @param _operator address\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n   */\n  function addAddressToWhitelist(address _operator)\n    public\n    onlyOwner\n  {\n    addRole(_operator, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev getter to determine if address is in whitelist\n   */\n  function whitelist(address _operator)\n    public\n    view\n    returns (bool)\n  {\n    return hasRole(_operator, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev add addresses to the whitelist\n   * @param _operators addresses\n   * @return true if at least one address was added to the whitelist,\n   * false if all addresses were already in the whitelist\n   */\n  function addAddressesToWhitelist(address[] memory _operators)\n    public\n    onlyOwner\n  {\n    for (uint256 i = 0; i \u003c _operators.length; i++) {\n      addAddressToWhitelist(_operators[i]);\n    }\n  }\n    /**\n   * @dev remove an address from the whitelist\n   * @param _operator address\n   * @return true if the address was removed from the whitelist,\n   * false if the address wasn\u0027t in the whitelist in the first place\n   */\n  function removeAddressFromWhitelist(address _operator)\n    public\n    onlyOwner\n  {\n    removeRole(_operator, ROLE_WHITELISTED);\n  }\n\n  /**\n   * @dev remove addresses from the whitelist\n   * @param _operators addresses\n   * @return true if at least one address was removed from the whitelist,\n   * false if all addresses weren\u0027t in the whitelist in the first place\n   */\n  function removeAddressesFromWhitelist(address[] memory _operators)\n    public\n    onlyOwner\n  {\n    for (uint256 i = 0; i \u003c _operators.length; i++) {\n      removeAddressFromWhitelist(_operators[i]);\n    }\n  }\n\n}\n"},"safemath.sol":{"content":"pragma solidity \u003e=0.4.22 \u003c0.6.0;\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"}}