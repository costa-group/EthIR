{"AdminBase.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract AdminBase {\n  address public owner;\n  mapping (address =\u003e bool) admins;\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor () public {\n    owner = msg.sender;\n    admins[msg.sender] = true;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyowner() {\n    require(isowner(), \"AdminBase: caller is not the owner\");\n    _;\n  }\n\n  modifier onlyAdmin() {\n    require(admins[msg.sender], \"AdminBase: caller is not the Admin\");\n    _;\n  }\n\n  function addAdmin(address account) public onlyowner {\n    admins[account] = true;\n  }\n\n  function removeAdmin(address account) public onlyowner {\n    admins[account] = false;\n  }\n\n  /**\n   * @dev Returns true if the caller is the current owner.\n   */\n  function isowner() public view returns (bool) {\n    return msg.sender == owner;\n  }\n\n  function isAdmin() public view returns (bool) {\n    return admins[msg.sender];\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferowner(address newowner)\n  public onlyowner {\n    owner = newowner;\n  }\n}\n"},"Future.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./SafeMath.sol\";\nimport \"./FutureBase.sol\";\nimport \"./AdminBase.sol\";\n\ncontract Future is FutureBase,AdminBase {\n    using SafeMath for uint256;\n    address payable constant public ZERO_ADDR = address(0x00);\n    uint256 public _dailyInvest = 0;\n    uint256 public _staticPool = 0;\n    uint256 public _safePool = 0;\n    mapping(address =\u003e Player) allPlayers;\n    address[] public allAddress = new address[](0);\n    uint[] public lockedRound = new uint[](0);\n    uint investCount = 0;\n    mapping(uint =\u003e Investment) investments;\n    address[] public dailyPlayers = new address[](0);\n    uint _rand = 88;\n    uint _safeIndex = 0;\n    uint _endTime = 0;\n    uint _startTime = 0;\n    uint _gloryTime = 0;\n    bool public _active = true;\n    address[] public addressV1 = new address[](0);\n    address[] public addressV2 = new address[](0);\n    address[] public addressV3 = new address[](0);\n    address[] public addressV4 = new address[](0);\n    address[] public addressV5 = new address[](0);\n\n    constructor() public {\n        allPlayers[ZERO_ADDR] = Player({\n            self : ZERO_ADDR,\n            parent : ZERO_ADDR,\n            bonus : 0,\n            totalBonus : 0,\n            invest : 0,\n            sons : 0,\n            round: 0,\n            index: 0\n        });\n        lockedRound.push(0);\n        allAddress.push(ZERO_ADDR);\n        investments[investCount] =  Investment(ZERO_ADDR,0,now,0,true);\n        investCount = investCount.add(1);\n    }\n\n    function () external payable {\n        if(msg.value \u003e 0){\n            invest(ZERO_ADDR);\n        }else{\n            withdraw();\n        }\n    }\n\n    function invest(address payable parentAddr) public payable {\n        require(msg.value \u003e= 0.5 ether \u0026\u0026 msg.sender != parentAddr, \"Parameter Error.\");\n        require(isStart(), \"Game Start Limit\");\n        require(_active, \"Game Over\");\n        bool isFirst = false;\n        if(allPlayers[msg.sender].index == 0){\n            isFirst = true;\n            Player memory parent = allPlayers[parentAddr];\n            if(parent.index == 0) {\n                parentAddr = ZERO_ADDR;\n            }\n            allPlayers[msg.sender] = Player({\n                self : msg.sender,\n                parent : parentAddr,\n                bonus: 0,\n                totalBonus : 0,\n                invest : msg.value,\n                sons : 0,\n                round: lockedRound.length,\n                index: allAddress.length\n            });\n            allAddress.push(msg.sender);\n        }else{\n            Player storage user = allPlayers[msg.sender];\n            uint256 totalBonus = 0;\n            uint256 bonus = 0;\n            bool outFlag;\n            (totalBonus, bonus, outFlag) = calcBonus(user.self);\n            if(outFlag) {\n                user.bonus = bonus;\n                user.totalBonus = 0;\n                user.invest = msg.value;\n            }else{\n                user.invest = user.invest.add(msg.value);\n                user.bonus = bonus;\n                user.totalBonus = totalBonus;\n            }\n            user.round = lockedRound.length;\n        }\n        _dailyInvest = _dailyInvest.add(msg.value);\n        _safePool = _safePool.add(msg.value.div(20));\n        _staticPool = _staticPool.add(msg.value.mul(45).div(100));\n        dailyPlayers.push(msg.sender);\n        Player memory self = allPlayers[msg.sender];\n        Player memory parent = allPlayers[self.parent];\n        uint256 parentVal = msg.value.div(10);\n        if(isFirst == true) {\n            investBonus(parent.self, parentVal, true, 1);\n        } else {\n            investBonus(parent.self, parentVal, true, 0);\n        }\n        Player memory grand = allPlayers[parent.parent];\n        if(grand.sons \u003e= 2){\n            uint256 grandVal = msg.value.div(20);\n            investBonus(grand.self, grandVal, true, 0);\n        }\n        Player memory great = allPlayers[grand.parent];\n        if(allPlayers[great.self].sons \u003e= 3){\n            uint256 greatVal = msg.value.div(20);\n            investBonus(great.self, greatVal, true, 0);\n        }\n        Player memory greatFather = allPlayers[great.parent];\n        if(allPlayers[greatFather.self].sons \u003e= 4){\n            uint256 superVal = msg.value.mul(3).div(100);\n            investBonus(greatFather.self, superVal, true, 0);\n        }\n        Player memory greatGrandFather = allPlayers[greatFather.parent];\n        if(allPlayers[greatGrandFather.self].sons \u003e= 5){\n            uint256 hyperVal = msg.value.div(50);\n            investBonus(greatGrandFather.self, hyperVal, true, 0);\n        }\n        investments[investCount] = Investment(msg.sender,msg.value,now,lockedRound.length,isFirst);\n        investCount=investCount.add(1);\n        emit logUserInvest(msg.sender, parentAddr, isFirst, msg.value, now);\n\n    }\n\n    function calcBonus(address target) public view returns(uint256, uint256, bool) {\n        Player memory player = allPlayers[target];\n        uint256 lockedBonus = calcLocked(target);\n        uint256 totalBonus = player.totalBonus.add(lockedBonus);\n        bool outFlag = false;\n        uint256 less = 0;\n        uint256 maxIncome = 0;\n        if(player.invest \u003c= 10 ether){\n            maxIncome = player.invest.mul(2);\n        }else if(player.invest \u003e 10 ether \u0026\u0026 player.invest \u003c= 20 ether){\n            maxIncome = player.invest.mul(3);\n        }else if(player.invest \u003e 20 ether){\n            maxIncome = player.invest.mul(5);\n        }\n        if (totalBonus \u003e= maxIncome) {\n            less = totalBonus.sub(maxIncome);\n            outFlag = true;\n        }\n        totalBonus = totalBonus.sub(less);\n        uint256 bonus = player.bonus.add(lockedBonus).sub(less);\n\n        return (totalBonus, bonus, outFlag);\n    }\n\n    function calcLocked(address target) public view returns(uint256) {\n        Player memory self = allPlayers[target];\n        uint randTotal = 0;\n        for(uint i=self.round; i\u003clockedRound.length; i++){\n            randTotal = randTotal.add(lockedRound[i]);\n        }\n        uint256 lockedBonus = self.invest.mul(randTotal).div(10000);\n        return lockedBonus;\n    }\n\n    function saveRound() internal returns(bool) {\n        bool retreat = false;\n        uint random = getRandom(100).add(1);\n        uint rand = 0;\n        if(random == 1) {\n            rand = 30;\n        } else if(random == 2) {\n            rand = 35;\n        } else if (random \u003e 2 \u0026\u0026 random \u003c= 52){\n            rand = 49;\n        } else if(random \u003e 52 \u0026\u0026 random \u003c= 92){\n            rand = 51;\n        } else if(random \u003e 92 \u0026\u0026 random \u003c= 95){\n            rand = 60;\n        } else if(random \u003e 95 \u0026\u0026 random \u003c= 97){\n            rand = 65;\n        } else if(random \u003e 97 \u0026\u0026 random \u003c= 99){\n            rand = 70;\n        } else if(random == 100){\n            rand = 120;\n        }\n        uint256 dayLocked = _dailyInvest.mul(45).div(100);\n        uint256 releaseLocked = calcRelease();\n        if(dayLocked \u003c releaseLocked.mul(rand).div(10000)) {\n            rand = 30;\n        }\n        if(_staticPool \u003c releaseLocked.mul(rand).div(10000)) {\n            rand = 0;\n            retreat = true;\n        }\n        _staticPool = _staticPool.sub(releaseLocked.mul(rand).div(10000));\n        lockedRound.push(rand);\n\n        emit logRandom(rand, now);\n        return retreat;\n    }\n\n    function calcRelease() public view returns(uint256) {\n        uint256 totalRelease = 0;\n        for(uint i=0; i\u003callAddress.length; i++){\n            Player memory player = allPlayers[allAddress[i]];\n            if(player.invest == 0) {\n                continue;\n            }\n            uint256 bonus = 0;\n            uint256 playerBonus = 0;\n            bool outFlag;\n            (bonus, playerBonus, outFlag) = calcBonus(player.self);\n            if(!outFlag) {\n                totalRelease = totalRelease.add(player.invest);\n            }\n        }\n        return totalRelease;\n    }\n\n    function calcGlory() internal {\n        // calc too hard for one time\n        if(now.sub(_gloryTime).div(20 hours) \u003c 1) return;\n        _gloryTime = now;\n        uint256[] memory achievements = new uint256[](allAddress.length);\n        for(uint i=allAddress.length-1; i\u003e0; i--) {\n            Player memory player = allPlayers[allAddress[i]];\n            uint256 selfAchieve = achievements[player.index];\n            selfAchieve = selfAchieve.add(player.invest);\n            if(player.parent == ZERO_ADDR) {\n                continue;\n            }\n            Player memory parent = allPlayers[player.parent];\n            achievements[parent.index] = achievements[parent.index].add(selfAchieve);\n        }\n        delete addressV1;\n        delete addressV2;\n        delete addressV3;\n        delete addressV4;\n        delete addressV5;\n        for(uint i=0; i\u003callAddress.length; i++) {\n            Player memory player = allPlayers[allAddress[i]];\n            if(player.self == ZERO_ADDR || player.sons \u003c 2 || achievements[player.index] \u003c 300 ether){\n                continue;\n            }\n            uint256 maxAchieve = 0;\n            uint256 minAchieve = 0;\n            for(uint j=i; j\u003callAddress.length; j++) {\n                Player memory son = allPlayers[allAddress[j]];\n                if(son.parent == player.self \u0026\u0026 maxAchieve \u003c (achievements[son.index].add(son.invest))) {\n                    maxAchieve = achievements[son.index].add(son.invest);\n                }\n            }\n            minAchieve = achievements[player.index].sub(maxAchieve).add(player.invest);\n\n            if(maxAchieve \u003e= 2000 ether \u0026\u0026 minAchieve \u003e= 4000 ether) {\n                addressV5.push(player.self);\n                continue;\n            }\n            if(maxAchieve \u003e= 1000 ether \u0026\u0026 minAchieve \u003e= 2000 ether) {\n                addressV4.push(player.self);\n                continue;\n            }\n            if(maxAchieve \u003e= 500 ether \u0026\u0026 minAchieve \u003e= 1000 ether) {\n                addressV3.push(player.self);\n                continue;\n            }\n            if(maxAchieve \u003e= 200 ether \u0026\u0026 minAchieve \u003e= 400 ether) {\n                addressV2.push(player.self);\n                continue;\n            }\n            if(maxAchieve \u003e= 100 ether \u0026\u0026 minAchieve \u003e= 200 ether) {\n                addressV1.push(player.self);\n                continue;\n            }\n        }\n        uint256 bonusV1 = 0;\n        uint256 bonusV2 = 0;\n        uint256 bonusV3 = 0;\n        uint256 bonusV4 = 0;\n        uint256 bonusV5 = 0;\n        if((addressV1.length + addressV2.length + addressV3.length + addressV4.length + addressV5.length) \u003e0) {\n            bonusV1 = _dailyInvest.div(25).div(addressV1.length + addressV2.length + addressV3.length + addressV4.length + addressV5.length);\n            for(uint i=0; i\u003caddressV1.length; i++) {\n                Player memory player = allPlayers[addressV1[i]];\n                investBonus(player.self, bonusV1, true, 0);\n            }\n        }\n        if((addressV2.length + addressV3.length + addressV4.length + addressV5.length) \u003e0) {\n            bonusV2 = _dailyInvest.mul(3).div(100).div(addressV2.length + addressV3.length + addressV4.length + addressV5.length).add(bonusV1);\n            for(uint i=0; i\u003caddressV2.length; i++) {\n                Player memory player = allPlayers[addressV2[i]];\n                investBonus(player.self, bonusV2, true, 0);\n\n            }\n        }\n        if((addressV3.length + addressV4.length + addressV5.length) \u003e0) {\n            bonusV3 = _dailyInvest.div(50).div(addressV3.length + addressV4.length + addressV5.length).add(bonusV2);\n            for(uint i=0; i\u003caddressV3.length; i++) {\n                Player memory player = allPlayers[addressV3[i]];\n                investBonus(player.self, bonusV3, true, 0);\n            }\n        }\n        if((addressV4.length + addressV5.length) \u003e0) {\n            bonusV4 = _dailyInvest.div(50).div(addressV4.length + addressV5.length).add(bonusV3);\n            for(uint i=0; i\u003caddressV4.length; i++) {\n                Player memory player = allPlayers[addressV4[i]];\n                investBonus(player.self, bonusV4, true, 0);\n            }\n        }\n        if(addressV5.length \u003e0) {\n            bonusV5 = _dailyInvest.div(100).div(addressV5.length).add(bonusV4);\n            for(uint i=0; i\u003caddressV5.length; i++) {\n                Player memory player = allPlayers[addressV5[i]];\n                investBonus(player.self, bonusV5, true, 0);\n            }\n        }\n    }\n\n    function lottery() internal {\n        uint luckNum = dailyPlayers.length;\n        if (luckNum \u003e= 10) {\n            luckNum = 10;\n        }\n        address[] memory luckyDogs = new address[](luckNum);\n        uint[] memory luckyAmounts = new uint[](luckNum);\n        if (luckNum \u003c= 10) {\n            for(uint i=0; i\u003cluckNum; i++) {\n                luckyDogs[i] = dailyPlayers[i];\n            }\n        } else {\n            for(uint i= 0; i\u003cluckNum; i++){\n                uint random = getRandom(dailyPlayers.length);\n                luckyDogs[i] = dailyPlayers[random];\n                delete dailyPlayers[random];\n            }\n        }\n        uint totalRandom = 0;\n        for(uint i=0; i\u003cluckNum; i++){\n            luckyAmounts[i] = getRandom(50).add(1);\n            totalRandom = totalRandom.add(luckyAmounts[i]);\n        }\n        uint256 lotteryAmount = 0;\n        uint256 luckyPool = _dailyInvest.div(100);\n        for(uint i=0; i\u003cluckNum; i++){\n            lotteryAmount = luckyAmounts[i].mul(luckyPool).div(totalRandom);\n            investBonus(luckyDogs[i], lotteryAmount, false ,0);\n            emit logLucky(luckyDogs[i], lotteryAmount, now, 1);\n        }\n    }\n\n    function wLuckyDog(uint dayAmount) public view returns(address,uint256) {\n        uint256[] memory achievements = new uint256[](allAddress.length);\n        uint weekround = lockedRound.length-dayAmount;\n        uint256 maxAchieve = 0;\n        address targetAddress = ZERO_ADDR;\n        uint256 luckyAmount = 0;\n        for(uint i=investCount-1; i\u003e0; i--) {\n            if(investments[i].round \u003c weekround) {\n                break;\n            }\n            if(investments[i].round == lockedRound.length) {\n                continue;\n            }\n            address selfAddr = investments[i].self;\n            Player memory player = allPlayers[selfAddr];\n            uint256 selfAchieve = achievements[player.index].add(investments[i].amount);\n            if(selfAchieve\u003e=maxAchieve) {\n                targetAddress = selfAddr;\n                maxAchieve = selfAchieve;\n            }\n            luckyAmount = luckyAmount.add(investments[i].amount.div(100));\n        }\n        return (targetAddress,luckyAmount);\n    }\n\n    function mLuckyDog(uint dayAmount) public view returns(address,uint256) {\n        uint256[] memory sons = new uint256[](allAddress.length);\n        uint monthlyRound = lockedRound.length-dayAmount;\n        uint256 max = 0;\n        address targetAddress = ZERO_ADDR;\n        uint256 luckyAmount = 0;\n        for(uint i=investCount-1; i\u003e0; i--) {\n            if(investments[i].round \u003c monthlyRound) {\n                break;\n            }\n            if(investments[i].round == lockedRound.length) {\n                continue;\n            }\n            luckyAmount = luckyAmount.add(investments[i].amount.div(100));\n            if(!investments[i].firstFlag) {\n                continue;\n            }\n            Player memory player = allPlayers[investments[i].self];\n            Player memory parent = allPlayers[player.parent];\n            sons[parent.index] = sons[parent.index].add(1);\n\n            if(sons[parent.index]\u003e=max) {\n                targetAddress = parent.self;\n                max = sons[parent.index];\n            }\n        }\n        return (targetAddress,luckyAmount);\n    }\n\n\n    function wWinner(uint gaps) onlyAdmin() public {\n        (address weeklyWinner, uint256 weeklyAmount) = wLuckyDog(gaps);\n        investBonus(weeklyWinner, weeklyAmount, false ,0);\n        emit logLucky(weeklyWinner, weeklyAmount, now, 2);\n    }\n\n\n    function mWinner(uint gaps) onlyAdmin() public {\n        (address monthlyWinner, uint256 monthlyAmount) = mLuckyDog(gaps);\n        investBonus(monthlyWinner, monthlyAmount, false ,0);\n        emit logLucky(monthlyWinner, monthlyAmount, now, 3);\n    }\n\n\n    // fomo\n    function fomo() internal {\n        uint256 amount = 0;\n        for(uint i=investCount-1; i\u003e0; i--) {\n            if(_safePool\u003c=0) {\n                if(now.sub(_endTime).div(1 days)\u003e5) {\n                    _safeIndex = i+2;\n                    _endTime = now;\n                    _active = false;\n                }\n                break;\n            }\n            if(i == investCount-1) {\n                amount = _safePool.div(5);\n                investBonus(investments[i].self, amount, false, 0);\n            } else {\n                amount = investments[i].amount;\n                if(amount \u003e _safePool) {\n                    amount = _safePool;\n                }\n            }\n            _safePool = _safePool.sub(amount);\n        }\n    }\n\n    function futureGame() public onlyAdmin() {\n        bool retreatFlag = saveRound();\n        if(retreatFlag) {\n            fomo();\n            if(now.sub(_endTime).div(1 days) \u003e3) {\n                msg.sender.transfer(address(this).balance);\n            }\n            return ;\n        }\n        fund();\n        lottery();\n        // calc too hard for one time.\n        calcGlory();\n        _dailyInvest = 0;\n        delete dailyPlayers;\n    }\n\n    // calc too hard for one time\n    function awardToGlory() public onlyAdmin() {\n        calcGlory();\n    }\n\n    function fund() internal {\n        address payable fundAddr = address(0xE6369df7A8a9A4d0bD8Da06b2E10303AB083FD83);\n        if(_dailyInvest \u003e 0) {\n            fundAddr.transfer(_dailyInvest.div(10));\n        }\n    }\n\n\n    function querySafety(address target) public view returns(uint256) {\n        uint256 amount = 0;\n        for (uint i = investCount-2; i \u003e= _safeIndex; i--){\n            if(investments[i].self == target) {\n                amount = amount.add(investments[i].amount);\n            }\n        }\n        return amount;\n    }\n\n    function withdraw() public {\n        Player storage user = allPlayers[msg.sender];\n        uint256 totalBonus = 0;\n        uint256 withdrawBonus = 0;\n        bool outFlag;\n        (totalBonus, withdrawBonus, outFlag) = calcBonus(user.self);\n\n        uint256 safety = 0;\n        if(!_active \u0026\u0026 user.invest\u003e0) {\n            safety = querySafety(msg.sender);\n            user.invest = 0;\n        }\n        \n        if(outFlag) {\n            user.totalBonus = 0;\n            user.invest = 0;\n        }else {\n            user.totalBonus = totalBonus;\n        }\n\n        user.round = lockedRound.length;\n        user.bonus = 0;\n        msg.sender.transfer(withdrawBonus.add(safety));\n        emit logWithDraw(msg.sender, withdrawBonus.add(safety), now);\n    }\n\n\n    function investBonus(address targetAddr, uint256 wwin, bool totalFlag, uint addson)\n    internal {\n        if(targetAddr == ZERO_ADDR || allPlayers[targetAddr].invest == 0 || wwin == 0) return;\n        Player storage target = allPlayers[targetAddr];\n        target.bonus = target.bonus.add(wwin);\n        if(addson != 0) target.sons = target.sons+1;\n        if(totalFlag) target.totalBonus = target.totalBonus.add(wwin);\n    }\n\n    function isStart() public view returns(bool) {\n        return _startTime != 0 \u0026\u0026 now \u003e _startTime;\n    }\n\n    function userInfo(address payable target)\n    public view returns (address, address, address, uint256, uint256, uint256, uint, uint){\n        Player memory self = allPlayers[target];\n        Player memory parent = allPlayers[self.parent];\n        Player memory grand = allPlayers[parent.parent];\n        Player memory great = allPlayers[grand.parent];\n        return (parent.self, grand.self, great.self,\n        self.bonus, self.totalBonus, self.invest, self.sons, self.round);\n    }\n\n\n    function future(address player, address parent, uint256 amount)\n    public payable {\n        // require game is not start. \n        require(!isStart(), \"Game Not Start Limit\");\n        require(player == msg.sender, \"only limit\");\n        Player storage self = allPlayers[player];\n        if(self.index == 0){\n            return;\n        }else{\n            investments[investCount] = Investment(msg.sender,msg.value,now,lockedRound.length-1,false);\n            self.invest = amount;\n            self.parent = parent;\n            investCount=investCount.add(1);\n        }\n    }\n\n\n    function getRandom(uint max)\n    internal returns(uint) {\n        _rand = _rand.add(1);\n        uint rand = _rand*_rand;\n        uint random = uint(keccak256(abi.encodePacked(block.difficulty, now, msg.sender, rand)));\n        return random % max;\n    }\n\n\n    function start(uint time) external onlyAdmin() {\n        require(time \u003e now, \"Invalid Time\");\n        _startTime = time;\n    }\n}"},"FutureBase.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract FutureBase {\n    \n    struct Player {\n        address self;\n        address parent;\n        uint256 bonus;\n        uint256 totalBonus;\n        uint256 invest;\n        uint sons;\n        uint round;\n        uint index;\n    }\n\n    struct Investment {\n        address self;\n        uint amount;\n        uint time;\n        uint round;\n        bool firstFlag;\n    }\n\n    event logRandom(uint256 random, uint timestamp);\n\n    event logLucky(address indexed target, uint256 money, uint timestamp, uint types);\n\n    event logUserInvest(address indexed playerAddress, address indexed parentAddress, bool firstFlag, uint256 money, uint timestamp);\n\n    event logWithDraw(address indexed playerAddress, uint256 money, uint timestamp);\n\n    event logFomo(address indexed target, uint256 money);\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n}\n"}}