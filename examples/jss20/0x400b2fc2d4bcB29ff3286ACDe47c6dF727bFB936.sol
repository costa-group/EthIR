{"MToken.sol":{"content":"import \"./StandardToken.sol\";\r\npragma solidity ^0.4.8;\r\ncontract MToken is StandardToken {\r\n    /* Public variables of the token */\r\n    string public name;                   //名称: eg Davie\r\n    uint8 public decimals;                //最多的小数位数How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u0027s like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //token简称: eg DAC\r\n    string public version = \u0027H0.1\u0027;       //版本\r\n\r\n    function MToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol,address owner) {\r\n        balances[owner] = _initialAmount; // 初始token数量给予消息发送者\r\n        totalSupply = _initialAmount;         // 设置初始总量\r\n        name = _tokenName;                   // token名称\r\n        decimals = _decimalUnits;           // 小数位数\r\n        symbol = _tokenSymbol;             // token简称\r\n    }\r\n   \r\n}"},"StandardToken.sol":{"content":"pragma solidity ^0.4.8;\r\nimport \"./Token.sol\";\r\ncontract StandardToken is Token {\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Ĭ��totalSupply ���ᳬ�����ֵ (2^256 - 1).\r\n        //�������ʱ������ƽ������µ�token���ɣ������������������������쳣\r\n        //require(balances[msg.sender] \u003e= _value \u0026\u0026 balances[_to] + _value \u003ebalances[_to]);\r\n        require(balances[msg.sender] \u003e= _value);\r\n        balances[msg.sender] -= _value;//����Ϣ�������˻��м�ȥtoken����_value\r\n        balances[_to] += _value;//�������˻�����token����_value\r\n        Transfer(msg.sender, _to, _value);//����ת�ҽ����¼�\r\n        return true;\r\n    }\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //require(balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e= _value \u0026\u0026 balances[_to] + _value \u003e balances[_to]);\r\n        require(balances[_from] \u003e= _value \u0026\u0026 allowed[_from][msg.sender] \u003e=  _value);\r\n        balances[_to] += _value;//�����˻�����token����_value\r\n        balances[_from] -= _value;//֧���˻�_from��ȥtoken����_value\r\n        allowed[_from][msg.sender] -= _value;//��Ϣ�����߿��Դ��˻�_from��ת������������_value\r\n        Transfer(_from, _to, _value);//����ת�ҽ����¼�\r\n        return true;\r\n    }\r\n    //��ѯ���\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n    //��Ȩ�˻�_spender���Դ���Ϣ�������˻�ת������Ϊ_value��token\r\n    function approve(address _spender, uint256 _value) returns (bool success)   \r\n    {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];//����_spender��_owner��ת����token��\r\n    }\r\n\r\n    mapping (address =\u003e uint256) balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) allowed;\r\n}"},"Token.sol":{"content":"pragma solidity ^0.4.8;\r\ncontract Token {\r\n    /// token总量，默认会为public变量生成一个getter函数接口，名称为totalSupply().\r\n    uint256 public totalSupply;\r\n\r\n    /// 获取账户_owner拥有token的数量\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n\r\n    //从消息发送者账户中往_to账户转数量为_value的token\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n\r\n    //从账户_from中往账户_to转数量为_value的token，与approve方法配合使用\r\n    function transferFrom(address _from, address _to, uint256 _value) returns  (bool success);\r\n\r\n    //消息发送账户设置账户_spender能从发送账户中转出数量为_value的token\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n\r\n    //获取账户_spender可以从账户_owner中转出token的数量\r\n    function allowance(address _owner, address _spender) constant returns  (uint256 remaining);\r\n\r\n    //发生转账时必须要触发的事件 \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    //当函数approve(address _spender, uint256 _value)成功执行时必须触发的事件\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}"}}