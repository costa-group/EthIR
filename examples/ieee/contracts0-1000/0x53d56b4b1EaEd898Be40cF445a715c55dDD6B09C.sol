{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ContractRegistryAccessor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IContractRegistry.sol\";\nimport \"./WithClaimableRegistryManagement.sol\";\nimport \"./Initializable.sol\";\n\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\n\n    IContractRegistry private contractRegistry;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\n        setContractRegistry(_contractRegistry);\n        _transferRegistryManagement(_registryAdmin);\n    }\n\n    modifier onlyAdmin {\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\n\n        _;\n    }\n\n    function isManager(string memory role) internal view returns (bool) {\n        IContractRegistry _contractRegistry = contractRegistry;\n        return isAdmin() || _contractRegistry != IContractRegistry(0) \u0026\u0026 contractRegistry.getManager(role) == msg.sender;\n    }\n\n    function isAdmin() internal view returns (bool) {\n        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);\n    }\n\n    function getProtocolContract() internal view returns (address) {\n        return contractRegistry.getContract(\"protocol\");\n    }\n\n    function getStakingRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewards\");\n    }\n\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\n    }\n\n    function getCommitteeContract() internal view returns (address) {\n        return contractRegistry.getContract(\"committee\");\n    }\n\n    function getElectionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"elections\");\n    }\n\n    function getDelegationsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"delegations\");\n    }\n\n    function getGuardiansRegistrationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"guardiansRegistration\");\n    }\n\n    function getCertificationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"certification\");\n    }\n\n    function getStakingContract() internal view returns (address) {\n        return contractRegistry.getContract(\"staking\");\n    }\n\n    function getSubscriptionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"subscriptions\");\n    }\n\n    function getStakingRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\n    }\n\n    function getBootstrapRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\n    }\n\n    function getGeneralFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"generalFeesWallet\");\n    }\n\n    function getCertifiedFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\n    }\n\n    function getStakingContractHandler() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingContractHandler\");\n    }\n\n    /*\n    * Governance functions\n    */\n\n    event ContractRegistryAddressUpdated(address addr);\n\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\n        contractRegistry = newContractRegistry;\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n    }\n\n    function getContractRegistry() public view returns (IContractRegistry) {\n        return contractRegistry;\n    }\n\n}\n"},"Delegations.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./SafeMath.sol\";\nimport \"./SafeMath96.sol\";\nimport \"./IElections.sol\";\nimport \"./IDelegation.sol\";\nimport \"./IStakeChangeNotifier.sol\";\nimport \"./IStakingContractHandler.sol\";\nimport \"./IStakingRewards.sol\";\nimport \"./ManagedContract.sol\";\n\ncontract Delegations is IDelegations, IStakeChangeNotifier, ManagedContract {\n\tusing SafeMath for uint256;\n\tusing SafeMath96 for uint96;\n\n\taddress constant public VOID_ADDR = address(-1);\n\n\tstruct StakeOwnerData {\n\t\taddress delegation;\n\t\tuint96 stake;\n\t}\n\tmapping(address =\u003e StakeOwnerData) public stakeOwnersData;\n\tmapping(address =\u003e uint256) public uncappedDelegatedStake;\n\n\tuint256 totalDelegatedStake;\n\n\tstruct DelegateStatus {\n\t\taddress addr;\n\t\tuint256 uncappedDelegatedStake;\n\t\tbool isSelfDelegating;\n\t\tuint256 delegatedStake;\n\t\tuint96 selfDelegatedStake;\n\t}\n\n\tconstructor(IContractRegistry _contractRegistry, address _registryAdmin) ManagedContract(_contractRegistry, _registryAdmin) public {\n\t\taddress VOID_ADDRESS_DUMMY_DELEGATION = address(-2);\n\t\tassert(VOID_ADDR != VOID_ADDRESS_DUMMY_DELEGATION \u0026\u0026 VOID_ADDR != address(0) \u0026\u0026 VOID_ADDRESS_DUMMY_DELEGATION != address(0));\n\t\tstakeOwnersData[VOID_ADDR].delegation = VOID_ADDRESS_DUMMY_DELEGATION;\n\t}\n\n\tmodifier onlyStakingContractHandler() {\n\t\trequire(msg.sender == address(stakingContractHandler), \"caller is not the staking contract handler\");\n\n\t\t_;\n\t}\n\n\t/*\n\t* External functions\n\t*/\n\n\tfunction delegate(address to) external override onlyWhenActive {\n\t\tdelegateFrom(msg.sender, to);\n\t}\n\n\tfunction getDelegation(address addr) external override view returns (address) {\n\t\treturn getStakeOwnerData(addr).delegation;\n\t}\n\n\tfunction getDelegationInfo(address addr) external override view returns (address delegation, uint256 delegatorStake) {\n\t\tStakeOwnerData memory data = getStakeOwnerData(addr);\n\t\treturn (data.delegation, data.stake);\n\t}\n\n\tfunction getDelegatedStake(address addr) external override view returns (uint256) {\n\t\treturn getDelegateStatus(addr).delegatedStake;\n\t}\n\n\tfunction getTotalDelegatedStake() external override view returns (uint256) {\n\t\treturn totalDelegatedStake;\n\t}\n\n\tfunction refreshStake(address addr) external override onlyWhenActive {\n\t\t_stakeChange(addr, stakingContractHandler.getStakeBalanceOf(addr));\n\t}\n\n\t/*\n\t* Notifications from staking contract\n\t*/\n\n\tfunction stakeChange(address _stakeOwner, uint256, bool, uint256 _updatedStake) external override onlyStakingContractHandler onlyWhenActive {\n\t\t_stakeChange(_stakeOwner, _updatedStake);\n\t}\n\n\tfunction stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs, uint256[] calldata _updatedStakes) external override onlyStakingContractHandler onlyWhenActive {\n\t\tuint batchLength = _stakeOwners.length;\n\t\trequire(batchLength == _amounts.length, \"_stakeOwners, _amounts - array length mismatch\");\n\t\trequire(batchLength == _signs.length, \"_stakeOwners, _signs - array length mismatch\");\n\t\trequire(batchLength == _updatedStakes.length, \"_stakeOwners, _updatedStakes - array length mismatch\");\n\n\t\tfor (uint i = 0; i \u003c _stakeOwners.length; i++) {\n\t\t\t_stakeChange(_stakeOwners[i], _updatedStakes[i]);\n\t\t}\n\t}\n\n\tfunction stakeMigration(address _stakeOwner, uint256 _amount) external override onlyStakingContractHandler onlyWhenActive {}\n\n\t/*\n\t* Governance functions\n\t*/\n\n\tfunction importDelegations(address[] calldata from, address to) external override onlyInitializationAdmin {\n\t\trequire(to != address(0), \"to must be a non zero address\");\n\t\trequire(from.length \u003e 0, \"from array must contain at least one address\");\n\t\t(uint96 stakingRewardsPerWeight, ) = stakingRewardsContract.getStakingRewardsState();\n\t\trequire(stakingRewardsPerWeight == 0, \"no rewards may be allocated prior to importing delegations\");\n\n\t\tuint256 uncappedDelegatedStakeDelta = 0;\n\t\tStakeOwnerData memory data;\n\t\tuint256 newTotalDelegatedStake = totalDelegatedStake;\n\t\tDelegateStatus memory delegateStatus = getDelegateStatus(to);\n\t\tIStakingContractHandler _stakingContractHandler = stakingContractHandler;\n\t\tuint256 delegatorUncapped;\n\t\tuint256[] memory delegatorsStakes = new uint256[](from.length);\n\t\tfor (uint i = 0; i \u003c from.length; i++) {\n\t\t\tdata = stakeOwnersData[from[i]];\n\t\t\trequire(data.delegation == address(0), \"import allowed only for uninitialized accounts. existing delegation detected\");\n\t\t\trequire(from[i] != to, \"import cannot be used for self-delegation (already self delegated)\");\n\t\t\trequire(data.stake == 0 , \"import allowed only for uninitialized accounts. existing stake detected\");\n\n\t\t\t// from[i] stops being self delegating. any uncappedDelegatedStake it has now stops being counted towards totalDelegatedStake\n\t\t\tdelegatorUncapped = uncappedDelegatedStake[from[i]];\n\t\t\tif (delegatorUncapped \u003e 0) {\n\t\t\t\tnewTotalDelegatedStake = newTotalDelegatedStake.sub(delegatorUncapped);\n\t\t\t\temit DelegatedStakeChanged(\n\t\t\t\t\tfrom[i],\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tfrom[i],\n\t\t\t\t\t0\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// update state\n\t\t\tdata.delegation = to;\n\t\t\tdata.stake = uint96(_stakingContractHandler.getStakeBalanceOf(from[i]));\n\t\t\tstakeOwnersData[from[i]] = data;\n\n\t\t\tuncappedDelegatedStakeDelta = uncappedDelegatedStakeDelta.add(data.stake);\n\n\t\t\t// store individual stake for event\n\t\t\tdelegatorsStakes[i] = data.stake;\n\n\t\t\temit Delegated(from[i], to);\n\n\t\t\temit DelegatedStakeChanged(\n\t\t\t\tto,\n\t\t\t\tdelegateStatus.selfDelegatedStake,\n\t\t\t\tdelegateStatus.isSelfDelegating ? delegateStatus.delegatedStake.add(uncappedDelegatedStakeDelta) : 0,\n\t\t\t\tfrom[i],\n\t\t\t\tdata.stake\n\t\t\t);\n\t\t}\n\n\t\t// update totals\n\t\tuncappedDelegatedStake[to] = uncappedDelegatedStake[to].add(uncappedDelegatedStakeDelta);\n\n\t\tif (delegateStatus.isSelfDelegating) {\n\t\t\tnewTotalDelegatedStake = newTotalDelegatedStake.add(uncappedDelegatedStakeDelta);\n\t\t}\n\t\ttotalDelegatedStake = newTotalDelegatedStake;\n\n\t\t// emit events\n\t\temit DelegationsImported(from, to);\n\t}\n\n\tfunction initDelegation(address from, address to) external override onlyInitializationAdmin {\n\t\tdelegateFrom(from, to);\n\t\temit DelegationInitialized(from, to);\n\t}\n\n\t/*\n\t* Private functions\n\t*/\n\n\tfunction getDelegateStatus(address addr) private view returns (DelegateStatus memory status) {\n\t\tStakeOwnerData memory data = getStakeOwnerData(addr);\n\n\t\tstatus.addr = addr;\n\t\tstatus.uncappedDelegatedStake = uncappedDelegatedStake[addr];\n\t\tstatus.isSelfDelegating = data.delegation == addr;\n\t\tstatus.selfDelegatedStake = status.isSelfDelegating ? data.stake : 0;\n\t\tstatus.delegatedStake = status.isSelfDelegating ? status.uncappedDelegatedStake : 0;\n\n\t\treturn status;\n\t}\n\n\tfunction getStakeOwnerData(address addr) private view returns (StakeOwnerData memory data) {\n\t\tdata = stakeOwnersData[addr];\n\t\tdata.delegation = (data.delegation == address(0)) ? addr : data.delegation;\n\t\treturn data;\n\t}\n\n\tstruct DelegateFromVars {\n\t\tDelegateStatus prevDelegateStatusBefore;\n\t\tDelegateStatus newDelegateStatusBefore;\n\t\tDelegateStatus prevDelegateStatusAfter;\n\t\tDelegateStatus newDelegateStatusAfter;\n\t}\n\n\tfunction delegateFrom(address from, address to) private {\n\t\trequire(to != address(0), \"cannot delegate to a zero address\");\n\n\t\tDelegateFromVars memory vars;\n\n\t\tStakeOwnerData memory delegatorData = getStakeOwnerData(from);\n\n\t\t// Optimization - no need for the full flow in the case of a zero staked delegator with no delegations\n\t\tif (delegatorData.stake == 0 \u0026\u0026 uncappedDelegatedStake[from] == 0) {\n\t\t\tstakeOwnersData[from].delegation = to;\n\t\t\temit Delegated(from, to);\n\t\t\treturn;\n\t\t}\n\n\t\taddress prevDelegate = delegatorData.delegation;\n\n\t\tvars.prevDelegateStatusBefore = getDelegateStatus(prevDelegate);\n\t\tvars.newDelegateStatusBefore = getDelegateStatus(to);\n\n\t\tstakingRewardsContract.delegationWillChange(prevDelegate, vars.prevDelegateStatusBefore.delegatedStake, from, delegatorData.stake, to, vars.newDelegateStatusBefore.delegatedStake);\n\n\t\tstakeOwnersData[from].delegation = to;\n\n\t\tuint256 delegatorStake = delegatorData.stake;\n\n\t\tuncappedDelegatedStake[prevDelegate] = vars.prevDelegateStatusBefore.uncappedDelegatedStake.sub(delegatorStake);\n\t\tuncappedDelegatedStake[to] = vars.newDelegateStatusBefore.uncappedDelegatedStake.add(delegatorStake);\n\n\t\tvars.prevDelegateStatusAfter = getDelegateStatus(prevDelegate);\n\t\tvars.newDelegateStatusAfter = getDelegateStatus(to);\n\n\t\tuint256 _totalDelegatedStake = totalDelegatedStake.sub(\n\t\t\tvars.prevDelegateStatusBefore.delegatedStake\n\t\t).add(\n\t\t\tvars.prevDelegateStatusAfter.delegatedStake\n\t\t).sub(\n\t\t\tvars.newDelegateStatusBefore.delegatedStake\n\t\t).add(\n\t\t\tvars.newDelegateStatusAfter.delegatedStake\n\t\t);\n\n\t\ttotalDelegatedStake = _totalDelegatedStake;\n\n\t\temit Delegated(from, to);\n\n\t\tIElections _electionsContract = electionsContract;\n\n\t\tif (vars.prevDelegateStatusBefore.delegatedStake != vars.prevDelegateStatusAfter.delegatedStake) {\n\t\t\t_electionsContract.delegatedStakeChange(\n\t\t\t\tprevDelegate,\n\t\t\t\tvars.prevDelegateStatusAfter.selfDelegatedStake,\n\t\t\t\tvars.prevDelegateStatusAfter.delegatedStake,\n\t\t\t\t_totalDelegatedStake\n\t\t\t);\n\n\t\t\temit DelegatedStakeChanged(\n\t\t\t\tprevDelegate,\n\t\t\t\tvars.prevDelegateStatusAfter.selfDelegatedStake,\n\t\t\t\tvars.prevDelegateStatusAfter.delegatedStake,\n\t\t\t\tfrom,\n\t\t\t\t0\n\t\t\t);\n\t\t}\n\n\t\tif (vars.newDelegateStatusBefore.delegatedStake != vars.newDelegateStatusAfter.delegatedStake) {\n\t\t\t_electionsContract.delegatedStakeChange(\n\t\t\t\tto,\n\t\t\t\tvars.newDelegateStatusAfter.selfDelegatedStake,\n\t\t\t\tvars.newDelegateStatusAfter.delegatedStake,\n\t\t\t\t_totalDelegatedStake\n\t\t\t);\n\n\t\t\temit DelegatedStakeChanged(\n\t\t\t\tto,\n\t\t\t\tvars.newDelegateStatusAfter.selfDelegatedStake,\n\t\t\t\tvars.newDelegateStatusAfter.delegatedStake,\n\t\t\t\tfrom,\n\t\t\t\tdelegatorStake\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction _stakeChange(address _stakeOwner, uint256 _updatedStake) private {\n\t\tStakeOwnerData memory stakeOwnerDataBefore = getStakeOwnerData(_stakeOwner);\n\t\tDelegateStatus memory delegateStatusBefore = getDelegateStatus(stakeOwnerDataBefore.delegation);\n\n\t\tuint256 prevUncappedStake = delegateStatusBefore.uncappedDelegatedStake;\n\t\tuint256 newUncappedStake = prevUncappedStake.sub(stakeOwnerDataBefore.stake).add(_updatedStake);\n\n\t\tstakingRewardsContract.delegationWillChange(stakeOwnerDataBefore.delegation, delegateStatusBefore.delegatedStake, _stakeOwner, stakeOwnerDataBefore.stake, stakeOwnerDataBefore.delegation, delegateStatusBefore.delegatedStake);\n\n\t\tuncappedDelegatedStake[stakeOwnerDataBefore.delegation] = newUncappedStake;\n\n\t\trequire(uint256(uint96(_updatedStake)) == _updatedStake, \"Delegations::updatedStakes value too big (\u003e96 bits)\");\n\t\tstakeOwnersData[_stakeOwner].stake = uint96(_updatedStake);\n\n\t\tuint256 _totalDelegatedStake = totalDelegatedStake;\n\t\tif (delegateStatusBefore.isSelfDelegating) {\n\t\t\t_totalDelegatedStake = _totalDelegatedStake.sub(stakeOwnerDataBefore.stake).add(_updatedStake);\n\t\t\ttotalDelegatedStake = _totalDelegatedStake;\n\t\t}\n\n\t\tDelegateStatus memory delegateStatusAfter = getDelegateStatus(stakeOwnerDataBefore.delegation);\n\n\t\telectionsContract.delegatedStakeChange(\n\t\t\tstakeOwnerDataBefore.delegation,\n\t\t\tdelegateStatusAfter.selfDelegatedStake,\n\t\t\tdelegateStatusAfter.delegatedStake,\n\t\t\t_totalDelegatedStake\n\t\t);\n\n\t\tif (_updatedStake != stakeOwnerDataBefore.stake) {\n\t\t\temit DelegatedStakeChanged(\n\t\t\t\tstakeOwnerDataBefore.delegation,\n\t\t\t\tdelegateStatusAfter.selfDelegatedStake,\n\t\t\t\tdelegateStatusAfter.delegatedStake,\n\t\t\t\t_stakeOwner,\n\t\t\t\t_updatedStake\n\t\t\t);\n\t\t}\n\t}\n\n\t/*\n     * Contracts topology / registry interface\n     */\n\n\tIElections electionsContract;\n\tIStakingRewards stakingRewardsContract;\n\tIStakingContractHandler stakingContractHandler;\n\tfunction refreshContracts() external override {\n\t\telectionsContract = IElections(getElectionsContract());\n\t\tstakingContractHandler = IStakingContractHandler(getStakingContractHandler());\n\t\tstakingRewardsContract = IStakingRewards(getStakingRewardsContract());\n\t}\n\n}\n"},"IContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface IContractRegistry {\n\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n\tevent ManagerChanged(string role, address newManager);\n\tevent ContractRegistryUpdated(address newContractRegistry);\n\n\t/*\n\t* External functions\n\t*/\n\n\t/// @dev updates the contracts address and emits a corresponding event\n\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\n\n\t/// @dev returns the current address of the given contracts\n\tfunction getContract(string calldata contractName) external view returns (address);\n\n\t/// @dev returns the list of contract addresses managed by the registry\n\tfunction getManagedContracts() external view returns (address[] memory);\n\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n\n\tfunction getManager(string calldata role) external view returns (address);\n\n\tfunction lockContracts() external /* onlyAdmin */;\n\n\tfunction unlockContracts() external /* onlyAdmin */;\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n\n\tfunction getPreviousContractRegistry() external view returns (address);\n\n}\n"},"IDelegation.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Delegations contract interface\ninterface IDelegations /* is IStakeChangeNotifier */ {\n\n    // Delegation state change events\n\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);\n\n    // Function calls\n\tevent Delegated(address indexed from, address indexed to);\n\n\t/*\n     * External functions\n     */\n\n\t/// @dev Stake delegation\n\tfunction delegate(address to) external /* onlyWhenActive */;\n\n\tfunction refreshStake(address addr) external /* onlyWhenActive */;\n\n\tfunction getDelegatedStake(address addr) external view returns (uint256);\n\n\tfunction getDelegation(address addr) external view returns (address);\n\n\tfunction getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);\n\n\tfunction getTotalDelegatedStake() external view returns (uint256) ;\n\n\t/*\n\t * Governance functions\n\t */\n\n\tevent DelegationsImported(address[] from, address indexed to);\n\n\tevent DelegationInitialized(address indexed from, address indexed to);\n\n\tfunction importDelegations(address[] calldata from, address to) external /* onlyMigrationManager onlyDuringDelegationImport */;\n\n\tfunction initDelegation(address from, address to) external /* onlyInitializationAdmin */;\n}\n"},"IElections.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Elections contract interface\ninterface IElections {\n\t\n\t// Election state change events\n\tevent StakeChanged(address indexed addr, uint256 selfStake, uint256 delegatedStake, uint256 effectiveStake);\n\tevent GuardianStatusUpdated(address indexed guardian, bool readyToSync, bool readyForCommittee);\n\n\t// Vote out / Vote unready\n\tevent GuardianVotedUnready(address indexed guardian);\n\tevent VoteUnreadyCasted(address indexed voter, address indexed subject, uint256 expiration);\n\tevent GuardianVotedOut(address indexed guardian);\n\tevent VoteOutCasted(address indexed voter, address indexed subject);\n\n\t/*\n\t * External functions\n\t */\n\n\t/// @dev Called by a guardian when ready to start syncing with other nodes\n\tfunction readyToSync() external;\n\n\t/// @dev Called by a guardian when ready to join the committee, typically after syncing is complete or after being voted out\n\tfunction readyForCommittee() external;\n\n\t/// @dev Called to test if a guardian calling readyForCommittee() will lead to joining the committee\n\tfunction canJoinCommittee(address guardian) external view returns (bool);\n\n\t/// @dev Returns an address effective stake\n\tfunction getEffectiveStake(address guardian) external view returns (uint effectiveStake);\n\n\t/// @dev returns the current committee\n\t/// used also by the rewards and fees contracts\n\tfunction getCommittee() external view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);\n\n\t// Vote-unready\n\n\t/// @dev Called by a guardian as part of the automatic vote-unready flow\n\tfunction voteUnready(address subject, uint expiration) external;\n\n\tfunction getVoteUnreadyVote(address voter, address subject) external view returns (bool valid, uint256 expiration);\n\n\t/// @dev Returns the current vote-unready status of a subject guardian.\n\t/// votes indicates wether the specific committee member voted the guardian unready\n\tfunction getVoteUnreadyStatus(address subject) external view returns (\n\t\taddress[] memory committee,\n\t\tuint256[] memory weights,\n\t\tbool[] memory certification,\n\t\tbool[] memory votes,\n\t\tbool subjectInCommittee,\n\t\tbool subjectInCertifiedCommittee\n\t);\n\n\t// Vote-out\n\n\t/// @dev Casts a voteOut vote by the sender to the given address\n\tfunction voteOut(address subject) external;\n\n\t/// @dev Returns the subject address the addr has voted-out against\n\tfunction getVoteOutVote(address voter) external view returns (address);\n\n\t/// @dev Returns the governance voteOut status of a guardian.\n\t/// A guardian is voted out if votedStake / totalDelegatedStake (in percent mille) \u003e threshold\n\tfunction getVoteOutStatus(address subject) external view returns (bool votedOut, uint votedStake, uint totalDelegatedStake);\n\n\t/*\n\t * Notification functions from other PoS contracts\n\t */\n\n\t/// @dev Called by: delegation contract\n\t/// Notifies a delegated stake change event\n\t/// total_delegated_stake = 0 if addr delegates to another guardian\n\tfunction delegatedStakeChange(address delegate, uint256 selfStake, uint256 delegatedStake, uint256 totalDelegatedStake) external /* onlyDelegationsContract onlyWhenActive */;\n\n\t/// @dev Called by: guardian registration contract\n\t/// Notifies a new guardian was unregistered\n\tfunction guardianUnregistered(address guardian) external /* onlyGuardiansRegistrationContract */;\n\n\t/// @dev Called by: guardian registration contract\n\t/// Notifies on a guardian certification change\n\tfunction guardianCertificationChanged(address guardian, bool isCertified) external /* onlyCertificationContract */;\n\n\n\t/*\n     * Governance functions\n\t */\n\n\tevent VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);\n\tevent VoteOutPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\n\tevent VoteUnreadyPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\n\tevent MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);\n\n\t/// @dev Sets the minimum self-stake required for the effective stake\n\t/// minSelfStakePercentMille - the minimum self stake in percent-mille (0-100,000)\n\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external /* onlyFunctionalManager onlyWhenActive */;\n\n\t/// @dev Returns the minimum self-stake required for the effective stake\n\tfunction getMinSelfStakePercentMille() external view returns (uint32);\n\n\t/// @dev Sets the vote-out threshold\n\t/// voteOutPercentMilleThreshold - the minimum threshold in percent-mille (0-100,000)\n\tfunction setVoteOutPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external /* onlyFunctionalManager onlyWhenActive */;\n\n\t/// @dev Returns the vote-out threshold\n\tfunction getVoteOutPercentMilleThreshold() external view returns (uint32);\n\n\t/// @dev Sets the vote-unready threshold\n\t/// voteUnreadyPercentMilleThreshold - the minimum threshold in percent-mille (0-100,000)\n\tfunction setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external /* onlyFunctionalManager onlyWhenActive */;\n\n\t/// @dev Returns the vote-unready threshold\n\tfunction getVoteUnreadyPercentMilleThreshold() external view returns (uint32);\n\n\t/// @dev Returns the contract\u0027s settings \n\tfunction getSettings() external view returns (\n\t\tuint32 minSelfStakePercentMille,\n\t\tuint32 voteUnreadyPercentMilleThreshold,\n\t\tuint32 voteOutPercentMilleThreshold\n\t);\n\n\tfunction initReadyForCommittee(address[] calldata guardians) external /* onlyInitializationAdmin */;\n\n}\n\n"},"ILockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface ILockable {\n\n    event Locked();\n    event Unlocked();\n\n    function lock() external /* onlyLockOwner */;\n    function unlock() external /* onlyLockOwner */;\n    function isLocked() view external returns (bool);\n\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ncontract Initializable {\n\n    address private _initializationAdmin;\n\n    event InitializationComplete();\n\n    constructor() public{\n        _initializationAdmin = msg.sender;\n    }\n\n    modifier onlyInitializationAdmin() {\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function initializationAdmin() public view returns (address) {\n        return _initializationAdmin;\n    }\n\n    function initializationComplete() external onlyInitializationAdmin {\n        _initializationAdmin = address(0);\n        emit InitializationComplete();\n    }\n\n    function isInitializationComplete() public view returns (bool) {\n        return _initializationAdmin == address(0);\n    }\n\n}"},"IStakeChangeNotifier.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\ninterface IStakeChangeNotifier {\n    /// @dev Notifies of stake change event.\n    /// @param _stakeOwner address The address of the subject stake owner.\n    /// @param _amount uint256 The difference in the total staked amount.\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\n    /// @param _updatedStake uint256 The updated total staked amount.\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\n\n    /// @dev Notifies of multiple stake change events.\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\n    /// @param _amounts uint256[] The differences in total staked amounts.\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\n        uint256[] calldata _updatedStakes) external;\n\n    /// @dev Notifies of stake migration event.\n    /// @param _stakeOwner address The address of the subject stake owner.\n    /// @param _amount uint256 The migrated amount.\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\n}\n"},"IStakingContractHandler.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title An interface for staking contracts.\ninterface IStakingContractHandler {\n    event StakeChangeNotificationSkipped(address indexed stakeOwner);\n    event StakeChangeBatchNotificationSkipped(address[] stakeOwners);\n    event StakeMigrationNotificationSkipped(address indexed stakeOwner);\n\n    /*\n    * External functions\n    */\n\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\n    /// @param _stakeOwner address The address to check.\n    /// @return uint256 The total stake.\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\n\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\n    /// @return uint256 The total staked tokens of all stake owners.\n    function getTotalStakedTokens() external view returns (uint256);\n\n    /*\n    * Governance functions\n    */\n\n    event NotifyDelegationsChanged(bool notifyDelegations);\n\n    function setNotifyDelegations(bool notifyDelegations) external; /* onlyMigrationManager */\n\n    function getNotifyDelegations() external returns (bool);\n}\n"},"IStakingRewards.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Staking rewards contract interface\ninterface IStakingRewards {\n\n    event DelegatorStakingRewardsAssigned(address indexed delegator, uint256 amount, uint256 totalAwarded, address guardian, uint256 delegatorRewardsPerToken);\n    event GuardianStakingRewardsAssigned(address indexed guardian, uint256 amount, uint256 totalAwarded, uint256 delegatorRewardsPerToken, uint256 stakingRewardsPerWeight);\n    event StakingRewardsClaimed(address indexed addr, uint256 claimedDelegatorRewards, uint256 claimedGuardianRewards, uint256 totalClaimedDelegatorRewards, uint256 totalClaimedGuardianRewards);\n    event StakingRewardsAllocated(uint256 allocatedRewards, uint256 stakingRewardsPerWeight);\n    event GuardianDelegatorsStakingRewardsPercentMilleUpdated(address indexed guardian, uint256 delegatorsStakingRewardsPercentMille);\n\n    /*\n     * External functions\n     */\n\n    /// @dev Returns the currently unclaimed orbs token reward balance of the given address.\n    function getStakingRewardsBalance(address addr) external view returns (uint256 balance);\n\n    /// @dev Allows Guardian to set a different delegator staking reward cut than the default\n    /// delegatorRewardsPercentMille accepts values between 0 - maxDelegatorsStakingRewardsPercentMille\n    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external;\n\n    /// @dev Returns the guardian\u0027s delegatorRewardsPercentMille\n    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external view returns (uint256 delegatorRewardsRatioPercentMille);\n\n    /// @dev Claims the staking rewards balance of addr by staking\n    function claimStakingRewards(address addr) external;\n\n    /// @dev Returns the amount of ORBS tokens in the staking wallet that were allocated\n    /// but not yet claimed. The staking wallet balance must always larger than the allocated value.\n    function getStakingRewardsWalletAllocatedTokens() external view returns (uint256 allocated);\n\n    function getGuardianStakingRewardsData(address guardian) external view returns (\n        uint256 balance,\n        uint256 claimed,\n        uint256 delegatorRewardsPerToken,\n        uint256 lastStakingRewardsPerWeight\n    );\n\n    function getDelegatorStakingRewardsData(address delegator) external view returns (\n        uint256 balance,\n        uint256 claimed,\n        uint256 lastDelegatorRewardsPerToken\n    );\n\n    function getStakingRewardsState() external view returns (\n        uint96 stakingRewardsPerWeight,\n        uint96 unclaimedStakingRewards\n    );\n\n    function getCurrentStakingRewardsRatePercentMille() external returns (uint256);\n\n    /// @dev called by the Committee contract upon expected change in the committee membership of the guardian\n    /// Triggers update of the member rewards\n    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external /* onlyCommitteeContract */;\n\n    /// @dev called by the Delegation contract upon expected change in a committee member delegator stake\n    /// Triggers update of the delegator and guardian staking rewards\n    function delegationWillChange(address guardian, uint256 delegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external /* onlyDelegationsContract */;\n\n    /*\n     * Governance functions\n     */\n\n    event AnnualStakingRewardsRateChanged(uint256 annualRateInPercentMille, uint256 annualCap);\n    event DefaultDelegatorsStakingRewardsChanged(uint32 defaultDelegatorsStakingRewardsPercentMille);\n    event MaxDelegatorsStakingRewardsChanged(uint32 maxDelegatorsStakingRewardsPercentMille);\n    event RewardDistributionActivated(uint256 startTime);\n    event RewardDistributionDeactivated();\n    event StakingRewardsBalanceMigrated(address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards, address toRewardsContract);\n    event StakingRewardsBalanceMigrationAccepted(address from, address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards);\n    event EmergencyWithdrawal(address addr);\n\n    /// @dev activates reward distribution, all rewards will be distributed up\n    /// assuming the last assignment was on startTime (the time the old contarct was deactivated)\n    function activateRewardDistribution(uint startTime) external /* onlyInitializationAdmin */;\n\n    /// @dev deactivates reward distribution, all rewards will be distributed up\n    /// deactivate moment.\n    function deactivateRewardDistribution() external /* onlyMigrationManager */;\n\n    /// @dev Sets the default cut of the delegators staking reward.\n    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager onlyWhenActive */;\n\n    function getDefaultDelegatorsStakingRewardsPercentMille() external view returns (uint32);\n\n    /// @dev Sets the maximum cut of the delegators staking reward.\n    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager onlyWhenActive */;\n\n    function getMaxDelegatorsStakingRewardsPercentMille() external view returns (uint32);\n\n    /// @dev Sets a new annual rate and cap for the staking reward.\n    function setAnnualStakingRewardsRate(uint256 annualRateInPercentMille, uint256 annualCap) external /* onlyFunctionalManager */;\n\n    function getAnnualStakingRewardsRatePercentMille() external view returns (uint32);\n\n    function getAnnualStakingRewardsCap() external view returns (uint256);\n\n    function isRewardAllocationActive() external view returns (bool);\n\n    /// @dev Returns the contract\u0027s settings\n    function getSettings() external view returns (\n        uint annualStakingRewardsCap,\n        uint32 annualStakingRewardsRatePercentMille,\n        uint32 defaultDelegatorsStakingRewardsPercentMille,\n        uint32 maxDelegatorsStakingRewardsPercentMille,\n        bool rewardAllocationActive\n    );\n\n    /// @dev migrates the staking rewards balance of the guardian to the rewards contract as set in the registry.\n    function migrateRewardsBalance(address guardian) external;\n\n    /// @dev accepts guardian\u0027s balance migration from a previous rewards contarct.\n    function acceptRewardsBalanceMigration(address guardian, uint256 guardianStakingRewards, uint256 delegatorStakingRewards) external;\n\n    /// @dev emergency withdrawal of the rewards contract balances, may eb called only by the EmergencyManager. \n    function emergencyWithdraw() external /* onlyMigrationManager */;\n}\n\n"},"Lockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./ContractRegistryAccessor.sol\";\nimport \"./ILockable.sol\";\n\ncontract Lockable is ILockable, ContractRegistryAccessor {\n\n    bool public locked;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyLockOwner() {\n        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), \"caller is not a lock owner\");\n\n        _;\n    }\n\n    function lock() external override onlyLockOwner {\n        locked = true;\n        emit Locked();\n    }\n\n    function unlock() external override onlyLockOwner {\n        locked = false;\n        emit Unlocked();\n    }\n\n    function isLocked() external override view returns (bool) {\n        return locked;\n    }\n\n    modifier onlyWhenActive() {\n        require(!locked, \"contract is locked for this operation\");\n\n        _;\n    }\n}\n"},"ManagedContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Lockable.sol\";\n\ncontract ManagedContract is Lockable {\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyMigrationManager {\n        require(isManager(\"migrationManager\"), \"sender is not the migration manager\");\n\n        _;\n    }\n\n    modifier onlyFunctionalManager {\n        require(isManager(\"functionalManager\"), \"sender is not the functional manager\");\n\n        _;\n    }\n\n    function refreshContracts() virtual external {}\n\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SafeMath96.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath96 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint96 a, uint256 b) internal pure returns (uint96) {\n        require(uint256(uint96(b)) == b, \"SafeMath: addition overflow\");\n        uint96 c = a + uint96(b);\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint96 a, uint256 b) internal pure returns (uint96) {\n        require(uint256(uint96(b)) == b, \"SafeMath: subtraction overflow\");\n        return sub(a, uint96(b), \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b \u003c= a, errorMessage);\n        uint96 c = a - b;\n\n        return c;\n    }\n\n}\n"},"WithClaimableRegistryManagement.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract WithClaimableRegistryManagement is Context {\n    address private _registryAdmin;\n    address private _pendingRegistryAdmin;\n\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _registryAdmin = msgSender;\n        emit RegistryManagementTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current registryAdmin.\n     */\n    function registryAdmin() public view returns (address) {\n        return _registryAdmin;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the registryAdmin.\n     */\n    modifier onlyRegistryAdmin() {\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current registryAdmin.\n     */\n    function isRegistryAdmin() public view returns (bool) {\n        return _msgSender() == _registryAdmin;\n    }\n\n    /**\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n     *\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n     * thereby removing any functionality that is only available to the registryAdmin.\n     */\n    function renounceRegistryManagement() public onlyRegistryAdmin {\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\n        _registryAdmin = address(0);\n    }\n\n    /**\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n     */\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n        _registryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingManager.\n     */\n    modifier onlyPendingRegistryAdmin() {\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\n        _;\n    }\n    /**\n     * @dev Allows the current registryAdmin to set the pendingManager address.\n     * @param newRegistryAdmin The address to transfer registryManagement to.\n     */\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n        _pendingRegistryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n     */\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n        _transferRegistryManagement(_pendingRegistryAdmin);\n        _pendingRegistryAdmin = address(0);\n    }\n\n    /**\n     * @dev Returns the current pendingRegistryAdmin\n    */\n    function pendingRegistryAdmin() public view returns (address) {\n       return _pendingRegistryAdmin;  \n    }\n}\n"}}