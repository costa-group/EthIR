{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ContractRegistryAccessor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IContractRegistry.sol\";\nimport \"./WithClaimableRegistryManagement.sol\";\nimport \"./Initializable.sol\";\n\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\n\n    IContractRegistry private contractRegistry;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\n        setContractRegistry(_contractRegistry);\n        _transferRegistryManagement(_registryAdmin);\n    }\n\n    modifier onlyAdmin {\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\n\n        _;\n    }\n\n    function isManager(string memory role) internal view returns (bool) {\n        IContractRegistry _contractRegistry = contractRegistry;\n        return isAdmin() || _contractRegistry != IContractRegistry(0) \u0026\u0026 contractRegistry.getManager(role) == msg.sender;\n    }\n\n    function isAdmin() internal view returns (bool) {\n        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);\n    }\n\n    function getProtocolContract() internal view returns (address) {\n        return contractRegistry.getContract(\"protocol\");\n    }\n\n    function getStakingRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewards\");\n    }\n\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\n    }\n\n    function getCommitteeContract() internal view returns (address) {\n        return contractRegistry.getContract(\"committee\");\n    }\n\n    function getElectionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"elections\");\n    }\n\n    function getDelegationsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"delegations\");\n    }\n\n    function getGuardiansRegistrationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"guardiansRegistration\");\n    }\n\n    function getCertificationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"certification\");\n    }\n\n    function getStakingContract() internal view returns (address) {\n        return contractRegistry.getContract(\"staking\");\n    }\n\n    function getSubscriptionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"subscriptions\");\n    }\n\n    function getStakingRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\n    }\n\n    function getBootstrapRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\n    }\n\n    function getGeneralFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"generalFeesWallet\");\n    }\n\n    function getCertifiedFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\n    }\n\n    function getStakingContractHandler() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingContractHandler\");\n    }\n\n    /*\n    * Governance functions\n    */\n\n    event ContractRegistryAddressUpdated(address addr);\n\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\n        contractRegistry = newContractRegistry;\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n    }\n\n    function getContractRegistry() public view returns (IContractRegistry) {\n        return contractRegistry;\n    }\n\n}\n"},"IContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface IContractRegistry {\n\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n\tevent ManagerChanged(string role, address newManager);\n\tevent ContractRegistryUpdated(address newContractRegistry);\n\n\t/*\n\t* External functions\n\t*/\n\n\t/// @dev updates the contracts address and emits a corresponding event\n\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\n\n\t/// @dev returns the current address of the given contracts\n\tfunction getContract(string calldata contractName) external view returns (address);\n\n\t/// @dev returns the list of contract addresses managed by the registry\n\tfunction getManagedContracts() external view returns (address[] memory);\n\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n\n\tfunction getManager(string calldata role) external view returns (address);\n\n\tfunction lockContracts() external /* onlyAdmin */;\n\n\tfunction unlockContracts() external /* onlyAdmin */;\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n\n\tfunction getPreviousContractRegistry() external view returns (address);\n\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"ILockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface ILockable {\n\n    event Locked();\n    event Unlocked();\n\n    function lock() external /* onlyLockOwner */;\n    function unlock() external /* onlyLockOwner */;\n    function isLocked() view external returns (bool);\n\n}\n"},"IMigratableStakingContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\n\n/// @title An interface for staking contracts which support stake migration.\ninterface IMigratableStakingContract {\n    /// @dev Returns the address of the underlying staked token.\n    /// @return IERC20 The address of the token.\n    function getToken() external view returns (IERC20);\n\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\n    /// the required amount using ERC20 approve.\n    /// @param _stakeOwner address The specified stake owner.\n    /// @param _amount uint256 The number of tokens to stake.\n    function acceptMigration(address _stakeOwner, uint256 _amount) external;\n\n    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ncontract Initializable {\n\n    address private _initializationAdmin;\n\n    event InitializationComplete();\n\n    constructor() public{\n        _initializationAdmin = msg.sender;\n    }\n\n    modifier onlyInitializationAdmin() {\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function initializationAdmin() public view returns (address) {\n        return _initializationAdmin;\n    }\n\n    function initializationComplete() external onlyInitializationAdmin {\n        _initializationAdmin = address(0);\n        emit InitializationComplete();\n    }\n\n    function isInitializationComplete() public view returns (bool) {\n        return _initializationAdmin == address(0);\n    }\n\n}"},"IStakeChangeNotifier.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title An interface for notifying of stake change events (e.g., stake, unstake, partial unstake, restate, etc.).\ninterface IStakeChangeNotifier {\n    /// @dev Notifies of stake change event.\n    /// @param _stakeOwner address The address of the subject stake owner.\n    /// @param _amount uint256 The difference in the total staked amount.\n    /// @param _sign bool The sign of the added (true) or subtracted (false) amount.\n    /// @param _updatedStake uint256 The updated total staked amount.\n    function stakeChange(address _stakeOwner, uint256 _amount, bool _sign, uint256 _updatedStake) external;\n\n    /// @dev Notifies of multiple stake change events.\n    /// @param _stakeOwners address[] The addresses of subject stake owners.\n    /// @param _amounts uint256[] The differences in total staked amounts.\n    /// @param _signs bool[] The signs of the added (true) or subtracted (false) amounts.\n    /// @param _updatedStakes uint256[] The updated total staked amounts.\n    function stakeChangeBatch(address[] calldata _stakeOwners, uint256[] calldata _amounts, bool[] calldata _signs,\n        uint256[] calldata _updatedStakes) external;\n\n    /// @dev Notifies of stake migration event.\n    /// @param _stakeOwner address The address of the subject stake owner.\n    /// @param _amount uint256 The migrated amount.\n    function stakeMigration(address _stakeOwner, uint256 _amount) external;\n}\n"},"IStakingContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IMigratableStakingContract.sol\";\n\n/// @title An interface for staking contracts.\ninterface IStakingContract {\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\n    /// the required amount using ERC20 approve.\n    /// @param _amount uint256 The amount of tokens to stake.\n    function stake(uint256 _amount) external;\n\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\n    /// msg.sender would be able to withdraw all of his tokens.\n    /// @param _amount uint256 The amount of tokens to unstake.\n    function unstake(uint256 _amount) external;\n\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\n    /// requested to release all stakes).\n    function withdraw() external;\n\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\n    function restake() external;\n\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\n    /// convenience method, we aren\u0027t concerned about reaching block gas limit by using large lists. We assume that\n    /// callers will be able to properly batch/paginate their requests.\n    /// @param _totalAmount uint256 The total amount of rewards to distributes.\n    /// @param _stakeOwners address[] The addresses of the stake owners.\n    /// @param _amounts uint256[] The amounts of the rewards.\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\n\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\n    /// @param _stakeOwner address The address to check.\n    /// @return uint256 The total stake.\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\n\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\n    /// @return uint256 The total staked tokens of all stake owners.\n    function getTotalStakedTokens() external view returns (uint256);\n\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\n    /// @param _stakeOwner address The address to check.\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\n        uint256 cooldownEndTime);\n\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\n    /// @param _amount uint256 The amount of tokens to migrate.\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\n\n    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n}\n"},"IStakingContractHandler.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title An interface for staking contracts.\ninterface IStakingContractHandler {\n    event StakeChangeNotificationSkipped(address indexed stakeOwner);\n    event StakeChangeBatchNotificationSkipped(address[] stakeOwners);\n    event StakeMigrationNotificationSkipped(address indexed stakeOwner);\n\n    /*\n    * External functions\n    */\n\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\n    /// @param _stakeOwner address The address to check.\n    /// @return uint256 The total stake.\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\n\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\n    /// @return uint256 The total staked tokens of all stake owners.\n    function getTotalStakedTokens() external view returns (uint256);\n\n    /*\n    * Governance functions\n    */\n\n    event NotifyDelegationsChanged(bool notifyDelegations);\n\n    function setNotifyDelegations(bool notifyDelegations) external; /* onlyMigrationManager */\n\n    function getNotifyDelegations() external returns (bool);\n}\n"},"Lockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./ContractRegistryAccessor.sol\";\nimport \"./ILockable.sol\";\n\ncontract Lockable is ILockable, ContractRegistryAccessor {\n\n    bool public locked;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyLockOwner() {\n        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), \"caller is not a lock owner\");\n\n        _;\n    }\n\n    function lock() external override onlyLockOwner {\n        locked = true;\n        emit Locked();\n    }\n\n    function unlock() external override onlyLockOwner {\n        locked = false;\n        emit Unlocked();\n    }\n\n    function isLocked() external override view returns (bool) {\n        return locked;\n    }\n\n    modifier onlyWhenActive() {\n        require(!locked, \"contract is locked for this operation\");\n\n        _;\n    }\n}\n"},"ManagedContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Lockable.sol\";\n\ncontract ManagedContract is Lockable {\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyMigrationManager {\n        require(isManager(\"migrationManager\"), \"sender is not the migration manager\");\n\n        _;\n    }\n\n    modifier onlyFunctionalManager {\n        require(isManager(\"functionalManager\"), \"sender is not the functional manager\");\n\n        _;\n    }\n\n    function refreshContracts() virtual external {}\n\n}"},"StakingContractHandler.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IStakingContractHandler.sol\";\nimport \"./IStakeChangeNotifier.sol\";\nimport \"./IStakingContract.sol\";\nimport \"./ManagedContract.sol\";\n\ncontract StakingContractHandler is IStakingContractHandler, IStakeChangeNotifier, ManagedContract {\n\n    bool notifyDelegations = true;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public ManagedContract(_contractRegistry, _registryAdmin) {}\n\n    modifier onlyStakingContract() {\n        require(msg.sender == address(getStakingContract()), \"caller is not the staking contract\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function stakeChange(address stakeOwner, uint256 amount, bool sign, uint256 updatedStake) external override onlyStakingContract {\n        if (!notifyDelegations) {\n            emit StakeChangeNotificationSkipped(stakeOwner);\n            return;\n        }\n\n        delegationsContract.stakeChange(stakeOwner, amount, sign, updatedStake);\n    }\n\n    /// @dev Notifies of multiple stake change events.\n    /// @param stakeOwners address[] The addresses of subject stake owners.\n    /// @param amounts uint256[] The differences in total staked amounts.\n    /// @param signs bool[] The signs of the added (true) or subtracted (false) amounts.\n    /// @param updatedStakes uint256[] The updated total staked amounts.\n    function stakeChangeBatch(address[] calldata stakeOwners, uint256[] calldata amounts, bool[] calldata signs, uint256[] calldata updatedStakes) external override onlyStakingContract {\n        if (!notifyDelegations) {\n            emit StakeChangeBatchNotificationSkipped(stakeOwners);\n            return;\n        }\n\n        delegationsContract.stakeChangeBatch(stakeOwners, amounts, signs, updatedStakes);\n    }\n\n    /// @dev Notifies of stake migration event.\n    /// @param stakeOwner address The address of the subject stake owner.\n    /// @param amount uint256 The migrated amount.\n    function stakeMigration(address stakeOwner, uint256 amount) external override onlyStakingContract {\n        if (!notifyDelegations) {\n            emit StakeMigrationNotificationSkipped(stakeOwner);\n            return;\n        }\n\n        delegationsContract.stakeMigration(stakeOwner, amount);\n    }\n\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\n    /// @param stakeOwner address The address to check.\n    /// @return uint256 The total stake.\n    function getStakeBalanceOf(address stakeOwner) external override view returns (uint256) {\n        return stakingContract.getStakeBalanceOf(stakeOwner);\n    }\n\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\n    /// @return uint256 The total staked tokens of all stake owners.\n    function getTotalStakedTokens() external override view returns (uint256) {\n        return stakingContract.getTotalStakedTokens();\n    }\n\n    /*\n    * Governance functions\n    */\n\n    function setNotifyDelegations(bool _notifyDelegations) external override onlyMigrationManager {\n        notifyDelegations = _notifyDelegations;\n        emit NotifyDelegationsChanged(_notifyDelegations);\n    }\n\n    function getNotifyDelegations() external override returns (bool) {\n        return notifyDelegations;\n    }\n\n    /*\n     * Contracts topology / registry interface\n     */\n\n    IStakeChangeNotifier delegationsContract;\n    IStakingContract stakingContract;\n    function refreshContracts() external override {\n        delegationsContract = IStakeChangeNotifier(getDelegationsContract());\n        stakingContract = IStakingContract(getStakingContract());\n    }\n}"},"WithClaimableRegistryManagement.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract WithClaimableRegistryManagement is Context {\n    address private _registryAdmin;\n    address private _pendingRegistryAdmin;\n\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _registryAdmin = msgSender;\n        emit RegistryManagementTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current registryAdmin.\n     */\n    function registryAdmin() public view returns (address) {\n        return _registryAdmin;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the registryAdmin.\n     */\n    modifier onlyRegistryAdmin() {\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current registryAdmin.\n     */\n    function isRegistryAdmin() public view returns (bool) {\n        return _msgSender() == _registryAdmin;\n    }\n\n    /**\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n     *\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n     * thereby removing any functionality that is only available to the registryAdmin.\n     */\n    function renounceRegistryManagement() public onlyRegistryAdmin {\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\n        _registryAdmin = address(0);\n    }\n\n    /**\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n     */\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n        _registryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingManager.\n     */\n    modifier onlyPendingRegistryAdmin() {\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\n        _;\n    }\n    /**\n     * @dev Allows the current registryAdmin to set the pendingManager address.\n     * @param newRegistryAdmin The address to transfer registryManagement to.\n     */\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n        _pendingRegistryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n     */\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n        _transferRegistryManagement(_pendingRegistryAdmin);\n        _pendingRegistryAdmin = address(0);\n    }\n\n    /**\n     * @dev Returns the current pendingRegistryAdmin\n    */\n    function pendingRegistryAdmin() public view returns (address) {\n       return _pendingRegistryAdmin;  \n    }\n}\n"}}