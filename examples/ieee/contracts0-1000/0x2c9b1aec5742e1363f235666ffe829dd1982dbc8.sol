{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ContractRegistryAccessor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IContractRegistry.sol\";\nimport \"./WithClaimableRegistryManagement.sol\";\nimport \"./Initializable.sol\";\n\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\n\n    IContractRegistry private contractRegistry;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\n        setContractRegistry(_contractRegistry);\n        _transferRegistryManagement(_registryAdmin);\n    }\n\n    modifier onlyAdmin {\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\n\n        _;\n    }\n\n    function isManager(string memory role) internal view returns (bool) {\n        IContractRegistry _contractRegistry = contractRegistry;\n        return isAdmin() || _contractRegistry != IContractRegistry(0) \u0026\u0026 contractRegistry.getManager(role) == msg.sender;\n    }\n\n    function isAdmin() internal view returns (bool) {\n        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);\n    }\n\n    function getProtocolContract() internal view returns (address) {\n        return contractRegistry.getContract(\"protocol\");\n    }\n\n    function getStakingRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewards\");\n    }\n\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\n    }\n\n    function getCommitteeContract() internal view returns (address) {\n        return contractRegistry.getContract(\"committee\");\n    }\n\n    function getElectionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"elections\");\n    }\n\n    function getDelegationsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"delegations\");\n    }\n\n    function getGuardiansRegistrationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"guardiansRegistration\");\n    }\n\n    function getCertificationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"certification\");\n    }\n\n    function getStakingContract() internal view returns (address) {\n        return contractRegistry.getContract(\"staking\");\n    }\n\n    function getSubscriptionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"subscriptions\");\n    }\n\n    function getStakingRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\n    }\n\n    function getBootstrapRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\n    }\n\n    function getGeneralFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"generalFeesWallet\");\n    }\n\n    function getCertifiedFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\n    }\n\n    function getStakingContractHandler() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingContractHandler\");\n    }\n\n    /*\n    * Governance functions\n    */\n\n    event ContractRegistryAddressUpdated(address addr);\n\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\n        contractRegistry = newContractRegistry;\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n    }\n\n    function getContractRegistry() public view returns (IContractRegistry) {\n        return contractRegistry;\n    }\n\n}\n"},"Elections.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./SafeMath.sol\";\n\nimport \"./IElections.sol\";\nimport \"./IDelegation.sol\";\nimport \"./IGuardiansRegistration.sol\";\nimport \"./ICommittee.sol\";\nimport \"./ICertification.sol\";\nimport \"./ManagedContract.sol\";\n\ncontract Elections is IElections, ManagedContract {\n\tusing SafeMath for uint256;\n\n\tuint32 constant PERCENT_MILLIE_BASE = 100000;\n\n\tmapping(address =\u003e mapping(address =\u003e uint256)) voteUnreadyVotes; // by =\u003e to =\u003e expiration\n\tmapping(address =\u003e uint256) public votersStake;\n\tmapping(address =\u003e address) voteOutVotes; // by =\u003e to\n\tmapping(address =\u003e uint256) accumulatedStakesForVoteOut; // addr =\u003e total stake\n\tmapping(address =\u003e bool) votedOutGuardians;\n\n\tstruct Settings {\n\t\tuint32 minSelfStakePercentMille;\n\t\tuint32 voteUnreadyPercentMilleThreshold;\n\t\tuint32 voteOutPercentMilleThreshold;\n\t}\n\tSettings settings;\n\n\tconstructor(IContractRegistry _contractRegistry, address _registryAdmin, uint32 minSelfStakePercentMille, uint32 voteUnreadyPercentMilleThreshold, uint32 voteOutPercentMilleThreshold) ManagedContract(_contractRegistry, _registryAdmin) public {\n\t\tsetMinSelfStakePercentMille(minSelfStakePercentMille);\n\t\tsetVoteOutPercentMilleThreshold(voteOutPercentMilleThreshold);\n\t\tsetVoteUnreadyPercentMilleThreshold(voteUnreadyPercentMilleThreshold);\n\t}\n\n\tmodifier onlyDelegationsContract() {\n\t\trequire(msg.sender == address(delegationsContract), \"caller is not the delegations contract\");\n\n\t\t_;\n\t}\n\n\tmodifier onlyGuardiansRegistrationContract() {\n\t\trequire(msg.sender == address(guardianRegistrationContract), \"caller is not the guardian registrations contract\");\n\n\t\t_;\n\t}\n\n\t/*\n\t * External functions\n\t */\n\n\tfunction readyToSync() external override onlyWhenActive {\n\t\taddress guardian = guardianRegistrationContract.resolveGuardianAddress(msg.sender); // this validates registration\n\t\trequire(!isVotedOut(guardian), \"caller is voted-out\");\n\n\t\temit GuardianStatusUpdated(guardian, true, false);\n\n\t\tcommitteeContract.removeMember(guardian);\n\t}\n\n\tfunction readyForCommittee() external override onlyWhenActive {\n\t\t_readyForCommittee(msg.sender);\n\t}\n\n\tfunction canJoinCommittee(address guardian) external view override returns (bool) {\n\t\tguardian = guardianRegistrationContract.resolveGuardianAddress(guardian); // this validates registration\n\n\t\tif (isVotedOut(guardian)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t(, uint256 effectiveStake, ) = getGuardianStakeInfo(guardian, settings);\n\t\treturn committeeContract.checkAddMember(guardian, effectiveStake);\n\t}\n\n\tfunction getEffectiveStake(address guardian) external override view returns (uint effectiveStake) {\n\t\t(, effectiveStake, ) = getGuardianStakeInfo(guardian, settings);\n\t}\n\n\t/// @dev returns the current committee\n\tfunction getCommittee() external override view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips) {\n\t\tIGuardiansRegistration _guardianRegistrationContract = guardianRegistrationContract;\n\t\t(committee, weights, certification) = committeeContract.getCommittee();\n\t\torbsAddrs = _guardianRegistrationContract.getGuardiansOrbsAddress(committee);\n\t\tips = _guardianRegistrationContract.getGuardianIps(committee);\n\t}\n\n\t// Vote-unready\n\n\tfunction voteUnready(address subject, uint voteExpiration) external override onlyWhenActive {\n\t\trequire(voteExpiration \u003e= block.timestamp, \"vote expiration time must not be in the past\");\n\n\t\taddress voter = guardianRegistrationContract.resolveGuardianAddress(msg.sender);\n\t\tvoteUnreadyVotes[voter][subject] = voteExpiration;\n\t\temit VoteUnreadyCasted(voter, subject, voteExpiration);\n\n\t\t(address[] memory generalCommittee, uint256[] memory generalWeights, bool[] memory certification) = committeeContract.getCommittee();\n\n\t\tbool votedUnready = isCommitteeVoteUnreadyThresholdReached(generalCommittee, generalWeights, certification, subject);\n\t\tif (votedUnready) {\n\t\t\tclearCommitteeUnreadyVotes(generalCommittee, subject);\n\t\t\temit GuardianVotedUnready(subject);\n\n\t\t\temit GuardianStatusUpdated(subject, false, false);\n\t\t\tcommitteeContract.removeMember(subject);\n\t\t}\n\t}\n\n\tfunction getVoteUnreadyVote(address voter, address subject) public override view returns (bool valid, uint256 expiration) {\n\t\texpiration = voteUnreadyVotes[voter][subject];\n\t\tvalid = expiration != 0 \u0026\u0026 block.timestamp \u003c expiration;\n\t}\n\n\tfunction getVoteUnreadyStatus(address subject) external override view returns (address[] memory committee, uint256[] memory weights, bool[] memory certification, bool[] memory votes, bool subjectInCommittee, bool subjectInCertifiedCommittee) {\n\t\t(committee, weights, certification) = committeeContract.getCommittee();\n\n\t\tvotes = new bool[](committee.length);\n\t\tfor (uint i = 0; i \u003c committee.length; i++) {\n\t\t\taddress memberAddr = committee[i];\n\t\t\tif (block.timestamp \u003c voteUnreadyVotes[memberAddr][subject]) {\n\t\t\t\tvotes[i] = true;\n\t\t\t}\n\n\t\t\tif (memberAddr == subject) {\n\t\t\t\tsubjectInCommittee = true;\n\t\t\t\tsubjectInCertifiedCommittee = certification[i];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Vote-out\n\n\tfunction voteOut(address subject) external override onlyWhenActive {\n\t\tSettings memory _settings = settings;\n\n\t\taddress voter = msg.sender;\n\t\taddress prevSubject = voteOutVotes[voter];\n\n\t\tvoteOutVotes[voter] = subject;\n\t\temit VoteOutCasted(voter, subject);\n\n\t\tuint256 voterStake = delegationsContract.getDelegatedStake(voter);\n\n\t\tif (prevSubject == address(0)) {\n\t\t\tvotersStake[voter] = voterStake;\n\t\t}\n\n\t\tif (subject == address(0)) {\n\t\t\tdelete votersStake[voter];\n\t\t}\n\n\t\tuint totalStake = delegationsContract.getTotalDelegatedStake();\n\n\t\tif (prevSubject != address(0) \u0026\u0026 prevSubject != subject) {\n\t\t\tapplyVoteOutVotesFor(prevSubject, 0, voterStake, totalStake, _settings);\n\t\t}\n\n\t\tif (subject != address(0)) {\n\t\t\tuint voteStakeAdded = prevSubject != subject ? voterStake : 0;\n\t\t\tapplyVoteOutVotesFor(subject, voteStakeAdded, 0, totalStake, _settings); // recheck also if not new\n\t\t}\n\t}\n\n\tfunction getVoteOutVote(address voter) external override view returns (address) {\n\t\treturn voteOutVotes[voter];\n\t}\n\n\tfunction getVoteOutStatus(address subject) external override view returns (bool votedOut, uint votedStake, uint totalDelegatedStake) {\n\t\tvotedOut = isVotedOut(subject);\n\t\tvotedStake = accumulatedStakesForVoteOut[subject];\n\t\ttotalDelegatedStake = delegationsContract.getTotalDelegatedStake();\n\t}\n\n\t/*\n\t * Notification functions from other PoS contracts\n\t */\n\n\tfunction delegatedStakeChange(address delegate, uint256 selfStake, uint256 delegatedStake, uint256 totalDelegatedStake) external override onlyDelegationsContract onlyWhenActive {\n\t\tSettings memory _settings = settings;\n\n\t\tuint effectiveStake = calcEffectiveStake(selfStake, delegatedStake, _settings);\n\t\temit StakeChanged(delegate, selfStake, delegatedStake, effectiveStake);\n\n\t\tcommitteeContract.memberWeightChange(delegate, effectiveStake);\n\n\t\tapplyStakesToVoteOutBy(delegate, delegatedStake, totalDelegatedStake, _settings);\n\t}\n\n\t/// @dev Called by: guardian registration contract\n\t/// Notifies a new guardian was unregistered\n\tfunction guardianUnregistered(address guardian) external override onlyGuardiansRegistrationContract onlyWhenActive {\n\t\temit GuardianStatusUpdated(guardian, false, false);\n\t\tcommitteeContract.removeMember(guardian);\n\t}\n\n\t/// @dev Called by: guardian registration contract\n\t/// Notifies on a guardian certification change\n\tfunction guardianCertificationChanged(address guardian, bool isCertified) external override onlyWhenActive {\n\t\tcommitteeContract.memberCertificationChange(guardian, isCertified);\n\t}\n\n\t/*\n     * Governance functions\n\t */\n\n\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) public override onlyFunctionalManager {\n\t\trequire(minSelfStakePercentMille \u003c= PERCENT_MILLIE_BASE, \"minSelfStakePercentMille must be 100000 at most\");\n\t\temit MinSelfStakePercentMilleChanged(minSelfStakePercentMille, settings.minSelfStakePercentMille);\n\t\tsettings.minSelfStakePercentMille = minSelfStakePercentMille;\n\t}\n\n\tfunction getMinSelfStakePercentMille() external override view returns (uint32) {\n\t\treturn settings.minSelfStakePercentMille;\n\t}\n\n\tfunction setVoteOutPercentMilleThreshold(uint32 voteOutPercentMilleThreshold) public override onlyFunctionalManager {\n\t\trequire(voteOutPercentMilleThreshold \u003c= PERCENT_MILLIE_BASE, \"voteOutPercentMilleThreshold must not be larger than 100000\");\n\t\temit VoteOutPercentMilleThresholdChanged(voteOutPercentMilleThreshold, settings.voteOutPercentMilleThreshold);\n\t\tsettings.voteOutPercentMilleThreshold = voteOutPercentMilleThreshold;\n\t}\n\n\tfunction getVoteOutPercentMilleThreshold() external override view returns (uint32) {\n\t\treturn settings.voteOutPercentMilleThreshold;\n\t}\n\n\tfunction setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) public override onlyFunctionalManager {\n\t\trequire(voteUnreadyPercentMilleThreshold \u003c= PERCENT_MILLIE_BASE, \"voteUnreadyPercentMilleThreshold must not be larger than 100000\");\n\t\temit VoteUnreadyPercentMilleThresholdChanged(voteUnreadyPercentMilleThreshold, settings.voteUnreadyPercentMilleThreshold);\n\t\tsettings.voteUnreadyPercentMilleThreshold = voteUnreadyPercentMilleThreshold;\n\t}\n\n\tfunction getVoteUnreadyPercentMilleThreshold() external override view returns (uint32) {\n\t\treturn settings.voteUnreadyPercentMilleThreshold;\n\t}\n\n\tfunction getSettings() external override view returns (\n\t\tuint32 minSelfStakePercentMille,\n\t\tuint32 voteUnreadyPercentMilleThreshold,\n\t\tuint32 voteOutPercentMilleThreshold\n\t) {\n\t\tSettings memory _settings = settings;\n\t\tminSelfStakePercentMille = _settings.minSelfStakePercentMille;\n\t\tvoteUnreadyPercentMilleThreshold = _settings.voteUnreadyPercentMilleThreshold;\n\t\tvoteOutPercentMilleThreshold = _settings.voteOutPercentMilleThreshold;\n\t}\n\n\tfunction initReadyForCommittee(address[] calldata guardians) external override onlyInitializationAdmin {\n\t\tfor (uint i = 0; i \u003c guardians.length; i++) {\n\t\t\t_readyForCommittee(guardians[i]);\n\t\t}\n\t}\n\n\t/*\n     * Private functions\n\t */\n\n\tfunction _readyForCommittee(address guardian) private {\n\t\tguardian = guardianRegistrationContract.resolveGuardianAddress(guardian); // this validates registration\n\t\trequire(!isVotedOut(guardian), \"caller is voted-out\");\n\n\t\temit GuardianStatusUpdated(guardian, true, true);\n\n\t\t(, uint256 effectiveStake, ) = getGuardianStakeInfo(guardian, settings);\n\t\tcommitteeContract.addMember(guardian, effectiveStake, certificationContract.isGuardianCertified(guardian));\n\t}\n\n\tfunction calcEffectiveStake(uint256 selfStake, uint256 delegatedStake, Settings memory _settings) private pure returns (uint256) {\n\t\tif (selfStake.mul(PERCENT_MILLIE_BASE) \u003e= delegatedStake.mul(_settings.minSelfStakePercentMille)) {\n\t\t\treturn delegatedStake;\n\t\t}\n\t\treturn selfStake.mul(PERCENT_MILLIE_BASE).div(_settings.minSelfStakePercentMille); // never overflows or divides by zero\n\t}\n\n\tfunction getGuardianStakeInfo(address guardian, Settings memory _settings) private view returns (uint256 selfStake, uint256 effectiveStake, uint256 delegatedStake) {\n\t\tIDelegations _delegationsContract = delegationsContract;\n\t\t(,selfStake) = _delegationsContract.getDelegationInfo(guardian);\n\t\tdelegatedStake = _delegationsContract.getDelegatedStake(guardian);\n\t\teffectiveStake = calcEffectiveStake(selfStake, delegatedStake, _settings);\n\t}\n\n\t// Vote-unready\n\n\tfunction isCommitteeVoteUnreadyThresholdReached(address[] memory committee, uint256[] memory weights, bool[] memory certification, address subject) private returns (bool) {\n\t\tSettings memory _settings = settings;\n\n\t\tuint256 totalCommitteeStake = 0;\n\t\tuint256 totalVoteUnreadyStake = 0;\n\t\tuint256 totalCertifiedStake = 0;\n\t\tuint256 totalCertifiedVoteUnreadyStake = 0;\n\n\t\taddress member;\n\t\tuint256 memberStake;\n\t\tbool isSubjectCertified;\n\t\tfor (uint i = 0; i \u003c committee.length; i++) {\n\t\t\tmember = committee[i];\n\t\t\tmemberStake = weights[i];\n\n\t\t\tif (member == subject \u0026\u0026 certification[i]) {\n\t\t\t\tisSubjectCertified = true;\n\t\t\t}\n\n\t\t\ttotalCommitteeStake = totalCommitteeStake.add(memberStake);\n\t\t\tif (certification[i]) {\n\t\t\t\ttotalCertifiedStake = totalCertifiedStake.add(memberStake);\n\t\t\t}\n\n\t\t\t(bool valid, uint256 expiration) = getVoteUnreadyVote(member, subject);\n\t\t\tif (valid) {\n\t\t\t\ttotalVoteUnreadyStake = totalVoteUnreadyStake.add(memberStake);\n\t\t\t\tif (certification[i]) {\n\t\t\t\t\ttotalCertifiedVoteUnreadyStake = totalCertifiedVoteUnreadyStake.add(memberStake);\n\t\t\t\t}\n\t\t\t} else if (expiration != 0) {\n\t\t\t\t// Vote is stale, delete from state\n\t\t\t\tdelete voteUnreadyVotes[member][subject];\n\t\t\t}\n\t\t}\n\n\t\treturn (\n\t\t\ttotalCommitteeStake \u003e 0 \u0026\u0026\n\t\t\ttotalVoteUnreadyStake.mul(PERCENT_MILLIE_BASE) \u003e= uint256(_settings.voteUnreadyPercentMilleThreshold).mul(totalCommitteeStake)\n\t\t) || (\n\t\t\tisSubjectCertified \u0026\u0026\n\t\t\ttotalCertifiedStake \u003e 0 \u0026\u0026\n\t\t\ttotalCertifiedVoteUnreadyStake.mul(PERCENT_MILLIE_BASE) \u003e= uint256(_settings.voteUnreadyPercentMilleThreshold).mul(totalCertifiedStake)\n\t\t);\n\t}\n\n\tfunction clearCommitteeUnreadyVotes(address[] memory committee, address subject) private {\n\t\tfor (uint i = 0; i \u003c committee.length; i++) {\n\t\t\tvoteUnreadyVotes[committee[i]][subject] = 0; // clear vote-outs\n\t\t}\n\t}\n\n\t// Vote-out\n\n\tfunction applyStakesToVoteOutBy(address voter, uint256 currentVoterStake, uint256 totalGovernanceStake, Settings memory _settings) private {\n\t\taddress subject = voteOutVotes[voter];\n\t\tif (subject == address(0)) return;\n\n\t\tuint256 prevVoterStake = votersStake[voter];\n\t\tvotersStake[voter] = currentVoterStake;\n\n\t\tapplyVoteOutVotesFor(subject, currentVoterStake, prevVoterStake, totalGovernanceStake, _settings);\n\t}\n\n    function applyVoteOutVotesFor(address subject, uint256 voteOutStakeAdded, uint256 voteOutStakeRemoved, uint256 totalGovernanceStake, Settings memory _settings) private {\n\t\tif (isVotedOut(subject)) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 accumulated = accumulatedStakesForVoteOut[subject].\n\t\t\tsub(voteOutStakeRemoved).\n\t\t\tadd(voteOutStakeAdded);\n\n\t\tbool shouldBeVotedOut = totalGovernanceStake \u003e 0 \u0026\u0026 accumulated.mul(PERCENT_MILLIE_BASE) \u003e= uint256(_settings.voteOutPercentMilleThreshold).mul(totalGovernanceStake);\n\t\tif (shouldBeVotedOut) {\n\t\t\tvotedOutGuardians[subject] = true;\n\t\t\temit GuardianVotedOut(subject);\n\n\t\t\temit GuardianStatusUpdated(subject, false, false);\n\t\t\tcommitteeContract.removeMember(subject);\n\t\t}\n\n\t\taccumulatedStakesForVoteOut[subject] = accumulated;\n\t}\n\n\tfunction isVotedOut(address guardian) private view returns (bool) {\n\t\treturn votedOutGuardians[guardian];\n\t}\n\n\t/*\n     * Contracts topology / registry interface\n     */\n\n\tICommittee committeeContract;\n\tIDelegations delegationsContract;\n\tIGuardiansRegistration guardianRegistrationContract;\n\tICertification certificationContract;\n\tfunction refreshContracts() external override {\n\t\tcommitteeContract = ICommittee(getCommitteeContract());\n\t\tdelegationsContract = IDelegations(getDelegationsContract());\n\t\tguardianRegistrationContract = IGuardiansRegistration(getGuardiansRegistrationContract());\n\t\tcertificationContract = ICertification(getCertificationContract());\n\t}\n\n}\n"},"ICertification.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Elections contract interface\ninterface ICertification /* is Ownable */ {\n\tevent GuardianCertificationUpdate(address indexed guardian, bool isCertified);\n\n\t/*\n     * External methods\n     */\n\n\t/// @dev Returns the certification status of a guardian\n\tfunction isGuardianCertified(address guardian) external view returns (bool isCertified);\n\n\t/// @dev Sets the guardian certification status\n\tfunction setGuardianCertification(address guardian, bool isCertified) external /* Owner only */ ;\n}\n"},"ICommittee.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Committee contract interface\ninterface ICommittee {\n\tevent CommitteeChange(address indexed addr, uint256 weight, bool certification, bool inCommittee);\n\tevent CommitteeSnapshot(address[] addrs, uint256[] weights, bool[] certification);\n\n\t// No external functions\n\n\t/*\n     * External functions\n     */\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a weight change of certification change of a member\n\tfunction memberWeightChange(address addr, uint256 weight) external /* onlyElectionsContract onlyWhenActive */;\n\n\tfunction memberCertificationChange(address addr, bool isCertified) external /* onlyElectionsContract onlyWhenActive */;\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a a member removal for example due to voteOut / voteUnready\n\tfunction removeMember(address addr) external returns (bool memberRemoved, uint removedMemberEffectiveStake, bool removedMemberCertified)/* onlyElectionContract */;\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a new member applicable for committee (due to registration, unbanning, certification change)\n\tfunction addMember(address addr, uint256 weight, bool isCertified) external returns (bool memberAdded)  /* onlyElectionsContract */;\n\n\t/// @dev Called by: Elections contract\n\t/// Checks if addMember() would add a the member to the committee\n\tfunction checkAddMember(address addr, uint256 weight) external view returns (bool wouldAddMember);\n\n\t/// @dev Called by: Elections contract\n\t/// Returns the committee members and their weights\n\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification);\n\n\tfunction getCommitteeStats() external view returns (uint generalCommitteeSize, uint certifiedCommitteeSize, uint totalStake);\n\n\tfunction getMemberInfo(address addr) external view returns (bool inCommittee, uint weight, bool isCertified, uint totalCommitteeWeight);\n\n\tfunction emitCommitteeSnapshot() external;\n\n\t/*\n\t * Governance functions\n\t */\n\n\tevent MaxCommitteeSizeChanged(uint8 newValue, uint8 oldValue);\n\n\tfunction setMaxCommitteeSize(uint8 maxCommitteeSize) external /* onlyFunctionalManager onlyWhenActive */;\n\n\tfunction getMaxCommitteeSize() external view returns (uint8);\n}\n"},"IContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface IContractRegistry {\n\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n\tevent ManagerChanged(string role, address newManager);\n\tevent ContractRegistryUpdated(address newContractRegistry);\n\n\t/*\n\t* External functions\n\t*/\n\n\t/// @dev updates the contracts address and emits a corresponding event\n\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\n\n\t/// @dev returns the current address of the given contracts\n\tfunction getContract(string calldata contractName) external view returns (address);\n\n\t/// @dev returns the list of contract addresses managed by the registry\n\tfunction getManagedContracts() external view returns (address[] memory);\n\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n\n\tfunction getManager(string calldata role) external view returns (address);\n\n\tfunction lockContracts() external /* onlyAdmin */;\n\n\tfunction unlockContracts() external /* onlyAdmin */;\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n\n\tfunction getPreviousContractRegistry() external view returns (address);\n\n}\n"},"IDelegation.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Delegations contract interface\ninterface IDelegations /* is IStakeChangeNotifier */ {\n\n    // Delegation state change events\n\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);\n\n    // Function calls\n\tevent Delegated(address indexed from, address indexed to);\n\n\t/*\n     * External functions\n     */\n\n\t/// @dev Stake delegation\n\tfunction delegate(address to) external /* onlyWhenActive */;\n\n\tfunction refreshStake(address addr) external /* onlyWhenActive */;\n\n\tfunction getDelegatedStake(address addr) external view returns (uint256);\n\n\tfunction getDelegation(address addr) external view returns (address);\n\n\tfunction getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);\n\n\tfunction getTotalDelegatedStake() external view returns (uint256) ;\n\n\t/*\n\t * Governance functions\n\t */\n\n\tevent DelegationsImported(address[] from, address indexed to);\n\n\tevent DelegationInitialized(address indexed from, address indexed to);\n\n\tfunction importDelegations(address[] calldata from, address to) external /* onlyMigrationManager onlyDuringDelegationImport */;\n\n\tfunction initDelegation(address from, address to) external /* onlyInitializationAdmin */;\n}\n"},"IElections.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Elections contract interface\ninterface IElections {\n\t\n\t// Election state change events\n\tevent StakeChanged(address indexed addr, uint256 selfStake, uint256 delegatedStake, uint256 effectiveStake);\n\tevent GuardianStatusUpdated(address indexed guardian, bool readyToSync, bool readyForCommittee);\n\n\t// Vote out / Vote unready\n\tevent GuardianVotedUnready(address indexed guardian);\n\tevent VoteUnreadyCasted(address indexed voter, address indexed subject, uint256 expiration);\n\tevent GuardianVotedOut(address indexed guardian);\n\tevent VoteOutCasted(address indexed voter, address indexed subject);\n\n\t/*\n\t * External functions\n\t */\n\n\t/// @dev Called by a guardian when ready to start syncing with other nodes\n\tfunction readyToSync() external;\n\n\t/// @dev Called by a guardian when ready to join the committee, typically after syncing is complete or after being voted out\n\tfunction readyForCommittee() external;\n\n\t/// @dev Called to test if a guardian calling readyForCommittee() will lead to joining the committee\n\tfunction canJoinCommittee(address guardian) external view returns (bool);\n\n\t/// @dev Returns an address effective stake\n\tfunction getEffectiveStake(address guardian) external view returns (uint effectiveStake);\n\n\t/// @dev returns the current committee\n\t/// used also by the rewards and fees contracts\n\tfunction getCommittee() external view returns (address[] memory committee, uint256[] memory weights, address[] memory orbsAddrs, bool[] memory certification, bytes4[] memory ips);\n\n\t// Vote-unready\n\n\t/// @dev Called by a guardian as part of the automatic vote-unready flow\n\tfunction voteUnready(address subject, uint expiration) external;\n\n\tfunction getVoteUnreadyVote(address voter, address subject) external view returns (bool valid, uint256 expiration);\n\n\t/// @dev Returns the current vote-unready status of a subject guardian.\n\t/// votes indicates wether the specific committee member voted the guardian unready\n\tfunction getVoteUnreadyStatus(address subject) external view returns (\n\t\taddress[] memory committee,\n\t\tuint256[] memory weights,\n\t\tbool[] memory certification,\n\t\tbool[] memory votes,\n\t\tbool subjectInCommittee,\n\t\tbool subjectInCertifiedCommittee\n\t);\n\n\t// Vote-out\n\n\t/// @dev Casts a voteOut vote by the sender to the given address\n\tfunction voteOut(address subject) external;\n\n\t/// @dev Returns the subject address the addr has voted-out against\n\tfunction getVoteOutVote(address voter) external view returns (address);\n\n\t/// @dev Returns the governance voteOut status of a guardian.\n\t/// A guardian is voted out if votedStake / totalDelegatedStake (in percent mille) \u003e threshold\n\tfunction getVoteOutStatus(address subject) external view returns (bool votedOut, uint votedStake, uint totalDelegatedStake);\n\n\t/*\n\t * Notification functions from other PoS contracts\n\t */\n\n\t/// @dev Called by: delegation contract\n\t/// Notifies a delegated stake change event\n\t/// total_delegated_stake = 0 if addr delegates to another guardian\n\tfunction delegatedStakeChange(address delegate, uint256 selfStake, uint256 delegatedStake, uint256 totalDelegatedStake) external /* onlyDelegationsContract onlyWhenActive */;\n\n\t/// @dev Called by: guardian registration contract\n\t/// Notifies a new guardian was unregistered\n\tfunction guardianUnregistered(address guardian) external /* onlyGuardiansRegistrationContract */;\n\n\t/// @dev Called by: guardian registration contract\n\t/// Notifies on a guardian certification change\n\tfunction guardianCertificationChanged(address guardian, bool isCertified) external /* onlyCertificationContract */;\n\n\n\t/*\n     * Governance functions\n\t */\n\n\tevent VoteUnreadyTimeoutSecondsChanged(uint32 newValue, uint32 oldValue);\n\tevent VoteOutPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\n\tevent VoteUnreadyPercentMilleThresholdChanged(uint32 newValue, uint32 oldValue);\n\tevent MinSelfStakePercentMilleChanged(uint32 newValue, uint32 oldValue);\n\n\t/// @dev Sets the minimum self-stake required for the effective stake\n\t/// minSelfStakePercentMille - the minimum self stake in percent-mille (0-100,000)\n\tfunction setMinSelfStakePercentMille(uint32 minSelfStakePercentMille) external /* onlyFunctionalManager onlyWhenActive */;\n\n\t/// @dev Returns the minimum self-stake required for the effective stake\n\tfunction getMinSelfStakePercentMille() external view returns (uint32);\n\n\t/// @dev Sets the vote-out threshold\n\t/// voteOutPercentMilleThreshold - the minimum threshold in percent-mille (0-100,000)\n\tfunction setVoteOutPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external /* onlyFunctionalManager onlyWhenActive */;\n\n\t/// @dev Returns the vote-out threshold\n\tfunction getVoteOutPercentMilleThreshold() external view returns (uint32);\n\n\t/// @dev Sets the vote-unready threshold\n\t/// voteUnreadyPercentMilleThreshold - the minimum threshold in percent-mille (0-100,000)\n\tfunction setVoteUnreadyPercentMilleThreshold(uint32 voteUnreadyPercentMilleThreshold) external /* onlyFunctionalManager onlyWhenActive */;\n\n\t/// @dev Returns the vote-unready threshold\n\tfunction getVoteUnreadyPercentMilleThreshold() external view returns (uint32);\n\n\t/// @dev Returns the contract\u0027s settings \n\tfunction getSettings() external view returns (\n\t\tuint32 minSelfStakePercentMille,\n\t\tuint32 voteUnreadyPercentMilleThreshold,\n\t\tuint32 voteOutPercentMilleThreshold\n\t);\n\n\tfunction initReadyForCommittee(address[] calldata guardians) external /* onlyInitializationAdmin */;\n\n}\n\n"},"IGuardiansRegistration.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Guardian registration contract interface\ninterface IGuardiansRegistration {\n\tevent GuardianRegistered(address indexed guardian);\n\tevent GuardianUnregistered(address indexed guardian);\n\tevent GuardianDataUpdated(address indexed guardian, bool isRegistered, bytes4 ip, address orbsAddr, string name, string website);\n\tevent GuardianMetadataChanged(address indexed guardian, string key, string newValue, string oldValue);\n\n\t/*\n     * External methods\n     */\n\n    /// @dev Called by a participant who wishes to register as a guardian\n\tfunction registerGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external;\n\n    /// @dev Called by a participant who wishes to update its propertires\n\tfunction updateGuardian(bytes4 ip, address orbsAddr, string calldata name, string calldata website) external;\n\n\t/// @dev Called by a participant who wishes to update its IP address (can be call by both main and Orbs addresses)\n\tfunction updateGuardianIp(bytes4 ip) external /* onlyWhenActive */;\n\n    /// @dev Called by a participant to update additional guardian metadata properties.\n    function setMetadata(string calldata key, string calldata value) external;\n\n    /// @dev Called by a participant to get additional guardian metadata properties.\n    function getMetadata(address guardian, string calldata key) external view returns (string memory);\n\n    /// @dev Called by a participant who wishes to unregister\n\tfunction unregisterGuardian() external;\n\n    /// @dev Returns a guardian\u0027s data\n\tfunction getGuardianData(address guardian) external view returns (bytes4 ip, address orbsAddr, string memory name, string memory website, uint registrationTime, uint lastUpdateTime);\n\n\t/// @dev Returns the Orbs addresses of a list of guardians\n\tfunction getGuardiansOrbsAddress(address[] calldata guardianAddrs) external view returns (address[] memory orbsAddrs);\n\n\t/// @dev Returns a guardian\u0027s ip\n\tfunction getGuardianIp(address guardian) external view returns (bytes4 ip);\n\n\t/// @dev Returns guardian ips\n\tfunction getGuardianIps(address[] calldata guardian) external view returns (bytes4[] memory ips);\n\n\t/// @dev Returns true if the given address is of a registered guardian\n\tfunction isRegistered(address guardian) external view returns (bool);\n\n\t/// @dev Translates a list guardians Orbs addresses to guardian addresses\n\tfunction getGuardianAddresses(address[] calldata orbsAddrs) external view returns (address[] memory guardianAddrs);\n\n\t/// @dev Resolves the guardian address for a guardian, given a Guardian/Orbs address\n\tfunction resolveGuardianAddress(address guardianOrOrbsAddress) external view returns (address guardianAddress);\n\n\t/*\n\t * Governance functions\n\t */\n\n\tfunction migrateGuardians(address[] calldata guardiansToMigrate, IGuardiansRegistration previousContract) external /* onlyInitializationAdmin */;\n\n}\n"},"ILockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface ILockable {\n\n    event Locked();\n    event Unlocked();\n\n    function lock() external /* onlyLockOwner */;\n    function unlock() external /* onlyLockOwner */;\n    function isLocked() view external returns (bool);\n\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ncontract Initializable {\n\n    address private _initializationAdmin;\n\n    event InitializationComplete();\n\n    constructor() public{\n        _initializationAdmin = msg.sender;\n    }\n\n    modifier onlyInitializationAdmin() {\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function initializationAdmin() public view returns (address) {\n        return _initializationAdmin;\n    }\n\n    function initializationComplete() external onlyInitializationAdmin {\n        _initializationAdmin = address(0);\n        emit InitializationComplete();\n    }\n\n    function isInitializationComplete() public view returns (bool) {\n        return _initializationAdmin == address(0);\n    }\n\n}"},"Lockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./ContractRegistryAccessor.sol\";\nimport \"./ILockable.sol\";\n\ncontract Lockable is ILockable, ContractRegistryAccessor {\n\n    bool public locked;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyLockOwner() {\n        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), \"caller is not a lock owner\");\n\n        _;\n    }\n\n    function lock() external override onlyLockOwner {\n        locked = true;\n        emit Locked();\n    }\n\n    function unlock() external override onlyLockOwner {\n        locked = false;\n        emit Unlocked();\n    }\n\n    function isLocked() external override view returns (bool) {\n        return locked;\n    }\n\n    modifier onlyWhenActive() {\n        require(!locked, \"contract is locked for this operation\");\n\n        _;\n    }\n}\n"},"ManagedContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Lockable.sol\";\n\ncontract ManagedContract is Lockable {\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyMigrationManager {\n        require(isManager(\"migrationManager\"), \"sender is not the migration manager\");\n\n        _;\n    }\n\n    modifier onlyFunctionalManager {\n        require(isManager(\"functionalManager\"), \"sender is not the functional manager\");\n\n        _;\n    }\n\n    function refreshContracts() virtual external {}\n\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"WithClaimableRegistryManagement.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract WithClaimableRegistryManagement is Context {\n    address private _registryAdmin;\n    address private _pendingRegistryAdmin;\n\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _registryAdmin = msgSender;\n        emit RegistryManagementTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current registryAdmin.\n     */\n    function registryAdmin() public view returns (address) {\n        return _registryAdmin;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the registryAdmin.\n     */\n    modifier onlyRegistryAdmin() {\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current registryAdmin.\n     */\n    function isRegistryAdmin() public view returns (bool) {\n        return _msgSender() == _registryAdmin;\n    }\n\n    /**\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n     *\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n     * thereby removing any functionality that is only available to the registryAdmin.\n     */\n    function renounceRegistryManagement() public onlyRegistryAdmin {\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\n        _registryAdmin = address(0);\n    }\n\n    /**\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n     */\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n        _registryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingManager.\n     */\n    modifier onlyPendingRegistryAdmin() {\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\n        _;\n    }\n    /**\n     * @dev Allows the current registryAdmin to set the pendingManager address.\n     * @param newRegistryAdmin The address to transfer registryManagement to.\n     */\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n        _pendingRegistryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n     */\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n        _transferRegistryManagement(_pendingRegistryAdmin);\n        _pendingRegistryAdmin = address(0);\n    }\n\n    /**\n     * @dev Returns the current pendingRegistryAdmin\n    */\n    function pendingRegistryAdmin() public view returns (address) {\n       return _pendingRegistryAdmin;  \n    }\n}\n"}}