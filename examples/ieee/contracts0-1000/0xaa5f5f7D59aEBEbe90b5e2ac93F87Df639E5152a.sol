{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ContractRegistryAccessor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IContractRegistry.sol\";\nimport \"./WithClaimableRegistryManagement.sol\";\nimport \"./Initializable.sol\";\n\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\n\n    IContractRegistry private contractRegistry;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\n        setContractRegistry(_contractRegistry);\n        _transferRegistryManagement(_registryAdmin);\n    }\n\n    modifier onlyAdmin {\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\n\n        _;\n    }\n\n    function isManager(string memory role) internal view returns (bool) {\n        IContractRegistry _contractRegistry = contractRegistry;\n        return isAdmin() || _contractRegistry != IContractRegistry(0) \u0026\u0026 contractRegistry.getManager(role) == msg.sender;\n    }\n\n    function isAdmin() internal view returns (bool) {\n        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);\n    }\n\n    function getProtocolContract() internal view returns (address) {\n        return contractRegistry.getContract(\"protocol\");\n    }\n\n    function getStakingRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewards\");\n    }\n\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\n    }\n\n    function getCommitteeContract() internal view returns (address) {\n        return contractRegistry.getContract(\"committee\");\n    }\n\n    function getElectionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"elections\");\n    }\n\n    function getDelegationsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"delegations\");\n    }\n\n    function getGuardiansRegistrationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"guardiansRegistration\");\n    }\n\n    function getCertificationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"certification\");\n    }\n\n    function getStakingContract() internal view returns (address) {\n        return contractRegistry.getContract(\"staking\");\n    }\n\n    function getSubscriptionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"subscriptions\");\n    }\n\n    function getStakingRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\n    }\n\n    function getBootstrapRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\n    }\n\n    function getGeneralFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"generalFeesWallet\");\n    }\n\n    function getCertifiedFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\n    }\n\n    function getStakingContractHandler() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingContractHandler\");\n    }\n\n    /*\n    * Governance functions\n    */\n\n    event ContractRegistryAddressUpdated(address addr);\n\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\n        contractRegistry = newContractRegistry;\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n    }\n\n    function getContractRegistry() public view returns (IContractRegistry) {\n        return contractRegistry;\n    }\n\n}\n"},"FeesAndBootstrapRewards.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./SafeMath.sol\";\nimport \"./SafeMath96.sol\";\nimport \"./Math.sol\";\nimport \"./IERC20.sol\";\n\nimport \"./ICommittee.sol\";\nimport \"./IProtocolWallet.sol\";\nimport \"./IFeesWallet.sol\";\nimport \"./IFeesAndBootstrapRewards.sol\";\nimport \"./ManagedContract.sol\";\n\ncontract FeesAndBootstrapRewards is IFeesAndBootstrapRewards, ManagedContract {\n    using SafeMath for uint256;\n    using SafeMath96 for uint96;\n\n    uint256 constant PERCENT_MILLIE_BASE = 100000;\n    uint256 constant TOKEN_BASE = 1e18;\n\n    struct Settings {\n        uint96 generalCommitteeAnnualBootstrap;\n        uint96 certifiedCommitteeAnnualBootstrap;\n        bool rewardAllocationActive;\n    }\n    Settings settings;\n\n    IERC20 public bootstrapToken;\n    IERC20 public erc20;\n\n    struct FeesAndBootstrapState {\n        uint96 certifiedFeesPerMember;\n        uint96 generalFeesPerMember;\n        uint96 certifiedBootstrapPerMember;\n        uint96 generalBootstrapPerMember;\n        uint32 lastAssigned;\n    }\n    FeesAndBootstrapState public feesAndBootstrapState;\n\n    struct FeesAndBootstrap {\n        uint96 feeBalance;\n        uint96 lastFeesPerMember;\n        uint96 bootstrapBalance;\n        uint96 lastBootstrapPerMember;\n    }\n    mapping(address =\u003e FeesAndBootstrap) public feesAndBootstrap;\n\n    constructor(\n        IContractRegistry _contractRegistry,\n        address _registryAdmin,\n        IERC20 _erc20,\n        IERC20 _bootstrapToken,\n        uint generalCommitteeAnnualBootstrap,\n        uint certifiedCommitteeAnnualBootstrap\n    ) ManagedContract(_contractRegistry, _registryAdmin) public {\n        require(address(_bootstrapToken) != address(0), \"bootstrapToken must not be 0\");\n        require(address(_erc20) != address(0), \"erc20 must not be 0\");\n\n        _setGeneralCommitteeAnnualBootstrap(generalCommitteeAnnualBootstrap);\n        _setCertifiedCommitteeAnnualBootstrap(certifiedCommitteeAnnualBootstrap);\n\n        erc20 = _erc20;\n        bootstrapToken = _bootstrapToken;\n    }\n\n    modifier onlyCommitteeContract() {\n        require(msg.sender == address(committeeContract), \"caller is not the elections contract\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function committeeMembershipWillChange(address guardian, bool inCommittee, bool isCertified, bool nextCertification, uint generalCommitteeSize, uint certifiedCommitteeSize) external override onlyWhenActive onlyCommitteeContract {\n        _updateGuardianFeesAndBootstrap(guardian, inCommittee, isCertified, nextCertification, generalCommitteeSize, certifiedCommitteeSize);\n    }\n\n    function getFeesAndBootstrapBalance(address guardian) external override view returns (uint256 feeBalance, uint256 bootstrapBalance) {\n        FeesAndBootstrap memory guardianFeesAndBootstrap = getGuardianFeesAndBootstrap(guardian);\n        return (guardianFeesAndBootstrap.feeBalance, guardianFeesAndBootstrap.bootstrapBalance);\n    }\n\n    function withdrawBootstrapFunds(address guardian) external override onlyWhenActive {\n        updateGuardianFeesAndBootstrap(guardian);\n        uint256 amount = feesAndBootstrap[guardian].bootstrapBalance;\n        feesAndBootstrap[guardian].bootstrapBalance = 0;\n        emit BootstrapRewardsWithdrawn(guardian, amount);\n\n        require(bootstrapToken.transfer(guardian, amount), \"Rewards::withdrawBootstrapFunds - insufficient funds\");\n    }\n\n    function withdrawFees(address guardian) external override onlyWhenActive {\n        updateGuardianFeesAndBootstrap(guardian);\n\n        uint256 amount = feesAndBootstrap[guardian].feeBalance;\n        feesAndBootstrap[guardian].feeBalance = 0;\n        emit FeesWithdrawn(guardian, amount);\n        require(erc20.transfer(guardian, amount), \"Rewards::withdrawFees - insufficient funds\");\n    }\n\n    function getFeesAndBootstrapState() external override view returns (\n        uint256 certifiedFeesPerMember,\n        uint256 generalFeesPerMember,\n        uint256 certifiedBootstrapPerMember,\n        uint256 generalBootstrapPerMember,\n        uint256 lastAssigned\n    ) {\n        (uint generalCommitteeSize, uint certifiedCommitteeSize, ) = committeeContract.getCommitteeStats();\n        (FeesAndBootstrapState memory _feesAndBootstrapState,) = _getFeesAndBootstrapState(generalCommitteeSize, certifiedCommitteeSize, generalFeesWallet.getOutstandingFees(), certifiedFeesWallet.getOutstandingFees(), settings);\n        certifiedFeesPerMember = _feesAndBootstrapState.certifiedFeesPerMember;\n        generalFeesPerMember = _feesAndBootstrapState.generalFeesPerMember;\n        certifiedBootstrapPerMember = _feesAndBootstrapState.certifiedBootstrapPerMember;\n        generalBootstrapPerMember = _feesAndBootstrapState.generalBootstrapPerMember;\n        lastAssigned = _feesAndBootstrapState.lastAssigned;\n    }\n\n    function getFeesAndBootstrapData(address guardian) external override view returns (\n        uint256 feeBalance,\n        uint256 lastFeesPerMember,\n        uint256 bootstrapBalance,\n        uint256 lastBootstrapPerMember\n    ) {\n        FeesAndBootstrap memory guardianFeesAndBootstrap = getGuardianFeesAndBootstrap(guardian);\n        return (\n            guardianFeesAndBootstrap.feeBalance,\n            guardianFeesAndBootstrap.lastFeesPerMember,\n            guardianFeesAndBootstrap.bootstrapBalance,\n            guardianFeesAndBootstrap.lastBootstrapPerMember\n        );\n    }\n\n    /*\n     * Governance functions\n     */\n\n    function migrateRewardsBalance(address guardian) external override {\n        require(!settings.rewardAllocationActive, \"Reward distribution must be deactivated for migration\");\n\n        IFeesAndBootstrapRewards currentRewardsContract = IFeesAndBootstrapRewards(getFeesAndBootstrapRewardsContract());\n        require(address(currentRewardsContract) != address(this), \"New rewards contract is not set\");\n\n        updateGuardianFeesAndBootstrap(guardian);\n\n        FeesAndBootstrap memory guardianFeesAndBootstrap = feesAndBootstrap[guardian];\n        uint256 fees = guardianFeesAndBootstrap.feeBalance;\n        uint256 bootstrap = guardianFeesAndBootstrap.bootstrapBalance;\n\n        guardianFeesAndBootstrap.feeBalance = 0;\n        guardianFeesAndBootstrap.bootstrapBalance = 0;\n        feesAndBootstrap[guardian] = guardianFeesAndBootstrap;\n\n        require(erc20.approve(address(currentRewardsContract), fees), \"migrateRewardsBalance: approve failed\");\n        require(bootstrapToken.approve(address(currentRewardsContract), bootstrap), \"migrateRewardsBalance: approve failed\");\n        currentRewardsContract.acceptRewardsBalanceMigration(guardian, fees, bootstrap);\n\n        emit FeesAndBootstrapRewardsBalanceMigrated(guardian, fees, bootstrap, address(currentRewardsContract));\n    }\n\n    function acceptRewardsBalanceMigration(address guardian, uint256 fees, uint256 bootstrap) external override {\n        FeesAndBootstrap memory guardianFeesAndBootstrap = feesAndBootstrap[guardian];\n        guardianFeesAndBootstrap.feeBalance = guardianFeesAndBootstrap.feeBalance.add(fees);\n        guardianFeesAndBootstrap.bootstrapBalance = guardianFeesAndBootstrap.bootstrapBalance.add(bootstrap);\n        feesAndBootstrap[guardian] = guardianFeesAndBootstrap;\n\n        if (fees \u003e 0) {\n            require(erc20.transferFrom(msg.sender, address(this), fees), \"acceptRewardBalanceMigration: transfer failed\");\n        }\n        if (bootstrap \u003e 0) {\n            require(bootstrapToken.transferFrom(msg.sender, address(this), bootstrap), \"acceptRewardBalanceMigration: transfer failed\");\n        }\n\n        emit FeesAndBootstrapRewardsBalanceMigrationAccepted(msg.sender, guardian, fees, bootstrap);\n    }\n\n    function activateRewardDistribution(uint startTime) external override onlyMigrationManager {\n        feesAndBootstrapState.lastAssigned = uint32(startTime);\n        settings.rewardAllocationActive = true;\n\n        emit RewardDistributionActivated(startTime);\n    }\n\n    function deactivateRewardDistribution() external override onlyMigrationManager {\n        require(settings.rewardAllocationActive, \"reward distribution is already deactivated\");\n\n        updateFeesAndBootstrapState();\n\n        settings.rewardAllocationActive = false;\n\n        emit RewardDistributionDeactivated();\n    }\n\n    function getSettings() external override view returns (\n        uint generalCommitteeAnnualBootstrap,\n        uint certifiedCommitteeAnnualBootstrap,\n        bool rewardAllocationActive\n    ) {\n        Settings memory _settings = settings;\n        generalCommitteeAnnualBootstrap = _settings.generalCommitteeAnnualBootstrap;\n        certifiedCommitteeAnnualBootstrap = _settings.certifiedCommitteeAnnualBootstrap;\n        rewardAllocationActive = _settings.rewardAllocationActive;\n    }\n\n    function setGeneralCommitteeAnnualBootstrap(uint256 annualAmount) external override onlyFunctionalManager {\n        updateFeesAndBootstrapState();\n        _setGeneralCommitteeAnnualBootstrap(annualAmount);\n    }\n\n    function getGeneralCommitteeAnnualBootstrap() external override view returns (uint256) {\n        return settings.generalCommitteeAnnualBootstrap;\n    }\n\n    function setCertifiedCommitteeAnnualBootstrap(uint256 annualAmount) external override onlyFunctionalManager {\n        updateFeesAndBootstrapState();\n        _setCertifiedCommitteeAnnualBootstrap(annualAmount);\n    }\n\n    function getCertifiedCommitteeAnnualBootstrap() external override view returns (uint256) {\n        return settings.certifiedCommitteeAnnualBootstrap;\n    }\n\n    function emergencyWithdraw() external override onlyMigrationManager {\n        emit EmergencyWithdrawal(msg.sender);\n        require(erc20.transfer(msg.sender, erc20.balanceOf(address(this))), \"Rewards::emergencyWithdraw - transfer failed (fee token)\");\n        require(bootstrapToken.transfer(msg.sender, bootstrapToken.balanceOf(address(this))), \"Rewards::emergencyWithdraw - transfer failed (bootstrap token)\");\n    }\n\n    function isRewardAllocationActive() external override view returns (bool) {\n        return settings.rewardAllocationActive;\n    }\n\n    /*\n    * Private functions\n    */\n\n    // Global state\n\n    function _getFeesAndBootstrapState(uint generalCommitteeSize, uint certifiedCommitteeSize, uint256 collectedGeneralFees, uint256 collectedCertifiedFees, Settings memory _settings) private view returns (FeesAndBootstrapState memory _feesAndBootstrapState, uint256 allocatedBootstrap) {\n        _feesAndBootstrapState = feesAndBootstrapState;\n\n        if (_settings.rewardAllocationActive) {\n            uint256 generalFeesDelta = generalCommitteeSize == 0 ? 0 : collectedGeneralFees.div(generalCommitteeSize);\n            uint256 certifiedFeesDelta = generalFeesDelta.add(certifiedCommitteeSize == 0 ? 0 : collectedCertifiedFees.div(certifiedCommitteeSize));\n\n            _feesAndBootstrapState.generalFeesPerMember = _feesAndBootstrapState.generalFeesPerMember.add(generalFeesDelta);\n            _feesAndBootstrapState.certifiedFeesPerMember = _feesAndBootstrapState.certifiedFeesPerMember.add(certifiedFeesDelta);\n\n            uint duration = block.timestamp.sub(_feesAndBootstrapState.lastAssigned);\n            uint256 generalBootstrapDelta = uint256(_settings.generalCommitteeAnnualBootstrap).mul(duration).div(365 days);\n            uint256 certifiedBootstrapDelta = generalBootstrapDelta.add(uint256(_settings.certifiedCommitteeAnnualBootstrap).mul(duration).div(365 days));\n\n            _feesAndBootstrapState.generalBootstrapPerMember = _feesAndBootstrapState.generalBootstrapPerMember.add(generalBootstrapDelta);\n            _feesAndBootstrapState.certifiedBootstrapPerMember = _feesAndBootstrapState.certifiedBootstrapPerMember.add(certifiedBootstrapDelta);\n            _feesAndBootstrapState.lastAssigned = uint32(block.timestamp);\n\n            allocatedBootstrap = generalBootstrapDelta.mul(generalCommitteeSize).add(certifiedBootstrapDelta.mul(certifiedCommitteeSize));\n        }\n    }\n\n    function _updateFeesAndBootstrapState(uint generalCommitteeSize, uint certifiedCommitteeSize) private returns (FeesAndBootstrapState memory _feesAndBootstrapState) {\n        Settings memory _settings = settings;\n        if (!_settings.rewardAllocationActive) {\n            return feesAndBootstrapState;\n        }\n\n        uint256 collectedGeneralFees = generalFeesWallet.collectFees();\n        uint256 collectedCertifiedFees = certifiedFeesWallet.collectFees();\n        uint256 allocatedBootstrap;\n\n        (_feesAndBootstrapState, allocatedBootstrap) = _getFeesAndBootstrapState(generalCommitteeSize, certifiedCommitteeSize, collectedGeneralFees, collectedCertifiedFees, _settings);\n        bootstrapRewardsWallet.withdraw(allocatedBootstrap);\n\n        feesAndBootstrapState = _feesAndBootstrapState;\n    }\n\n    function updateFeesAndBootstrapState() private returns (FeesAndBootstrapState memory _feesAndBootstrapState) {\n        (uint generalCommitteeSize, uint certifiedCommitteeSize, ) = committeeContract.getCommitteeStats();\n        return _updateFeesAndBootstrapState(generalCommitteeSize, certifiedCommitteeSize);\n    }\n\n    // Guardian state\n\n    function _getGuardianFeesAndBootstrap(address guardian, bool inCommittee, bool isCertified, bool nextCertification, FeesAndBootstrapState memory _feesAndBootstrapState) private view returns (FeesAndBootstrap memory guardianFeesAndBootstrap, uint256 addedBootstrapAmount, uint256 addedFeesAmount) {\n        guardianFeesAndBootstrap = feesAndBootstrap[guardian];\n\n        if (inCommittee) {\n            addedBootstrapAmount = (isCertified ? _feesAndBootstrapState.certifiedBootstrapPerMember : _feesAndBootstrapState.generalBootstrapPerMember).sub(guardianFeesAndBootstrap.lastBootstrapPerMember);\n            guardianFeesAndBootstrap.bootstrapBalance = guardianFeesAndBootstrap.bootstrapBalance.add(addedBootstrapAmount);\n\n            addedFeesAmount = (isCertified ? _feesAndBootstrapState.certifiedFeesPerMember : _feesAndBootstrapState.generalFeesPerMember).sub(guardianFeesAndBootstrap.lastFeesPerMember);\n            guardianFeesAndBootstrap.feeBalance = guardianFeesAndBootstrap.feeBalance.add(addedFeesAmount);\n        }\n\n        guardianFeesAndBootstrap.lastBootstrapPerMember = nextCertification ?  _feesAndBootstrapState.certifiedBootstrapPerMember : _feesAndBootstrapState.generalBootstrapPerMember;\n        guardianFeesAndBootstrap.lastFeesPerMember = nextCertification ?  _feesAndBootstrapState.certifiedFeesPerMember : _feesAndBootstrapState.generalFeesPerMember;\n    }\n\n    function _updateGuardianFeesAndBootstrap(address guardian, bool inCommittee, bool isCertified, bool nextCertification, uint generalCommitteeSize, uint certifiedCommitteeSize) private {\n        uint256 addedBootstrapAmount;\n        uint256 addedFeesAmount;\n\n        FeesAndBootstrapState memory _feesAndBootstrapState = _updateFeesAndBootstrapState(generalCommitteeSize, certifiedCommitteeSize);\n        (feesAndBootstrap[guardian], addedBootstrapAmount, addedFeesAmount) = _getGuardianFeesAndBootstrap(guardian, inCommittee, isCertified, nextCertification, _feesAndBootstrapState);\n\n        emit BootstrapRewardsAssigned(guardian, addedBootstrapAmount);\n        emit FeesAssigned(guardian, addedFeesAmount);\n    }\n\n    function getGuardianFeesAndBootstrap(address guardian) private view returns (FeesAndBootstrap memory guardianFeesAndBootstrap) {\n        ICommittee _committeeContract = committeeContract;\n        (uint generalCommitteeSize, uint certifiedCommitteeSize, ) = _committeeContract.getCommitteeStats();\n        (FeesAndBootstrapState memory _feesAndBootstrapState,) = _getFeesAndBootstrapState(generalCommitteeSize, certifiedCommitteeSize, generalFeesWallet.getOutstandingFees(), certifiedFeesWallet.getOutstandingFees(), settings);\n        (bool inCommittee, , bool isCertified,) = _committeeContract.getMemberInfo(guardian);\n        (guardianFeesAndBootstrap, ,) = _getGuardianFeesAndBootstrap(guardian, inCommittee, isCertified, isCertified, _feesAndBootstrapState);\n    }\n\n    function updateGuardianFeesAndBootstrap(address guardian) private {\n        ICommittee _committeeContract = committeeContract;\n        (uint generalCommitteeSize, uint certifiedCommitteeSize, ) = _committeeContract.getCommitteeStats();\n        (bool inCommittee, , bool isCertified,) = _committeeContract.getMemberInfo(guardian);\n        _updateGuardianFeesAndBootstrap(guardian, inCommittee, isCertified, isCertified, generalCommitteeSize, certifiedCommitteeSize);\n    }\n\n    // Governance and misc.\n\n    function _setGeneralCommitteeAnnualBootstrap(uint256 annualAmount) private {\n        require(uint256(uint96(annualAmount)) == annualAmount, \"annualAmount must fit in uint96\");\n\n        settings.generalCommitteeAnnualBootstrap = uint96(annualAmount);\n        emit GeneralCommitteeAnnualBootstrapChanged(annualAmount);\n    }\n\n    function _setCertifiedCommitteeAnnualBootstrap(uint256 annualAmount) private {\n        require(uint256(uint96(annualAmount)) == annualAmount, \"annualAmount must fit in uint96\");\n\n        settings.certifiedCommitteeAnnualBootstrap = uint96(annualAmount);\n        emit CertifiedCommitteeAnnualBootstrapChanged(annualAmount);\n    }\n\n    /*\n     * Contracts topology / registry interface\n     */\n\n    ICommittee committeeContract;\n    IFeesWallet generalFeesWallet;\n    IFeesWallet certifiedFeesWallet;\n    IProtocolWallet bootstrapRewardsWallet;\n    function refreshContracts() external override {\n        committeeContract = ICommittee(getCommitteeContract());\n        generalFeesWallet = IFeesWallet(getGeneralFeesWallet());\n        certifiedFeesWallet = IFeesWallet(getCertifiedFeesWallet());\n        bootstrapRewardsWallet = IProtocolWallet(getBootstrapRewardsWallet());\n    }\n}\n"},"ICommittee.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Committee contract interface\ninterface ICommittee {\n\tevent CommitteeChange(address indexed addr, uint256 weight, bool certification, bool inCommittee);\n\tevent CommitteeSnapshot(address[] addrs, uint256[] weights, bool[] certification);\n\n\t// No external functions\n\n\t/*\n     * External functions\n     */\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a weight change of certification change of a member\n\tfunction memberWeightChange(address addr, uint256 weight) external /* onlyElectionsContract onlyWhenActive */;\n\n\tfunction memberCertificationChange(address addr, bool isCertified) external /* onlyElectionsContract onlyWhenActive */;\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a a member removal for example due to voteOut / voteUnready\n\tfunction removeMember(address addr) external returns (bool memberRemoved, uint removedMemberEffectiveStake, bool removedMemberCertified)/* onlyElectionContract */;\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a new member applicable for committee (due to registration, unbanning, certification change)\n\tfunction addMember(address addr, uint256 weight, bool isCertified) external returns (bool memberAdded)  /* onlyElectionsContract */;\n\n\t/// @dev Called by: Elections contract\n\t/// Checks if addMember() would add a the member to the committee\n\tfunction checkAddMember(address addr, uint256 weight) external view returns (bool wouldAddMember);\n\n\t/// @dev Called by: Elections contract\n\t/// Returns the committee members and their weights\n\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification);\n\n\tfunction getCommitteeStats() external view returns (uint generalCommitteeSize, uint certifiedCommitteeSize, uint totalStake);\n\n\tfunction getMemberInfo(address addr) external view returns (bool inCommittee, uint weight, bool isCertified, uint totalCommitteeWeight);\n\n\tfunction emitCommitteeSnapshot() external;\n\n\t/*\n\t * Governance functions\n\t */\n\n\tevent MaxCommitteeSizeChanged(uint8 newValue, uint8 oldValue);\n\n\tfunction setMaxCommitteeSize(uint8 maxCommitteeSize) external /* onlyFunctionalManager onlyWhenActive */;\n\n\tfunction getMaxCommitteeSize() external view returns (uint8);\n}\n"},"IContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface IContractRegistry {\n\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n\tevent ManagerChanged(string role, address newManager);\n\tevent ContractRegistryUpdated(address newContractRegistry);\n\n\t/*\n\t* External functions\n\t*/\n\n\t/// @dev updates the contracts address and emits a corresponding event\n\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\n\n\t/// @dev returns the current address of the given contracts\n\tfunction getContract(string calldata contractName) external view returns (address);\n\n\t/// @dev returns the list of contract addresses managed by the registry\n\tfunction getManagedContracts() external view returns (address[] memory);\n\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n\n\tfunction getManager(string calldata role) external view returns (address);\n\n\tfunction lockContracts() external /* onlyAdmin */;\n\n\tfunction unlockContracts() external /* onlyAdmin */;\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n\n\tfunction getPreviousContractRegistry() external view returns (address);\n\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"IFeesAndBootstrapRewards.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Rewards contract interface\ninterface IFeesAndBootstrapRewards {\n    event FeesAssigned(address indexed guardian, uint256 amount);\n    event FeesWithdrawn(address indexed guardian, uint256 amount);\n    event BootstrapRewardsAssigned(address indexed guardian, uint256 amount);\n    event BootstrapRewardsWithdrawn(address indexed guardian, uint256 amount);\n\n    /*\n    * External functions\n    */\n\n    /// @dev called by the Committee contract upon expected change in the committee membership of the guardian\n    /// Triggers update of the member rewards\n    function committeeMembershipWillChange(address guardian, bool inCommittee, bool isCertified, bool nextCertification, uint generalCommitteeSize, uint certifiedCommitteeSize) external /* onlyCommitteeContract */;\n\n    function getFeesAndBootstrapBalance(address guardian) external view returns (\n        uint256 feeBalance,\n        uint256 bootstrapBalance\n    );\n\n    /// @dev Transfer all of msg.sender\u0027s outstanding balance to their account\n    function withdrawFees(address guardian) external;\n\n    /// @dev Transfer all of msg.sender\u0027s outstanding balance to their account\n    function withdrawBootstrapFunds(address guardian) external;\n\n    /// @dev Returns the global Fees and Bootstrap rewards state \n    function getFeesAndBootstrapState() external view returns (\n        uint256 certifiedFeesPerMember,\n        uint256 generalFeesPerMember,\n        uint256 certifiedBootstrapPerMember,\n        uint256 generalBootstrapPerMember,\n        uint256 lastAssigned\n    );\n\n    function getFeesAndBootstrapData(address guardian) external view returns (\n        uint256 feeBalance,\n        uint256 lastFeesPerMember,\n        uint256 bootstrapBalance,\n        uint256 lastBootstrapPerMember\n    );\n\n    /*\n     * Governance\n     */\n\n    event GeneralCommitteeAnnualBootstrapChanged(uint256 generalCommitteeAnnualBootstrap);\n    event CertifiedCommitteeAnnualBootstrapChanged(uint256 certifiedCommitteeAnnualBootstrap);\n    event RewardDistributionActivated(uint256 startTime);\n    event RewardDistributionDeactivated();\n    event FeesAndBootstrapRewardsBalanceMigrated(address indexed guardian, uint256 fees, uint256 bootstrapRewards, address toRewardsContract);\n    event FeesAndBootstrapRewardsBalanceMigrationAccepted(address from, address indexed guardian, uint256 fees, uint256 bootstrapRewards);\n    event EmergencyWithdrawal(address addr);\n\n    /// @dev deactivates reward distribution, all rewards will be distributed up\n    /// deactivate moment.\n    function deactivateRewardDistribution() external /* onlyMigrationManager */;\n\n    /// @dev activates reward distribution, all rewards will be distributed up\n    /// assuming the last assignment was on startTime (the time the old contarct was deactivated)\n    function activateRewardDistribution(uint startTime) external /* onlyInitializationAdmin */;\n\n    /// @dev Returns the contract\u0027s settings\n    function getSettings() external view returns (\n        uint generalCommitteeAnnualBootstrap,\n        uint certifiedCommitteeAnnualBootstrap,\n        bool rewardAllocationActive\n    );\n\n    function getGeneralCommitteeAnnualBootstrap() external view returns (uint256);\n\n    /// @dev Assigns rewards and sets a new monthly rate for the geenral commitee bootstrap.\n    function setGeneralCommitteeAnnualBootstrap(uint256 annual_amount) external /* onlyFunctionalManager */;\n\n    function getCertifiedCommitteeAnnualBootstrap() external view returns (uint256);\n\n    /// @dev Assigns rewards and sets a new monthly rate for the certification commitee bootstrap.\n    function setCertifiedCommitteeAnnualBootstrap(uint256 annual_amount) external /* onlyFunctionalManager */;\n\n    function isRewardAllocationActive() external view returns (bool);\n\n    /// @dev migrates the staking rewards balance of the guardian to the rewards contract as set in the registry.\n    function migrateRewardsBalance(address guardian) external;\n\n    /// @dev accepts guardian\u0027s balance migration from a previous rewards contarct.\n    function acceptRewardsBalanceMigration(address guardian, uint256 fees, uint256 bootstrapRewards) external;\n\n    /// @dev emergency withdrawal of the rewards contract balances, may eb called only by the EmergencyManager. \n    function emergencyWithdraw() external; /* onlyMigrationManager */\n}\n\n"},"IFeesWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IMigratableFeesWallet.sol\";\n\n/// @title Fees Wallet contract interface, manages the fee buckets\ninterface IFeesWallet {\n\n    event FeesWithdrawnFromBucket(uint256 bucketId, uint256 withdrawn, uint256 total);\n    event FeesAddedToBucket(uint256 bucketId, uint256 added, uint256 total);\n\n    /*\n     *   External methods\n     */\n\n    /// @dev Called by: subscriptions contract.\n    /// Top-ups the fee pool with the given amount at the given rate (typically called by the subscriptions contract).\n    function fillFeeBuckets(uint256 amount, uint256 monthlyRate, uint256 fromTimestamp) external;\n\n    /// @dev collect fees from the buckets since the last call and transfers the amount back.\n    /// Called by: only Rewards contract.\n    function collectFees() external returns (uint256 collectedFees) /* onlyRewardsContract */;\n\n    /// @dev Returns the amount of fees that are currently available for withdrawal\n    function getOutstandingFees() external view returns (uint256 outstandingFees);\n\n    /*\n     * General governance\n     */\n\n    event EmergencyWithdrawal(address addr);\n\n    /// @dev migrates the fees of bucket starting at startTimestamp.\n    /// bucketStartTime must be a bucket\u0027s start time.\n    /// Calls acceptBucketMigration in the destination contract.\n    function migrateBucket(IMigratableFeesWallet destination, uint256 bucketStartTime) external /* onlyMigrationManager */;\n\n    /// @dev Called by the old FeesWallet contract.\n    /// Part of the IMigratableFeesWallet interface.\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\n\n    /// @dev an emergency withdrawal enables withdrawal of all funds to an escrow account. To be use in emergencies only.\n    function emergencyWithdraw() external /* onlyMigrationManager */;\n\n}\n"},"ILockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface ILockable {\n\n    event Locked();\n    event Unlocked();\n\n    function lock() external /* onlyLockOwner */;\n    function unlock() external /* onlyLockOwner */;\n    function isLocked() view external returns (bool);\n\n}\n"},"IMigratableFeesWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title An interface for Fee wallets that support bucket migration.\ninterface IMigratableFeesWallet {\n    /// @dev receives a bucket start time and an amount\n    function acceptBucketMigration(uint256 bucketStartTime, uint256 amount) external;\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ncontract Initializable {\n\n    address private _initializationAdmin;\n\n    event InitializationComplete();\n\n    constructor() public{\n        _initializationAdmin = msg.sender;\n    }\n\n    modifier onlyInitializationAdmin() {\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function initializationAdmin() public view returns (address) {\n        return _initializationAdmin;\n    }\n\n    function initializationComplete() external onlyInitializationAdmin {\n        _initializationAdmin = address(0);\n        emit InitializationComplete();\n    }\n\n    function isInitializationComplete() public view returns (bool) {\n        return _initializationAdmin == address(0);\n    }\n\n}"},"IProtocolWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\nimport \"./IERC20.sol\";\n\n/// @title Protocol Wallet interface\ninterface IProtocolWallet {\n    event FundsAddedToPool(uint256 added, uint256 total);\n\n    /*\n    * External functions\n    */\n\n    /// @dev Returns the address of the underlying staked token.\n    /// @return balance uint256 the balance\n    function getBalance() external view returns (uint256 balance);\n\n    /// @dev Transfers the given amount of orbs tokens form the sender to this contract an update the pool.\n    function topUp(uint256 amount) external;\n\n    /// @dev Withdraw from pool to a the sender\u0027s address, limited by the pool\u0027s MaxRate.\n    /// A maximum of MaxRate x time period since the last Orbs transfer may be transferred out.\n    function withdraw(uint256 amount) external; /* onlyClient */\n\n\n    /*\n    * Governance functions\n    */\n\n    event ClientSet(address client);\n    event MaxAnnualRateSet(uint256 maxAnnualRate);\n    event EmergencyWithdrawal(address addr);\n    event OutstandingTokensReset(uint256 startTime);\n\n    /// @dev Sets a new transfer rate for the Orbs pool.\n    function setMaxAnnualRate(uint256 annual_rate) external; /* onlyMigrationManager */\n\n    function getMaxAnnualRate() external view returns (uint256);\n\n    /// @dev transfer the entire pool\u0027s balance to a new wallet.\n    function emergencyWithdraw() external; /* onlyMigrationManager */\n\n    /// @dev sets the address of the new contract\n    function setClient(address client) external; /* onlyFunctionalManager */\n\n    function resetOutstandingTokens(uint256 startTime) external; /* onlyMigrationOwner */\n\n    }\n"},"Lockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./ContractRegistryAccessor.sol\";\nimport \"./ILockable.sol\";\n\ncontract Lockable is ILockable, ContractRegistryAccessor {\n\n    bool public locked;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyLockOwner() {\n        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), \"caller is not a lock owner\");\n\n        _;\n    }\n\n    function lock() external override onlyLockOwner {\n        locked = true;\n        emit Locked();\n    }\n\n    function unlock() external override onlyLockOwner {\n        locked = false;\n        emit Unlocked();\n    }\n\n    function isLocked() external override view returns (bool) {\n        return locked;\n    }\n\n    modifier onlyWhenActive() {\n        require(!locked, \"contract is locked for this operation\");\n\n        _;\n    }\n}\n"},"ManagedContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Lockable.sol\";\n\ncontract ManagedContract is Lockable {\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyMigrationManager {\n        require(isManager(\"migrationManager\"), \"sender is not the migration manager\");\n\n        _;\n    }\n\n    modifier onlyFunctionalManager {\n        require(isManager(\"functionalManager\"), \"sender is not the functional manager\");\n\n        _;\n    }\n\n    function refreshContracts() virtual external {}\n\n}"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SafeMath96.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath96 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint96 a, uint256 b) internal pure returns (uint96) {\n        require(uint256(uint96(b)) == b, \"SafeMath: addition overflow\");\n        uint96 c = a + uint96(b);\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint96 a, uint256 b) internal pure returns (uint96) {\n        require(uint256(uint96(b)) == b, \"SafeMath: subtraction overflow\");\n        return sub(a, uint96(b), \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b \u003c= a, errorMessage);\n        uint96 c = a - b;\n\n        return c;\n    }\n\n}\n"},"WithClaimableRegistryManagement.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract WithClaimableRegistryManagement is Context {\n    address private _registryAdmin;\n    address private _pendingRegistryAdmin;\n\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _registryAdmin = msgSender;\n        emit RegistryManagementTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current registryAdmin.\n     */\n    function registryAdmin() public view returns (address) {\n        return _registryAdmin;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the registryAdmin.\n     */\n    modifier onlyRegistryAdmin() {\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current registryAdmin.\n     */\n    function isRegistryAdmin() public view returns (bool) {\n        return _msgSender() == _registryAdmin;\n    }\n\n    /**\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n     *\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n     * thereby removing any functionality that is only available to the registryAdmin.\n     */\n    function renounceRegistryManagement() public onlyRegistryAdmin {\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\n        _registryAdmin = address(0);\n    }\n\n    /**\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n     */\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n        _registryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingManager.\n     */\n    modifier onlyPendingRegistryAdmin() {\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\n        _;\n    }\n    /**\n     * @dev Allows the current registryAdmin to set the pendingManager address.\n     * @param newRegistryAdmin The address to transfer registryManagement to.\n     */\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n        _pendingRegistryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n     */\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n        _transferRegistryManagement(_pendingRegistryAdmin);\n        _pendingRegistryAdmin = address(0);\n    }\n\n    /**\n     * @dev Returns the current pendingRegistryAdmin\n    */\n    function pendingRegistryAdmin() public view returns (address) {\n       return _pendingRegistryAdmin;  \n    }\n}\n"}}