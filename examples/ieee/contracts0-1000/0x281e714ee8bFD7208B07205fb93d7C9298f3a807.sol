{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ContractRegistryAccessor.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IContractRegistry.sol\";\nimport \"./WithClaimableRegistryManagement.sol\";\nimport \"./Initializable.sol\";\n\ncontract ContractRegistryAccessor is WithClaimableRegistryManagement, Initializable {\n\n    IContractRegistry private contractRegistry;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) public {\n        require(address(_contractRegistry) != address(0), \"_contractRegistry cannot be 0\");\n        setContractRegistry(_contractRegistry);\n        _transferRegistryManagement(_registryAdmin);\n    }\n\n    modifier onlyAdmin {\n        require(isAdmin(), \"sender is not an admin (registryManger or initializationAdmin)\");\n\n        _;\n    }\n\n    function isManager(string memory role) internal view returns (bool) {\n        IContractRegistry _contractRegistry = contractRegistry;\n        return isAdmin() || _contractRegistry != IContractRegistry(0) \u0026\u0026 contractRegistry.getManager(role) == msg.sender;\n    }\n\n    function isAdmin() internal view returns (bool) {\n        return msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == address(contractRegistry);\n    }\n\n    function getProtocolContract() internal view returns (address) {\n        return contractRegistry.getContract(\"protocol\");\n    }\n\n    function getStakingRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewards\");\n    }\n\n    function getFeesAndBootstrapRewardsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"feesAndBootstrapRewards\");\n    }\n\n    function getCommitteeContract() internal view returns (address) {\n        return contractRegistry.getContract(\"committee\");\n    }\n\n    function getElectionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"elections\");\n    }\n\n    function getDelegationsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"delegations\");\n    }\n\n    function getGuardiansRegistrationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"guardiansRegistration\");\n    }\n\n    function getCertificationContract() internal view returns (address) {\n        return contractRegistry.getContract(\"certification\");\n    }\n\n    function getStakingContract() internal view returns (address) {\n        return contractRegistry.getContract(\"staking\");\n    }\n\n    function getSubscriptionsContract() internal view returns (address) {\n        return contractRegistry.getContract(\"subscriptions\");\n    }\n\n    function getStakingRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingRewardsWallet\");\n    }\n\n    function getBootstrapRewardsWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"bootstrapRewardsWallet\");\n    }\n\n    function getGeneralFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"generalFeesWallet\");\n    }\n\n    function getCertifiedFeesWallet() internal view returns (address) {\n        return contractRegistry.getContract(\"certifiedFeesWallet\");\n    }\n\n    function getStakingContractHandler() internal view returns (address) {\n        return contractRegistry.getContract(\"stakingContractHandler\");\n    }\n\n    /*\n    * Governance functions\n    */\n\n    event ContractRegistryAddressUpdated(address addr);\n\n    function setContractRegistry(IContractRegistry newContractRegistry) public onlyAdmin {\n        require(newContractRegistry.getPreviousContractRegistry() == address(contractRegistry), \"new contract registry must provide the previous contract registry\");\n        contractRegistry = newContractRegistry;\n        emit ContractRegistryAddressUpdated(address(newContractRegistry));\n    }\n\n    function getContractRegistry() public view returns (IContractRegistry) {\n        return contractRegistry;\n    }\n\n}\n"},"ICommittee.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Committee contract interface\ninterface ICommittee {\n\tevent CommitteeChange(address indexed addr, uint256 weight, bool certification, bool inCommittee);\n\tevent CommitteeSnapshot(address[] addrs, uint256[] weights, bool[] certification);\n\n\t// No external functions\n\n\t/*\n     * External functions\n     */\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a weight change of certification change of a member\n\tfunction memberWeightChange(address addr, uint256 weight) external /* onlyElectionsContract onlyWhenActive */;\n\n\tfunction memberCertificationChange(address addr, bool isCertified) external /* onlyElectionsContract onlyWhenActive */;\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a a member removal for example due to voteOut / voteUnready\n\tfunction removeMember(address addr) external returns (bool memberRemoved, uint removedMemberEffectiveStake, bool removedMemberCertified)/* onlyElectionContract */;\n\n\t/// @dev Called by: Elections contract\n\t/// Notifies a new member applicable for committee (due to registration, unbanning, certification change)\n\tfunction addMember(address addr, uint256 weight, bool isCertified) external returns (bool memberAdded)  /* onlyElectionsContract */;\n\n\t/// @dev Called by: Elections contract\n\t/// Checks if addMember() would add a the member to the committee\n\tfunction checkAddMember(address addr, uint256 weight) external view returns (bool wouldAddMember);\n\n\t/// @dev Called by: Elections contract\n\t/// Returns the committee members and their weights\n\tfunction getCommittee() external view returns (address[] memory addrs, uint256[] memory weights, bool[] memory certification);\n\n\tfunction getCommitteeStats() external view returns (uint generalCommitteeSize, uint certifiedCommitteeSize, uint totalStake);\n\n\tfunction getMemberInfo(address addr) external view returns (bool inCommittee, uint weight, bool isCertified, uint totalCommitteeWeight);\n\n\tfunction emitCommitteeSnapshot() external;\n\n\t/*\n\t * Governance functions\n\t */\n\n\tevent MaxCommitteeSizeChanged(uint8 newValue, uint8 oldValue);\n\n\tfunction setMaxCommitteeSize(uint8 maxCommitteeSize) external /* onlyFunctionalManager onlyWhenActive */;\n\n\tfunction getMaxCommitteeSize() external view returns (uint8);\n}\n"},"IContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface IContractRegistry {\n\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n\tevent ManagerChanged(string role, address newManager);\n\tevent ContractRegistryUpdated(address newContractRegistry);\n\n\t/*\n\t* External functions\n\t*/\n\n\t/// @dev updates the contracts address and emits a corresponding event\n\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\n\n\t/// @dev returns the current address of the given contracts\n\tfunction getContract(string calldata contractName) external view returns (address);\n\n\t/// @dev returns the list of contract addresses managed by the registry\n\tfunction getManagedContracts() external view returns (address[] memory);\n\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n\n\tfunction getManager(string calldata role) external view returns (address);\n\n\tfunction lockContracts() external /* onlyAdmin */;\n\n\tfunction unlockContracts() external /* onlyAdmin */;\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n\n\tfunction getPreviousContractRegistry() external view returns (address);\n\n}\n"},"IDelegation.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Delegations contract interface\ninterface IDelegations /* is IStakeChangeNotifier */ {\n\n    // Delegation state change events\n\tevent DelegatedStakeChanged(address indexed addr, uint256 selfDelegatedStake, uint256 delegatedStake, address indexed delegator, uint256 delegatorContributedStake);\n\n    // Function calls\n\tevent Delegated(address indexed from, address indexed to);\n\n\t/*\n     * External functions\n     */\n\n\t/// @dev Stake delegation\n\tfunction delegate(address to) external /* onlyWhenActive */;\n\n\tfunction refreshStake(address addr) external /* onlyWhenActive */;\n\n\tfunction getDelegatedStake(address addr) external view returns (uint256);\n\n\tfunction getDelegation(address addr) external view returns (address);\n\n\tfunction getDelegationInfo(address addr) external view returns (address delegation, uint256 delegatorStake);\n\n\tfunction getTotalDelegatedStake() external view returns (uint256) ;\n\n\t/*\n\t * Governance functions\n\t */\n\n\tevent DelegationsImported(address[] from, address indexed to);\n\n\tevent DelegationInitialized(address indexed from, address indexed to);\n\n\tfunction importDelegations(address[] calldata from, address to) external /* onlyMigrationManager onlyDuringDelegationImport */;\n\n\tfunction initDelegation(address from, address to) external /* onlyInitializationAdmin */;\n}\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"ILockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface ILockable {\n\n    event Locked();\n    event Unlocked();\n\n    function lock() external /* onlyLockOwner */;\n    function unlock() external /* onlyLockOwner */;\n    function isLocked() view external returns (bool);\n\n}\n"},"IMigratableStakingContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\n\n/// @title An interface for staking contracts which support stake migration.\ninterface IMigratableStakingContract {\n    /// @dev Returns the address of the underlying staked token.\n    /// @return IERC20 The address of the token.\n    function getToken() external view returns (IERC20);\n\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\n    /// the required amount using ERC20 approve.\n    /// @param _stakeOwner address The specified stake owner.\n    /// @param _amount uint256 The number of tokens to stake.\n    function acceptMigration(address _stakeOwner, uint256 _amount) external;\n\n    event AcceptedMigration(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ncontract Initializable {\n\n    address private _initializationAdmin;\n\n    event InitializationComplete();\n\n    constructor() public{\n        _initializationAdmin = msg.sender;\n    }\n\n    modifier onlyInitializationAdmin() {\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function initializationAdmin() public view returns (address) {\n        return _initializationAdmin;\n    }\n\n    function initializationComplete() external onlyInitializationAdmin {\n        _initializationAdmin = address(0);\n        emit InitializationComplete();\n    }\n\n    function isInitializationComplete() public view returns (bool) {\n        return _initializationAdmin == address(0);\n    }\n\n}"},"IProtocolWallet.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\nimport \"./IERC20.sol\";\n\n/// @title Protocol Wallet interface\ninterface IProtocolWallet {\n    event FundsAddedToPool(uint256 added, uint256 total);\n\n    /*\n    * External functions\n    */\n\n    /// @dev Returns the address of the underlying staked token.\n    /// @return balance uint256 the balance\n    function getBalance() external view returns (uint256 balance);\n\n    /// @dev Transfers the given amount of orbs tokens form the sender to this contract an update the pool.\n    function topUp(uint256 amount) external;\n\n    /// @dev Withdraw from pool to a the sender\u0027s address, limited by the pool\u0027s MaxRate.\n    /// A maximum of MaxRate x time period since the last Orbs transfer may be transferred out.\n    function withdraw(uint256 amount) external; /* onlyClient */\n\n\n    /*\n    * Governance functions\n    */\n\n    event ClientSet(address client);\n    event MaxAnnualRateSet(uint256 maxAnnualRate);\n    event EmergencyWithdrawal(address addr);\n    event OutstandingTokensReset(uint256 startTime);\n\n    /// @dev Sets a new transfer rate for the Orbs pool.\n    function setMaxAnnualRate(uint256 annual_rate) external; /* onlyMigrationManager */\n\n    function getMaxAnnualRate() external view returns (uint256);\n\n    /// @dev transfer the entire pool\u0027s balance to a new wallet.\n    function emergencyWithdraw() external; /* onlyMigrationManager */\n\n    /// @dev sets the address of the new contract\n    function setClient(address client) external; /* onlyFunctionalManager */\n\n    function resetOutstandingTokens(uint256 startTime) external; /* onlyMigrationOwner */\n\n    }\n"},"IStakingContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IMigratableStakingContract.sol\";\n\n/// @title An interface for staking contracts.\ninterface IStakingContract {\n    /// @dev Stakes ORBS tokens on behalf of msg.sender. This method assumes that the user has already approved at least\n    /// the required amount using ERC20 approve.\n    /// @param _amount uint256 The amount of tokens to stake.\n    function stake(uint256 _amount) external;\n\n    /// @dev Unstakes ORBS tokens from msg.sender. If successful, this will start the cooldown period, after which\n    /// msg.sender would be able to withdraw all of his tokens.\n    /// @param _amount uint256 The amount of tokens to unstake.\n    function unstake(uint256 _amount) external;\n\n    /// @dev Requests to withdraw all of staked ORBS tokens back to msg.sender. Stake owners can withdraw their ORBS\n    /// tokens only after previously unstaking them and after the cooldown period has passed (unless the contract was\n    /// requested to release all stakes).\n    function withdraw() external;\n\n    /// @dev Restakes unstaked ORBS tokens (in or after cooldown) for msg.sender.\n    function restake() external;\n\n    /// @dev Distributes staking rewards to a list of addresses by directly adding rewards to their stakes. This method\n    /// assumes that the user has already approved at least the required amount using ERC20 approve. Since this is a\n    /// convenience method, we aren\u0027t concerned about reaching block gas limit by using large lists. We assume that\n    /// callers will be able to properly batch/paginate their requests.\n    /// @param _totalAmount uint256 The total amount of rewards to distributes.\n    /// @param _stakeOwners address[] The addresses of the stake owners.\n    /// @param _amounts uint256[] The amounts of the rewards.\n    function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts) external;\n\n    /// @dev Returns the stake of the specified stake owner (excluding unstaked tokens).\n    /// @param _stakeOwner address The address to check.\n    /// @return uint256 The total stake.\n    function getStakeBalanceOf(address _stakeOwner) external view returns (uint256);\n\n    /// @dev Returns the total amount staked tokens (excluding unstaked tokens).\n    /// @return uint256 The total staked tokens of all stake owners.\n    function getTotalStakedTokens() external view returns (uint256);\n\n    /// @dev Returns the time that the cooldown period ends (or ended) and the amount of tokens to be released.\n    /// @param _stakeOwner address The address to check.\n    /// @return cooldownAmount uint256 The total tokens in cooldown.\n    /// @return cooldownEndTime uint256 The time when the cooldown period ends (in seconds).\n    function getUnstakeStatus(address _stakeOwner) external view returns (uint256 cooldownAmount,\n        uint256 cooldownEndTime);\n\n    /// @dev Migrates the stake of msg.sender from this staking contract to a new approved staking contract.\n    /// @param _newStakingContract IMigratableStakingContract The new staking contract which supports stake migration.\n    /// @param _amount uint256 The amount of tokens to migrate.\n    function migrateStakedTokens(IMigratableStakingContract _newStakingContract, uint256 _amount) external;\n\n    event Staked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event Unstaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event Withdrew(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event Restaked(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n    event MigratedStake(address indexed stakeOwner, uint256 amount, uint256 totalStakedAmount);\n}\n"},"IStakingRewards.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/// @title Staking rewards contract interface\ninterface IStakingRewards {\n\n    event DelegatorStakingRewardsAssigned(address indexed delegator, uint256 amount, uint256 totalAwarded, address guardian, uint256 delegatorRewardsPerToken);\n    event GuardianStakingRewardsAssigned(address indexed guardian, uint256 amount, uint256 totalAwarded, uint256 delegatorRewardsPerToken, uint256 stakingRewardsPerWeight);\n    event StakingRewardsClaimed(address indexed addr, uint256 claimedDelegatorRewards, uint256 claimedGuardianRewards, uint256 totalClaimedDelegatorRewards, uint256 totalClaimedGuardianRewards);\n    event StakingRewardsAllocated(uint256 allocatedRewards, uint256 stakingRewardsPerWeight);\n    event GuardianDelegatorsStakingRewardsPercentMilleUpdated(address indexed guardian, uint256 delegatorsStakingRewardsPercentMille);\n\n    /*\n     * External functions\n     */\n\n    /// @dev Returns the currently unclaimed orbs token reward balance of the given address.\n    function getStakingRewardsBalance(address addr) external view returns (uint256 balance);\n\n    /// @dev Allows Guardian to set a different delegator staking reward cut than the default\n    /// delegatorRewardsPercentMille accepts values between 0 - maxDelegatorsStakingRewardsPercentMille\n    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external;\n\n    /// @dev Returns the guardian\u0027s delegatorRewardsPercentMille\n    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external view returns (uint256 delegatorRewardsRatioPercentMille);\n\n    /// @dev Claims the staking rewards balance of addr by staking\n    function claimStakingRewards(address addr) external;\n\n    /// @dev Returns the amount of ORBS tokens in the staking wallet that were allocated\n    /// but not yet claimed. The staking wallet balance must always larger than the allocated value.\n    function getStakingRewardsWalletAllocatedTokens() external view returns (uint256 allocated);\n\n    function getGuardianStakingRewardsData(address guardian) external view returns (\n        uint256 balance,\n        uint256 claimed,\n        uint256 delegatorRewardsPerToken,\n        uint256 lastStakingRewardsPerWeight\n    );\n\n    function getDelegatorStakingRewardsData(address delegator) external view returns (\n        uint256 balance,\n        uint256 claimed,\n        uint256 lastDelegatorRewardsPerToken\n    );\n\n    function getStakingRewardsState() external view returns (\n        uint96 stakingRewardsPerWeight,\n        uint96 unclaimedStakingRewards\n    );\n\n    function getCurrentStakingRewardsRatePercentMille() external returns (uint256);\n\n    /// @dev called by the Committee contract upon expected change in the committee membership of the guardian\n    /// Triggers update of the member rewards\n    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external /* onlyCommitteeContract */;\n\n    /// @dev called by the Delegation contract upon expected change in a committee member delegator stake\n    /// Triggers update of the delegator and guardian staking rewards\n    function delegationWillChange(address guardian, uint256 delegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external /* onlyDelegationsContract */;\n\n    /*\n     * Governance functions\n     */\n\n    event AnnualStakingRewardsRateChanged(uint256 annualRateInPercentMille, uint256 annualCap);\n    event DefaultDelegatorsStakingRewardsChanged(uint32 defaultDelegatorsStakingRewardsPercentMille);\n    event MaxDelegatorsStakingRewardsChanged(uint32 maxDelegatorsStakingRewardsPercentMille);\n    event RewardDistributionActivated(uint256 startTime);\n    event RewardDistributionDeactivated();\n    event StakingRewardsBalanceMigrated(address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards, address toRewardsContract);\n    event StakingRewardsBalanceMigrationAccepted(address from, address indexed addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards);\n    event EmergencyWithdrawal(address addr);\n\n    /// @dev activates reward distribution, all rewards will be distributed up\n    /// assuming the last assignment was on startTime (the time the old contarct was deactivated)\n    function activateRewardDistribution(uint startTime) external /* onlyInitializationAdmin */;\n\n    /// @dev deactivates reward distribution, all rewards will be distributed up\n    /// deactivate moment.\n    function deactivateRewardDistribution() external /* onlyMigrationManager */;\n\n    /// @dev Sets the default cut of the delegators staking reward.\n    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager onlyWhenActive */;\n\n    function getDefaultDelegatorsStakingRewardsPercentMille() external view returns (uint32);\n\n    /// @dev Sets the maximum cut of the delegators staking reward.\n    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) external /* onlyFunctionalManager onlyWhenActive */;\n\n    function getMaxDelegatorsStakingRewardsPercentMille() external view returns (uint32);\n\n    /// @dev Sets a new annual rate and cap for the staking reward.\n    function setAnnualStakingRewardsRate(uint256 annualRateInPercentMille, uint256 annualCap) external /* onlyFunctionalManager */;\n\n    function getAnnualStakingRewardsRatePercentMille() external view returns (uint32);\n\n    function getAnnualStakingRewardsCap() external view returns (uint256);\n\n    function isRewardAllocationActive() external view returns (bool);\n\n    /// @dev Returns the contract\u0027s settings\n    function getSettings() external view returns (\n        uint annualStakingRewardsCap,\n        uint32 annualStakingRewardsRatePercentMille,\n        uint32 defaultDelegatorsStakingRewardsPercentMille,\n        uint32 maxDelegatorsStakingRewardsPercentMille,\n        bool rewardAllocationActive\n    );\n\n    /// @dev migrates the staking rewards balance of the guardian to the rewards contract as set in the registry.\n    function migrateRewardsBalance(address guardian) external;\n\n    /// @dev accepts guardian\u0027s balance migration from a previous rewards contarct.\n    function acceptRewardsBalanceMigration(address guardian, uint256 guardianStakingRewards, uint256 delegatorStakingRewards) external;\n\n    /// @dev emergency withdrawal of the rewards contract balances, may eb called only by the EmergencyManager. \n    function emergencyWithdraw() external /* onlyMigrationManager */;\n}\n\n"},"Lockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./ContractRegistryAccessor.sol\";\nimport \"./ILockable.sol\";\n\ncontract Lockable is ILockable, ContractRegistryAccessor {\n\n    bool public locked;\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) ContractRegistryAccessor(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyLockOwner() {\n        require(msg.sender == registryAdmin() || msg.sender == address(getContractRegistry()), \"caller is not a lock owner\");\n\n        _;\n    }\n\n    function lock() external override onlyLockOwner {\n        locked = true;\n        emit Locked();\n    }\n\n    function unlock() external override onlyLockOwner {\n        locked = false;\n        emit Unlocked();\n    }\n\n    function isLocked() external override view returns (bool) {\n        return locked;\n    }\n\n    modifier onlyWhenActive() {\n        require(!locked, \"contract is locked for this operation\");\n\n        _;\n    }\n}\n"},"ManagedContract.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Lockable.sol\";\n\ncontract ManagedContract is Lockable {\n\n    constructor(IContractRegistry _contractRegistry, address _registryAdmin) Lockable(_contractRegistry, _registryAdmin) public {}\n\n    modifier onlyMigrationManager {\n        require(isManager(\"migrationManager\"), \"sender is not the migration manager\");\n\n        _;\n    }\n\n    modifier onlyFunctionalManager {\n        require(isManager(\"functionalManager\"), \"sender is not the functional manager\");\n\n        _;\n    }\n\n    function refreshContracts() virtual external {}\n\n}"},"Math.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"SafeMath96.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath96 {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint96 a, uint256 b) internal pure returns (uint96) {\n        require(uint256(uint96(b)) == b, \"SafeMath: addition overflow\");\n        uint96 c = a + uint96(b);\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint96 a, uint256 b) internal pure returns (uint96) {\n        require(uint256(uint96(b)) == b, \"SafeMath: subtraction overflow\");\n        return sub(a, uint96(b), \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b \u003c= a, errorMessage);\n        uint96 c = a - b;\n\n        return c;\n    }\n\n}\n"},"StakingRewards.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./SafeMath.sol\";\nimport \"./SafeMath96.sol\";\nimport \"./Math.sol\";\nimport \"./IERC20.sol\";\n\nimport \"./ICommittee.sol\";\nimport \"./IProtocolWallet.sol\";\nimport \"./IStakingRewards.sol\";\nimport \"./IDelegation.sol\";\nimport \"./IStakingContract.sol\";\nimport \"./ManagedContract.sol\";\n\ncontract StakingRewards is IStakingRewards, ManagedContract {\n    using SafeMath for uint256;\n    using SafeMath96 for uint96;\n\n    uint256 constant PERCENT_MILLIE_BASE = 100000;\n    uint256 constant TOKEN_BASE = 1e18;\n\n    struct Settings {\n        uint96 annualCap;\n        uint32 annualRateInPercentMille;\n        uint32 defaultDelegatorsStakingRewardsPercentMille;\n        uint32 maxDelegatorsStakingRewardsPercentMille;\n        bool rewardAllocationActive;\n    }\n    Settings settings;\n\n    IERC20 public erc20;\n\n    struct StakingRewardsState {\n        uint96 stakingRewardsPerWeight;\n        uint96 unclaimedStakingRewards;\n        uint32 lastAssigned;\n    }\n    StakingRewardsState public stakingRewardsState;\n\n    uint256 public stakingRewardsWithdrawnFromWallet;\n\n    struct GuardianStakingRewards {\n        uint96 delegatorRewardsPerToken;\n        uint96 lastStakingRewardsPerWeight;\n        uint96 balance;\n        uint96 claimed;\n    }\n    mapping(address =\u003e GuardianStakingRewards) public guardiansStakingRewards;\n\n    struct GuardianRewardSettings {\n        uint32 delegatorsStakingRewardsPercentMille;\n        bool overrideDefault;\n    }\n    mapping(address =\u003e GuardianRewardSettings) public guardiansRewardSettings;\n\n    struct DelegatorStakingRewards {\n        uint96 balance;\n        uint96 lastDelegatorRewardsPerToken;\n        uint96 claimed;\n    }\n    mapping(address =\u003e DelegatorStakingRewards) public delegatorsStakingRewards;\n\n    constructor(\n        IContractRegistry _contractRegistry,\n        address _registryAdmin,\n        IERC20 _erc20,\n        uint annualRateInPercentMille,\n        uint annualCap,\n        uint32 defaultDelegatorsStakingRewardsPercentMille,\n        uint32 maxDelegatorsStakingRewardsPercentMille,\n        IStakingRewards previousRewardsContract,\n        address[] memory guardiansToMigrate\n    ) ManagedContract(_contractRegistry, _registryAdmin) public {\n        require(address(_erc20) != address(0), \"erc20 must not be 0\");\n\n        _setAnnualStakingRewardsRate(annualRateInPercentMille, annualCap);\n        setMaxDelegatorsStakingRewardsPercentMille(maxDelegatorsStakingRewardsPercentMille);\n        setDefaultDelegatorsStakingRewardsPercentMille(defaultDelegatorsStakingRewardsPercentMille);\n\n        erc20 = _erc20;\n\n        if (address(previousRewardsContract) != address(0)) {\n            migrateGuardiansSettings(previousRewardsContract, guardiansToMigrate);\n        }\n    }\n\n    modifier onlyCommitteeContract() {\n        require(msg.sender == address(committeeContract), \"caller is not the elections contract\");\n\n        _;\n    }\n\n    modifier onlyDelegationsContract() {\n        require(msg.sender == address(delegationsContract), \"caller is not the delegations contract\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function committeeMembershipWillChange(address guardian, uint256 weight, uint256 totalCommitteeWeight, bool inCommittee, bool inCommitteeAfter) external override onlyWhenActive onlyCommitteeContract {\n        uint256 delegatedStake = delegationsContract.getDelegatedStake(guardian);\n\n        Settings memory _settings = settings;\n        StakingRewardsState memory _stakingRewardsState = _updateStakingRewardsState(totalCommitteeWeight, _settings);\n        _updateGuardianStakingRewards(guardian, inCommittee, inCommitteeAfter, weight, delegatedStake, _stakingRewardsState, _settings);\n    }\n\n    function delegationWillChange(address guardian, uint256 guardianDelegatedStake, address delegator, uint256 delegatorStake, address nextGuardian, uint256 nextGuardianDelegatedStake) external override onlyWhenActive onlyDelegationsContract {\n        Settings memory _settings = settings;\n        (bool inCommittee, uint256 weight, , uint256 totalCommitteeWeight) = committeeContract.getMemberInfo(guardian);\n\n        StakingRewardsState memory _stakingRewardsState = _updateStakingRewardsState(totalCommitteeWeight, _settings);\n        GuardianStakingRewards memory guardianStakingRewards = _updateGuardianStakingRewards(guardian, inCommittee, inCommittee, weight, guardianDelegatedStake, _stakingRewardsState, _settings);\n        _updateDelegatorStakingRewards(delegator, delegatorStake, guardian, guardianStakingRewards);\n\n        if (nextGuardian != guardian) {\n            (inCommittee, weight, , totalCommitteeWeight) = committeeContract.getMemberInfo(nextGuardian);\n            GuardianStakingRewards memory nextGuardianStakingRewards = _updateGuardianStakingRewards(nextGuardian, inCommittee, inCommittee, weight, nextGuardianDelegatedStake, _stakingRewardsState, _settings);\n            delegatorsStakingRewards[delegator].lastDelegatorRewardsPerToken = nextGuardianStakingRewards.delegatorRewardsPerToken;\n        }\n    }\n\n    function getStakingRewardsBalance(address addr) external override view returns (uint256) {\n        DelegatorStakingRewards memory delegatorStakingRewards = getDelegatorStakingRewards(addr);\n        GuardianStakingRewards memory guardianStakingRewards = getGuardianStakingRewards(addr); // TODO consider removing, data in state must be up to date at this point\n        return delegatorStakingRewards.balance.add(guardianStakingRewards.balance);\n    }\n\n    function claimStakingRewards(address addr) external override onlyWhenActive {\n        (uint256 guardianRewards, uint256 delegatorRewards) = claimStakingRewardsLocally(addr);\n\n        uint96 claimedGuardianRewards = guardiansStakingRewards[addr].claimed.add(guardianRewards);\n        guardiansStakingRewards[addr].claimed = claimedGuardianRewards;\n        uint96 claimedDelegatorRewards = delegatorsStakingRewards[addr].claimed.add(delegatorRewards);\n        delegatorsStakingRewards[addr].claimed = claimedDelegatorRewards;\n\n        uint256 total = delegatorRewards.add(guardianRewards);\n\n        require(erc20.approve(address(stakingContract), total), \"claimStakingRewards: approve failed\");\n\n        address[] memory addrs = new address[](1);\n        addrs[0] = addr;\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = total;\n        stakingContract.distributeRewards(total, addrs, amounts);\n\n        emit StakingRewardsClaimed(addr, delegatorRewards, guardianRewards, claimedDelegatorRewards, claimedGuardianRewards);\n    }\n\n    function getGuardianStakingRewardsData(address guardian) external override view returns (\n        uint256 balance,\n        uint256 claimed,\n        uint256 delegatorRewardsPerToken,\n        uint256 lastStakingRewardsPerWeight\n    ) {\n        GuardianStakingRewards memory rewards = getGuardianStakingRewards(guardian);\n        return (rewards.balance, rewards.claimed, rewards.delegatorRewardsPerToken, rewards.lastStakingRewardsPerWeight);\n    }\n\n    function getDelegatorStakingRewardsData(address delegator) external override view returns (\n        uint256 balance,\n        uint256 claimed,\n        uint256 lastDelegatorRewardsPerToken\n    ) {\n        DelegatorStakingRewards memory rewards = getDelegatorStakingRewards(delegator);\n        return (rewards.balance, rewards.claimed, rewards.lastDelegatorRewardsPerToken);\n    }\n\n    function getStakingRewardsState() public override view returns (\n        uint96 stakingRewardsPerWeight,\n        uint96 unclaimedStakingRewards\n    ) {\n        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n        (StakingRewardsState memory _stakingRewardsState,) = _getStakingRewardsState(totalCommitteeWeight, settings);\n        stakingRewardsPerWeight = _stakingRewardsState.stakingRewardsPerWeight;\n        unclaimedStakingRewards = _stakingRewardsState.unclaimedStakingRewards;\n    }\n\n    function getCurrentStakingRewardsRatePercentMille() external override returns (uint256) {\n        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n        return _getAnnualRate(totalCommitteeWeight, settings);\n    }\n\n    function setGuardianDelegatorsStakingRewardsPercentMille(uint32 delegatorRewardsPercentMille) external override onlyWhenActive {\n        require(delegatorRewardsPercentMille \u003c= PERCENT_MILLIE_BASE, \"delegatorRewardsPercentMille must be 100000 at most\");\n        require(delegatorRewardsPercentMille \u003c= settings.maxDelegatorsStakingRewardsPercentMille, \"delegatorRewardsPercentMille must not be larger than maxDelegatorsStakingRewardsPercentMille\");\n        updateDelegatorStakingRewards(msg.sender);\n        _setGuardianDelegatorsStakingRewardsPercentMille(msg.sender, delegatorRewardsPercentMille);\n    }\n\n    function getGuardianDelegatorsStakingRewardsPercentMille(address guardian) external override view returns (uint256 delegatorRewardsRatioPercentMille) {\n        return _getGuardianDelegatorsStakingRewardsPercentMille(guardian, settings);\n    }\n\n    function getStakingRewardsWalletAllocatedTokens() external override view returns (uint256 allocated) {\n        (, uint96 unclaimedStakingRewards) = getStakingRewardsState();\n        return uint256(unclaimedStakingRewards).sub(stakingRewardsWithdrawnFromWallet);\n    }\n\n    /*\n    * Governance functions\n    */\n\n    function migrateRewardsBalance(address addr) external override {\n        require(!settings.rewardAllocationActive, \"Reward distribution must be deactivated for migration\");\n\n        IStakingRewards currentRewardsContract = IStakingRewards(getStakingRewardsContract());\n        require(address(currentRewardsContract) != address(this), \"New rewards contract is not set\");\n\n        (uint256 guardianRewards, uint256 delegatorRewards) = claimStakingRewardsLocally(addr);\n\n        require(erc20.approve(address(currentRewardsContract), guardianRewards.add(delegatorRewards)), \"migrateRewardsBalance: approve failed\");\n        currentRewardsContract.acceptRewardsBalanceMigration(addr, guardianRewards, delegatorRewards);\n\n        emit StakingRewardsBalanceMigrated(addr, guardianRewards, delegatorRewards, address(currentRewardsContract));\n    }\n\n    function acceptRewardsBalanceMigration(address addr, uint256 guardianStakingRewards, uint256 delegatorStakingRewards) external override {\n        guardiansStakingRewards[addr].balance = guardiansStakingRewards[addr].balance.add(guardianStakingRewards);\n        delegatorsStakingRewards[addr].balance = delegatorsStakingRewards[addr].balance.add(delegatorStakingRewards);\n\n        uint orbsTransferAmount = guardianStakingRewards.add(delegatorStakingRewards);\n        if (orbsTransferAmount \u003e 0) {\n            require(erc20.transferFrom(msg.sender, address(this), orbsTransferAmount), \"acceptRewardBalanceMigration: transfer failed\");\n        }\n\n        emit StakingRewardsBalanceMigrationAccepted(msg.sender, addr, guardianStakingRewards, delegatorStakingRewards);\n    }\n\n    function emergencyWithdraw() external override onlyMigrationManager {\n        emit EmergencyWithdrawal(msg.sender);\n        require(erc20.transfer(msg.sender, erc20.balanceOf(address(this))), \"Rewards::emergencyWithdraw - transfer failed (orbs token)\");\n    }\n\n    function activateRewardDistribution(uint startTime) external override onlyMigrationManager {\n        stakingRewardsState.lastAssigned = uint32(startTime);\n        settings.rewardAllocationActive = true;\n\n        emit RewardDistributionActivated(startTime);\n    }\n\n    function deactivateRewardDistribution() external override onlyMigrationManager {\n        require(settings.rewardAllocationActive, \"reward distribution is already deactivated\");\n\n        updateStakingRewardsState();\n\n        settings.rewardAllocationActive = false;\n\n        emit RewardDistributionDeactivated();\n    }\n\n    function setDefaultDelegatorsStakingRewardsPercentMille(uint32 defaultDelegatorsStakingRewardsPercentMille) public override onlyFunctionalManager {\n        require(defaultDelegatorsStakingRewardsPercentMille \u003c= PERCENT_MILLIE_BASE, \"defaultDelegatorsStakingRewardsPercentMille must not be larger than 100000\");\n        require(defaultDelegatorsStakingRewardsPercentMille \u003c= settings.maxDelegatorsStakingRewardsPercentMille, \"defaultDelegatorsStakingRewardsPercentMille must not be larger than maxDelegatorsStakingRewardsPercentMille\");\n        settings.defaultDelegatorsStakingRewardsPercentMille = defaultDelegatorsStakingRewardsPercentMille;\n        emit DefaultDelegatorsStakingRewardsChanged(defaultDelegatorsStakingRewardsPercentMille);\n    }\n\n    function getDefaultDelegatorsStakingRewardsPercentMille() public override view returns (uint32) {\n        return settings.defaultDelegatorsStakingRewardsPercentMille;\n    }\n\n    function setMaxDelegatorsStakingRewardsPercentMille(uint32 maxDelegatorsStakingRewardsPercentMille) public override onlyFunctionalManager {\n        require(maxDelegatorsStakingRewardsPercentMille \u003c= PERCENT_MILLIE_BASE, \"maxDelegatorsStakingRewardsPercentMille must not be larger than 100000\");\n        settings.maxDelegatorsStakingRewardsPercentMille = maxDelegatorsStakingRewardsPercentMille;\n        emit MaxDelegatorsStakingRewardsChanged(maxDelegatorsStakingRewardsPercentMille);\n    }\n\n    function getMaxDelegatorsStakingRewardsPercentMille() public override view returns (uint32) {\n        return settings.maxDelegatorsStakingRewardsPercentMille;\n    }\n\n    function setAnnualStakingRewardsRate(uint256 annualRateInPercentMille, uint256 annualCap) external override onlyFunctionalManager {\n        updateStakingRewardsState();\n        return _setAnnualStakingRewardsRate(annualRateInPercentMille, annualCap);\n    }\n\n    function getAnnualStakingRewardsRatePercentMille() external override view returns (uint32) {\n        return settings.annualRateInPercentMille;\n    }\n\n    function getAnnualStakingRewardsCap() external override view returns (uint256) {\n        return settings.annualCap;\n    }\n\n    function isRewardAllocationActive() external override view returns (bool) {\n        return settings.rewardAllocationActive;\n    }\n\n    function getSettings() external override view returns (\n        uint annualStakingRewardsCap,\n        uint32 annualStakingRewardsRatePercentMille,\n        uint32 defaultDelegatorsStakingRewardsPercentMille,\n        uint32 maxDelegatorsStakingRewardsPercentMille,\n        bool rewardAllocationActive\n    ) {\n        Settings memory _settings = settings;\n        annualStakingRewardsCap = _settings.annualCap;\n        annualStakingRewardsRatePercentMille = _settings.annualRateInPercentMille;\n        defaultDelegatorsStakingRewardsPercentMille = _settings.defaultDelegatorsStakingRewardsPercentMille;\n        maxDelegatorsStakingRewardsPercentMille = _settings.maxDelegatorsStakingRewardsPercentMille;\n        rewardAllocationActive = _settings.rewardAllocationActive;\n    }\n\n    /*\n    * Private functions\n    */\n\n    // Global state\n\n    function _getAnnualRate(uint256 totalCommitteeWeight, Settings memory _settings) private pure returns (uint256) {\n        return totalCommitteeWeight == 0 ? 0 : Math.min(uint(_settings.annualRateInPercentMille), uint256(_settings.annualCap).mul(PERCENT_MILLIE_BASE).div(totalCommitteeWeight));\n    }\n\n    function calcStakingRewardPerWeightDelta(uint256 totalCommitteeWeight, uint duration, Settings memory _settings) private pure returns (uint256 stakingRewardsPerTokenDelta) {\n        stakingRewardsPerTokenDelta = 0;\n\n        if (totalCommitteeWeight \u003e 0) {\n            uint annualRateInPercentMille = _getAnnualRate(totalCommitteeWeight, _settings);\n            stakingRewardsPerTokenDelta = annualRateInPercentMille.mul(TOKEN_BASE).mul(duration).div(PERCENT_MILLIE_BASE.mul(365 days));\n        }\n    }\n\n    function _getStakingRewardsState(uint256 totalCommitteeWeight, Settings memory _settings) private view returns (StakingRewardsState memory _stakingRewardsState, uint256 allocatedRewards) {\n        _stakingRewardsState = stakingRewardsState;\n        if (_settings.rewardAllocationActive) {\n            uint delta = calcStakingRewardPerWeightDelta(totalCommitteeWeight, block.timestamp.sub(stakingRewardsState.lastAssigned), _settings);\n            _stakingRewardsState.stakingRewardsPerWeight = stakingRewardsState.stakingRewardsPerWeight.add(delta);\n            _stakingRewardsState.lastAssigned = uint32(block.timestamp);\n            allocatedRewards = delta.mul(totalCommitteeWeight).div(TOKEN_BASE);\n            _stakingRewardsState.unclaimedStakingRewards = _stakingRewardsState.unclaimedStakingRewards.add(allocatedRewards);\n        }\n    }\n\n    function _updateStakingRewardsState(uint256 totalCommitteeWeight, Settings memory _settings) private returns (StakingRewardsState memory _stakingRewardsState) {\n        if (!_settings.rewardAllocationActive) {\n            return stakingRewardsState;\n        }\n\n        uint allocatedRewards;\n        (_stakingRewardsState, allocatedRewards) = _getStakingRewardsState(totalCommitteeWeight, _settings);\n        stakingRewardsState = _stakingRewardsState;\n        emit StakingRewardsAllocated(allocatedRewards, _stakingRewardsState.stakingRewardsPerWeight);\n    }\n\n    function updateStakingRewardsState() private returns (StakingRewardsState memory _stakingRewardsState) {\n        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n        return _updateStakingRewardsState(totalCommitteeWeight, settings);\n    }\n\n    // Guardian state\n\n    function _getGuardianStakingRewards(address guardian, bool inCommittee, bool inCommitteeAfter, uint256 guardianWeight, uint256 guardianDelegatedStake, StakingRewardsState memory _stakingRewardsState, Settings memory _settings) private view returns (GuardianStakingRewards memory guardianStakingRewards, uint256 rewardsAdded) {\n        guardianStakingRewards = guardiansStakingRewards[guardian];\n\n        if (inCommittee) {\n            uint256 totalRewards = uint256(_stakingRewardsState.stakingRewardsPerWeight)\n                .sub(guardianStakingRewards.lastStakingRewardsPerWeight)\n                .mul(guardianWeight);\n\n            uint256 delegatorRewardsRatioPercentMille = _getGuardianDelegatorsStakingRewardsPercentMille(guardian, _settings);\n\n            uint256 delegatorRewardsPerTokenDelta = guardianDelegatedStake == 0 ? 0 : totalRewards\n                .div(guardianDelegatedStake)\n                .mul(delegatorRewardsRatioPercentMille)\n                .div(PERCENT_MILLIE_BASE);\n\n            uint256 guardianCutPercentMille = PERCENT_MILLIE_BASE.sub(delegatorRewardsRatioPercentMille);\n\n            rewardsAdded = totalRewards\n                    .mul(guardianCutPercentMille)\n                    .div(PERCENT_MILLIE_BASE)\n                    .div(TOKEN_BASE);\n\n            guardianStakingRewards.delegatorRewardsPerToken = guardianStakingRewards.delegatorRewardsPerToken.add(delegatorRewardsPerTokenDelta);\n            guardianStakingRewards.balance = guardianStakingRewards.balance.add(rewardsAdded);\n        }\n\n        guardianStakingRewards.lastStakingRewardsPerWeight = inCommitteeAfter ? _stakingRewardsState.stakingRewardsPerWeight : 0;\n    }\n\n    function getGuardianStakingRewards(address guardian) private view returns (GuardianStakingRewards memory guardianStakingRewards) {\n        Settings memory _settings = settings;\n\n        (bool inCommittee, uint256 guardianWeight, ,uint256 totalCommitteeWeight) = committeeContract.getMemberInfo(guardian);\n        uint256 guardianDelegatedStake = delegationsContract.getDelegatedStake(guardian);\n\n        (StakingRewardsState memory _stakingRewardsState,) = _getStakingRewardsState(totalCommitteeWeight, _settings);\n        (guardianStakingRewards,) = _getGuardianStakingRewards(guardian, inCommittee, inCommittee, guardianWeight, guardianDelegatedStake, _stakingRewardsState, _settings);\n    }\n\n    function _updateGuardianStakingRewards(address guardian, bool inCommittee, bool inCommitteeAfter, uint256 guardianWeight, uint256 guardianDelegatedStake, StakingRewardsState memory _stakingRewardsState, Settings memory _settings) private returns (GuardianStakingRewards memory guardianStakingRewards) {\n        uint256 guardianStakingRewardsAdded;\n        (guardianStakingRewards, guardianStakingRewardsAdded) = _getGuardianStakingRewards(guardian, inCommittee, inCommitteeAfter, guardianWeight, guardianDelegatedStake, _stakingRewardsState, _settings);\n        guardiansStakingRewards[guardian] = guardianStakingRewards;\n        emit GuardianStakingRewardsAssigned(guardian, guardianStakingRewardsAdded, guardianStakingRewards.claimed.add(guardianStakingRewards.balance), guardianStakingRewards.delegatorRewardsPerToken, _stakingRewardsState.stakingRewardsPerWeight);\n    }\n\n    function updateGuardianStakingRewards(address guardian, StakingRewardsState memory _stakingRewardsState, Settings memory _settings) private returns (GuardianStakingRewards memory guardianStakingRewards) {\n        (bool inCommittee, uint256 guardianWeight,,) = committeeContract.getMemberInfo(guardian);\n        return _updateGuardianStakingRewards(guardian, inCommittee, inCommittee, guardianWeight, delegationsContract.getDelegatedStake(guardian), _stakingRewardsState, _settings);\n    }\n\n    // Delegator state\n\n    function _getDelegatorStakingRewards(address delegator, uint256 delegatorStake, GuardianStakingRewards memory guardianStakingRewards) private view returns (DelegatorStakingRewards memory delegatorStakingRewards, uint256 delegatorRewardsAdded) {\n        delegatorStakingRewards = delegatorsStakingRewards[delegator];\n\n        delegatorRewardsAdded = uint256(guardianStakingRewards.delegatorRewardsPerToken)\n                .sub(delegatorStakingRewards.lastDelegatorRewardsPerToken)\n                .mul(delegatorStake)\n                .div(TOKEN_BASE);\n\n        delegatorStakingRewards.balance = delegatorStakingRewards.balance.add(delegatorRewardsAdded);\n        delegatorStakingRewards.lastDelegatorRewardsPerToken = guardianStakingRewards.delegatorRewardsPerToken;\n    }\n\n    function getDelegatorStakingRewards(address delegator) private view returns (DelegatorStakingRewards memory delegatorStakingRewards) {\n        (address guardian, uint256 delegatorStake) = delegationsContract.getDelegationInfo(delegator);\n        GuardianStakingRewards memory guardianStakingRewards = getGuardianStakingRewards(guardian);\n\n        (delegatorStakingRewards,) = _getDelegatorStakingRewards(delegator, delegatorStake, guardianStakingRewards);\n    }\n\n    function _updateDelegatorStakingRewards(address delegator, uint256 delegatorStake, address guardian, GuardianStakingRewards memory guardianStakingRewards) private {\n        uint256 delegatorStakingRewardsAdded;\n        DelegatorStakingRewards memory delegatorStakingRewards;\n        (delegatorStakingRewards, delegatorStakingRewardsAdded) = _getDelegatorStakingRewards(delegator, delegatorStake, guardianStakingRewards);\n        delegatorsStakingRewards[delegator] = delegatorStakingRewards;\n\n        emit DelegatorStakingRewardsAssigned(delegator, delegatorStakingRewardsAdded, delegatorStakingRewards.claimed.add(delegatorStakingRewards.balance), guardian, guardianStakingRewards.delegatorRewardsPerToken);\n    }\n\n    function updateDelegatorStakingRewards(address delegator) private {\n        Settings memory _settings = settings;\n\n        (, , uint totalCommitteeWeight) = committeeContract.getCommitteeStats();\n        StakingRewardsState memory _stakingRewardsState = _updateStakingRewardsState(totalCommitteeWeight, _settings);\n\n        (address guardian, uint delegatorStake) = delegationsContract.getDelegationInfo(delegator);\n        GuardianStakingRewards memory guardianRewards = updateGuardianStakingRewards(guardian, _stakingRewardsState, _settings);\n\n        _updateDelegatorStakingRewards(delegator, delegatorStake, guardian, guardianRewards);\n    }\n\n    // Guardian settings\n\n    function _getGuardianDelegatorsStakingRewardsPercentMille(address guardian, Settings memory _settings) private view returns (uint256 delegatorRewardsRatioPercentMille) {\n        GuardianRewardSettings memory guardianSettings = guardiansRewardSettings[guardian];\n        delegatorRewardsRatioPercentMille =  guardianSettings.overrideDefault ? guardianSettings.delegatorsStakingRewardsPercentMille : _settings.defaultDelegatorsStakingRewardsPercentMille;\n        return Math.min(delegatorRewardsRatioPercentMille, _settings.maxDelegatorsStakingRewardsPercentMille);\n    }\n\n    function migrateGuardiansSettings(IStakingRewards previousRewardsContract, address[] memory guardiansToMigrate) private {\n        for (uint i = 0; i \u003c guardiansToMigrate.length; i++) {\n            _setGuardianDelegatorsStakingRewardsPercentMille(guardiansToMigrate[i], uint32(previousRewardsContract.getGuardianDelegatorsStakingRewardsPercentMille(guardiansToMigrate[i])));\n        }\n    }\n\n    // Governance and misc.\n\n    function _setAnnualStakingRewardsRate(uint256 annualRateInPercentMille, uint256 annualCap) private {\n        require(uint256(uint96(annualCap)) == annualCap, \"annualCap must fit in uint96\");\n\n        Settings memory _settings = settings;\n        _settings.annualRateInPercentMille = uint32(annualRateInPercentMille);\n        _settings.annualCap = uint96(annualCap);\n        settings = _settings;\n\n        emit AnnualStakingRewardsRateChanged(annualRateInPercentMille, annualCap);\n    }\n\n    function _setGuardianDelegatorsStakingRewardsPercentMille(address guardian, uint32 delegatorRewardsPercentMille) private {\n        guardiansRewardSettings[guardian] = GuardianRewardSettings({\n            overrideDefault: true,\n            delegatorsStakingRewardsPercentMille: delegatorRewardsPercentMille\n            });\n\n        emit GuardianDelegatorsStakingRewardsPercentMilleUpdated(guardian, delegatorRewardsPercentMille);\n    }\n\n    function claimStakingRewardsLocally(address addr) private returns (uint256 guardianRewards, uint256 delegatorRewards) {\n        updateDelegatorStakingRewards(addr);\n\n        guardianRewards = guardiansStakingRewards[addr].balance;\n        guardiansStakingRewards[addr].balance = 0;\n\n        delegatorRewards = delegatorsStakingRewards[addr].balance;\n        delegatorsStakingRewards[addr].balance = 0;\n\n        uint256 total = delegatorRewards.add(guardianRewards);\n\n        StakingRewardsState memory _stakingRewardsState = stakingRewardsState;\n\n        uint256 _stakingRewardsWithdrawnFromWallet = stakingRewardsWithdrawnFromWallet;\n        if (total \u003e _stakingRewardsWithdrawnFromWallet) {\n            uint256 allocated = _stakingRewardsState.unclaimedStakingRewards.sub(_stakingRewardsWithdrawnFromWallet);\n            stakingRewardsWallet.withdraw(allocated);\n            _stakingRewardsWithdrawnFromWallet = _stakingRewardsWithdrawnFromWallet.add(allocated);\n        }\n\n        stakingRewardsWithdrawnFromWallet = _stakingRewardsWithdrawnFromWallet.sub(total);\n        stakingRewardsState.unclaimedStakingRewards = _stakingRewardsState.unclaimedStakingRewards.sub(total);\n    }\n\n    /*\n     * Contracts topology / registry interface\n     */\n\n    ICommittee committeeContract;\n    IDelegations delegationsContract;\n    IProtocolWallet stakingRewardsWallet;\n    IStakingContract stakingContract;\n    function refreshContracts() external override {\n        committeeContract = ICommittee(getCommitteeContract());\n        delegationsContract = IDelegations(getDelegationsContract());\n        stakingRewardsWallet = IProtocolWallet(getStakingRewardsWallet());\n        stakingContract = IStakingContract(getStakingContract());\n    }\n}\n"},"WithClaimableRegistryManagement.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract WithClaimableRegistryManagement is Context {\n    address private _registryAdmin;\n    address private _pendingRegistryAdmin;\n\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _registryAdmin = msgSender;\n        emit RegistryManagementTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current registryAdmin.\n     */\n    function registryAdmin() public view returns (address) {\n        return _registryAdmin;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the registryAdmin.\n     */\n    modifier onlyRegistryAdmin() {\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current registryAdmin.\n     */\n    function isRegistryAdmin() public view returns (bool) {\n        return _msgSender() == _registryAdmin;\n    }\n\n    /**\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n     *\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n     * thereby removing any functionality that is only available to the registryAdmin.\n     */\n    function renounceRegistryManagement() public onlyRegistryAdmin {\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\n        _registryAdmin = address(0);\n    }\n\n    /**\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n     */\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n        _registryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingManager.\n     */\n    modifier onlyPendingRegistryAdmin() {\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\n        _;\n    }\n    /**\n     * @dev Allows the current registryAdmin to set the pendingManager address.\n     * @param newRegistryAdmin The address to transfer registryManagement to.\n     */\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n        _pendingRegistryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n     */\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n        _transferRegistryManagement(_pendingRegistryAdmin);\n        _pendingRegistryAdmin = address(0);\n    }\n\n    /**\n     * @dev Returns the current pendingRegistryAdmin\n    */\n    function pendingRegistryAdmin() public view returns (address) {\n       return _pendingRegistryAdmin;  \n    }\n}\n"}}