{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"ContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\nimport \"./IContractRegistry.sol\";\nimport \"./ILockable.sol\";\nimport \"./IContractRegistryListener.sol\";\nimport \"./WithClaimableRegistryManagement.sol\";\nimport \"./Initializable.sol\";\n\ncontract ContractRegistry is IContractRegistry, Initializable, WithClaimableRegistryManagement {\n\n\taddress previousContractRegistry;\n\tmapping(string =\u003e address) contracts;\n\taddress[] managedContractAddresses;\n\tmapping(string =\u003e address) managers;\n\n\tconstructor(address _previousContractRegistry, address registryAdmin) public {\n\t\tpreviousContractRegistry = _previousContractRegistry;\n\t\t_transferRegistryManagement(registryAdmin);\n\t}\n\n\tmodifier onlyAdmin {\n\t\trequire(msg.sender == registryAdmin() || msg.sender == initializationAdmin(), \"sender is not an admin (registryAdmin or initializationAdmin when initialization in progress)\");\n\n\t\t_;\n\t}\n\n\tmodifier onlyAdminOrMigrationManager {\n\t\trequire(msg.sender == registryAdmin() || msg.sender == initializationAdmin() || msg.sender == managers[\"migrationManager\"], \"sender is not an admin (registryAdmin or initializationAdmin when initialization in progress) and not the migration manager\");\n\n\t\t_;\n\t}\n\n\t/*\n\t* External functions\n\t*/\n\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external override onlyAdminOrMigrationManager {\n\t\trequire(!managedContract || addr != address(0), \"managed contract may not have address(0)\");\n\t\tremoveManagedContract(contracts[contractName]);\n\t\tcontracts[contractName] = addr;\n\t\tif (managedContract) {\n\t\t\taddManagedContract(addr);\n\t\t}\n\t\temit ContractAddressUpdated(contractName, addr, managedContract);\n\t\tnotifyOnContractsChange();\n\t}\n\n\tfunction getContract(string calldata contractName) external override view returns (address) {\n\t\treturn contracts[contractName];\n\t}\n\n\tfunction lockContracts() external override onlyAdminOrMigrationManager {\n\t\tfor (uint i = 0; i \u003c managedContractAddresses.length; i++) {\n\t\t\tILockable(managedContractAddresses[i]).lock();\n\t\t}\n\t}\n\n\tfunction unlockContracts() external override onlyAdminOrMigrationManager {\n\t\tfor (uint i = 0; i \u003c managedContractAddresses.length; i++) {\n\t\t\tILockable(managedContractAddresses[i]).unlock();\n\t\t}\n\t}\n\n\tfunction getManagedContracts() external override view returns (address[] memory) {\n\t\treturn managedContractAddresses;\n\t}\n\n\tfunction setManager(string calldata role, address manager) external override onlyAdmin {\n\t\tmanagers[role] = manager;\n\t\temit ManagerChanged(role, manager);\n\t}\n\n\tfunction getManager(string calldata role) external override view returns (address) {\n\t\treturn managers[role];\n\t}\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external override onlyAdmin {\n\t\tfor (uint i = 0; i \u003c managedContractAddresses.length; i++) {\n\t\t\tIContractRegistryListener(managedContractAddresses[i]).setContractRegistry(newRegistry);\n\t\t\tIContractRegistryListener(managedContractAddresses[i]).refreshContracts();\n\t\t}\n\t\temit ContractRegistryUpdated(address(newRegistry));\n\t}\n\n\tfunction getPreviousContractRegistry() external override view returns (address) {\n\t\treturn previousContractRegistry;\n\t}\n\n\t/*\n\t* Private methods\n\t*/\n\n\tfunction notifyOnContractsChange() private {\n\t\tfor (uint i = 0; i \u003c managedContractAddresses.length; i++) {\n\t\t\tIContractRegistryListener(managedContractAddresses[i]).refreshContracts();\n\t\t}\n\t}\n\n\tfunction addManagedContract(address addr) private {\n\t\tmanagedContractAddresses.push(addr);\n\t}\n\n\tfunction removeManagedContract(address addr) private {\n\t\tuint length = managedContractAddresses.length;\n\t\tfor (uint i = 0; i \u003c length; i++) {\n\t\t\tif (managedContractAddresses[i] == addr) {\n\t\t\t\tif (i != length - 1) {\n\t\t\t\t\tmanagedContractAddresses[i] = managedContractAddresses[length-1];\n\t\t\t\t}\n\t\t\t\tmanagedContractAddresses.pop();\n\t\t\t\tlength--;\n\t\t\t}\n\t\t}\n\t}\n\n}\n"},"IContractRegistry.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface IContractRegistry {\n\n\tevent ContractAddressUpdated(string contractName, address addr, bool managedContract);\n\tevent ManagerChanged(string role, address newManager);\n\tevent ContractRegistryUpdated(address newContractRegistry);\n\n\t/*\n\t* External functions\n\t*/\n\n\t/// @dev updates the contracts address and emits a corresponding event\n\t/// managedContract indicates whether the contract is managed by the registry and notified on changes\n\tfunction setContract(string calldata contractName, address addr, bool managedContract) external /* onlyAdmin */;\n\n\t/// @dev returns the current address of the given contracts\n\tfunction getContract(string calldata contractName) external view returns (address);\n\n\t/// @dev returns the list of contract addresses managed by the registry\n\tfunction getManagedContracts() external view returns (address[] memory);\n\n\tfunction setManager(string calldata role, address manager) external /* onlyAdmin */;\n\n\tfunction getManager(string calldata role) external view returns (address);\n\n\tfunction lockContracts() external /* onlyAdmin */;\n\n\tfunction unlockContracts() external /* onlyAdmin */;\n\n\tfunction setNewContractRegistry(IContractRegistry newRegistry) external /* onlyAdmin */;\n\n\tfunction getPreviousContractRegistry() external view returns (address);\n\n}\n"},"IContractRegistryListener.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./IContractRegistry.sol\";\n\ninterface IContractRegistryListener {\n\n    function refreshContracts() external;\n\n    function setContractRegistry(IContractRegistry newRegistry) external;\n\n}\n"},"ILockable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ninterface ILockable {\n\n    event Locked();\n    event Unlocked();\n\n    function lock() external /* onlyLockOwner */;\n    function unlock() external /* onlyLockOwner */;\n    function isLocked() view external returns (bool);\n\n}\n"},"Initializable.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\ncontract Initializable {\n\n    address private _initializationAdmin;\n\n    event InitializationComplete();\n\n    constructor() public{\n        _initializationAdmin = msg.sender;\n    }\n\n    modifier onlyInitializationAdmin() {\n        require(msg.sender == initializationAdmin(), \"sender is not the initialization admin\");\n\n        _;\n    }\n\n    /*\n    * External functions\n    */\n\n    function initializationAdmin() public view returns (address) {\n        return _initializationAdmin;\n    }\n\n    function initializationComplete() external onlyInitializationAdmin {\n        _initializationAdmin = address(0);\n        emit InitializationComplete();\n    }\n\n    function isInitializationComplete() public view returns (bool) {\n        return _initializationAdmin == address(0);\n    }\n\n}"},"WithClaimableRegistryManagement.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.12;\n\nimport \"./Context.sol\";\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract WithClaimableRegistryManagement is Context {\n    address private _registryAdmin;\n    address private _pendingRegistryAdmin;\n\n    event RegistryManagementTransferred(address indexed previousRegistryAdmin, address indexed newRegistryAdmin);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial registryRegistryAdmin.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _registryAdmin = msgSender;\n        emit RegistryManagementTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current registryAdmin.\n     */\n    function registryAdmin() public view returns (address) {\n        return _registryAdmin;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the registryAdmin.\n     */\n    modifier onlyRegistryAdmin() {\n        require(isRegistryAdmin(), \"WithClaimableRegistryManagement: caller is not the registryAdmin\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current registryAdmin.\n     */\n    function isRegistryAdmin() public view returns (bool) {\n        return _msgSender() == _registryAdmin;\n    }\n\n    /**\n     * @dev Leaves the contract without registryAdmin. It will not be possible to call\n     * `onlyManager` functions anymore. Can only be called by the current registryAdmin.\n     *\n     * NOTE: Renouncing registryManagement will leave the contract without an registryAdmin,\n     * thereby removing any functionality that is only available to the registryAdmin.\n     */\n    function renounceRegistryManagement() public onlyRegistryAdmin {\n        emit RegistryManagementTransferred(_registryAdmin, address(0));\n        _registryAdmin = address(0);\n    }\n\n    /**\n     * @dev Transfers registryManagement of the contract to a new account (`newManager`).\n     */\n    function _transferRegistryManagement(address newRegistryAdmin) internal {\n        require(newRegistryAdmin != address(0), \"RegistryAdmin: new registryAdmin is the zero address\");\n        emit RegistryManagementTransferred(_registryAdmin, newRegistryAdmin);\n        _registryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the pendingManager.\n     */\n    modifier onlyPendingRegistryAdmin() {\n        require(msg.sender == _pendingRegistryAdmin, \"Caller is not the pending registryAdmin\");\n        _;\n    }\n    /**\n     * @dev Allows the current registryAdmin to set the pendingManager address.\n     * @param newRegistryAdmin The address to transfer registryManagement to.\n     */\n    function transferRegistryManagement(address newRegistryAdmin) public onlyRegistryAdmin {\n        _pendingRegistryAdmin = newRegistryAdmin;\n    }\n\n    /**\n     * @dev Allows the _pendingRegistryAdmin address to finalize the transfer.\n     */\n    function claimRegistryManagement() external onlyPendingRegistryAdmin {\n        _transferRegistryManagement(_pendingRegistryAdmin);\n        _pendingRegistryAdmin = address(0);\n    }\n\n    /**\n     * @dev Returns the current pendingRegistryAdmin\n    */\n    function pendingRegistryAdmin() public view returns (address) {\n       return _pendingRegistryAdmin;  \n    }\n}\n"}}