{"interfaces.sol":{"content":"pragma solidity ^0.6.12;\n\ninterface DaiErc20 {\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address,address,uint256) external returns (bool);\n    function approve(address,uint256) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n    function allowance(address, address) external view returns (uint);\n}\n\n"},"mathlib.sol":{"content":"pragma solidity ^0.6.12;\n\nlibrary mathlib\n{\n     \n     // --- Math functions as implemented in DAI ERC20 Token---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) \u003e= x);\n    }\n    \n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) \u003c= x);\n    }\n    \n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n   function calculatereservationdays(uint rstart,uint rend) internal pure returns(uint)\n    {\n        /*\n\t    1)Calculates the length of stay between two dates.\n\t    2)For example the number of days between reservation start and end.\t\t\n            3)Days are rounded, so 5.6 days becomes 6 days. 0.5 days become 1 day.\n        */\n        \n\t    require(rend \u003e rstart,\"Reservation End has to be greater than Reservation Start\");\n\n        uint diff = sub(rend,rstart);\n        \n        uint dlen = diff / 86400; //div is Math.floor()\n        \n        uint md = diff % 86400;\n        \n        return md \u003e= 43200 ? add(dlen,1) : dlen;\n        \n    }\n    \n}\n\n"},"owned.sol":{"content":"pragma solidity ^0.6.12;\n\ncontract owned\n{\n    /*\n        1) Allows the manager to pause the main Factory contract\n        2) Only the Factory contract is owned.\n        3) The Manager has no control over the Reservation\n    */\n    \n    address public manager;\n    \n    constructor() public \n\t{\n\t    manager = msg.sender;\n\t}\n\n\n    modifier onlyManager()\n    {\n        require(msg.sender == manager);\n        _;\n    }\n    \n\n    function setManager(address newmanager) external onlyManager\n    {\n        /*\n            Allows the current manager to set a new manager\n        */\n        \n        require(newmanager.balance \u003e 0);\n        manager = newmanager;\n    }\n    \n}\n\n\n\n\n"},"stayusb.sol":{"content":"pragma solidity ^0.6.12;\n\nimport \"./owned.sol\";\nimport \"./mathlib.sol\";\nimport \"./interfaces.sol\";\n\n\nenum reservationstatus {CANCELLED, ACTIVATED, COMPLETED}\n\n\ncontract ReservationFactory is owned\n{\n    /*\n        1) The Reservation Factory contract to create and manage reservations\n\t    2) Only the Reservation Factory is owned by the manager\n\t    3) The manager has no control over each reservation or the cumulative advance payment locked in the Factory contract\n    */\n    \n    address constant private dai_ = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    DaiErc20 constant private daiToken  = DaiErc20(dai_);\n\n    //Reservation Fee in wad payed to the manager to create a reservation\n    uint public reservationfee;\n    \n    uint constant private secondsinday = 86400;\n    uint constant private secondsin21hrs = 75600;\n    \n    //Switch that controls whether the factory is active\n    bool public factorycontractactive;\n    \n    uint private reservationid;\n    \n    uint constant private maxuint = 2**256-1;\n    \n    struct Reservation \n    {\n        address guest;\n        address host;\n        uint reservationstart;\n        uint reservationend;\n        uint dailyprice;\n        uint advancepayment;\n        reservationstatus rstatus;\n    }\n    \n    mapping (bytes32 =\u003e Reservation) public Reservations;\n    \n    //Event for new Reservation\n    event NewReservationEvent(bytes32 indexed rsvid, address indexed guest, address indexed host, uint rstart, uint rend, uint dprice, uint advpay, bytes8 rstartformat, bytes8 rendformat, uint eventtime);\n    \n    //Reservation Status Change Event\n    event ReservationStatusEvent(bytes32 indexed rsvid, reservationstatus rstatus, uint rbalance, uint eventtime);\n\n    constructor() public \n\t{\n\t    reservationid =0;\n\t    reservationfee = 1000000000000000000; //1 DAI\n\t\tfactorycontractactive = true;\n\t}\n\n\n    function setReservationFee(uint newfee) external onlyManager\n    {\n        /*\n            1) Changes the Reservation fee that is paid to the manager\n            2) The Reservation fee at launch of contract is set to 1 DAI\n\t        3) The reservationfee is a public variable and can always queried\t\n        */\n        \n        require(newfee \u003e 0);\n        \n        reservationfee = newfee;\n    }\n    \n\n    function setFactoryContractSwitch() external onlyManager\n    {\n        /*\n            1) Switch that controls whether the contract is active\n\t        2) If the contract is paused new reservations can not be created, but existing reservations can still be completed.\n        */\n        \n        factorycontractactive = factorycontractactive == true ? false : true;\n    }\n    \n\n    function createnewReservation(address host, uint reservationstart, uint reservationend, uint dailyprice, uint advancepayment , bytes8 rstartformat, bytes8 rendformat) external \n    {\n        /*\n            Will Create a new reservation between guest and host\n        */\n        \n        require(factorycontractactive, \"Factory Contract should be Active\");\n        require(reservationid \u003c maxuint, \"Maximum reservationid reached\");\n        require(msg.sender != host,\"Host and Guest can not be same\");\n        require(dailyprice \u003e 0, \"Daily Price should be \u003e 0\");\n        \n        require(now \u003c mathlib.add(reservationstart,secondsin21hrs),\"Too late to start this reservation\");\n        \n        uint lengthofstay = mathlib.calculatereservationdays(reservationstart,reservationend);\n        \n        require(lengthofstay \u003e 0,\"Length of Stay should be \u003e 0\");\n        \n        uint totalreservationamount = mathlib.mul(dailyprice,lengthofstay);\n        \n        uint minadvpayment = lengthofstay \u003e 5 ? mathlib.mul(dailyprice,2) : dailyprice;\n        \n        require(advancepayment \u003e= minadvpayment \u0026\u0026 advancepayment \u003c= totalreservationamount ,\"Advance Payment should be \u003e= minadvpayment and \u003c= reservation amount \");\n        \n        //Check daitoken allowance for Factory contract\n        require(daiToken.allowance(msg.sender,address(this)) \u003e= mathlib.add(advancepayment, reservationfee), \"daiToken allowance exceeded\");\n        \n        bytes32 rsvid = keccak256(abi.encodePacked(reservationid));\n        \n        Reservations[rsvid] = Reservation(msg.sender, host, reservationstart, reservationend, dailyprice, advancepayment, reservationstatus.ACTIVATED);\n        \n        reservationid = mathlib.add(reservationid,1);\n        \n        //Transfer the advance payment to this contract\n        daiToken.transferFrom(msg.sender, address(this), advancepayment);\n        \n        //Transfer the reservation fee to factory manager\n        daiToken.transferFrom(msg.sender, manager, reservationfee);\n\n        emit NewReservationEvent(rsvid, msg.sender, host, reservationstart, reservationend, dailyprice, advancepayment, rstartformat, rendformat, now);\n        \n    }\n    \n     modifier onlyGuest(bytes32 rsvid)\n    {\n        require(msg.sender == Reservations[rsvid].guest, \"Only Guest\");\n        _;\n    }\n    \n    modifier onlyHost(bytes32 rsvid)\n    {\n        require(msg.sender == Reservations[rsvid].host, \"Only Host\");\n        _;\n    }\n    \n     function getReservationDetails(bytes32 rsvid) external view returns (reservationstatus, uint)\n    {\n    \t/*\n    \t   Will get the changing variables for each reservation based on reservation ID\t\n    \t*/\n\n        Reservation memory thisreservation = Reservations[rsvid];\n        \n        require(thisreservation.guest !=address(0),\"Reservation does not exist\");\n        \n        return(thisreservation.rstatus, thisreservation.advancepayment);\n    }\n    \n   \n    function setHostCancelsReservation(bytes32 rsvid) external onlyHost(rsvid)\n    {\n        /*\n            1) Allows the host to cancel the reservation upto 21 Hrs after reservation start if ACTIVATED\n            2) Guest gets a Full Refund Instantly, since the Host is cancelling\n        */\n        \n        Reservation storage thisreservation = Reservations[rsvid];\n        \n        require(thisreservation.rstatus == reservationstatus.ACTIVATED,\"Reservation must be ACTIVATED\");\n        \n        uint reservationstart21Hrs = mathlib.add(thisreservation.reservationstart,secondsin21hrs);\n        \n        require(now \u003c reservationstart21Hrs,\"Reservation Can be CANCELLED upto 21 Hrs after reservation start\");\n        \n        uint rsvbalance = thisreservation.advancepayment;\n        \n        thisreservation.advancepayment = 0;\n        thisreservation.rstatus = reservationstatus.CANCELLED;\n        \n\t    //Guest is refunded the entire advance payment balance\n        daiToken.transfer(thisreservation.guest, rsvbalance);\n        \n        emit ReservationStatusEvent(rsvid, thisreservation.rstatus, thisreservation.advancepayment, now);\n    }\n    \n     function setGuestCancelReservation(bytes32 rsvid) external onlyGuest(rsvid)\n    {\n        /*\n            1) Guest can cancel the reservation upto 21 Hrs after reservation start if ACTIVATED\n            2) If length of stay is 5 days or less, cancel upto 3 days before reservation start, otherwise a cancellation fee of dailyprice is applied\n            3) If length of stay is greater than 5 days, cancel upto 5 days before reservation start, otherwise a cancellation fee of 2*dailyprice is applied\n        */\n        \n        Reservation storage thisreservation = Reservations[rsvid];\n        \n        require(thisreservation.rstatus == reservationstatus.ACTIVATED,\"Reservation must be ACTIVATED\");\n        \n        uint reservationstart21Hrs = mathlib.add(thisreservation.reservationstart,secondsin21hrs);\n            \n        require(now \u003c reservationstart21Hrs,\"Guest can only cancel upto 21 Hrs after reservation start\");\n        \n        uint lengthofstay = mathlib.calculatereservationdays(thisreservation.reservationstart,thisreservation.reservationend); \n            \n        uint cancellationperiod = lengthofstay \u003e 5 ? 5 : 3;\n        \n        uint rsvbalance = thisreservation.advancepayment;\n        \n        thisreservation.advancepayment = 0;\n        thisreservation.rstatus = reservationstatus.CANCELLED;\n            \n            if (now \u003c mathlib.sub(thisreservation.reservationstart,mathlib.mul(cancellationperiod,secondsinday)))\n            {\n                daiToken.transfer(thisreservation.guest,rsvbalance);\n            }\n            else\n            {\n                uint cancellationfee = lengthofstay \u003e 5 ? mathlib.mul(thisreservation.dailyprice,2) : thisreservation.dailyprice;\n                \n                uint guestdue = mathlib.sub(rsvbalance,cancellationfee);\n                \n                //Host gets compensated for cancellation    \n                 daiToken.transfer(thisreservation.host,cancellationfee);\n                 \n                 //Guest gets refunded the remaining balance\n                 if (guestdue \u003e 0)\n                 {\n                    daiToken.transfer(thisreservation.guest,guestdue);\n                 }\n            }\n        \n         emit ReservationStatusEvent(rsvid, thisreservation.rstatus, thisreservation.advancepayment, now);\n    }\n    \n    \n     function setHostClaimsRent(bytes32 rsvid) external onlyHost(rsvid)\n    {\n        /*\n            Host can claim the rent 21 Hrs after reservation start\n        */\n        \n        Reservation storage thisreservation = Reservations[rsvid];\n        \n        require(thisreservation.rstatus == reservationstatus.ACTIVATED,\"Reservation must be ACTIVATED\");\n        \n        uint reservationstart21Hrs = mathlib.add(thisreservation.reservationstart,secondsin21hrs);\n            \n        require(now \u003e= reservationstart21Hrs,\"Host can only claim the rent 21 Hrs after reservation start\");\n        \n        uint rsvbalance = thisreservation.advancepayment;\n        \n        thisreservation.advancepayment = 0;\n        thisreservation.rstatus = reservationstatus.COMPLETED;\n        \n        //Host claims the entire advance payment balance\n         daiToken.transfer(thisreservation.host,rsvbalance);\n         \n        emit ReservationStatusEvent(rsvid, thisreservation.rstatus, thisreservation.advancepayment, now);\n    }\n    \n    \n     function setHostRefundsPartRent(bytes32 rsvid, uint refundamount) external onlyHost(rsvid)\n    {\n        /*\n            1) Host can refund the Guest a part or full amount 21 Hrs after reservation start\n            2) The remaining balance if any will be transferred to the Host. \n        */\n        \n        Reservation storage thisreservation = Reservations[rsvid];\n        \n        require(thisreservation.rstatus == reservationstatus.ACTIVATED, \"Reservation has to be ACTIVATED\");\n        \n        uint reservationstart21Hrs = mathlib.add(thisreservation.reservationstart,secondsin21hrs);\n        \n        require(now \u003e= reservationstart21Hrs, \"Host can refund part of contract balance 21 Hrs after Reservation Start\");\n        \n        uint rsvbalance = thisreservation.advancepayment;\n        \n        require(refundamount \u003e 0 \u0026\u0026 refundamount \u003c= rsvbalance, \"Refund amount should be \u003e 0 \u0026\u0026 \u003c= rsvbalance\");\n        \n        uint hostdue = mathlib.sub(rsvbalance,refundamount);\n        \n        thisreservation.advancepayment = 0;\n        thisreservation.rstatus = reservationstatus.COMPLETED;\n        \n        //The refund amount is transferred to the guest\n        daiToken.transfer(thisreservation.guest,refundamount);\n        \n        //The remaining amount is transferred to the Host\n        if (hostdue \u003e 0)\n        {\n            daiToken.transfer(thisreservation.host,hostdue);\n        }\n        \n        emit ReservationStatusEvent(rsvid, thisreservation.rstatus, thisreservation.advancepayment, now);\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}}