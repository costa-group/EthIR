{"BasicToken.sol":{"content":"pragma solidity 0.5.12;\n\nimport \"./IERC777.sol\";\nimport \"./IERC20.sol\";\nimport \"./LBasicToken.sol\";\nimport \"./PDelegate.sol\";\nimport \"./Owned.sol\";\n\ncontract BasicToken is IERC777, IERC20, Owned, PDelegate {\n\n  uint8 public constant decimals = 18;\n  uint256 public constant granularity = 1;\n  string public name;\n  string public symbol;\n\n  LBasicToken.TokenState private tokenState;\n  address public extensionContract; // TODO: Move to tokenState?\n\n  event LogContractExtended(address indexed extensionContract);\n\n  constructor(string memory _name, string memory _symbol, uint256 _initialSupply)\n    public\n  {\n    require(bytes(_name).length != 0, \"Needs a name\");\n    require(bytes(_symbol).length != 0, \"Needs a symbol\");\n    name = _name;\n    symbol = _symbol;\n    LBasicToken.init(tokenState, decimals, _initialSupply);\n  }\n\n  modifier onlyOperator(address _holder) {\n    require(isOperatorFor(msg.sender, _holder), \"Not an operator\");\n    _;\n  }\n\n  // MUST be overriden by any extension contract to avoid recursion of delegateFwd calls.\n  function ()\n    external\n  {\n    require(extensionContract != address(0), \"Extended functionality contract not found\");\n    delegatedFwd(extensionContract, msg.data);\n  }\n\n  function extend(address _extensionContract)\n    external\n    onlyOwner\n  {\n    extensionContract = _extensionContract;\n    emit LogContractExtended(_extensionContract);\n  }\n\n  function balanceOf(address _holder)\n    external\n    view\n    returns (uint256 balance_)\n  {\n    balance_ = tokenState.balances[_holder];\n  }\n\n  function transfer(address _to, uint256 _value)\n    external\n    returns (bool success_)\n  {\n    doSend(msg.sender, msg.sender, _to, _value, \"\", \"\", false);\n    success_ = true;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value)\n    external\n    returns (bool success_)\n  {\n    LBasicToken.transferFrom(tokenState, _from, _to, _value);\n    success_ = true;\n  }\n\n  function approve(address _spender, uint256 _value)\n    external\n    returns (bool success_)\n  {\n    LBasicToken.approve(tokenState, _spender, _value);\n    success_ = true;\n  }\n\n  function allowance(address _holder, address _spender)\n    external\n    view\n    returns (uint256 remaining_)\n  {\n    remaining_ = tokenState.approvals[_holder][_spender];\n  }\n\n  function defaultOperators()\n    external\n    view\n    returns (address[] memory)\n  {\n    return tokenState.defaultOperators;\n  }\n\n  function authorizeOperator(address _operator)\n    external\n  {\n    LBasicToken.authorizeOperator(tokenState, _operator);\n  }\n\n  function revokeOperator(address _operator)\n    external\n  {\n    LBasicToken.revokeOperator(tokenState, _operator);\n  }\n\n  function send(address _to, uint256 _amount, bytes calldata _data)\n    external\n  {\n    doSend(msg.sender, msg.sender, _to, _amount, _data, \"\", true);\n  }\n\n  function operatorSend(address _from, address _to, uint256 _amount, bytes calldata _data, bytes calldata _operatorData)\n    external\n    onlyOperator(_from)\n  {\n    doSend(msg.sender, _from, _to, _amount, _data, _operatorData, true);\n  }\n\n  function burn(uint256 _amount, bytes calldata _data)\n    external\n  {\n    doBurn(msg.sender, msg.sender, _amount, _data, \"\");\n  }\n\n  function operatorBurn(address _from, uint256 _amount, bytes calldata _data, bytes calldata _operatorData)\n    external\n    onlyOperator(_from)\n  {\n    doBurn(msg.sender, _from, _amount, _data, _operatorData);\n  }\n\n  function totalSupply()\n    external\n    view\n    returns (uint256 totalSupply_)\n  {\n    totalSupply_ = tokenState.totalSupply;\n  }\n\n  function isOperatorFor(address _operator, address _holder)\n    public\n    view\n    returns (bool isOperatorFor_)\n  {\n    isOperatorFor_ = (_operator == _holder || tokenState.authorizedOperators[_operator][_holder]\n        || _operator == address(this) \u0026\u0026 !tokenState.defaultOperatorIsRevoked[_holder]);\n  }\n\n  function doSend(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\n      bytes memory _operatorData, bool _enforceERC777)\n    internal\n  {\n    LBasicToken.doSend(tokenState, _operator, _from, _to, _amount, _data, _operatorData, _enforceERC777);\n  }\n\n  function doMint(address _to, uint256 _amount)\n    internal\n  {\n    LBasicToken.doMint(tokenState, _to, _amount);\n  }\n\n  function doBurn(address _operator, address _from, uint256 _amount, bytes memory _data, bytes memory _operatorData)\n    internal\n  {\n    LBasicToken.doBurn(tokenState, _operator, _from, _amount, _data, _operatorData);\n  }\n}"},"IERC1820Implementer.sol":{"content":"pragma solidity 0.5.12;\n\n// As defined in https://eips.ethereum.org/EIPS/eip-1820 for use in contracts the 1820 registry needs to call\ninterface IERC1820Implementer {\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32);\n}"},"IERC1820Registry.sol":{"content":"// From open https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/introspection/IERC1820Registry.sol\n\npragma solidity 0.5.12;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as `account`\u0027s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller\u0027s address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller\u0027s address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}"},"IERC20.sol":{"content":"pragma solidity 0.5.12;\n\n// https://eips.ethereum.org/EIPS/eip-20\ninterface IERC20 {\n  function name() external view returns (string memory); // optional method - see eip spec\n  function symbol() external view returns (string memory); // optional method - see eip spec\n  function decimals() external view returns (uint8); // optional method - see eip spec\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address owner) external view returns (uint256);\n  function transfer(address to, uint256 value) external returns (bool);\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\n  function approve(address spender, uint256 value) external returns (bool);\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}"},"IERC777.sol":{"content":"pragma solidity 0.5.12;\n\n// https://eips.ethereum.org/EIPS/eip-777\ninterface IERC777 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address holder) external view returns (uint256);\n    function granularity() external view returns (uint256);\n\n    function defaultOperators() external view returns (address[] memory);\n    function isOperatorFor(\n        address operator,\n        address holder\n    ) external view returns (bool);\n    function authorizeOperator(address operator) external;\n    function revokeOperator(address operator) external;\n\n    function send(address to, uint256 amount, bytes calldata data) external;\n    function operatorSend(\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    function burn(uint256 amount, bytes calldata data) external;\n    function operatorBurn(\n        address from,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n    event Minted(\n        address indexed operator,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n    event Burned(\n        address indexed operator,\n        address indexed from,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n    event AuthorizedOperator(\n        address indexed operator,\n        address indexed holder\n    );\n    event RevokedOperator(address indexed operator, address indexed holder);\n}"},"IERC777Recipient.sol":{"content":"pragma solidity 0.5.12;\n\n// As defined in the \u0027ERC777TokensRecipient And The tokensReceived Hook\u0027 section of https://eips.ethereum.org/EIPS/eip-777\ninterface IERC777Recipient {\n  function tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata data,\n    bytes calldata operatorData) external;\n}"},"IERC777Sender.sol":{"content":"pragma solidity 0.5.12;\n\n// As defined in the \u0027ERC777TokensSender And The tokensToSend Hook\u0027 section of https://eips.ethereum.org/EIPS/eip-777\ninterface IERC777Sender {\n  function tokensToSend(address operator, address from, address to, uint256 amount, bytes calldata data,\n      bytes calldata operatorData) external;\n}"},"LBasicToken.sol":{"content":"pragma solidity 0.5.12;\n\nimport \"./IERC1820Registry.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary LBasicToken {\n  using SafeMath for uint256;\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Sent(address indexed operator, address indexed from, address indexed to, uint256 amount, bytes data,\n      bytes operatorData);\n  event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n  event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n  event AuthorizedOperator(address indexed operator, address indexed holder);\n  event RevokedOperator(address indexed operator, address indexed holder);\n\n  // Universal address as defined in Registry Contract Address section of https://eips.ethereum.org/EIPS/eip-1820\n  IERC1820Registry constant internal ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n  bytes32 constant internal TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n  bytes32 constant internal TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n  struct TokenState {\n    uint256 totalSupply;\n    mapping(address =\u003e uint256) balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) approvals;\n    mapping(address =\u003e mapping(address =\u003e bool)) authorizedOperators;\n    address[] defaultOperators;\n    mapping(address =\u003e bool) defaultOperatorIsRevoked;\n  }\n\n  function init(TokenState storage _tokenState, uint8 _decimals, uint256 _initialSupply)\n    external\n  {\n    _tokenState.defaultOperators.push(address(this));\n    _tokenState.totalSupply = _initialSupply.mul(10**uint256(_decimals));\n    _tokenState.balances[msg.sender] = _tokenState.totalSupply;\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n    ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n  }\n\n  function transferFrom(TokenState storage _tokenState, address _from, address _to, uint256 _value)\n    external\n  {\n    require(_tokenState.approvals[_from][msg.sender] \u003e= _value, \"Amount not approved\");\n    _tokenState.approvals[_from][msg.sender] = _tokenState.approvals[_from][msg.sender].sub(_value);\n    doSend(_tokenState, msg.sender, _from, _to, _value, \"\", \"\", false);\n  }\n\n  function approve(TokenState storage _tokenState, address _spender, uint256 _value)\n    external\n  {\n    require(_spender != address(0), \"Cannot approve to zero address\");\n    _tokenState.approvals[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n  }\n\n  function authorizeOperator(TokenState storage _tokenState, address _operator)\n    external\n  {\n    require(_operator != msg.sender, \"Self cannot be operator\");\n    if (_operator == address(this))\n      _tokenState.defaultOperatorIsRevoked[msg.sender] = false;\n    else\n      _tokenState.authorizedOperators[_operator][msg.sender] = true;\n    emit AuthorizedOperator(_operator, msg.sender);\n  }\n\n  function revokeOperator(TokenState storage _tokenState, address _operator)\n    external\n  {\n    require(_operator != msg.sender, \"Self cannot be operator\");\n    if (_operator == address(this))\n      _tokenState.defaultOperatorIsRevoked[msg.sender] = true;\n    else\n      _tokenState.authorizedOperators[_operator][msg.sender] = false;\n    emit RevokedOperator(_operator, msg.sender);\n  }\n\n  function doMint(TokenState storage _tokenState, address _to, uint256 _amount)\n    external\n  {\n    assert(_to != address(0));\n\n    _tokenState.totalSupply = _tokenState.totalSupply.add(_amount);\n    _tokenState.balances[_to] = _tokenState.balances[_to].add(_amount);\n\n    // From ERC777: The token contract MUST call the tokensReceived hook after updating the state.\n    receiveHook(address(this), address(0), _to, _amount, \"\", \"\", true);\n\n    emit Minted(address(this), _to, _amount, \"\", \"\");\n    emit Transfer(address(0), _to, _amount);\n  }\n\n  function doBurn(TokenState storage _tokenState, address _operator, address _from, uint256 _amount, bytes calldata _data,\n      bytes calldata _operatorData)\n    external\n  {\n    assert(_from != address(0));\n    // From ERC777: The token contract MUST call the tokensToSend hook before updating the state.\n    sendHook(_operator, _from, address(0), _amount, _data, _operatorData);\n\n    _tokenState.balances[_from] = _tokenState.balances[_from].sub(_amount);\n    _tokenState.totalSupply = _tokenState.totalSupply.sub(_amount);\n\n    emit Burned(_operator, _from, _amount, _data, _operatorData);\n    emit Transfer(_from, address(0), _amount);\n  }\n\n  function doSend(TokenState storage _tokenState, address _operator, address _from, address _to, uint256 _amount,\n      bytes memory _data, bytes memory _operatorData, bool _enforceERC777)\n    public\n  {\n    assert(_from != address(0));\n\n    require(_to != address(0), \"Zero address cannot receive funds\");\n    // From ERC777: The token contract MUST call the tokensToSend hook before updating the state.\n    sendHook(_operator, _from, _to, _amount, _data, _operatorData);\n\n    _tokenState.balances[_from] = _tokenState.balances[_from].sub(_amount);\n    _tokenState.balances[_to] = _tokenState.balances[_to].add(_amount);\n\n    emit Sent(_operator, _from, _to, _amount, _data, _operatorData);\n    emit Transfer(_from, _to, _amount);\n\n    // From ERC777: The token contract MUST call the tokensReceived hook after updating the state.\n    receiveHook(_operator, _from, _to, _amount, _data, _operatorData, _enforceERC777);\n  }\n\n  function receiveHook(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\n      bytes memory _operatorData, bool _enforceERC777)\n    public\n  {\n    address implementer = ERC1820_REGISTRY.getInterfaceImplementer(_to, TOKENS_RECIPIENT_INTERFACE_HASH);\n    if (implementer != address(0))\n      IERC777Recipient(implementer).tokensReceived(_operator, _from, _to, _amount, _data, _operatorData);\n    else if (_enforceERC777)\n      require(!isContract(_to), \"Contract must be registered with ERC1820 as implementing ERC777TokensRecipient\");\n  }\n\n  function sendHook(address _operator, address _from, address _to, uint256 _amount, bytes memory _data,\n      bytes memory _operatorData)\n    public\n  {\n    address implementer = ERC1820_REGISTRY.getInterfaceImplementer(_from, TOKENS_SENDER_INTERFACE_HASH);\n    if (implementer != address(0))\n      IERC777Sender(implementer).tokensToSend(_operator, _from, _to, _amount, _data, _operatorData);\n  }\n\n  function isContract(address _account)\n    private\n    view\n    returns (bool isContract_)\n  {\n    uint256 size;\n\n    assembly {\n      size := extcodesize(_account)\n    }\n\n    isContract_ = size != 0;\n  }\n}"},"Owned.sol":{"content":"pragma solidity 0.5.12;\n\ncontract Owned {\n\n  address public owner = msg.sender;\n\n  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\n\n  modifier onlyOwner {\n    require(msg.sender == owner, \"Sender must be owner\");\n    _;\n  }\n\n  function setOwner(address _owner)\n    external\n    onlyOwner\n  {\n    require(_owner != address(0), \"Owner cannot be zero address\");\n    emit LogOwnershipTransferred(owner, _owner);\n    owner = _owner;\n  }\n}"},"PDelegate.sol":{"content":"pragma solidity 0.5.12;\n\ncontract PDelegate {\n\n  /**\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n  * @param _dst Destination address to perform the delegatecall\n  * @param _calldata Calldata for the delegatecall\n  */\n  function delegatedFwd(address _dst, bytes memory _calldata)\n    internal\n  {\n    assert(isContract(_dst));\n\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n      let size := returndatasize\n      let ptr := mload(0x40)\n      returndatacopy(ptr, 0, size)\n\n      // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n      // if the call returned error data, forward it\n      switch result case 0 { revert(ptr, size) }\n      default { return(ptr, size) }\n    }\n  }\n\n  // ONLY_IF_ASSERTS_ON:\n  function isContract(address _target)\n    view\n    internal\n    returns (bool result_)\n  {\n    uint256 size;\n\n    assembly {\n      size := extcodesize(_target)\n    }\n\n    result_ = (size != 0);\n  }\n  // :ONLY_IF_ASSERTS_ON\n}"},"SafeMath.sol":{"content":"// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"VOWTokenPublic.sol":{"content":"pragma solidity 0.5.12;\n\nimport \"./BasicToken.sol\";\n\ncontract VOWTokenPublic is BasicToken {\n  mapping(address =\u003e bool) public vscContracts;\n\n  event LogVSCContractRegistered(address indexed vscContract);\n  event LogVSCContractDeregistered(address indexed vscContract);\n\n  constructor(uint256 _initialSupply)\n    BasicToken(\"Vow\", \"Vow\", _initialSupply)\n    public {}\n\n  function registerVSCContract(address _vscContract)\n    external\n    onlyOwner\n  {\n    require(!vscContracts[_vscContract], \"VSC contract already registered\");\n    vscContracts[_vscContract] = true;\n\n    emit LogVSCContractRegistered(_vscContract);\n  }\n\n  function deregisterVSCContract(address _vscContract)\n    external\n    onlyOwner\n  {\n    require(vscContracts[_vscContract], \"VSC contract is not registered\");\n    vscContracts[_vscContract] = false;\n\n    emit LogVSCContractDeregistered(_vscContract);\n  }\n\n  function isRegisteredVSCContract(address _vscContract)\n    public\n    view\n    returns (bool isRegistered_)\n  {\n    isRegistered_ = vscContracts[_vscContract];\n  }\n}"}}