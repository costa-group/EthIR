{{
  "language": "Solidity",
  "sources": {
    "contracts/BootstrapDistribution.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\npragma solidity 0.6.12;\ninterface HermezVesting {\n    function move(address recipient, uint256 amount) external;\n    function changeAddress(address newAddress) external;\n} \ninterface HEZ {\n    function approve(address spender, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract BootstrapDistribution {\n    using SafeMath for uint256;\n\n    HEZ public constant TOKEN_ADDRESS = HEZ(0xEEF9f339514298C6A857EfCfC1A762aF84438dEE);\n    HermezVesting public constant VESTING_0 = HermezVesting(0x8109dfB06D4d9e694a8349B855cBF493A0B22186);\n    HermezVesting public constant VESTING_1 = HermezVesting(0xDd90cA911a5dbfB1624fF7Eb586901a9b4BFC53D);\n    HermezVesting public constant VESTING_2 = HermezVesting(0xB213aeAeF76f82e42263fe896433A260EF018df2);\n    HermezVesting public constant VESTING_3 = HermezVesting(0x3049399e1308db7d2b28488880C6cFE9Aa003275);\n    address public constant MULTISIG_VESTING_2  = 0xC21BE548060cB6E07017bFc0b926A71b5E638e09;\n    address public constant MULTISIG_VESTING_3  = 0x5Fa543E23a1B62e45d010f81AFC0602456BD1F1d;\n    address public constant VESTING_0_ADDRESS_0 = 0x94E886bB17451A7B82E594db12570a5AdFC2D453;\n    address public constant VESTING_0_ADDRESS_1 = 0x4FE10B3e306aC1F4b966Db07f031ae5780BC48fB;\n    address public constant VESTING_0_ADDRESS_2 = 0x6629300128CCdda1e88641Ba2941a22Ce82F5df9;\n    address public constant VESTING_0_ADDRESS_3 = 0xEb60e28Ce3aCa617d1E0293791c1903cF022b9Cd;\n    address public constant VESTING_0_ADDRESS_4 = 0x9a415E0cE643abc4AD953B651b2D7e4db2FF3bEa;\n    address public constant VESTING_0_ADDRESS_5 = 0x15b54c53093aF3e11d787db86e268a6C4F2F72A2;\n    address public constant VESTING_0_ADDRESS_6 = 0x3279c71F132833190F6cd1D6a9975FFBf8d7C6dC;\n    address public constant VESTING_0_ADDRESS_7 = 0x312e6f33155177774CDa1A3C4e9f077D93266063;\n    address public constant VESTING_0_ADDRESS_8 = 0x47690A724Ed551fe2ff1A5eBa335B7c1B7a40990;\n    address public constant VESTING_1_ADDRESS_0 = 0x80FbB6dd386FC98D2B387F37845A373c8441c069;\n    address public constant VESTING_2_ADDRESS_0 = 0xBd48F607E26d94772FB21ED1d814F9F116dBD95C;\n    address public constant VESTING_3_ADDRESS_0 = 0x520Cf70a2D0B3dfB7386A2Bc9F800321F62a5c3a;\n    address public constant NO_VESTED_ADDRESS_0 = 0x4D4a7675CC0eb0a3B1d81CbDcd828c4BD0D74155;\n    address public constant NO_VESTED_ADDRESS_1 = 0x9CdaeBd2bcEED9EB05a3B3cccd601A40CB0026be;\n    address public constant NO_VESTED_ADDRESS_2 = 0x9315F815002d472A3E993ac9dc7461f2601A3c09;\n    address public constant NO_VESTED_ADDRESS_3 = 0xF96A39d61F6972d8dC0CCd2A3c082eD922E096a7;\n    address public constant NO_VESTED_ADDRESS_4 = 0xA93Bb239509D16827B7ee9DA7dA6Fc8478837247;\n    address public constant NO_VESTED_ADDRESS_5 = 0x99Ae889E171B82BB04FD22E254024716932e5F2f;\n    uint256 public constant VESTING_0_AMOUNT            = 20_000_000 ether;\n    uint256 public constant VESTING_1_AMOUNT            = 10_000_000 ether;\n    uint256 public constant VESTING_2_AMOUNT            =  6_200_000 ether;\n    uint256 public constant VESTING_3_AMOUNT            = 17_500_000 ether;    \n    uint256 public constant VESTING_0_ADDRESS_0_AMOUNT  = 12_000_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_1_AMOUNT  =  1_850_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_2_AMOUNT  =  1_675_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_3_AMOUNT  =  1_300_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_4_AMOUNT  =  1_000_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_5_AMOUNT  =    750_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_6_AMOUNT  =    625_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_7_AMOUNT  =    525_000 ether;\n    uint256 public constant VESTING_0_ADDRESS_8_AMOUNT  =    275_000 ether;\n    uint256 public constant VESTING_1_ADDRESS_0_AMOUNT  = 10_000_000 ether;\n    uint256 public constant VESTING_2_ADDRESS_0_AMOUNT  =    500_000 ether;\n    uint256 public constant VESTING_3_ADDRESS_0_AMOUNT  =    300_000 ether;\n    uint256 public constant NO_VESTED_ADDRESS_0_AMOUNT  = 19_000_000 ether;\n    uint256 public constant NO_VESTED_ADDRESS_1_AMOUNT  =  9_000_000 ether;\n    uint256 public constant NO_VESTED_ADDRESS_2_AMOUNT  =  7_500_000 ether;\n    uint256 public constant NO_VESTED_ADDRESS_3_AMOUNT  =  5_000_000 ether;\n    uint256 public constant NO_VESTED_ADDRESS_4_AMOUNT  =  3_000_000 ether;\n    uint256 public constant NO_VESTED_ADDRESS_5_AMOUNT  =  2_800_000 ether;\n    uint256 public constant INTERMEDIATE_BALANCE        = 46_300_000 ether;\n\n    function distribute() public {\n        require(\n            TOKEN_ADDRESS.balanceOf(address(this)) == (100_000_000 ether), \n            \"BootstrapDistribution::distribute NOT_ENOUGH_BALANCE\"\n        );\n\n        // Vested Tokens\n        // Transfer HEZ tokens\n        TOKEN_ADDRESS.transfer(address(VESTING_0),VESTING_0_AMOUNT);\n        TOKEN_ADDRESS.transfer(address(VESTING_1),VESTING_1_AMOUNT);\n        TOKEN_ADDRESS.transfer(address(VESTING_2),VESTING_2_AMOUNT);\n        TOKEN_ADDRESS.transfer(address(VESTING_3),VESTING_3_AMOUNT);\n        // Transfer vested tokens\n        transferVestedTokens0();\n        transferVestedTokens1();\n        transferVestedTokens2();\n        transferVestedTokens3();\n\n        // Check intermediate balance\n        require(\n            TOKEN_ADDRESS.balanceOf(address(this)) == INTERMEDIATE_BALANCE,\n            \"BootstrapDistribution::distribute NOT_ENOUGH_NO_VESTED_BALANCE\"\n        );\n\n        // No Vested Tokens\n        TOKEN_ADDRESS.transfer(NO_VESTED_ADDRESS_0, NO_VESTED_ADDRESS_0_AMOUNT);\n        TOKEN_ADDRESS.transfer(NO_VESTED_ADDRESS_1, NO_VESTED_ADDRESS_1_AMOUNT);\n        TOKEN_ADDRESS.transfer(NO_VESTED_ADDRESS_2, NO_VESTED_ADDRESS_2_AMOUNT);\n        TOKEN_ADDRESS.transfer(NO_VESTED_ADDRESS_3, NO_VESTED_ADDRESS_3_AMOUNT);\n        TOKEN_ADDRESS.transfer(NO_VESTED_ADDRESS_4, NO_VESTED_ADDRESS_4_AMOUNT);\n        TOKEN_ADDRESS.transfer(NO_VESTED_ADDRESS_5, NO_VESTED_ADDRESS_5_AMOUNT);\n\n        require(\n            TOKEN_ADDRESS.balanceOf(address(this)) == 0, \n            \"BootstrapDistribution::distribute PENDING_BALANCE\"\n        );\n    }\n\n    function transferVestedTokens0() internal {\n        VESTING_0.move(VESTING_0_ADDRESS_0, VESTING_0_ADDRESS_0_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_1, VESTING_0_ADDRESS_1_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_2, VESTING_0_ADDRESS_2_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_3, VESTING_0_ADDRESS_3_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_4, VESTING_0_ADDRESS_4_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_5, VESTING_0_ADDRESS_5_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_6, VESTING_0_ADDRESS_6_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_7, VESTING_0_ADDRESS_7_AMOUNT);\n        VESTING_0.move(VESTING_0_ADDRESS_8, VESTING_0_ADDRESS_8_AMOUNT);\n        VESTING_0.changeAddress(address(0));\n    }\n\n    function transferVestedTokens1() internal {\n        VESTING_1.move(VESTING_1_ADDRESS_0, VESTING_1_ADDRESS_0_AMOUNT);\n        VESTING_1.changeAddress(address(0));\n    }\n\n    function transferVestedTokens2() internal {\n        VESTING_2.move(VESTING_2_ADDRESS_0, VESTING_2_ADDRESS_0_AMOUNT);\n        VESTING_2.changeAddress(MULTISIG_VESTING_2);    \n    }\n\n    function transferVestedTokens3() internal {\n        VESTING_3.move(VESTING_3_ADDRESS_0, VESTING_3_ADDRESS_0_AMOUNT);\n        VESTING_3.changeAddress(MULTISIG_VESTING_3);  \n    }\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/HermezVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/IERC20.sol\";\n\ncontract HermezVesting {\n    using SafeMath for uint256;\n\n    address public distributor;\n\n    mapping(address => uint256) public vestedTokens;\n    mapping(address => uint256) public withdrawed;\n    uint256 public totalVestedTokens;\n\n    uint256 public startTime;\n    uint256 public cliffTime;\n    uint256 public endTime;\n    uint256 public initialPercentage;\n\n    address public constant HEZ = address(\n        0xEEF9f339514298C6A857EfCfC1A762aF84438dEE\n    );\n\n    event Withdraw(address indexed recipient, uint256 amount);\n    event Move(address indexed from, address indexed to, uint256 value);\n    event ChangeAddress(address indexed oldAddress, address indexed newAddress);\n\n    constructor(\n        address _distributor,\n        uint256 _totalVestedTokens,\n        uint256 _startTime,\n        uint256 _startToCliff,\n        uint256 _startToEnd,\n        uint256 _initialPercentage\n    ) public {\n        require(\n            _startToEnd >= _startToCliff,\n            \"HermezVesting::constructor: START_GREATER_THAN_CLIFF\"\n        );\n        require(\n            _initialPercentage <= 100,\n            \"HermezVesting::constructor: INITIALPERCENTAGE_GREATER_THAN_100\"\n        );\n        distributor = _distributor;\n        totalVestedTokens = _totalVestedTokens;\n        vestedTokens[_distributor] = _totalVestedTokens;\n        startTime = _startTime;\n        cliffTime = _startTime + _startToCliff;\n        endTime = _startTime + _startToEnd;\n        initialPercentage = _initialPercentage;\n    }\n\n    function totalTokensUnlockedAt(uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        if (timestamp < startTime) return 0;\n        if (timestamp > endTime) return totalVestedTokens;\n\n        uint256 initialAmount = totalVestedTokens.mul(initialPercentage).div(\n            100\n        );\n        if (timestamp < cliffTime) return initialAmount;\n\n        uint256 deltaT = timestamp.sub(startTime);\n        uint256 deltaTTotal = endTime.sub(startTime);\n        uint256 deltaAmountTotal = totalVestedTokens.sub(initialAmount);\n        return initialAmount.add(deltaT.mul(deltaAmountTotal).div(deltaTTotal));\n    }\n\n    function withdrawableTokens(address recipient)\n        public\n        view\n        returns (uint256)\n    {\n        return withdrawableTokensAt(recipient, block.timestamp);\n    }\n\n    function withdrawableTokensAt(address recipient, uint256 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 unlockedAmount = totalTokensUnlockedAt(timestamp)\n            .mul(vestedTokens[recipient])\n            .div(totalVestedTokens);\n        return unlockedAmount.sub(withdrawed[recipient]);\n    }\n\n    function withdraw() external {\n        require(\n            msg.sender != distributor,\n            \"HermezVesting::withdraw: DISTRIBUTOR_CANNOT_WITHDRAW\"\n        );\n\n        uint256 remainingToWithdraw = withdrawableTokensAt(\n            msg.sender,\n            block.timestamp\n        );\n\n        withdrawed[msg.sender] = withdrawed[msg.sender].add(\n            remainingToWithdraw\n        );\n\n        require(\n            IERC20(HEZ).transfer(msg.sender, remainingToWithdraw),\n            \"HermezVesting::withdraw: TOKEN_TRANSFER_ERROR\"\n        );\n\n        emit Withdraw(msg.sender, remainingToWithdraw);\n    }\n\n    function move(address recipient, uint256 amount) external {\n        require(\n            msg.sender == distributor,\n            \"HermezVesting::changeAddress: ONLY_DISTRIBUTOR\"\n        );\n        vestedTokens[msg.sender] = vestedTokens[msg.sender].sub(amount);\n        vestedTokens[recipient] = vestedTokens[recipient].add(amount);\n        emit Move(msg.sender, recipient, amount);\n    }\n\n    function changeAddress(address newAddress) external {\n        require(\n            vestedTokens[newAddress] == 0,\n            \"HermezVesting::changeAddress: ADDRESS_HAS_BALANCE\"\n        );\n        require(\n            withdrawed[newAddress] == 0,\n            \"HermezVesting::changeAddress: ADDRESS_ALREADY_WITHDRAWED\"\n        );\n\n        vestedTokens[newAddress] = vestedTokens[msg.sender];\n        vestedTokens[msg.sender] = 0;\n        withdrawed[newAddress] = withdrawed[msg.sender];\n        withdrawed[msg.sender] = 0;\n\n        if (msg.sender == distributor) {\n            distributor = newAddress;\n        }\n\n        emit ChangeAddress(msg.sender, newAddress);\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/HEZToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/SafeMath.sol\";\n\n// Lightweight token modelled after UNI-LP: \n// https://github.com/Uniswap/uniswap-v2-core/blob/v1.0.1/contracts/UniswapV2ERC20.sol\n// Adds:\n//   - An exposed `burn()`\n//   - ERC-3009 (`transferWithAuthorization()`)\n//   - domainSeparator is computed inside `_validateSignedData` to avoid reply-attacks due to Hardforks\n//   - to != address(this) && to != address(0); To avoid people sending tokens to this smartcontract and \n//          to distinguish burn events from transfer\n\ncontract HEZ is IERC20 {\n    using SafeMath for uint256;\n\n    uint8 public constant decimals = 18;    \n    string public constant symbol = \"HEZ\";\n    string public constant name = \"Hermez Network Token\";\n    uint256 public constant initialBalance = 100_000_000 * (1e18);\n\n    // bytes32 public constant PERMIT_TYPEHASH = \n    //      keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\n    //      keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\");\n    bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n    // bytes32 public constant EIP712DOMAIN_HASH =\n    //      keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n    bytes32 public constant EIP712DOMAIN_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n    // bytes32 public constant NAME_HASH =\n    //      keccak256(\"Hermez Network Token\")\n    bytes32 public constant NAME_HASH = 0x64c0a41a0260272b78f2a5bd50d5ff7c1779bc3bba16dcff4550c7c642b0e4b4;\n    // bytes32 public constant VERSION_HASH =\n    //      keccak256(\"1\")\n    bytes32 public constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n    mapping(address => uint256) public nonces;\n    mapping(address => mapping(bytes32 => bool)) public authorizationState;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n    constructor(address initialHolder) public {\n        _mint(initialHolder, initialBalance);\n    }\n\n    function _validateSignedData(\n        address signer,\n        bytes32 encodeData,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                EIP712DOMAIN_HASH,\n                NAME_HASH,\n                VERSION_HASH,\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, encodeData)\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        // Explicitly disallow authorizations for address(0) as ecrecover returns address(0) on malformed messages\n        require(\n            recoveredAddress != address(0) && recoveredAddress == signer,\n            \"HEZ::_validateSignedData: INVALID_SIGNATURE\"\n        );\n    }\n\n    function getChainId() public pure returns (uint256 chainId){\n        assembly { chainId := chainid() }\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        require(\n            to != address(this) && to != address(0),\n            \"HEZ::_transfer: NOT_VALID_TRANSFER\"\n        );\n        // Balance is implicitly checked with SafeMath's underflow protection\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function burn(uint256 value) external returns (bool) {\n        _burn(msg.sender, value);\n        return true;\n    }\n\n    function approve(address spender, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        uint256 fromAllowance = allowance[from][msg.sender];\n        if (fromAllowance != uint256(-1)) {\n            // Allowance is implicitly checked with SafeMath's underflow protection\n            allowance[from][msg.sender] = fromAllowance.sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"HEZ::permit: AUTH_EXPIRED\");\n        bytes32 encodeData = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline\n            )\n        );\n        _validateSignedData(owner, encodeData, v, r, s);\n        _approve(owner, spender, value);\n    }\n\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp > validAfter, \"HEZ::transferWithAuthorization: AUTH_NOT_YET_VALID\");\n        require(block.timestamp < validBefore, \"HEZ::transferWithAuthorization: AUTH_EXPIRED\");\n        require(!authorizationState[from][nonce], \"HEZ::transferWithAuthorization: AUTH_ALREADY_USED\");\n\n        bytes32 encodeData = keccak256(\n            abi.encode(\n                TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\n                from,\n                to,\n                value,\n                validAfter,\n                validBefore,\n                nonce\n            )\n        );\n        _validateSignedData(from, encodeData, v, r, s);\n\n        authorizationState[from][nonce] = true;\n        _transfer(from, to, value);\n        emit AuthorizationUsed(from, nonce);\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\n// A library for performing overflow-safe math, courtesy of DappHub: https://github.com/dapphub/ds-math/blob/d0ef6d6a5f/src/math.sol\n// Modified to include only the essentials\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH:ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH:SUB_UNDERFLOW\";\n\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, ERROR_ADD_OVERFLOW);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, ERROR_SUB_UNDERFLOW);\n    }\n}\n"
    },
    "contracts/mocks/HEZTokenMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport \"../HEZToken.sol\";\n\ncontract HEZMock is HEZ {\n    constructor(address initialHolder)\n        public\n        HEZ(initialHolder)\n    {}\n\n    function mint(address to, uint256 value) external {\n        super._mint(to, value);\n    }\n}\n"
    },
    "contracts/UniPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/introspection/IERC1820Registry.sol\";\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Uniswap v2 HEZ/ETH pair token\n    IERC20 public UNI = IERC20(0x4a9EFa254085F36122d4b8BD2111544F8dC77052);\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        UNI.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        UNI.safeTransfer(msg.sender, amount);\n    }\n}\n\ncontract Unipool is LPTokenWrapper, IERC777Recipient {\n    uint256 public constant DURATION = 30 days;\n    // Hermez Network Token\n    IERC20 public HEZ = IERC20(0xcAEf929782361ccE9618c014D2867E423fE84ae7);\n\n    IERC1820Registry private constant _ERC1820_REGISTRY = IERC1820Registry(\n        0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\n    );\n    bytes32 private constant _ERC777_RECIPIENT_INTERFACE_HASH = keccak256(\n        \"ERC777TokensRecipient\"\n    );\n\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    constructor() public {\n        _ERC1820_REGISTRY.setInterfaceImplementer(\n            address(this),\n            _ERC777_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        require(\n            lastTimeRewardApplicable() >= lastUpdateTime,\n            \"lastTimeRewardApplicable < lastUpdateTime\"\n        );\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        require(\n            rewardPerToken() >= userRewardPerTokenPaid[account],\n            \"rewardPerToken() < userRewardPerTokenPaid[account] \"\n        );\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            HEZ.safeTransfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    function tokensReceived(\n        // solhint-disable no-unused-vars\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _userData,\n        bytes calldata _operatorData\n    ) external override updateReward(address(0)) {\n        require(_amount > 0, \"Cannot approve 0\");\n        require(msg.sender == address(HEZ), \"Wrong token\");\n        require(\n            _from == 0xF35960302a07022aBa880DFFaEC2Fdd64d5BF1c1,\n            \"Not allowed\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = _amount.div(DURATION);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = _amount.add(leftover).div(DURATION);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(DURATION);\n\n        emit RewardAdded(_amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     *  @param account Address of the contract for which to update the cache.\n     *  @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not.\n     *  If the result is not cached a direct lookup on the contract address is performed.\n     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     *  {updateERC165Cache} with the contract address.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     *  @param account Address of the contract to check.\n     *  @param interfaceId ERC165 interface to check.\n     *  @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": false
    },
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}