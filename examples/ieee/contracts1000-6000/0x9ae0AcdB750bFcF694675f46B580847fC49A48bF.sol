{"BaseWallet.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./IModule.sol\";\nimport \"./IWallet.sol\";\n\n/**\n * @title BaseWallet\n * @notice Simple modular wallet that authorises modules to call its invoke() method.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ncontract BaseWallet is IWallet {\n\n    // The implementation of the proxy\n    address public implementation;\n    // The owner\n    address public override owner;\n    // The authorised modules\n    mapping (address =\u003e bool) public override authorised;\n    // The enabled static calls\n    mapping (bytes4 =\u003e address) public override enabled;\n    // The number of modules\n    uint public override modules;\n\n    event AuthorisedModule(address indexed module, bool value);\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n    event Received(uint indexed value, address indexed sender, bytes data);\n    event OwnerChanged(address owner);\n\n    /**\n     * @notice Throws if the sender is not an authorised module.\n     */\n    modifier moduleOnly {\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n        _;\n    }\n\n    /**\n     * @notice Inits the wallet by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] calldata _modules) external {\n        require(owner == address(0) \u0026\u0026 modules == 0, \"BW: wallet already initialised\");\n        require(_modules.length \u003e 0, \"BW: construction requires at least 1 module\");\n        owner = _owner;\n        modules = _modules.length;\n        for (uint256 i = 0; i \u003c _modules.length; i++) {\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n            authorised[_modules[i]] = true;\n            IModule(_modules[i]).init(address(this));\n            emit AuthorisedModule(_modules[i], true);\n        }\n        if (address(this).balance \u003e 0) {\n            emit Received(address(this).balance, address(0), \"\");\n        }\n    }\n\n    /**\n     * @inheritdoc IWallet\n     */\n    function authoriseModule(address _module, bool _value) external override moduleOnly {\n        if (authorised[_module] != _value) {\n            emit AuthorisedModule(_module, _value);\n            if (_value == true) {\n                modules += 1;\n                authorised[_module] = true;\n                IModule(_module).init(address(this));\n            } else {\n                modules -= 1;\n                require(modules \u003e 0, \"BW: wallet must have at least one module\");\n                delete authorised[_module];\n            }\n        }\n    }\n\n    /**\n    * @inheritdoc IWallet\n    */\n    function enableStaticCall(address _module, bytes4 _method) external override moduleOnly {\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n        enabled[_method] = _module;\n        emit EnabledStaticCall(_module, _method);\n    }\n\n    /**\n     * @inheritdoc IWallet\n     */\n    function setOwner(address _newOwner) external override moduleOnly {\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n\n    /**\n     * @notice Performs a generic transaction.\n     * @param _target The address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\n        bool success;\n        (success, _result) = _target.call{value: _value}(_data);\n        if (!success) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n\n    /**\n     * @notice This method delegates the static call to a target contract if the data corresponds\n     * to an enabled module, or logs the call otherwise.\n     */\n    fallback() external payable {\n        address module = enabled[msg.sig];\n        if (module == address(0)) {\n            emit Received(msg.value, msg.sender, msg.data);\n        } else {\n            require(authorised[module], \"BW: must be an authorised module for static call\");\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                calldatacopy(0, 0, calldatasize())\n                let result := staticcall(gas(), module, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                switch result\n                case 0 {revert(0, returndatasize())}\n                default {return (0, returndatasize())}\n            }\n        }\n    }\n\n    receive() external payable {\n    }\n}"},"IGuardianStorage.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\ninterface IGuardianStorage {\n\n    /**\n     * @notice Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(address _wallet, address _guardian) external;\n\n    /**\n     * @notice Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(address _wallet, address _guardian) external;\n\n    /**\n     * @notice Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(address _wallet, address _guardian) external view returns (bool);\n\n    function isLocked(address _wallet) external view returns (bool);\n\n    function getLock(address _wallet) external view returns (uint256);\n\n    function getLocker(address _wallet) external view returns (address);\n\n    function setLock(address _wallet, uint256 _releaseAfter) external;\n\n    function getGuardians(address _wallet) external view returns (address[] memory);\n\n    function guardianCount(address _wallet) external view returns (uint256);\n}"},"ILimitStorage.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ILimitStorage\n * @notice LimitStorage interface\n */\ninterface ILimitStorage {\n\n    struct Limit {\n        // the current limit\n        uint128 current;\n        // the pending limit if any\n        uint128 pending;\n        // when the pending limit becomes the current limit\n        uint64 changeAfter;\n    }\n\n    struct DailySpent {\n        // The amount already spent during the current period\n        uint128 alreadySpent;\n        // The end of the current period\n        uint64 periodEnd;\n    }\n\n    function setLimit(address _wallet, Limit memory _limit) external;\n\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\n\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\n\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\n\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\n\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\n}"},"IModule.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title IModule\n * @notice Interface for a module.\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n * can never end up in a \"frozen\" state.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ninterface IModule {\n    /**\n     * @notice Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external;\n\n    /**\t\n     * @notice Adds a module to a wallet. Cannot execute when wallet is locked (or under recovery)\t\n     * @param _wallet The target wallet.\t\n     * @param _module The modules to authorise.\t\n     */\t\n    function addModule(address _wallet, address _module) external;\n}"},"IModuleRegistry.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"},"IVersionManager.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ILimitStorage.sol\";\n\n/**\n * @title IVersionManager\n * @notice Interface for the VersionManager module.\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ninterface IVersionManager {\n    /**\n     * @notice Returns true if the feature is authorised for the wallet\n     * @param _wallet The target wallet.\n     * @param _feature The feature.\n     */\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\n\n    /**\n     * @notice Lets a feature (caller) invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function checkAuthorisedFeatureAndInvokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory _res);\n\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _wallet, address _newOwner) external;\n\n    /**\n     * @notice Lets a feature write data to a storage contract.\n     * @param _wallet The target wallet.\n     * @param _storage The storage contract.\n     * @param _data The data of the call\n     */\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\n\n    /**\n     * @notice Upgrade a wallet to a new version.\n     * @param _wallet the wallet to upgrade\n     * @param _toVersion the new version\n     */\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\n \n}"},"IWallet.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IWallet\n * @notice Interface for the BaseWallet\n */\ninterface IWallet {\n    /**\n     * @notice Returns the wallet owner.\n     * @return The wallet owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint);\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Checks if a module is authorised on the wallet.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible for a static call redirection.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external;\n\n    /**\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external;\n}"},"Managed.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\nimport \"./Owned.sol\";\n\n/**\n * @title Managed\n * @notice Basic contract that defines a set of managers. Only the owner can add/remove managers.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ncontract Managed is Owned {\n\n    // The managers\n    mapping (address =\u003e bool) public managers;\n\n    /**\n     * @notice Throws if the sender is not a manager.\n     */\n    modifier onlyManager {\n        require(managers[msg.sender] == true, \"M: Must be manager\");\n        _;\n    }\n\n    event ManagerAdded(address indexed _manager);\n    event ManagerRevoked(address indexed _manager);\n\n    /**\n    * @notice Adds a manager.\n    * @param _manager The address of the manager.\n    */\n    function addManager(address _manager) external onlyOwner {\n        require(_manager != address(0), \"M: Address must not be null\");\n        if (managers[_manager] == false) {\n            managers[_manager] = true;\n            emit ManagerAdded(_manager);\n        }\n    }\n\n    /**\n    * @notice Revokes a manager.\n    * @param _manager The address of the manager.\n    */\n    function revokeManager(address _manager) external onlyOwner {\n        require(managers[_manager] == true, \"M: Target must be an existing manager\");\n        delete managers[_manager];\n        emit ManagerRevoked(_manager);\n    }\n}"},"Owned.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title Owned\n * @notice Basic contract to define an owner.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ncontract Owned {\n\n    // The owner\n    address public owner;\n\n    event OwnerChanged(address indexed _newOwner);\n\n    /**\n     * @notice Throws if the sender is not the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @notice Lets the owner transfer ownership of the contract to a new owner.\n     * @param _newOwner The new owner.\n     */\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Address must not be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n}"},"Proxy.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\n/**\n * @title Proxy\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\n * The implementing contract cannot be upgraded.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ncontract Proxy {\n\n    address implementation;\n\n    event Received(uint indexed value, address indexed sender, bytes data);\n\n    constructor(address _implementation) public {\n        implementation = _implementation;\n    }\n\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let target := sload(0)\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {revert(0, returndatasize())}\n            default {return (0, returndatasize())}\n        }\n    }\n\n    receive() external payable {\n        emit Received(msg.value, msg.sender, msg.data);\n    }\n}"},"WalletFactory.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./Proxy.sol\";\nimport \"./BaseWallet.sol\";\nimport \"./Owned.sol\";\nimport \"./Managed.sol\";\nimport \"./IGuardianStorage.sol\";\nimport \"./IModuleRegistry.sol\";\nimport \"./IVersionManager.sol\";\n\n/**\n * @title WalletFactory\n * @notice The WalletFactory contract creates and assigns wallets to accounts.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ncontract WalletFactory is Owned, Managed {\n\n    // The address of the module dregistry\n    address public moduleRegistry;\n    // The address of the base wallet implementation\n    address public walletImplementation;\n    // The address of the GuardianStorage\n    address public guardianStorage;\n\n    // *************** Events *************************** //\n\n    event ModuleRegistryChanged(address addr);\n    event WalletCreated(address indexed wallet, address indexed owner, address indexed guardian);\n\n    // *************** Constructor ********************** //\n\n    /**\n     * @notice Default constructor.\n     */\n    constructor(address _moduleRegistry, address _walletImplementation, address _guardianStorage) public {\n        require(_moduleRegistry != address(0), \"WF: ModuleRegistry address not defined\");\n        require(_walletImplementation != address(0), \"WF: WalletImplementation address not defined\");\n        require(_guardianStorage != address(0), \"WF: GuardianStorage address not defined\");\n        moduleRegistry = _moduleRegistry;\n        walletImplementation = _walletImplementation;\n        guardianStorage = _guardianStorage;\n    }\n\n    // *************** External Functions ********************* //\n    /**\n     * @notice Lets the manager create a wallet for an owner account.\n     * The wallet is initialised with the version manager module, a version number and a first guardian.\n     * The wallet is created using the CREATE opcode.\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _version The version of the feature bundle.\n     */\n    function createWallet(\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        uint256 _version\n    )\n        external\n        onlyManager\n    {\n        validateInputs(_owner, _versionManager, _guardian, _version);\n        Proxy proxy = new Proxy(walletImplementation);\n        address payable wallet = address(proxy);\n        configureWallet(BaseWallet(wallet), _owner, _versionManager, _guardian, _version);\n    }\n     \n    /**\n     * @notice Lets the manager create a wallet for an owner account at a specific address.\n     * The wallet is initialised with the version manager module, the version number and a first guardian.\n     * The wallet is created using the CREATE2 opcode.\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _salt The salt.\n     * @param _version The version of the feature bundle.\n     */\n    function createCounterfactualWallet(\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        bytes32 _salt,\n        uint256 _version\n    )\n        external\n        onlyManager\n        returns (address _wallet)\n    {\n        validateInputs(_owner, _versionManager, _guardian, _version);\n        bytes32 newsalt = newSalt(_salt, _owner, _versionManager, _guardian, _version);\n        Proxy proxy = new Proxy{salt: newsalt}(walletImplementation);\n        address payable wallet = address(proxy);\n        configureWallet(BaseWallet(wallet), _owner, _versionManager, _guardian, _version);\n        return wallet;\n    }\n\n    /**\n     * @notice Gets the address of a counterfactual wallet with a first default guardian.\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _salt The salt.\n     * @param _version The version of feature bundle.\n     * @return _wallet The address that the wallet will have when created using CREATE2 and the same input parameters.\n     */\n    function getAddressForCounterfactualWallet(\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        bytes32 _salt,\n        uint256 _version\n    )\n        external\n        view\n        returns (address _wallet)\n    {\n        validateInputs(_owner, _versionManager, _guardian, _version);\n        bytes32 newsalt = newSalt(_salt, _owner, _versionManager, _guardian, _version);\n        bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint256(walletImplementation));\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), newsalt, keccak256(code)));\n        _wallet = address(uint160(uint256(hash)));\n    }\n\n    /**\n     * @notice Lets the owner change the address of the module registry contract.\n     * @param _moduleRegistry The address of the module registry contract.\n     */\n    function changeModuleRegistry(address _moduleRegistry) external onlyOwner {\n        require(_moduleRegistry != address(0), \"WF: address cannot be null\");\n        moduleRegistry = _moduleRegistry;\n        emit ModuleRegistryChanged(_moduleRegistry);\n    }\n\n    /**\n     * @notice Inits the module for a wallet by doing nothing.\n     * The method can only be called by the wallet itself.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external pure {\n        //do nothing\n    }\n\n    // *************** Internal Functions ********************* //\n\n    /**\n     * @notice Helper method to configure a wallet for a set of input parameters.\n     * @param _wallet The target wallet\n     * @param _owner The account address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _version The version of the feature bundle.\n     */\n    function configureWallet(\n        BaseWallet _wallet,\n        address _owner,\n        address _versionManager,\n        address _guardian,\n        uint256 _version\n    )\n        internal\n    {\n        // add the factory to modules so it can add a guardian and upgrade the wallet to the required version\n        address[] memory extendedModules = new address[](2);\n        extendedModules[0] = _versionManager;\n        extendedModules[1] = address(this);\n\n        // initialise the wallet with the owner and the extended modules\n        _wallet.init(_owner, extendedModules);\n\n        // add guardian\n        IGuardianStorage(guardianStorage).addGuardian(address(_wallet), _guardian);\n\n        // upgrade the wallet\n        IVersionManager(_versionManager).upgradeWallet(address(_wallet), _version);\n\n        // remove the factory from the authorised modules\n        _wallet.authoriseModule(address(this), false);\n\n        // emit event\n        emit WalletCreated(address(_wallet), _owner, _guardian);\n    }\n\n    /**\n     * @notice Generates a new salt based on a provided salt, an owner, a list of modules and an optional guardian.\n     * @param _salt The slat provided.\n     * @param _owner The owner address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address.\n     * @param _version The version of feature bundle\n     */\n    function newSalt(bytes32 _salt, address _owner, address _versionManager, address _guardian, uint256 _version) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_salt, _owner, _versionManager, _guardian, _version));\n    }\n\n    /**\n     * @notice Throws if the owner, guardian, version or version manager is invalid.\n     * @param _owner The owner address.\n     * @param _versionManager The version manager module\n     * @param _guardian The guardian address\n     * @param _version The version of feature bundle\n     */\n    function validateInputs(address _owner, address _versionManager, address _guardian, uint256 _version) internal view {\n        require(_owner != address(0), \"WF: owner cannot be null\");\n        require(IModuleRegistry(moduleRegistry).isRegisteredModule(_versionManager), \"WF: invalid _versionManager\");\n        require(_guardian != (address(0)), \"WF: guardian cannot be null\");\n        require(_version \u003e 0, \"WF: invalid _version\");\n    }\n}\n"}}