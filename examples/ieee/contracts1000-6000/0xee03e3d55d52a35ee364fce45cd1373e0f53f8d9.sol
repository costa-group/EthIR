{"NamedContract.sol":{"content":"pragma solidity ^0.5.0;\n\n/// @title Named Contract\n/// @author growlot (@growlot)\ncontract NamedContract {\n    /// @notice The name of contract, which can be set once\n    string public name;\n\n    /// @notice Sets contract name.\n    function setContractName(string memory newName) internal {\n        name = newName;\n    }\n}\n"},"Ownable.sol":{"content":"pragma solidity ^0.5.0;\n\n\n/// @title Ownable Contract\n/// @author growlot (@growlot)\ncontract Ownable {\n    /// @notice Storage position of the owner address\n    /// @dev The address of the current owner is stored in a\n    /// constant pseudorandom slot of the contract storage\n    /// (slot number obtained as a result of hashing a certain message),\n    /// the probability of rewriting which is almost zero\n    bytes32 private constant _ownerPosition = keccak256(\"owner\");\n\n    /// @notice Storage position of the authorized new owner address\n    bytes32 private constant _authorizedNewOwnerPosition = keccak256(\"authorizedNewOwner\");\n\n    /// @notice Contract constructor\n    /// @dev Sets msg sender address as owner address\n    constructor() public {\n        bytes32 ownerPosition = _ownerPosition;\n        address owner = msg.sender;\n        assembly {\n            sstore(ownerPosition, owner)\n        }\n    }\n\n    /// @notice Check that requires msg.sender to be the current owner\n    function requireOwner() internal view {\n        require(\n            msg.sender == getOwner(),\n            \"Sender must be owner\"\n        );\n    }\n\n    /// @notice Returns contract owner address\n    function getOwner() public view returns (address owner) {\n        bytes32 ownerPosition = _ownerPosition;\n        assembly {\n            owner := sload(ownerPosition)\n        }\n    }\n\n    /// @notice Returns authorized new owner address\n    function getAuthorizedNewOwner() public view returns (address newOwner) {\n        bytes32 authorizedNewOwnerPosition = _authorizedNewOwnerPosition;\n        assembly {\n            newOwner := sload(authorizedNewOwnerPosition)\n        }\n    }\n\n    /**\n     * @notice Authorizes the transfer of ownership to the provided address.\n     * NOTE: No transfer will occur unless authorizedAddress calls assumeOwnership( ).\n     * This authorization may be removed by another call to this function authorizing\n     * the null address.\n     *\n     * @param authorizedAddress The address authorized to become the new owner.\n     */\n    function authorizeOwnershipTransfer(address authorizedAddress) external {\n        requireOwner();\n        bytes32 authorizedNewOwnerPosition = _authorizedNewOwnerPosition;\n        assembly {\n            sstore(authorizedNewOwnerPosition, authorizedAddress)\n        }\n    }\n    \n    /**\n     * @notice Transfers ownership of this contract to the authorizedNewOwner.\n     */\n    function assumeOwnership() external {\n        bytes32 authorizedNewOwnerPosition = _authorizedNewOwnerPosition;\n        address newOwner;\n\n        assembly {\n            newOwner := sload(authorizedNewOwnerPosition)\n        }\n\n        require(\n            msg.sender == newOwner,\n            \"Only the authorized new owner can accept ownership\"\n        );\n        \n        bytes32 ownerPosition = _ownerPosition;\n        address zero = address(0);\n\n        assembly {\n            sstore(ownerPosition, newOwner)\n            sstore(authorizedNewOwnerPosition, zero)\n        }\n    }\n}\n"},"StakingEvent.sol":{"content":"pragma solidity ^0.5.0;\n\n/// @title Staking Event Contract\n/// @author growlot (@growlot)\ncontract StakingEvent {\n\n    event Initialize(\n        address indexed owner,\n        address indexed sxp,\n        address indexed rewardProvider,\n        uint256 minimumStakeAmount,\n        uint256 rewardCycle,\n        uint256 rewardAmount,\n        uint256 rewardCycleTimestamp\n    );\n\n    event Stake(\n        address indexed staker,\n        uint256 indexed amount\n    );\n\n    event Claim(\n        address indexed toAddress,\n        uint256 indexed amount,\n        uint256 indexed nonce\n    );\n\n    event Withdraw(\n        address indexed toAddress,\n        uint256 indexed amount\n    );\n\n    event GuardianshipTransferAuthorization(\n        address indexed authorizedAddress\n    );\n\n    event GuardianUpdate(\n        address indexed oldValue,\n        address indexed newValue\n    );\n\n    event MinimumStakeAmountUpdate(\n        uint256 indexed oldValue,\n        uint256 indexed newValue\n    );\n\n    event RewardProviderUpdate(\n        address indexed oldValue,\n        address indexed newValue\n    );\n\n    event RewardPolicyUpdate(\n        uint256 oldCycle,\n        uint256 oldAmount,\n        uint256 indexed newCycle,\n        uint256 indexed newAmount,\n        uint256 indexed newTimeStamp\n    );\n\n    event DepositRewardPool(\n        address indexed depositor,\n        uint256 indexed amount\n    );\n\n    event WithdrawRewardPool(\n        address indexed toAddress,\n        uint256 indexed amount\n    );\n\n    event ApproveClaim(\n        address indexed toAddress,\n        uint256 indexed amount,\n        uint256 indexed nonce\n    );\n}\n"},"StakingProxy.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./SwipeRegistry.sol\";\nimport \"./StakingEvent.sol\";\n\n/// @title Upgradeable Registry Contract\n/// @author growlot (@growlot)\ncontract StakingProxy is SwipeRegistry, StakingEvent {\n    /// @notice Contract constructor\n    /// @dev Calls SwipeRegistry contract constructor\n    constructor() public SwipeRegistry(\"Swipe Staking Proxy\") {}\n}\n"},"SwipeRegistry.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./NamedContract.sol\";\nimport \"./Upgradeable.sol\";\n\n/// @title Upgradeable Registry Contract\n/// @author growlot (@growlot)\ncontract SwipeRegistry is NamedContract, Upgradeable {\n    /// @notice Contract constructor\n    /// @dev Calls Upgradable contract constructor and sets contract name\n    constructor(string memory contractName) public Upgradeable() {\n        setContractName(contractName);\n    }\n    \n    /// @notice Performs a delegatecall to the implementation contract.\n    /// @dev Fallback function allows to perform a delegatecall to the given implementation.\n    /// This function will return whatever the implementation call returns.\n    function() external payable {\n        require(msg.data.length \u003e 0, \"Calldata must not be empty\");\n        address _impl = getImplementation();\n        assembly {\n            // The pointer to the free memory slot\n            let ptr := mload(0x40)\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(ptr, 0x0, calldatasize)\n            // Delegatecall method of the implementation contract, returns 0 on error\n            let result := delegatecall(gas, _impl, ptr, calldatasize, 0x0, 0)\n            // Get the size of the last return data\n            let size := returndatasize\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(ptr, 0x0, size)\n            // Depending on result value\n            switch result\n                case 0 {\n                    // End execution and revert state changes\n                    revert(ptr, size)\n                }\n                default {\n                    // Return data with length of size at pointers position\n                    return(ptr, size)\n                }\n        }\n    }\n}\n"},"Upgradeable.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./Ownable.sol\";\n\n\n/// @title Upgradeable contract\n/// @author growlot (@growlot)\ncontract Upgradeable is Ownable {\n    /// @notice Storage position of the current implementation address.\n    /// @dev The address of the current implementation is stored in a\n    /// constant pseudorandom slot of the contract proxy contract storage\n    /// (slot number obtained as a result of hashing a certain message),\n    /// the probability of rewriting which is almost zero\n    bytes32 private constant implementationPosition = keccak256(\n        \"implementation\"\n    );\n\n    /// @notice Contract constructor\n    /// @dev Calls Ownable contract constructor\n    constructor() public Ownable() {}\n\n    /// @notice Returns the current implementation contract address\n    function getImplementation() public view returns (address implementation) {\n        bytes32 position = implementationPosition;\n        assembly {\n            implementation := sload(position)\n        }\n    }\n\n    /// @notice Sets new implementation contract address as current\n    /// @param _newImplementation New implementation contract address\n    function setImplementation(address _newImplementation) public {\n        requireOwner();\n        require(_newImplementation != address(0), \"New implementation must have non-zero address\");\n        address currentImplementation = getImplementation();\n        require(currentImplementation != _newImplementation, \"New implementation must have new address\");\n        bytes32 position = implementationPosition;\n        assembly {\n            sstore(position, _newImplementation)\n        }\n    }\n\n    /// @notice Sets new implementation contract address and call its initializer.\n    /// @dev New implementation call is a low level delegatecall.\n    /// @param _newImplementation the new implementation address.\n    /// @param _newImplementaionCallData represents the msg.data to bet sent through the low level delegatecall.\n    /// This parameter may include the initializer function signature with the needed payload.\n    function setImplementationAndCall(\n        address _newImplementation,\n        bytes calldata _newImplementaionCallData\n    ) external payable {\n        setImplementation(_newImplementation);\n        if (_newImplementaionCallData.length \u003e 0) {\n            (bool success, ) = address(this).call.value(msg.value)(\n                _newImplementaionCallData\n            );\n            require(success, \"Delegatecall has failed\");\n        }\n    }\n}\n"}}