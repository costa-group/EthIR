{"Address.sol":{"content":"/**\n\n* MIT License\n* ===========\n* \n* Copyright (c) 2020 OLegacy\n* \n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n\npragma solidity 0.5.17;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n  \n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n      // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n      // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n      // for accounts without code, i.e. `keccak256(\u0027\u0027)`\n      bytes32 codehash;\n      bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n      // solhint-disable-next-line no-inline-assembly\n      assembly { codehash := extcodehash(account) }\n      return (codehash != accountHash \u0026\u0026 codehash != 0x0);\n  }\n\n}"},"ERC20Interface.sol":{"content":"/**\n\n* MIT License\n* ===========\n* \n* Copyright (c) 2020 OLegacy\n* \n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n\npragma solidity 0.5.17;\n\ncontract ERC20Interface {\n    function balanceOf(address tokenOwner) public view returns (uint256 balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\n    function transfer(address to, uint256 tokens) public returns (bool success);\n    function approve(address spender, uint256 tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n}"},"OToken.sol":{"content":"/**\n\n* MIT License\n* ===========\n* \n* Copyright (c) 2020 OLegacy\n* \n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n\npragma solidity 0.5.17;\n\nimport \"./Ownership.sol\";\nimport \"./Address.sol\";\nimport \"./ERC20Interface.sol\";\nimport \"./SafeERC20.sol\";\n\n\nlibrary SafeMath {\n    /**\n        The MIT License (MIT)\n\n        Copyright (c) 2016-2020 zOS Global Limited\n\n        Permission is hereby granted, free of charge, to any person obtaining\n        a copy of this software and associated documentation files (the\n        \"Software\"), to deal in the Software without restriction, including\n        without limitation the rights to use, copy, modify, merge, publish,\n        distribute, sublicense, and/or sell copies of the Software, and to\n        permit persons to whom the Software is furnished to do so, subject to\n        the following conditions:\n\n        The above copyright notice and this permission notice shall be included\n        in all copies or substantial portions of the Software.\n\n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    */\n\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c \u003e= a \u0026\u0026 c \u003e= b);\n        return c;\n    }\n}\n\n\ninterface TokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; \n    function tokenFallback(address _from, uint256 _value, bytes calldata _data) external;\n}\n\n/**\n * @title OToken\n * @author OLegacy\n */\ncontract OToken is ERC20Interface, Ownership {\n\n    using SafeMath for uint256;\n    using Address for address;\n    using SafeERC20 for ERC20Interface;\n\n    // State variables\n    string public constant name = \u0027O Token\u0027; // Name of token\n    string public constant symbol = \u0027OT\u0027;  // Symbol of token\n    uint256 public constant decimals = 8; // Decimals in token\n    address public deputyOwner; // to perform tasks on behalf of owner in automated applications\n    uint256 public totalSupply = 0; // initially totalSupply 0\n\n    // external wallet addresses\n    address public suspenseWallet; // the contract resposible for burning tokens\n    address public centralRevenueWallet; // platform wallet to collect commission\n    address public minter; // adddress of minter\n\n    // to hold commissions on each token transfer\n    uint256 public commission_numerator; // commission percentage numerator\n    uint256 public commission_denominator;// commission percentage denominator\n\n    // mappings\n    mapping (address =\u003e uint256) balances; // balances mapping to hold OT balance of address\n    mapping (address =\u003e mapping (address =\u003e uint256) ) allowed; // mapping to hold allowances\n\n    mapping (address =\u003e bool) public isTaxFreeSender; // tokens transferred from these users won\u0027t be taxed\n    mapping (address =\u003e bool) public isTaxFreeRecipeint; // if token transferred to these addresses won\u0027t be taxed\n    mapping (string =\u003e mapping(string =\u003e bool)) public sawtoothHashMapping;\n    mapping (address =\u003e bool) public trustedContracts; // contracts on which tokenFallback will be called\n\n    // events\n    event MintOrBurn(address _from, address to, uint256 _token, string sawtoothHash, string orderId );\n    event CommssionUpdate(uint256 _numerator, uint256 _denominator);\n    event TaxFreeUserUpdate(address _user, bool _isWhitelisted, string _type);\n    event TrustedContractUpdate(address _contractAddress, bool _isActive);\n    event MinterUpdated(address _newMinter, address _oldMinter);\n    event SuspenseWalletUpdated(address _newSuspenseWallet, address _oldSuspenseWallet);\n    event DeputyOwnerUpdated(address _oldOwner, address _newOwner);\n    event CRWUpdated(address _newCRW, address _oldCRW);\n\n    constructor (address _minter, address _crw, address _newDeputyOwner)\n        public\n        onlyNonZeroAddress(_minter)\n        onlyNonZeroAddress(_crw)\n        onlyNonZeroAddress(_newDeputyOwner)\n    {\n        owner = msg.sender; // set owner address to be msg.sender\n        minter = _minter; // set minter address\n        centralRevenueWallet = _crw; // set central revenue wallet address\n        deputyOwner = _newDeputyOwner; // set deputy owner\n        commission_numerator = 1; // set commission\n        commission_denominator = 100;\n        // emit proper events\n        emit MinterUpdated(_minter, address(0));\n        emit CRWUpdated(_crw, address(0));\n        emit DeputyOwnerUpdated(_newDeputyOwner, address(0));\n        emit CommssionUpdate(1, 100);\n    }\n\n\n    // Modifiers\n    modifier canBurn() {\n        require(msg.sender == suspenseWallet, \"only suspense wallet is allowed\");\n        _;\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter,\"only minter is allowed\");\n        _;\n    }\n\n    modifier onlyDeputyOrOwner() {\n        require(msg.sender == owner || msg.sender == deputyOwner, \"Only owner or deputy owner is allowed\");\n        _;\n    }\n\n    modifier onlyNonZeroAddress(address _user) {\n        require(_user != address(0), \"Zero address not allowed\");\n        _;\n    }\n\n    modifier onlyValidSawtoothEntry(string memory _sawtoothHash, string memory _orderId) {\n        require(!sawtoothHashMapping[_sawtoothHash][_orderId], \"Sawtooth hash amd orderId combination already used\");\n        _;\n    }\n \n \n    ////////////////////////////////////////////////////////////////\n    //                  Public Functions\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Standard transfer function to Transfer token\n     * @dev The commission will be charged on top of _value\n     * @param _to recipient address\n     * @param _value amount of tokens to be transferred to recipient\n     * @return Bool value\n     */ \n    function transfer(address _to, uint256 _value) public returns (bool) {\n        return privateTransfer(msg.sender, _to, _value, false, false); // internal method\n    }\n\n    /**\n     * @notice Alternate method to standard transfer with fee deducted from transfer amount\n     * @dev The commission will be deducted from _value\n     * @param _to recipient address\n     * @param _value amount of tokens to be transferred to recipient\n     * @return Bool value\n     */ \n    function transferIncludingFee(address _to, uint256 _value)\n        public\n        onlyNonZeroAddress(_to)\n        returns(bool)\n    {\n        return privateTransfer(msg.sender, _to, _value, false, true);\n    }\n\n    /**\n     * @notice Bulk transfer\n     * @dev The commission will be charged on top of _value\n     * @param _addressArr array of recipient address\n     * @param _amountArr array of amounts corresponding to index on _addressArr\n     * @param _includingFees Denotes if fee should be deducted from amount or added to amount\n     * @return Bool value\n     */ \n    function bulkTransfer (address[] memory _addressArr, uint256[] memory _amountArr, bool _includingFees) public returns (bool) {\n        require(_addressArr.length == _amountArr.length, \"Invalid params\");\n        for(uint256 i = 0 ; i \u003c _addressArr.length; i++){\n            uint256 _value = _amountArr[i];\n            address _to = _addressArr[i];\n            privateTransfer(msg.sender, _to, _value, false, _includingFees); // internal method\n        }\n        return true;\n    }\n    \n    /**\n     * @notice Standard Approve function\n     * @dev This suffers from race condition. Use increaseApproval/decreaseApproval instead\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _value amount of token allowed\n     * @return Bool value\n     */ \n    function approve(address _spender, uint256 _value) public returns (bool) {\n        return _approve(msg.sender, _spender, _value);\n    }\n\n    /**\n     * @notice Increase allowance\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _addedValue amount by which allowance needs to be increased\n     * @return Bool value\n     */ \n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n       return _increaseApproval(msg.sender, _spender, _addedValue);\n    }\n  \n    /**\n     * @notice Decrease allowance\n     * @dev if the _subtractedValue is more than previous allowance, allowance will be set to 0\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _subtractedValue amount by which allowance needs to be decreases\n     * @return Bool value\n     */ \n    function decreaseApproval (address _spender, uint256 _subtractedValue) public returns (bool) {\n        return _decreaseApproval(msg.sender, _spender, _subtractedValue);\n    }\n    \n    /**\n     * @notice Approve and call\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _value amount of token allowed\n     * @param _extraData The extra data that will be send to recipient contract\n     * @return Bool value\n     */ \n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) public returns (bool) {\n        TokenRecipient spender = TokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n                spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n                return true;\n        }else{\n            return false;\n        }\n    }\n\n    /**\n     * @notice Standard transferFrom. Send tokens on behalf of spender\n     * @dev from must have allowed msg.sender atleast _value to spend\n     * @param _from Spender which has allowed msg.sender to spend on his behalf\n     * @param _to Recipient to which tokens are to be transferred\n     * @param _value The amount of token that will be transferred\n     * @return Bool value\n     */ \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_value \u003c= allowed[_from][msg.sender] ,\"Insufficient approval\");\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        privateTransfer(_from, _to, _value, false, false);\n    }\n\n\n   \n    ////////////////////////////////////////////////////////////////\n    //                  Special User functions\n    ////////////////////////////////////////////////////////////////\n    /**\n     * @notice Mint function.\n     * @dev Only minter address is allowed to mint\n     * @param _to The address to which tokens will be minted\n     * @param _value No of tokens to be minted\n     * @param _sawtoothHash The hash on sawtooth blockchain to track complete token generation cycle\n     * @return Bool value\n     */\n    function mint(address _to, uint256 _value, string memory _sawtoothHash, string memory _orderId)\n        public\n        onlyMinter\n        onlyNonZeroAddress(_to)\n        onlyValidSawtoothEntry(_sawtoothHash, _orderId)\n        returns (bool)\n    {\n        sawtoothHashMapping[_sawtoothHash][_orderId] = true;\n        totalSupply = totalSupply.add(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(address(0), _to, _value);\n        emit MintOrBurn(address(0), _to, _value, _sawtoothHash, _orderId);\n        return true;\n\n    }\n\n    /**\n     * @notice Bulk Mint function.\n     * @dev Only minter address is allowed to mint\n     * @param _addressArr The array of address to which tokens will be minted\n     * @param _amountArr The array of tokens that will be minted\n     * @param _sawtoothHash The hash on sawtooth blockchain to track complete token generation cycle\n     * @param _orderId The id of order in sawtooth blockchain\n     * @return Bool value\n     */\n    function bulkMint (address[] memory _addressArr, uint256[] memory _amountArr, string memory _sawtoothHash, string memory _orderId)\n        public\n        onlyMinter\n        onlyValidSawtoothEntry(_sawtoothHash, _orderId)\n        returns (bool)\n    {\n        require(_addressArr.length == _amountArr.length, \"Invalid params\");\n        for(uint256 i = 0; i \u003c _addressArr.length; i++){\n            uint256 _value = _amountArr[i];\n            address _to = _addressArr[i];\n            \n            require(_to != address(0),\"Zero address not allowed\");\n            totalSupply = totalSupply.add(_value);\n            balances[_to] = balances[_to].add(_value);\n            sawtoothHashMapping[_sawtoothHash][_orderId] = true;\n            emit Transfer(address(0), _to, _value);\n            emit MintOrBurn(address(0), _to, _value, _sawtoothHash, _orderId);\n        }\n        return true;\n\n    }\n\n    /**\n     * @notice Standard burn function.\n     * @dev Only address allowd can burn\n     * @param _value No of tokens to be burned\n     * @param _sawtoothHash The hash on sawtooth blockchain to track gold withdrawal\n     * @param _orderId The id of order in sawtooth blockchain\n     * @return Bool value\n     */\n    function burn(uint256 _value, string memory _sawtoothHash, string memory _orderId)\n        public\n        canBurn\n        onlyValidSawtoothEntry(_sawtoothHash, _orderId)\n        returns (bool)\n    {\n        require(balances[msg.sender] \u003e= _value, \"Insufficient balance\");\n        sawtoothHashMapping[_sawtoothHash][_orderId] = true;\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        emit Transfer(msg.sender, address(0), _value);\n        emit MintOrBurn(msg.sender, address(0), _value, _sawtoothHash, _orderId);\n        return true;\n    }\n\n    /**\n     * @notice Add/Remove a whitelisted recipient. Token transfer to this address won\u0027t be taxed\n     * @dev Only Deputy owner can call\n     * @param _users The array of addresses to be whitelisted/blacklisted\n     * @param _isSpecial true means user will be added; false means user will be removed\n     * @return Bool value\n     */\n    function updateTaxFreeRecipient(address[] memory _users, bool _isSpecial)\n        public\n        onlyDeputyOrOwner\n        returns (bool)\n    {\n        for(uint256 i=0; i\u003c_users.length; i++) {\n            require(_users[i] != address(0), \"Zero address not allowed\");\n            isTaxFreeRecipeint[_users[i]] = _isSpecial;\n            emit TaxFreeUserUpdate(_users[i], _isSpecial, \u0027Recipient\u0027);\n        }\n        \n        return true;\n    }\n\n    /**\n     * @notice Add/Remove a whitelisted sender. Token transfer from this address won\u0027t be taxed\n     * @dev Only Deputy owner can call\n     * @param _users The array of addresses to be whitelisted/blacklisted\n     * @param _isSpecial true means user will be added; false means user will be removed\n     * @return Bool value\n     */\n    function updateTaxFreeSender(address[] memory _users, bool _isSpecial)\n        public\n        onlyDeputyOrOwner\n        returns (bool)\n    {\n        for(uint256 i=0; i\u003c_users.length; i++) {\n            require(_users[i] != address(0), \"Zero address not allowed\");\n            isTaxFreeSender[_users[i]] = _isSpecial;\n            emit TaxFreeUserUpdate(_users[i], _isSpecial, \u0027Sender\u0027);\n        }\n        return true;\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                  Only Owner functions\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Add Suspense wallet address. This can be updated again in case of suspense contract is upgraded.\n     * @dev Only owner can call\n     * @param _suspenseWallet The address suspense wallet\n     * @return Bool value\n     */\n    function addSuspenseWallet(address _suspenseWallet)\n        public\n        onlyOwner\n        onlyNonZeroAddress(_suspenseWallet)\n        returns (bool)\n    {\n        emit SuspenseWalletUpdated(_suspenseWallet, suspenseWallet);\n        suspenseWallet = _suspenseWallet;\n        return true;\n    }\n\n    /**\n     * @notice Add Minter wallet address. This address will be responsible for minting tokens\n     * @dev Only owner can call\n     * @param _minter The address of minter wallet\n     * @return Bool value\n     */\n    function updateMinter(address _minter)\n        public\n        onlyOwner\n        onlyNonZeroAddress(_minter)\n        returns (bool)\n    {\n        emit MinterUpdated(_minter, minter);\n        minter = _minter;\n        return true;\n    }\n\n    /**\n     * @notice Add/Remove trusted contracts. The trusted contracts will be notified in case of tokens are transferred to them\n     * @dev Only owner can call and only contract address can be added\n     * @param _contractAddress The address of trusted contract\n     * @param _isActive true means whitelited; false means blackkisted\n     */\n    function addTrustedContracts(address _contractAddress, bool _isActive) public onlyDeputyOrOwner {\n        require(_contractAddress.isContract(), \"Only contract address can be added\");\n        trustedContracts[_contractAddress] = _isActive;\n        emit TrustedContractUpdate(_contractAddress, _isActive);\n    }\n\n    /**\n     * @notice Update commission to be charged on each token transfer\n     * @dev Only owner can call\n     * @param _numerator The numerator of commission\n     * @param _denominator The denominator of commission\n     */\n    function updateCommssion(uint256 _numerator, uint256 _denominator)\n        public\n        onlyDeputyOrOwner\n    {\n        commission_denominator = _denominator;\n        commission_numerator = _numerator;\n        emit CommssionUpdate(_numerator, _denominator);\n    }\n\n    /**\n     * @notice Update deputy owner. The Hot wallet version of owner\n     * @dev Only owner can call\n     * @param _newDeputyOwner The address of new deputy owner\n     */\n    function updateDeputyOwner(address _newDeputyOwner)\n        public\n        onlyOwner\n        onlyNonZeroAddress(_newDeputyOwner)\n    {\n        emit DeputyOwnerUpdated(_newDeputyOwner, deputyOwner);\n        deputyOwner = _newDeputyOwner;\n    }\n\n\n    /**\n     * @notice Update central revenue wallet\n     * @dev Only owner can call\n     * @param _newCrw The address of new central revenue wallet\n     */\n    function updateCRW(address _newCrw)\n        public\n        onlyOwner\n        onlyNonZeroAddress(_newCrw)\n    {\n        emit CRWUpdated(_newCrw, centralRevenueWallet);\n        centralRevenueWallet = _newCrw;\n    }\n\n    /**\n     * @notice  Owner can transfer out any accidentally sent ERC20 tokens\n     * @param _tokenAddress The contract address of ERC-20 compitable token\n     * @param _value The number of tokens to be transferred to owner\n     */\n    function transferAnyERC20Token(address _tokenAddress, uint256 _value) public onlyOwner {\n        ERC20Interface(_tokenAddress).safeTransfer(owner, _value);\n    }\n\n\n\n    ////////////////////////////////////////////////////////////////\n    //                  Internal/ Private methods\n    ////////////////////////////////////////////////////////////////\n\n    /**\n     * @notice Internal method to handle transfer logic\n     * @dev Notifies recipient, if recipient is a trusted contract\n     * @param _from Sender address\n     * @param _to Recipient address\n     * @param _amount amount of tokens to be transferred\n     * @param _withoutFees If true, commission will not be charged\n     * @param _includingFees Denotes if fee should be deducted from amount or added to amount\n     * @return bool\n     */\n    function privateTransfer(address _from, address _to, uint256 _amount, bool _withoutFees, bool _includingFees)\n        internal\n        onlyNonZeroAddress(_to)\n        returns (bool)\n    {\n        uint256 _amountToTransfer = _amount;\n        if(_withoutFees || isTaxFreeTx(_from, _to)) {\n            require(balances[_from] \u003e= _amount, \"Insufficient balance\");\n            _transferWithoutFee(_from, _to, _amountToTransfer);\n        } else {\n            uint256 fee = calculateCommission(_amount);\n\n            if(_includingFees) {\n                require(balances[_from] \u003e= _amount, \"Insufficient balance\");\n                _amountToTransfer = _amount.sub(fee);\n            } else {\n                require(balances[_from] \u003e= _amount.add(fee), \"Insufficient balance\");\n            }\n            if(fee \u003e 0 ) _transferWithoutFee(_from, centralRevenueWallet, fee);\n            _transferWithoutFee(_from, _to, _amountToTransfer);\n        }\n        notifyTrustedContract(_from, _to, _amountToTransfer);\n        return true;\n    }\n\n\n    /**\n     * @notice Internal method to facilitate token approval\n     * @param _sender The user which allows _spender to spend on his behalf\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _value amount of token allowed\n     * @return Bool value\n     */ \n    function _approve(address _sender, address _spender, uint256 _value)\n        internal returns (bool)\n    {\n        allowed[_sender][_spender] = _value;\n        emit Approval (_sender, _spender, _value);\n        return true;\n    }\n\n   /**\n     * @notice Internal method to Increase allowance\n     * @param _sender The user which allows _spender to spend on his behalf\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _addedValue amount by which allowance needs to be increased\n     * @return Bool value\n     */ \n    function _increaseApproval(address _sender, address _spender, uint256 _addedValue)\n        internal returns (bool)\n    {\n        allowed[_sender][_spender] = allowed[_sender][_spender].add(_addedValue);\n        emit Approval(_sender, _spender, allowed[_sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @notice Internal method to Decrease allowance\n     * @dev if the _subtractedValue is more than previous allowance, allowance will be set to 0\n     * @param _sender The user which allows _spender to spend on his behalf\n     * @param _spender The user which is allowed to spend on behalf of msg.sender\n     * @param _subtractedValue amount by which allowance needs to be decreases\n     * @return Bool value\n     */\n    function _decreaseApproval (address _sender, address _spender, uint256 _subtractedValue )\n        internal returns (bool)\n    {\n        uint256 oldValue = allowed[_sender][_spender];\n        if (_subtractedValue \u003e oldValue) {\n            allowed[_sender][_spender] = 0;\n        } else {\n            allowed[_sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(_sender, _spender, allowed[_sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @notice Internal method to transfer tokens without commission\n     * @param _from Sender address\n     * @param _to Recipient address\n     * @param _amount amount of tokens to be transferred\n     * @return Bool value\n     */\n    function _transferWithoutFee(address _from, address _to, uint256 _amount)\n        private\n        returns (bool)\n    {\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n\n    /**\n     * @notice Notifies recipient about transfer only if recipient is trused contract\n     * @param _from Sender address\n     * @param _to Recipient contract address\n     * @param _value amount of tokens to be transferred\n     * @return Bool value\n     */\n    function notifyTrustedContract(address _from, address _to, uint256 _value) internal {\n        // if the contract is trusted, notify it about the transfer\n        if(trustedContracts[_to]) {\n            TokenRecipient trustedContract = TokenRecipient(_to);\n            trustedContract.tokenFallback(_from, _value, \u00270x\u0027);\n        }\n\n    }\n\n    ////////////////////////////////////////////////////////////////\n    //                  Public View functions\n    ////////////////////////////////////////////////////////////////\n\n  \n    /**\n     * @notice Get allowance from token owner to spender\n     * @param _tokenOwner The token owner\n     * @param _spender The user which is allowed to spend\n     * @return uint256 Remaining allowance\n     */\n    function allowance(address _tokenOwner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_tokenOwner][_spender];\n    }\n\n\n    /**\n     * @notice Get balance of user\n     * @param _tokenOwner User address\n     * @return uint256 Current token balance\n     */\n    function balanceOf(address _tokenOwner) public view returns (uint256 balance) {\n        return balances[_tokenOwner];\n    }\n\n    /**\n     * @notice check transer fee\n     * @dev Does not checks if sender/recipient is whitelisted\n     * @param _amount The intended amount of transfer\n     * @return uint256 Calculated commission\n     */\n    function calculateCommission(uint256 _amount) public view returns (uint256) {\n        return _amount.mul(commission_numerator).div(commission_denominator).div(100);\n    }\n\n    /**\n     * @notice Checks if transfer between parties will be taxed or not\n     * @param _from Sender address\n     * @param _to Recipient address\n     * @return bool true if no commission will be charged\n     */\n    function isTaxFreeTx(address _from, address _to) public view returns(bool) {\n        if(isTaxFreeRecipeint[_to] || isTaxFreeSender[_from]) return true;\n        else return false;\n    }\n\n    /**\n     * @notice Prevents contract from accepting ETHs\n     * @dev Contracts can still be sent ETH with self destruct. If anyone deliberately does that, the ETHs will be lost\n     */\n    function () external payable {\n        revert(\"Contract does not accept ethers\");\n    }\n}\n\n\n/**\n * @title AdvancedOToken\n * @author OLegacy\n */    \ncontract AdvancedOToken is OToken {\n    mapping(address =\u003e mapping(bytes32 =\u003e bool)) public tokenUsed; // mapping to track token is used or not\n    \n    bytes4 public methodWord_transfer = bytes4(keccak256(\"transfer(address,uint256)\"));\n    bytes4 public methodWord_approve = bytes4(keccak256(\"approve(address,uint256)\"));\n    bytes4 public methodWord_increaseApproval = bytes4(keccak256(\"increaseApproval(address,uint256)\"));\n    bytes4 public methodWord_decreaseApproval = bytes4(keccak256(\"decreaseApproval(address,uint256)\"));\n\n\n    constructor(address minter, address crw, address deputyOwner) public OToken(minter, crw, deputyOwner) {\n    }\n\n    /**\n        \n     */\n    function getChainID() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n\n    /**\n     * @notice Delegated Bulk transfer. Gas fee will be paid by relayer\n     * @param message The message that user signed\n     * @param r Signature component\n     * @param s Signature component\n     * @param v Signature component\n     * @param token The unique token for each delegated function\n     * @param networkFee The fee that will be paid to relayer for gas fee he spends\n     * @param _addressArr The array of recipients\n     * @param _amountArr The array of amounts to be transferred\n     * @param _includingFees Denotes if fee should be deducted from amount or added to amount\n     * @return Bool value\n     */\n    function preAuthorizedBulkTransfer(\n        bytes32 message, bytes32 r, bytes32 s, uint8 v, bytes32 token, uint256 networkFee, address[] memory _addressArr,\n        uint256[] memory _amountArr, bool _includingFees )\n        public\n        returns (bool)\n    {\n        require(_addressArr.length == _amountArr.length, \"Invalid params\");\n\n        bytes32 proof = getProofBulkTransfer(\n            token, networkFee, msg.sender, _addressArr, _amountArr, _includingFees\n        );\n       \n        address signer = preAuthValidations(proof, message, token, r, s, v);\n\n        // Deduct network fee if broadcaster charges network fee\n        if (networkFee \u003e 0) {\n            privateTransfer(signer, msg.sender, networkFee, true, false);\n        }\n        // Execute original transfer function\n\n        for(uint256 i = 0; i \u003c _addressArr.length; i++){\n            uint256 _value = _amountArr[i];\n            address _to = _addressArr[i];\n            privateTransfer(signer, _to, _value, false, _includingFees);\n        }\n\n        return true;\n\n    }\n\n    /**\n     * @notice Delegated transfer. Gas fee will be paid by relayer\n     * @param message The message that user signed\n     * @param r Signature component\n     * @param s Signature component\n     * @param v Signature component\n     * @param token The unique token for each delegated function\n     * @param networkFee The fee that will be paid to relayer for gas fee he spends\n     * @param to The recipient address\n     * @param amount The amount to be transferred\n     * @param includingFees Denotes if fee should be deducted from amount or added to amount\n     * @return Bool value\n     */\n    function preAuthorizedTransfer(\n        bytes32 message, bytes32 r, bytes32 s, uint8 v, bytes32 token, uint256 networkFee, address to, uint256 amount, bool includingFees)\n        public\n    {\n\n        bytes32 proof = getProofTransfer(methodWord_transfer, token, networkFee, msg.sender, to, amount, includingFees);\n        address signer = preAuthValidations(proof, message, token, r, s, v);\n\n        // Deduct network fee if broadcaster charges network fee\n        if (networkFee \u003e 0) {\n            privateTransfer(signer, msg.sender, networkFee, true, false);\n        }\n\n        privateTransfer(signer, to, amount, false, includingFees);\n        \n    }\n\n    /**\n     * @notice Delegated approval. Gas fee will be paid by relayer\n     * @dev Only approve, increaseApproval and decreaseApproval can be delegated\n     * @param message The message that user signed\n     * @param r Signature component\n     * @param s Signature component\n     * @param v Signature component\n     * @param token The unique token for each delegated function\n     * @param networkFee The fee that will be paid to relayer for gas fee he spends\n     * @param to The spender address\n     * @param amount The amount to be allowed\n     * @return Bool value\n     */\n    function preAuthorizedApproval(\n        bytes4 methodHash, bytes32 message, bytes32 r, bytes32 s, uint8 v, bytes32 token, uint256 networkFee, address to, uint256 amount)\n        public\n        returns (bool)\n    {\n        bytes32 proof = getProofApproval (methodHash, token, networkFee, msg.sender, to, amount);\n        address signer = preAuthValidations(proof, message, token, r, s, v);\n\n        // Perform approval\n        if(methodHash == methodWord_approve) return _approve(signer, to, amount);\n        else if(methodHash == methodWord_increaseApproval) return _increaseApproval(signer, to, amount);\n        else if(methodHash == methodWord_decreaseApproval) return _decreaseApproval(signer, to, amount);\n    }\n\n    /**\n     * @notice Validates the message and signature\n     * @param proof The message that was expected to be signed by user\n     * @param message The message that user signed\n     * @param r Signature component\n     * @param s Signature component\n     * @param v Signature component\n     * @param token The unique token for each delegated function\n     * @return address Signer of message\n     */\n    function preAuthValidations(bytes32 proof, bytes32 message, bytes32 token, bytes32 r, bytes32 s, uint8 v)\n        private\n        returns(address)\n    {\n        address signer = getSigner(message, r, s, v);\n        require(signer != address(0),\"Zero address not allowed\");\n        require(!tokenUsed[signer][token],\"Token already used\");\n        require(proof == message, \"Invalid proof\");\n        tokenUsed[signer][token] = true;\n        return signer;\n    }\n\n    \n    /**\n     * @notice Find signer\n     * @param message The message that user signed\n     * @param r Signature component\n     * @param s Signature component\n     * @param v Signature component\n     * @return address Signer of message\n     */\n    function getSigner(bytes32 message, bytes32 r, bytes32 s, uint8 v)\n        public\n        pure\n        returns (address)\n    {\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, message));\n        address signer = ecrecover(prefixedHash, v, r, s);\n        return signer;\n    }\n\n    \n    /**\n     * @notice The message to be signed in case of delegated bulk transfer\n     * @param token The unique token for each delegated function\n     * @param networkFee The fee that will be paid to relayer for gas fee he spends\n     * @param _addressArr The array of recipients\n     * @param _amountArr The array of amounts to be transferred\n     * @param _includingFees Denotes if fee should be deducted from amount or added to amount\n     * @return Bool value\n     */\n    function getProofBulkTransfer(bytes32 token, uint256 networkFee, address broadcaster, address[] memory _addressArr, uint256[] memory _amountArr, bool _includingFees)\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 proof = keccak256(abi.encodePacked(\n            getChainID(),\n            bytes4(methodWord_transfer),\n            address(this),\n            token,\n            networkFee,\n            broadcaster,\n            _addressArr,\n            _amountArr,\n            _includingFees\n        ));\n        return proof;\n    }\n\n\n\n    /**\n     * @notice Get the message to be signed in case of delegated transfer/approvals\n     * @param methodHash The method hash for which delegate action in to be performed\n     * @param token The unique token for each delegated function\n     * @param networkFee The fee that will be paid to relayer for gas fee he spends\n     * @param to The recipient or spender\n     * @param amount The amount to be approved\n     * @return Bool value\n     */\n    function getProofApproval(bytes4 methodHash, bytes32 token, uint256 networkFee, address broadcaster, address to, uint256 amount)\n        public\n        view\n        returns (bytes32)\n    {\n        require(\n            methodHash == methodWord_approve ||\n            methodHash == methodWord_increaseApproval ||\n            methodHash == methodWord_decreaseApproval,\n            \"Method not supported\");\n        bytes32 proof = keccak256(abi.encodePacked(\n            getChainID(),\n            bytes4(methodHash),\n            address(this),\n            token,\n            networkFee,\n            broadcaster,\n            to,\n            amount\n        ));\n        return proof;\n    }\n\n    /**\n     * @notice Get the message to be signed in case of delegated transfer/approvals\n     * @param methodHash The method hash for which delegate action in to be performed\n     * @param token The unique token for each delegated function\n     * @param networkFee The fee that will be paid to relayer for gas fee he spends\n     * @param to The recipient or spender\n     * @param amount The amount to be transferred\n     * @param includingFees Denotes if fee should be deducted from amount or added to amount\n     * @return Bool value\n     */\n    function getProofTransfer(bytes4 methodHash, bytes32 token, uint256 networkFee, address broadcaster, address to, uint256 amount, bool includingFees)\n        public\n        view\n        returns (bytes32)\n    {\n        require(methodHash == methodWord_transfer, \"Method not supported\");\n        bytes32 proof = keccak256(abi.encodePacked(\n            getChainID(),\n            bytes4(methodHash),\n            address(this),\n            token,\n            networkFee,\n            broadcaster,\n            to,\n            amount,\n            includingFees\n        ));\n        return proof;\n    }\n\n   \n\n}"},"Ownership.sol":{"content":"/**\n\n* MIT License\n* ===========\n* \n* Copyright (c) 2020 OLegacy\n* \n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n\npragma solidity 0.5.17;\n\ncontract Ownership {\n\n  address public owner;\n  event OwnershipUpdated(address oldOwner, address newOwner);\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Not owner\");\n    _;\n  }\n\n  /**\n   * @dev Transfer the ownership to some other address.\n   * new owner can not be a zero address.\n   * Only owner can call this function\n   * @param _newOwner Address to which ownership is being transferred\n   */\n  function updateOwner(address _newOwner)\n    public\n    onlyOwner\n  {\n    require(_newOwner != address(0x0), \"Invalid address\");\n    owner = _newOwner;\n    emit OwnershipUpdated(msg.sender, owner);\n  }\n\n  /**\n   * @dev Renounce the ownership.\n   * This will leave the contract without any owner.\n   * Only owner can call this function\n   * @param _validationCode A code to prevent aaccidental calling of this function\n   */\n  function renounceOwnership(uint _validationCode)\n    public\n    onlyOwner\n  {\n    require(_validationCode == 123456789, \"Invalid code\");\n    owner = address(0);\n    emit OwnershipUpdated(msg.sender, owner);\n  }\n}"},"SafeERC20.sol":{"content":"/**\n\n* MIT License\n* ===========\n* \n* Copyright (c) 2020 OLegacy\n* \n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n* \n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n* \n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*\n*/\n\npragma solidity ^0.5.17;\n\nimport \"./ERC20Interface.sol\";\nimport \"./Address.sol\";\n\n\nlibrary SafeERC20 {\n    /**\n        The MIT License (MIT)\n\n        Copyright (c) 2016-2020 zOS Global Limited\n\n        Permission is hereby granted, free of charge, to any person obtaining\n        a copy of this software and associated documentation files (the\n        \"Software\"), to deal in the Software without restriction, including\n        without limitation the rights to use, copy, modify, merge, publish,\n        distribute, sublicense, and/or sell copies of the Software, and to\n        permit persons to whom the Software is furnished to do so, subject to\n        the following conditions:\n\n        The above copyright notice and this permission notice shall be included\n        in all copies or substantial portions of the Software.\n\n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    */\n\n    using Address for address;\n\n    function safeTransfer(ERC20Interface token, address to, uint256 value) internal {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n  \n    function _callOptionalReturn(ERC20Interface token, bytes memory data) private {\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}"}}