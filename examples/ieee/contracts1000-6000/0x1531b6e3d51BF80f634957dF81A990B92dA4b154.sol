{{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/OnDemandSPV.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title OnDemandSPV */\n/** @author Summa (https://summa.one) */\n\nimport {Relay} from \"./Relay.sol\";\nimport {ISPVRequestManager, ISPVConsumer} from \"./Interfaces.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {ValidateSPV} from \"@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol\";\nimport {SafeMath} from \"@summa-tx/bitcoin-spv-sol/contracts/SafeMath.sol\";\n\n\ncontract OnDemandSPV is ISPVRequestManager, Relay {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n\n    struct ProofRequest {\n        bytes32 spends;\n        bytes32 pays;\n        uint256 notBefore;\n        address consumer;\n        uint64 paysValue;\n        uint8 numConfs;\n        address owner;\n        RequestStates state;\n    }\n\n    enum RequestStates { NONE, ACTIVE, CLOSED }\n    mapping (bytes32 => bool) internal validatedTxns;  // authenticated tx store\n    mapping (uint256 => ProofRequest) internal requests;  // request info\n    uint256 public constant BASE_COST = 24 * 60 * 60;  // 1 day\n\n    uint256 public nextID;\n    bytes32 public latestValidatedTx;\n    uint256 public remoteGasAllowance = 500000; // maximum gas for callback call\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _genesisHeader    The starting header\n    /// @param  _height           The starting height\n    /// @param  _periodStart      The hash of the first header in the genesis epoch\n    constructor(\n        bytes memory _genesisHeader,\n        uint256 _height,\n        bytes32 _periodStart,\n        uint256 _firstID\n    ) Relay(\n        _genesisHeader,\n        _height,\n        _periodStart\n    ) public {\n        nextID = _firstID;\n    }\n\n    /// @notice                 Cancel a bitcoin event request.\n    /// @dev                    Prevents the relay from forwarding tx infromation\n    /// @param  _requestID      The ID of the request to be cancelled\n    /// @return                 True if succesful, error otherwise\n    function cancelRequest(uint256 _requestID) external returns (bool) {\n        ProofRequest storage _req = requests[_requestID];\n        require(_req.state == RequestStates.ACTIVE, \"Request not active\");\n        require(msg.sender == _req.consumer || msg.sender == _req.owner, \"Can only be cancelled by owner or consumer\");\n        _req.state = RequestStates.CLOSED;\n        emit RequestClosed(_requestID);\n        return true;\n    }\n\n    function getLatestValidatedTx() external view returns (bytes32) {\n        return latestValidatedTx;\n    }\n\n    /// @notice             Retrieve info about a request\n    /// @dev                Requests ids are numerical\n    /// @param  _requestID  The numerical ID of the request\n    /// @return             A tuple representation of the request struct\n    function getRequest(\n        uint256 _requestID\n    ) external view returns (\n        bytes32 spends,\n        bytes32 pays,\n        uint64 paysValue,\n        uint8 state,\n        address consumer,\n        address owner,\n        uint8 numConfs,\n        uint256 notBefore\n    ) {\n        ProofRequest storage _req = requests[_requestID];\n        spends = _req.spends;\n        pays = _req.pays;\n        paysValue = _req.paysValue;\n        state = uint8(_req.state);\n        consumer = _req.consumer;\n        owner = _req.owner;\n        numConfs = _req.numConfs;\n        notBefore = _req.notBefore;\n    }\n\n    /// @notice                 Subscribe to a feed of Bitcoin txns matching a request\n    /// @dev                    The request can be a spent utxo and/or a created utxo\n    /// @param  _spends         An outpoint that must be spent in acceptable txns (optional)\n    /// @param  _pays           An output script that must be paid in acceptable txns (optional)\n    /// @param  _paysValue      A minimum value that must be paid to the output script (optional)\n    /// @param  _consumer       The address of a ISPVConsumer exposing spv\n    /// @param  _numConfs       The minimum number of Bitcoin confirmations to accept\n    /// @param  _notBefore      A timestamp before which proofs are not accepted\n    /// @return                 A unique request ID.\n    function request(\n        bytes calldata _spends,\n        bytes calldata _pays,\n        uint64 _paysValue,\n        address _consumer,\n        uint8 _numConfs,\n        uint256 _notBefore\n    ) external returns (uint256) {\n        return _request(_spends, _pays, _paysValue, _consumer, _numConfs, _notBefore);\n    }\n\n    /// @notice                 Subscribe to a feed of Bitcoin txns matching a request\n    /// @dev                    The request can be a spent utxo and/or a created utxo\n    /// @param  _spends         An outpoint that must be spent in acceptable txns (optional)\n    /// @param  _pays           An output script that must be paid in acceptable txns (optional)\n    /// @param  _paysValue      A minimum value that must be paid to the output script (optional)\n    /// @param  _consumer       The address of a ISPVConsumer exposing spv\n    /// @param  _numConfs       The minimum number of Bitcoin confirmations to accept\n    /// @param  _notBefore      A timestamp before which proofs are not accepted\n    /// @return                 A unique request ID\n    function _request(\n        bytes memory _spends,\n        bytes memory _pays,\n        uint64 _paysValue,\n        address _consumer,\n        uint8 _numConfs,\n        uint256 _notBefore\n    ) internal returns (uint256) {\n        uint256 _requestID = nextID;\n        nextID = nextID + 1;\n        bytes memory pays = _pays;\n\n        require(_spends.length == 36 || _spends.length == 0, \"Not a valid UTXO\");\n\n        /* NB: This will fail if the output is not p2pkh, p2sh, p2wpkh, or p2wsh*/\n        uint256 _paysLen = pays.length;\n\n        // if it's not length-prefixed, length-prefix it\n        if (_paysLen > 0 && uint8(pays[0]) != _paysLen - 1) {\n            pays = abi.encodePacked(uint8(_paysLen), pays);\n            _paysLen += 1; // update the length because we made it longer\n        }\n\n        bytes memory _p = abi.encodePacked(bytes8(0), pays);\n        require(\n            _paysLen == 0 ||  // no request OR\n            _p.extractHash().length > 0 || // standard output OR\n            _p.extractOpReturnData().length > 0, // OP_RETURN output\n            \"Not a standard output type\");\n\n        require(_spends.length > 0 || _paysLen > 0, \"No request specified\");\n\n        ProofRequest storage _req = requests[_requestID];\n        _req.owner = msg.sender;\n\n        if (_spends.length > 0) {\n            _req.spends = keccak256(_spends);\n        }\n        if (_paysLen > 0) {\n            _req.pays = keccak256(pays);\n        }\n        if (_paysValue > 0) {\n            _req.paysValue = _paysValue;\n        }\n        if (_numConfs > 0 && _numConfs < 241) { //241 is arbitray. 40 hours\n            _req.numConfs = _numConfs;\n        }\n        if (_notBefore > 0) {\n            _req.notBefore = _notBefore;\n        }\n        _req.consumer = _consumer;\n        _req.state = RequestStates.ACTIVE;\n\n        emit NewProofRequest(msg.sender, _requestID, _paysValue, _spends, pays);\n\n        return _requestID;\n    }\n\n    /// @notice                 Provide a proof of a tx that satisfies some request\n    /// @dev                    The caller must specify which inputs, which outputs, and which request\n    /// @param  _header         The header containing the merkleroot committing to the tx\n    /// @param  _proof          The merkle proof intermediate nodes\n    /// @param  _version        The tx version, always the first 4 bytes of the tx\n    /// @param  _locktime       The tx locktime, always the last 4 bytes of the tx\n    /// @param  _index          The index of the tx in the merkle tree's leaves\n    /// @param  _reqIndices  The input and output index to check against the request, packed\n    /// @param  _vin            The tx input vector\n    /// @param  _vout           The tx output vector\n    /// @param  _requestID       The id of the request that has been triggered\n    /// @return                 True if succesful, error otherwise\n    function provideProof(\n        bytes calldata _header,\n        bytes calldata _proof,\n        bytes4 _version,\n        bytes4 _locktime,\n        uint256 _index,\n        uint16 _reqIndices,\n        bytes calldata _vin,\n        bytes calldata _vout,\n        uint256 _requestID\n    ) external returns (bool) {\n        bytes32 _txid = abi.encodePacked(_version, _vin, _vout, _locktime).hash256();\n        /*\n        NB: this shortcuts validation of any txn we've seen before\n            repeats can omit header, proof, and index\n        */\n        if (!validatedTxns[_txid]) {\n            _checkInclusion(\n                _header,\n                _proof,\n                _index,\n                _txid,\n                _requestID);\n            validatedTxns[_txid] = true;\n            latestValidatedTx = _txid;\n        }\n        _checkRequests(_reqIndices, _vin, _vout, _requestID);\n        _callCallback(_txid, _reqIndices, _vin, _vout, _requestID);\n        return true;\n    }\n\n    /// @notice             Notify a consumer that one of its requests has been triggered\n    /// @dev                We include information about the tx that triggered it, so the consumer can take actions\n    /// @param  _vin        The tx input vector\n    /// @param  _vout       The tx output vector\n    /// @param  _txid       The transaction ID\n    /// @param  _requestID   The id of the request that has been triggered\n    function _callCallback(\n        bytes32 _txid,\n        uint16 _reqIndices,\n        bytes memory _vin,\n        bytes memory _vout,\n        uint256 _requestID\n    ) internal returns (bool) {\n        ProofRequest storage _req = requests[_requestID];\n        ISPVConsumer c = ISPVConsumer(_req.consumer);\n\n        uint8 _inputIndex = uint8(_reqIndices >> 8);\n        uint8 _outputIndex = uint8(_reqIndices & 0xff);\n\n        /*\n        NB:\n        We want to make the remote call, but we don't care about results\n        We use the low-level call so that we can ignore reverts and set gas\n        */\n        address(c).call.gas(remoteGasAllowance)(\n            abi.encodePacked(\n                c.spv.selector,\n                abi.encode(_txid, _vin, _vout, _requestID, _inputIndex, _outputIndex)\n            )\n        );\n\n        emit RequestFilled(_txid, _requestID);\n\n        return true;\n    }\n\n    /// @notice             Verifies inclusion of a tx in a header, and that header in the Relay chain\n    /// @dev                Specifically we check that both the best tip and the heaviest common header confirm it\n    /// @param  _header     The header containing the merkleroot committing to the tx\n    /// @param  _proof      The merkle proof intermediate nodes\n    /// @param  _index      The index of the tx in the merkle tree's leaves\n    /// @param  _txid       The txid that is the proof leaf\n    /// @param _requestID   The ID of the request to check against\n    function _checkInclusion(\n        bytes memory _header,\n        bytes memory _proof,\n        uint256 _index,\n        bytes32 _txid,\n        uint256 _requestID\n    ) internal view returns (bool) {\n        require(\n            ValidateSPV.prove(\n                _txid,\n                _header.extractMerkleRootLE().toBytes32(),\n                _proof,\n                _index),\n            \"Bad inclusion proof\");\n\n        bytes32 _headerHash = _header.hash256();\n        bytes32 _GCD = getLastReorgCommonAncestor();\n\n        require(\n            _isAncestor(\n                _headerHash,\n                _GCD,\n                240),\n            \"GCD does not confirm header\");\n        uint8 _numConfs = requests[_requestID].numConfs;\n        require(\n            _getConfs(_headerHash) >= _numConfs,\n            \"Insufficient confirmations\");\n\n        return true;\n    }\n\n    /// @notice             Finds the number of headers on top of the argument\n    /// @dev                Bounded to 6400 gas (8 looksups) max\n    /// @param _headerHash  The LE double-sha2 header hash\n    /// @return             The number of headers on top\n    function _getConfs(bytes32 _headerHash) internal view returns (uint8) {\n        return uint8(_findHeight(bestKnownDigest) - _findHeight(_headerHash));\n    }\n\n    /// @notice                 Verifies that a tx meets the requester's request\n    /// @dev                    Requests can be specify an input, and output, and/or an output value\n    /// @param  _reqIndices  The input and output index to check against the request, packed\n    /// @param  _vin            The tx input vector\n    /// @param  _vout           The tx output vector\n    /// @param  _requestID       The id of the request to check\n    function _checkRequests (\n        uint16 _reqIndices,\n        bytes memory _vin,\n        bytes memory _vout,\n        uint256 _requestID\n    ) internal view returns (bool) {\n        require(_vin.validateVin(), \"Vin is malformatted\");\n        require(_vout.validateVout(), \"Vout is malformatted\");\n\n        uint8 _inputIndex = uint8(_reqIndices >> 8);\n        uint8 _outputIndex = uint8(_reqIndices & 0xff);\n\n        ProofRequest storage _req = requests[_requestID];\n        require(_req.notBefore <= block.timestamp, \"Request is submitted too early\");\n        require(_req.state == RequestStates.ACTIVE, \"Request is not active\");\n\n        bytes32 _pays = _req.pays;\n        bool _hasPays = _pays != bytes32(0);\n        if (_hasPays) {\n            bytes memory _out = _vout.extractOutputAtIndex(uint8(_outputIndex));\n            bytes memory _scriptPubkey = _out.slice(8, _out.length - 8);\n            require(\n                keccak256(_scriptPubkey) == _pays,\n                \"Does not match pays request\");\n            uint64 _paysValue = _req.paysValue;\n            require(\n                _paysValue == 0 ||\n                _out.extractValue() >= _paysValue,\n                \"Does not match value request\");\n        }\n\n        bytes32 _spends = _req.spends;\n        bool _hasSpends = _spends != bytes32(0);\n        if (_hasSpends) {\n            bytes memory _in = _vin.extractInputAtIndex(uint8(_inputIndex));\n            require(\n                !_hasSpends ||\n                keccak256(_in.extractOutpoint()) == _spends,\n                \"Does not match spends request\");\n        }\n        return true;\n    }\n}\n"
    },
    "solidity/contracts/Interfaces.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/// @title      ISPVConsumer\n/// @author     Summa (https://summa.one)\n/// @notice     This interface consumes validated transaction information.\n///             It is the primary way that user contracts accept\n/// @dev        Implement this interface to process transactions provided by\n///             the Relay system.\ninterface ISPVConsumer {\n    /// @notice     A consumer for Bitcoin transaction information.\n    /// @dev        Users must implement this function. It handles Bitcoin\n    ///             events that have been validated by the Relay contract.\n    ///             It is VERY IMPORTANT that this function validates the\n    ///             msg.sender. The callee must check the origin of the data\n    ///             or risk accepting spurious information.\n    /// @param _txid        The LE(!) txid of the bitcoin transaction that\n    ///                     triggered the notification.\n    /// @param _vin         The length-prefixed input vector of the bitcoin tx\n    ///                     that triggered the notification.\n    /// @param _vout        The length-prefixed output vector of the bitcoin tx\n    ///                     that triggered the notification.\n    /// @param _requestID   The ID of the event request that this notification\n    ///                     satisfies. The ID is returned by\n    ///                     OnDemandSPV.request and should be locally stored by\n    ///                     any contract that makes more than one request.\n    /// @param _inputIndex  The index of the input in the _vin that triggered\n    ///                     the notification.\n    /// @param _outputIndex The index of the output in the _vout that triggered\n    ///                     the notification. Useful for subscribing to transactions\n    ///                     that spend the newly-created UTXO.\n    function spv(\n        bytes32 _txid,\n        bytes calldata _vin,\n        bytes calldata _vout,\n        uint256 _requestID,\n        uint8 _inputIndex,\n        uint8 _outputIndex) external;\n}\n\n/// @title      ISPVRequestManager\n/// @author     Summa (https://summa.one)\n/// @notice     The interface for using the OnDemandSPV system. This interface\n///             allows you to subscribe to Bitcoin events.\n/// @dev        Manage subscriptions to Bitcoin events. Register callbacks to\n///             be called whenever specific Bitcoin transactions are made.\ninterface ISPVRequestManager {\n    event NewProofRequest (\n        address indexed _requester,\n        uint256 indexed _requestID,\n        uint64 _paysValue,\n        bytes _spends,\n        bytes _pays\n    );\n\n    event RequestClosed(uint256 indexed _requestID);\n    event RequestFilled(bytes32 indexed _txid, uint256 indexed _requestID);\n\n    /// @notice             Subscribe to a feed of Bitcoin transactions matching a request\n    /// @dev                The request can be a spent utxo and/or a created utxo.\n    ///\n    ///                     The contract allows users to register a \"consumer\" contract\n    ///                     that implements ISPVConsumer to handle Bitcoin events.\n    ///\n    ///                     Bitcoin transactions are composed of a vector of inputs,\n    ///                     and a vector of outputs. The `_spends` parameter allows consumers\n    ///                     to watch a specific UTXO, and receive an event when it is spent.\n    ///\n    ///                     The `_pays` and `_paysValue` param allow the user to watch specific\n    ///                     Bitcoin output scripts. An output script is typically encoded\n    ///                     as an address, but an address is not an in-protocol construction.\n    ///                     In other words, consumers will receive an event whenever a specific\n    ///                     address receives funds, or when a specific OP_RETURN is created.\n    ///\n    ///                     Either `_spends` or `_pays` MUST be set. Both MAY be set.\n    ///                     If both are set, only notifications meeting both criteria\n    ///                     will be triggered.\n    ///\n    /// @param  _spends     An outpoint that must be spent in acceptable transactions.\n    ///                     The outpoint must be exactly 36 bytes, and composed of a\n    ///                     LE txid (32 bytes), and an 4-byte LE-encoded index integer.\n    ///                     In other words, the precise serialization format used in a\n    ///                     serialized Bitcoin TxIn.\n    ///\n    ///                     Note that while we might expect a `_spends` event to fire at most\n    ///                     one time, that expectation becomes invalid in long Bitcoin reorgs\n    ///                     if there is a double-spend or a disconfirmation followed by\n    ///                     reconfirmation.\n    ///\n    /// @param  _pays       An output script to watch for events. A filter with `_pays` set will\n    ///                     validate any number of events that create new UTXOs with a specific\n    ///                     output script.\n    ///\n    ///                     This is useful for watching an address and responding to incoming\n    ///                     payments.\n    ///\n    /// @param  _paysValue  A minimum value in satoshi that must be paid to the output script.\n    ///                     If this is set no any non-0 number, the Relay will only forward\n    ///                     `_pays` notifications to the consumer if the value of the new UTXO is\n    ///                     at least `_paysValue`.\n    ///\n    /// @param  _consumer   The address of a contract that implements the `ISPVConsumer` interface.\n    ///                     Whenever events are available, the Relay will validate inclusion\n    ///                     and confirmation, then call the `spv` function on the consumer.\n    ///\n    /// @param  _numConfs   The number of headers that must confirm the block\n    ///                     containing the transaction. Used as a security parameter.\n    ///                     More confirmations means less likely to revert due to a\n    ///                     chain reorganization. Note that 1 confirmation is required,\n    ///                     so the general \"6 confirmation\" rule would be expressed\n    ///                     as `5` when calling this function\n    ///\n    /// @param  _notBefore  An Ethereum timestamp before which proofs will not be accepted.\n    ///                     Used to control app flow for specific users.\n    ///\n    /// @return             A unique request ID.\n    function request(\n        bytes calldata _spends,\n        bytes calldata _pays,\n        uint64 _paysValue,\n        address _consumer,\n        uint8 _numConfs,\n        uint256 _notBefore\n    ) external returns (uint256);\n\n    /// @notice                 Cancel an active bitcoin event request.\n    /// @dev                    Prevents the relay from forwarding tx information\n    /// @param  _requestID      The ID of the request to be cancelled\n    /// @return                 True if succesful, error otherwise\n    function cancelRequest(uint256 _requestID) external returns (bool);\n\n    /// @notice             Retrieve info about a request\n    /// @dev                Requests ids are numerical\n    /// @param  _requestID  The numerical ID of the request\n    /// @return             A tuple representation of the request struct.\n    ///                     To save space`spends` and `pays` are stored as keccak256\n    ///                     hashes of the original information. The `state` is\n    ///                     `0` for \"does not exist\", `1` for \"active\" and `2` for\n    ///                     \"cancelled.\"\n    function getRequest(\n        uint256 _requestID\n    ) external view returns (\n        bytes32 spends,\n        bytes32 pays,\n        uint64 paysValue,\n        uint8 state,\n        address consumer,\n        address owner,\n        uint8 numConfs,\n        uint256 notBefore\n    );\n}\n\n\n\ninterface IRelay {\n    event Extension(bytes32 indexed _first, bytes32 indexed _last);\n    event NewTip(bytes32 indexed _from, bytes32 indexed _to, bytes32 indexed _gcd);\n\n    function getCurrentEpochDifficulty() external view returns (uint256);\n    function getPrevEpochDifficulty() external view returns (uint256);\n    function getRelayGenesis() external view returns (bytes32);\n    function getBestKnownDigest() external view returns (bytes32);\n    function getLastReorgCommonAncestor() external view returns (bytes32);\n\n    function findHeight(bytes32 _digest) external view returns (uint256);\n\n    function findAncestor(bytes32 _digest, uint256 _offset) external view returns (bytes32);\n\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view returns (bool);\n\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\n\n    function addHeadersWithRetarget(\n        bytes calldata _oldPeriodStartHeader,\n        bytes calldata _oldPeriodEndHeader,\n        bytes calldata _headers\n    ) external returns (bool);\n\n    function markNewHeaviest(\n        bytes32 _ancestor,\n        bytes calldata _currentBest,\n        bytes calldata _newBest,\n        uint256 _limit\n    ) external returns (bool);\n}\n"
    },
    "solidity/contracts/Relay.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title Relay */\n/** @author Summa (https://summa.one) */\n\nimport {SafeMath} from \"@summa-tx/bitcoin-spv-sol/contracts/SafeMath.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {BTCUtils} from \"@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {ValidateSPV} from \"@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol\";\nimport {IRelay} from \"./Interfaces.sol\";\n\ncontract Relay is IRelay {\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n    using ValidateSPV for bytes;\n\n    // How often do we store the height?\n    // A higher number incurs less storage cost, but more lookup cost\n    uint32 public constant HEIGHT_INTERVAL = 4;\n\n    bytes32 internal relayGenesis;\n    bytes32 internal bestKnownDigest;\n    bytes32 internal lastReorgCommonAncestor;\n    mapping (bytes32 => bytes32) internal previousBlock;\n    mapping (bytes32 => uint256) internal blockHeight;\n\n    uint256 internal currentEpochDiff;\n    uint256 internal prevEpochDiff;\n\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _genesisHeader    The starting header\n    /// @param  _height           The starting height\n    /// @param  _periodStart      The hash of the first header in the genesis epoch\n    constructor(bytes memory _genesisHeader, uint256 _height, bytes32 _periodStart) public {\n        require(_genesisHeader.length == 80, \"Stop being dumb\");\n        bytes32 _genesisDigest = _genesisHeader.hash256();\n\n        require(\n            _periodStart & bytes32(0x0000000000000000000000000000000000000000000000000000000000ffffff) == bytes32(0),\n            \"Period start hash does not have work. Hint: wrong byte order?\");\n\n        relayGenesis = _genesisDigest;\n        bestKnownDigest = _genesisDigest;\n        lastReorgCommonAncestor = _genesisDigest;\n        blockHeight[_genesisDigest] = _height;\n        blockHeight[_periodStart] = _height.sub(_height % 2016);\n\n        currentEpochDiff = _genesisHeader.extractDifficulty();\n    }\n\n    /// @notice     Getter for currentEpochDiff\n    /// @dev        This is updated when a new heavist header has a new diff\n    /// @return     The difficulty of the bestKnownDigest\n    function getCurrentEpochDifficulty() external view returns (uint256) {\n        return currentEpochDiff;\n    }\n    /// @notice     Getter for prevEpochDiff\n    /// @dev        This is updated when a difficulty change is accepted\n    /// @return     The difficulty of the previous epoch\n    function getPrevEpochDifficulty() external view returns (uint256) {\n        return prevEpochDiff;\n    }\n\n    /// @notice     Getter for relayGenesis\n    /// @dev        This is an initialization parameter\n    /// @return     The hash of the first block of the relay\n    function getRelayGenesis() public view returns (bytes32) {\n        return relayGenesis;\n    }\n\n    /// @notice     Getter for bestKnownDigest\n    /// @dev        This updated only by calling markNewHeaviest\n    /// @return     The hash of the best marked chain tip\n    function getBestKnownDigest() public view returns (bytes32) {\n        return bestKnownDigest;\n    }\n\n    /// @notice     Getter for relayGenesis\n    /// @dev        This is updated only by calling markNewHeaviest\n    /// @return     The hash of the shared ancestor of the most recent fork\n    function getLastReorgCommonAncestor() public view returns (bytes32) {\n        return lastReorgCommonAncestor;\n    }\n\n    /// @notice         Finds the height of a header by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header, or error if unknown\n    function findHeight(bytes32 _digest) external view returns (uint256) {\n        return _findHeight(_digest);\n    }\n\n    /// @notice         Finds an ancestor for a block by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header, or error if unknown\n    function findAncestor(bytes32 _digest, uint256 _offset) external view returns (bytes32) {\n        return _findAncestor(_digest, _offset);\n    }\n\n    /// @notice             Checks if a digest is an ancestor of the current one\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\n    /// @param _ancestor    The prospective ancestor\n    /// @param _descendant  The descendant to check\n    /// @param _limit       The maximum number of blocks to check\n    /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\n    function isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) external view returns (bool) {\n        return _isAncestor(_ancestor, _descendant, _limit);\n    }\n\n    /// @notice             Adds headers to storage after validating\n    /// @dev                We check integrity and consistency of the header chain\n    /// @param  _anchor     The header immediately preceeding the new chain\n    /// @param  _headers    A tightly-packed list of 80-byte Bitcoin headers\n    /// @return             True if successfully written, error otherwise\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool) {\n        return _addHeaders(_anchor, _headers, false);\n    }\n\n    /// @notice                       Adds headers to storage, performs additional validation of retarget\n    /// @dev                          Checks the retarget, the heights, and the linkage\n    /// @param  _oldPeriodStartHeader The first header in the difficulty period being closed\n    /// @param  _oldPeriodEndHeader   The last header in the difficulty period being closed\n    /// @param  _headers              A tightly-packed list of 80-byte Bitcoin headers\n    /// @return                       True if successfully written, error otherwise\n    function addHeadersWithRetarget(\n        bytes calldata _oldPeriodStartHeader,\n        bytes calldata _oldPeriodEndHeader,\n        bytes calldata _headers\n    ) external returns (bool) {\n        return _addHeadersWithRetarget(_oldPeriodStartHeader, _oldPeriodEndHeader, _headers);\n    }\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _ancestor         The digest of the most recent common ancestor\n    /// @param  _currentBest      The 80-byte header referenced by bestKnownDigest\n    /// @param  _newBest          The 80-byte header to mark as the new best\n    /// @param  _limit            Limit the amount of traversal of the chain\n    /// @return                   True if successfully updates bestKnownDigest, error otherwise\n    function markNewHeaviest(\n        bytes32 _ancestor,\n        bytes calldata _currentBest,\n        bytes calldata _newBest,\n        uint256 _limit\n    ) external returns (bool) {\n        return _markNewHeaviest(_ancestor, _currentBest, _newBest, _limit);\n    }\n\n    /// @notice             Adds headers to storage after validating\n    /// @dev                We check integrity and consistency of the header chain\n    /// @param  _anchor     The header immediately preceeding the new chain\n    /// @param  _headers    A tightly-packed list of new 80-byte Bitcoin headers to record\n    /// @param  _internal   True if called internally from addHeadersWithRetarget, false otherwise\n    /// @return             True if successfully written, error otherwise\n    function _addHeaders(bytes memory _anchor, bytes memory _headers, bool _internal) internal returns (bool) {\n        uint256 _height;\n        bytes memory _header;\n        bytes32 _currentDigest;\n        bytes32 _previousDigest = _anchor.hash256();\n\n        uint256 _target = _headers.slice(0, 80).extractTarget();\n        uint256 _anchorHeight = _findHeight(_previousDigest);  /* NB: errors if unknown */\n\n        require(\n            _internal || _anchor.extractTarget() == _target,\n            \"Unexpected retarget on external call\");\n        require(_headers.length % 80 == 0, \"Header array length must be divisible by 80\");\n\n        /*\n        NB:\n        1. check that the header has sufficient work\n        2. check that headers are in a coherent chain (no retargets, hash links good)\n        3. Store the block connection\n        4. Store the height\n        */\n        for (uint256 i = 0; i < _headers.length / 80; i = i.add(1)) {\n            _header = _headers.slice(i.mul(80), 80);\n            _height = _anchorHeight.add(i + 1);\n            _currentDigest = _header.hash256();\n\n            /*\n            NB:\n            if the block is already authenticated, we don't need to a work check\n            Or write anything to state. This saves gas\n            */\n            if (previousBlock[_currentDigest] == bytes32(0)) {\n                require(\n                    abi.encodePacked(_currentDigest).reverseEndianness().bytesToUint() <= _target,\n                    \"Header work is insufficient\");\n                previousBlock[_currentDigest] = _previousDigest;\n                if (_height % HEIGHT_INTERVAL == 0) {\n                    /*\n                    NB: We store the height only every 4th header to save gas\n                    */\n                    blockHeight[_currentDigest] = _height;\n                }\n            }\n\n            /* NB: we do still need to make chain level checks tho */\n            require(_header.extractTarget() == _target, \"Target changed unexpectedly\");\n            require(_header.validateHeaderPrevHash(_previousDigest), \"Headers do not form a consistent chain\");\n\n            _previousDigest = _currentDigest;\n        }\n\n        emit Extension(\n            _anchor.hash256(),\n            _currentDigest);\n        return true;\n    }\n\n    /// @notice                       Adds headers to storage, performs additional validation of retarget\n    /// @dev                          Checks the retarget, the heights, and the linkage\n    /// @param  _oldPeriodStartHeader The first header in the difficulty period being closed\n    /// @param  _oldPeriodEndHeader   The last header in the difficulty period being closed\n    /// @param  _headers              A tightly-packed list of 80-byte Bitcoin headers\n    /// @return                       True if successfully written, error otherwise\n    function _addHeadersWithRetarget(\n        bytes memory _oldPeriodStartHeader,\n        bytes memory _oldPeriodEndHeader,\n        bytes memory _headers\n    ) internal returns (bool) {\n        /* NB: requires that both blocks are known */\n        uint256 _startHeight = _findHeight(_oldPeriodStartHeader.hash256());\n        uint256 _endHeight = _findHeight(_oldPeriodEndHeader.hash256());\n\n        /* NB: retargets should happen at 2016 block intervals */\n        require(\n            _endHeight % 2016 == 2015,\n            \"Must provide the last header of the closing difficulty period\");\n        require(\n            _endHeight == _startHeight.add(2015),\n            \"Must provide exactly 1 difficulty period\");\n        require(\n            _oldPeriodStartHeader.extractDifficulty() == _oldPeriodEndHeader.extractDifficulty(),\n            \"Period header difficulties do not match\");\n\n        /* NB: This comparison looks weird because header nBits encoding truncates targets */\n        bytes memory _newPeriodStart = _headers.slice(0, 80);\n        uint256 _actualTarget = _newPeriodStart.extractTarget();\n        uint256 _expectedTarget = BTCUtils.retargetAlgorithm(\n            _oldPeriodStartHeader.extractTarget(),\n            _oldPeriodStartHeader.extractTimestamp(),\n            _oldPeriodEndHeader.extractTimestamp()\n        );\n        require(\n            (_actualTarget & _expectedTarget) == _actualTarget,\n            \"Invalid retarget provided\");\n\n        // If the current known prevEpochDiff doesn't match, and this old period is near the chaintip/\n        // update the stored prevEpochDiff\n        // Don't update if this is a deep past epoch\n        uint256 _oldDiff = _oldPeriodStartHeader.extractDifficulty();\n        if (prevEpochDiff != _oldDiff && _endHeight > _findHeight(bestKnownDigest).sub(2016)) {\n            prevEpochDiff = _oldDiff;\n        }\n\n        // Pass all but the first through to be added\n        return _addHeaders(_oldPeriodEndHeader, _headers, true);\n    }\n\n    /// @notice         Finds the height of a header by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header\n    function _findHeight(bytes32 _digest) internal view returns (uint256) {\n        uint256 _height = 0;\n        bytes32 _current = _digest;\n        for (uint256 i = 0; i < HEIGHT_INTERVAL + 1; i = i.add(1)) {\n            _height = blockHeight[_current];\n            if (_height == 0) {\n                _current = previousBlock[_current];\n            } else {\n                return _height.add(i);\n            }\n        }\n        revert(\"Unknown block\");\n    }\n\n    /// @notice         Finds an ancestor for a block by its digest\n    /// @dev            Will fail if the header is unknown\n    /// @param _digest  The header digest to search for\n    /// @return         The height of the header, or error if unknown\n    function _findAncestor(bytes32 _digest, uint256 _offset) internal view returns (bytes32) {\n        bytes32 _current = _digest;\n        for (uint256 i = 0; i < _offset; i = i.add(1)) {\n            _current = previousBlock[_current];\n        }\n        require(_current != bytes32(0), \"Unknown ancestor\");\n        return _current;\n    }\n\n    /// @notice             Checks if a digest is an ancestor of the current one\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\n    /// @param _ancestor    The prospective ancestor\n    /// @param _descendant  The descendant to check\n    /// @param _limit       The maximum number of blocks to check\n    /// @return             true if ancestor is at most limit blocks lower than descendant, otherwise false\n    function _isAncestor(bytes32 _ancestor, bytes32 _descendant, uint256 _limit) internal view returns (bool) {\n        bytes32 _current = _descendant;\n        /* NB: 200 gas/read, so gas is capped at ~200 * limit */\n        for (uint256 i = 0; i < _limit; i = i.add(1)) {\n            if (_current == _ancestor) {\n                return true;\n            }\n            _current = previousBlock[_current];\n        }\n        return false;\n    }\n\n    /// @notice                   Marks the new best-known chain tip\n    /// @param  _ancestor         The digest of the most recent common ancestor\n    /// @param  _currentBest      The 80-byte header referenced by bestKnownDigest\n    /// @param  _newBest          The 80-byte header to mark as the new best\n    /// @param  _limit            Limit the amount of traversal of the chain\n    /// @return                   True if successfully updates bestKnownDigest, error otherwise\n    function _markNewHeaviest(\n        bytes32 _ancestor,\n        bytes memory _currentBest,\n        bytes memory _newBest,\n        uint256 _limit\n    ) internal returns (bool) {\n        require(_limit <= 2016, \"Requested limit is greater than 1 difficulty period\");\n        bytes32 _newBestDigest = _newBest.hash256();\n        bytes32 _currentBestDigest = _currentBest.hash256();\n        require(_currentBestDigest == bestKnownDigest, \"Passed in best is not best known\");\n        require(\n            previousBlock[_newBestDigest] != bytes32(0),\n            \"New best is unknown\");\n        require(\n            _isMostRecentAncestor(_ancestor, bestKnownDigest, _newBestDigest, _limit),\n            \"Ancestor must be heaviest common ancestor\");\n        require(\n            _heaviestFromAncestor(_ancestor, _currentBest, _newBest) == _newBestDigest,\n            \"New best hash does not have more work than previous\");\n\n        bestKnownDigest = _newBestDigest;\n        lastReorgCommonAncestor = _ancestor;\n\n        uint256 _newDiff = _newBest.extractDifficulty();\n        if (_newDiff != currentEpochDiff) {\n            currentEpochDiff = _newDiff;\n        }\n\n        emit NewTip(\n            _currentBestDigest,\n            _newBestDigest,\n            _ancestor);\n        return true;\n    }\n\n    /// @notice             Checks if a digest is an ancestor of the current one\n    /// @dev                Limit the amount of lookups (and thus gas usage) with _limit\n    /// @param _ancestor    The prospective shared ancestor\n    /// @param _left        A chain tip\n    /// @param _right       A chain tip\n    /// @param _limit       The maximum number of blocks to check\n    /// @return             true if it is the most recent common ancestor within _limit, false otherwise\n    function _isMostRecentAncestor(\n        bytes32 _ancestor,\n        bytes32 _left,\n        bytes32 _right,\n        uint256 _limit\n    ) internal view returns (bool) {\n        /* NB: sure why not */\n        if (_ancestor == _left && _ancestor == _right) {\n            return true;\n        }\n\n        bytes32 _leftCurrent = _left;\n        bytes32 _rightCurrent = _right;\n        bytes32 _leftPrev = _left;\n        bytes32 _rightPrev = _right;\n\n        for(uint256 i = 0; i < _limit; i = i.add(1)) {\n            if (_leftPrev != _ancestor) {\n                _leftCurrent = _leftPrev;  // cheap\n                _leftPrev = previousBlock[_leftPrev];  // expensive\n            }\n            if (_rightPrev != _ancestor) {\n                _rightCurrent = _rightPrev;  // cheap\n                _rightPrev = previousBlock[_rightPrev];  // expensive\n            }\n        }\n        if (_leftCurrent == _rightCurrent) {return false;} /* NB: If the same, they're a nearer ancestor */\n        if (_leftPrev != _rightPrev) {return false;} /* NB: Both must be ancestor */\n        return true;\n    }\n\n    /// @notice             Decides which header is heaviest from the ancestor\n    /// @dev                Does not support reorgs above 2017 blocks (:\n    /// @param _ancestor    The prospective shared ancestor\n    /// @param _left        A chain tip\n    /// @param _right       A chain tip\n    /// @return             true if it is the most recent common ancestor within _limit, false otherwise\n    function _heaviestFromAncestor(\n        bytes32 _ancestor,\n        bytes memory _left,\n        bytes memory _right\n    ) internal view returns (bytes32) {\n        uint256 _ancestorHeight = _findHeight(_ancestor);\n        uint256 _leftHeight = _findHeight(_left.hash256());\n        uint256 _rightHeight = _findHeight(_right.hash256());\n\n        require(\n            _leftHeight >= _ancestorHeight && _rightHeight >= _ancestorHeight,\n            \"A descendant height is below the ancestor height\");\n\n        /* NB: we can shortcut if one block is in a new difficulty window and the other isn't */\n        uint256 _nextPeriodStartHeight = _ancestorHeight.add(2016).sub(_ancestorHeight % 2016);\n        bool _leftInPeriod = _leftHeight < _nextPeriodStartHeight;\n        bool _rightInPeriod = _rightHeight < _nextPeriodStartHeight;\n\n        /*\n        NB:\n        1. Left is in a new window, right is in the old window. Left is heavier\n        2. Right is in a new window, left is in the old window. Right is heavier\n        3. Both are in the same window, choose the higher one\n        4. They're in different new windows. Choose the heavier one\n        */\n        if (!_leftInPeriod && _rightInPeriod) {return _left.hash256();}\n        if (_leftInPeriod && !_rightInPeriod) {return _right.hash256();}\n        if (_leftInPeriod && _rightInPeriod) {\n            return _leftHeight >= _rightHeight ? _left.hash256() : _right.hash256();\n        } else {  // if (!_leftInPeriod && !_rightInPeriod) {\n            if (((_leftHeight % 2016).mul(_left.extractDifficulty())) <\n                (_rightHeight % 2016).mul(_right.extractDifficulty())) {\n                return _right.hash256();\n            } else {\n                return _left.hash256();\n            }\n        }\n    }\n}\n\n// For unittests\ncontract TestRelay is Relay {\n\n    /// @notice                   Gives a starting point for the relay\n    /// @dev                      We don't check this AT ALL really. Don't use relays with bad genesis\n    /// @param  _genesisHeader    The starting header\n    /// @param  _height           The starting height\n    /// @param  _periodStart      The hash of the first header in the genesis epoch\n    constructor(bytes memory _genesisHeader, uint256 _height, bytes32 _periodStart)\n        Relay(_genesisHeader, _height, _periodStart)\n    public {}\n\n    function heaviestFromAncestor(\n        bytes32 _ancestor,\n        bytes calldata _left,\n        bytes calldata _right\n    ) external view returns (bytes32) {\n        return _heaviestFromAncestor(_ancestor, _left, _right);\n    }\n\n    function isMostRecentAncestor(\n        bytes32 _ancestor,\n        bytes32 _left,\n        bytes32 _right,\n        uint256 _limit\n    ) external view returns (bool) {\n        return _isMostRecentAncestor(_ancestor, _left, _right, _limit);\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/SafeMath.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        c = _a * _b;\n        require(c / _a == _b, \"Overflow during multiplication.\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"Underflow during subtraction.\");\n        return _a - _b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        c = _a + _b;\n        require(c >= _a, \"Overflow during addition.\");\n        return c;\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/*\n\nhttps://github.com/GNSPS/solidity-bytes-utils/\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <https://unlicense.org>\n*/\n\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                        ),\n                        // and now shift left the number of bytes to\n                        // leave space for the length in the slot\n                        exp(0x100, sub(32, newlength))\n                        ),\n                        // increase length by the double of the memory\n                        // bytes length\n                        mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                    ),\n                    and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\n        if (_length == 0) {\n            return hex\"\";\n        }\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        uint _totalLen = _start + 20;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Address conversion out of bounds.\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        uint _totalLen = _start + 32;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Uint conversion out of bounds.\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/BTCUtils.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title BitcoinSPV */\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\n\nlibrary BTCUtils {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    // The target at minimum Difficulty. Also the target of the genesis block\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\n\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\n\n    uint256 public constant ERR_BAD_ARG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /* ***** */\n    /* UTILS */\n    /* ***** */\n\n    /// @notice         Determines the length of a VarInt in bytes\n    /// @dev            A VarInt of >1 byte is prefixed with a flag indicating its length\n    /// @param _flag    The first byte of a VarInt\n    /// @return         The number of non-flag bytes in the VarInt\n    function determineVarIntDataLength(bytes memory _flag) internal pure returns (uint8) {\n        if (uint8(_flag[0]) == 0xff) {\n            return 8;  // one-byte flag, 8 bytes data\n        }\n        if (uint8(_flag[0]) == 0xfe) {\n            return 4;  // one-byte flag, 4 bytes data\n        }\n        if (uint8(_flag[0]) == 0xfd) {\n            return 2;  // one-byte flag, 2 bytes data\n        }\n\n        return 0;  // flag is data\n    }\n\n    /// @notice     Parse a VarInt into its data length and the number it represents\n    /// @dev        Useful for Parsing Vins and Vouts. Returns ERR_BAD_ARG if insufficient bytes.\n    ///             Caller SHOULD explicitly handle this case (or bubble it up)\n    /// @param _b   A byte-string starting with a VarInt\n    /// @return     number of bytes in the encoding (not counting the tag), the encoded int\n    function parseVarInt(bytes memory _b) internal pure returns (uint256, uint256) {\n        uint8 _dataLen = determineVarIntDataLength(_b);\n\n        if (_dataLen == 0) {\n            return (0, uint8(_b[0]));\n        }\n        if (_b.length < 1 + _dataLen) {\n            return (ERR_BAD_ARG, 0);\n        }\n        uint256 _number = bytesToUint(reverseEndianness(_b.slice(1, _dataLen)));\n        return (_dataLen, _number);\n    }\n\n    /// @notice          Changes the endianness of a byte array\n    /// @dev             Returns a new, backwards, bytes\n    /// @param _b        The bytes to reverse\n    /// @return          The reversed bytes\n    function reverseEndianness(bytes memory _b) internal pure returns (bytes memory) {\n        bytes memory _newValue = new bytes(_b.length);\n\n        for (uint i = 0; i < _b.length; i++) {\n            _newValue[_b.length - i - 1] = _b[i];\n        }\n\n        return _newValue;\n    }\n\n    /// @notice          Changes the endianness of a uint256\n    /// @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n    /// @param _b        The unsigned integer to reverse\n    /// @return          The reversed value\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        // swap 8-byte long pairs\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /// @notice          Converts big-endian bytes to a uint\n    /// @dev             Traverses the byte array and sums the bytes\n    /// @param _b        The big-endian bytes-encoded integer\n    /// @return          The integer representation\n    function bytesToUint(bytes memory _b) internal pure returns (uint256) {\n        uint256 _number;\n\n        for (uint i = 0; i < _b.length; i++) {\n            _number = _number + uint8(_b[i]) * (2 ** (8 * (_b.length - (i + 1))));\n        }\n\n        return _number;\n    }\n\n    /// @notice          Get the last _num bytes from a byte array\n    /// @param _b        The byte array to slice\n    /// @param _num      The number of bytes to extract from the end\n    /// @return          The last _num bytes of _b\n    function lastBytes(bytes memory _b, uint256 _num) internal pure returns (bytes memory) {\n        uint256 _start = _b.length.sub(_num);\n\n        return _b.slice(_start, _num);\n    }\n\n    /// @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash160(bytes memory _b) internal pure returns (bytes memory) {\n        return abi.encodePacked(ripemd160(abi.encodePacked(sha256(_b))));\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash256(bytes memory _b) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(sha256(_b)));\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash256View(bytes memory _b) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            pop(staticcall(gas, 2, add(_b, 32), mload(_b), ptr, 32))\n            pop(staticcall(gas, 2, ptr, 32, ptr, 32))\n            res := mload(ptr)\n        }\n    }\n\n    /* ************ */\n    /* Legacy Input */\n    /* ************ */\n\n    /// @notice          Extracts the nth input from the vin (0-indexed)\n    /// @dev             Iterates over the vin. If you need to extract several, write a custom function\n    /// @param _vin      The vin as a tightly-packed byte array\n    /// @param _index    The 0-indexed location of the input to extract\n    /// @return          The input as a byte array\n    function extractInputAtIndex(bytes memory _vin, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nIns, \"Vin read overrun\");\n\n        bytes memory _remaining;\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _remaining = _vin.slice(_offset, _vin.length - _offset);\n            _len = determineInputLength(_remaining);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n            _offset = _offset + _len;\n        }\n\n        _remaining = _vin.slice(_offset, _vin.length - _offset);\n        _len = determineInputLength(_remaining);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _vin.slice(_offset, _len);\n    }\n\n    /// @notice          Determines whether an input is legacy\n    /// @dev             False if no scriptSig, otherwise True\n    /// @param _input    The input\n    /// @return          True for legacy, False for witness\n    function isLegacyInput(bytes memory _input) internal pure returns (bool) {\n        return _input.keccak256Slice(36, 1) != keccak256(hex\"00\");\n    }\n\n    /// @notice          Determines the length of a scriptSig in an input\n    /// @dev             Will return 0 if passed a witness input.\n    /// @param _input    The LEGACY input\n    /// @return          The length of the script sig\n    function extractScriptSigLen(bytes memory _input) internal pure returns (uint256, uint256) {\n        if (_input.length < 37) {\n            return (ERR_BAD_ARG, 0);\n        }\n        bytes memory _afterOutpoint = _input.slice(36, _input.length - 36);\n\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = parseVarInt(_afterOutpoint);\n\n        return (_varIntDataLen, _scriptSigLen);\n    }\n\n    /// @notice          Determines the length of an input from its scriptSig\n    /// @dev             36 for outpoint, 1 for scriptSig length, 4 for sequence\n    /// @param _input    The input\n    /// @return          The length of the input in bytes\n    function determineInputLength(bytes memory _input) internal pure returns (uint256) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        return 36 + 1 + _varIntDataLen + _scriptSigLen + 4;\n    }\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The LEGACY input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLELegacy(bytes memory _input) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice(36 + 1 + _varIntDataLen + _scriptSigLen, 4);\n    }\n\n    /// @notice          Extracts the sequence from the input\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The LEGACY input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceLegacy(bytes memory _input) internal pure returns (uint32) {\n        bytes memory _leSeqence = extractSequenceLELegacy(_input);\n        bytes memory _beSequence = reverseEndianness(_leSeqence);\n        return uint32(bytesToUint(_beSequence));\n    }\n    /// @notice          Extracts the VarInt-prepended scriptSig from the input in a tx\n    /// @dev             Will return hex\"00\" if passed a witness input\n    /// @param _input    The LEGACY input\n    /// @return          The length-prepended scriptSig\n    function extractScriptSig(bytes memory _input) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice(36, 1 + _varIntDataLen + _scriptSigLen);\n    }\n\n\n    /* ************* */\n    /* Witness Input */\n    /* ************* */\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The WITNESS input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLEWitness(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(37, 4);\n    }\n\n    /// @notice          Extracts the sequence from the input in a tx\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The WITNESS input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceWitness(bytes memory _input) internal pure returns (uint32) {\n        bytes memory _leSeqence = extractSequenceLEWitness(_input);\n        bytes memory _inputeSequence = reverseEndianness(_leSeqence);\n        return uint32(bytesToUint(_inputeSequence));\n    }\n\n    /// @notice          Extracts the outpoint from the input in a tx\n    /// @dev             32-byte tx id with 4-byte index\n    /// @param _input    The input\n    /// @return          The outpoint (LE bytes of prev tx hash + LE bytes of prev tx index)\n    function extractOutpoint(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(0, 36);\n    }\n\n    /// @notice          Extracts the outpoint tx id from an input\n    /// @dev             32-byte tx id\n    /// @param _input    The input\n    /// @return          The tx id (little-endian bytes)\n    function extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\n        return _input.slice(0, 32).toBytes32();\n    }\n\n    /// @notice          Extracts the LE tx input index from the input in a tx\n    /// @dev             4-byte tx index\n    /// @param _input    The input\n    /// @return          The tx index (little-endian bytes)\n    function extractTxIndexLE(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(32, 4);\n    }\n\n    /* ****** */\n    /* Output */\n    /* ****** */\n\n    /// @notice          Determines the length of an output\n    /// @dev             Works with any properly formatted output\n    /// @param _output   The output\n    /// @return          The length indicated by the prefix, error if invalid length\n    function determineOutputLength(bytes memory _output) internal pure returns (uint256) {\n        if (_output.length < 9) {\n            return ERR_BAD_ARG;\n        }\n        bytes memory _afterValue = _output.slice(8, _output.length - 8);\n\n        uint256 _varIntDataLen;\n        uint256 _scriptPubkeyLength;\n        (_varIntDataLen, _scriptPubkeyLength) = parseVarInt(_afterValue);\n\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        // 8-byte value, 1-byte for tag itself\n        return 8 + 1 + _varIntDataLen + _scriptPubkeyLength;\n    }\n\n    /// @notice          Extracts the output at a given index in the TxOuts vector\n    /// @dev             Iterates over the vout. If you need to extract multiple, write a custom function\n    /// @param _vout     The _vout to extract from\n    /// @param _index    The 0-indexed location of the output to extract\n    /// @return          The specified output\n    function extractOutputAtIndex(bytes memory _vout, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nOuts, \"Vout read overrun\");\n\n        bytes memory _remaining;\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _remaining = _vout.slice(_offset, _vout.length - _offset);\n            _len = determineOutputLength(_remaining);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n            _offset += _len;\n        }\n\n        _remaining = _vout.slice(_offset, _vout.length - _offset);\n        _len = determineOutputLength(_remaining);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n        return _vout.slice(_offset, _len);\n    }\n\n    /// @notice          Extracts the value bytes from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value as LE bytes\n    function extractValueLE(bytes memory _output) internal pure returns (bytes memory) {\n        return _output.slice(0, 8);\n    }\n\n    /// @notice          Extracts the value from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value\n    function extractValue(bytes memory _output) internal pure returns (uint64) {\n        bytes memory _leValue = extractValueLE(_output);\n        bytes memory _beValue = reverseEndianness(_leValue);\n        return uint64(bytesToUint(_beValue));\n    }\n\n    /// @notice          Extracts the data from an op return output\n    /// @dev             Returns hex\"\" if no data or not an op return\n    /// @param _output   The output\n    /// @return          Any data contained in the opreturn output, null if not an op return\n    function extractOpReturnData(bytes memory _output) internal pure returns (bytes memory) {\n        if (_output.keccak256Slice(9, 1) != keccak256(hex\"6a\")) {\n            return hex\"\";\n        }\n        bytes memory _dataLen = _output.slice(10, 1);\n        return _output.slice(11, bytesToUint(_dataLen));\n    }\n\n    /// @notice          Extracts the hash from the output script\n    /// @dev             Determines type by the length prefix and validates format\n    /// @param _output   The output\n    /// @return          The hash committed to by the pk_script, or null for errors\n    function extractHash(bytes memory _output) internal pure returns (bytes memory) {\n        uint8 _scriptLen = uint8(_output[8]);\n\n        // don't have to worry about overflow here.\n        // if _scriptLen + 9 overflows, then output.length would have to be < 9\n        // for this check to pass. if it's < 9, then we errored when assigning\n        // _scriptLen\n        if (_scriptLen + 9 != _output.length) {\n            return hex\"\";\n        }\n\n        if (uint8(_output[9]) == 0) {\n            if (_scriptLen < 2) {\n                return hex\"\";\n            }\n            uint256 _payloadLen = uint8(_output[10]);\n            // Check for maliciously formatted witness outputs.\n            // No need to worry about underflow as long b/c of the `< 2` check\n            if (_payloadLen != _scriptLen - 2 || (_payloadLen != 0x20 && _payloadLen != 0x14)) {\n                return hex\"\";\n            }\n            return _output.slice(11, _payloadLen);\n        } else {\n            bytes32 _tag = _output.keccak256Slice(8, 3);\n            // p2pkh\n            if (_tag == keccak256(hex\"1976a9\")) {\n                // Check for maliciously formatted p2pkh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[11]) != 0x14 ||\n                    _output.keccak256Slice(_output.length - 2, 2) != keccak256(hex\"88ac\")) {\n                    return hex\"\";\n                }\n                return _output.slice(12, 20);\n            //p2sh\n            } else if (_tag == keccak256(hex\"17a914\")) {\n                // Check for maliciously formatted p2sh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[_output.length - 1]) != 0x87) {\n                    return hex\"\";\n                }\n                return _output.slice(11, 20);\n            }\n        }\n        return hex\"\";  /* NB: will trigger on OPRETURN and any non-standard that doesn't overrun */\n    }\n\n    /* ********** */\n    /* Witness TX */\n    /* ********** */\n\n\n    /// @notice      Checks that the vin passed up is properly formatted\n    /// @dev         Consider a vin with a valid vout in its scriptsig\n    /// @param _vin  Raw bytes length-prefixed input vector\n    /// @return      True if it represents a validly formatted vin\n    function validateVin(bytes memory _vin) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n\n        // Not valid if it says there are too many or no inputs\n        if (_nIns == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nIns; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vin.length) {\n                return false;\n            }\n\n            // Grab the next input and determine its length.\n            bytes memory _next = _vin.slice(_offset, _vin.length - _offset);\n            uint256 _nextLen = determineInputLength(_next);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            // Increase the offset by that much\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vin.length;\n    }\n\n    /// @notice      Checks that the vout passed up is properly formatted\n    /// @dev         Consider a vout with a valid scriptpubkey\n    /// @param _vout Raw bytes length-prefixed output vector\n    /// @return      True if it represents a validly formatted vout\n    function validateVout(bytes memory _vout) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n\n        // Not valid if it says there are too many or no outputs\n        if (_nOuts == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nOuts; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vout.length) {\n                return false;\n            }\n\n            // Grab the next output and determine its length.\n            // Increase the offset by that much\n            bytes memory _next = _vout.slice(_offset, _vout.length - _offset);\n            uint256 _nextLen = determineOutputLength(_next);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vout.length;\n    }\n\n\n\n    /* ************ */\n    /* Block Header */\n    /* ************ */\n\n    /// @notice          Extracts the transaction merkle root from a block header\n    /// @dev             Use verifyHash256Merkle to verify proofs with this root\n    /// @param _header   The header\n    /// @return          The merkle root (little-endian)\n    function extractMerkleRootLE(bytes memory _header) internal pure returns (bytes memory) {\n        return _header.slice(36, 32);\n    }\n\n    /// @notice          Extracts the target from a block header\n    /// @dev             Target is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _header   The header\n    /// @return          The target threshold\n    function extractTarget(bytes memory _header) internal pure returns (uint256) {\n        bytes memory _m = _header.slice(72, 3);\n        uint8 _e = uint8(_header[75]);\n        uint256 _mantissa = bytesToUint(reverseEndianness(_m));\n        uint _exponent = _e - 3;\n\n        return _mantissa * (256 ** _exponent);\n    }\n\n    /// @notice          Calculate difficulty from the difficulty 1 target and current target\n    /// @dev             Difficulty 1 is 0x1d00ffff on mainnet and testnet\n    /// @dev             Difficulty 1 is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _target   The current target\n    /// @return          The block difficulty (bdiff)\n    function calculateDifficulty(uint256 _target) internal pure returns (uint256) {\n        // Difficulty 1 calculated from 0x1d00ffff\n        return DIFF1_TARGET.div(_target);\n    }\n\n    /// @notice          Extracts the previous block's hash from a block header\n    /// @dev             Block headers do NOT include block number :(\n    /// @param _header   The header\n    /// @return          The previous block's hash (little-endian)\n    function extractPrevBlockLE(bytes memory _header) internal pure returns (bytes memory) {\n        return _header.slice(4, 32);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (little-endian bytes)\n    function extractTimestampLE(bytes memory _header) internal pure returns (bytes memory) {\n        return _header.slice(68, 4);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (uint)\n    function extractTimestamp(bytes memory _header) internal pure returns (uint32) {\n        return uint32(bytesToUint(reverseEndianness(extractTimestampLE(_header))));\n    }\n\n    /// @notice          Extracts the expected difficulty from a block header\n    /// @dev             Does NOT verify the work\n    /// @param _header   The header\n    /// @return          The difficulty as an integer\n    function extractDifficulty(bytes memory _header) internal pure returns (uint256) {\n        return calculateDifficulty(extractTarget(_header));\n    }\n\n    /// @notice          Concatenates and hashes two inputs for merkle proving\n    /// @param _a        The first hash\n    /// @param _b        The second hash\n    /// @return          The double-sha256 of the concatenated hashes\n    function _hash256MerkleStep(bytes memory _a, bytes memory _b) internal pure returns (bytes32) {\n        return hash256(abi.encodePacked(_a, _b));\n    }\n\n    /// @notice          Verifies a Bitcoin-style merkle tree\n    /// @dev             Leaves are 0-indexed.\n    /// @param _proof    The proof. Tightly packed LE sha256 hashes. The last hash is the root\n    /// @param _index    The index of the leaf\n    /// @return          true if the proof is valid, else false\n    function verifyHash256Merkle(bytes memory _proof, uint _index) internal pure returns (bool) {\n        // Not an even number of hashes\n        if (_proof.length % 32 != 0) {\n            return false;\n        }\n\n        // Special case for coinbase-only blocks\n        if (_proof.length == 32) {\n            return true;\n        }\n\n        // Should never occur\n        if (_proof.length == 64) {\n            return false;\n        }\n\n        uint _idx = _index;\n        bytes32 _root = _proof.slice(_proof.length - 32, 32).toBytes32();\n        bytes32 _current = _proof.slice(0, 32).toBytes32();\n\n        for (uint i = 1; i < (_proof.length.div(32)) - 1; i++) {\n            if (_idx % 2 == 1) {\n                _current = _hash256MerkleStep(_proof.slice(i * 32, 32), abi.encodePacked(_current));\n            } else {\n                _current = _hash256MerkleStep(abi.encodePacked(_current), _proof.slice(i * 32, 32));\n            }\n            _idx = _idx >> 1;\n        }\n        return _current == _root;\n    }\n\n    /*\n    NB: https://github.com/bitcoin/bitcoin/blob/78dae8caccd82cfbfd76557f1fb7d7557c7b5edb/src/pow.cpp#L49-L72\n    NB: We get a full-bitlength target from this. For comparison with\n        header-encoded targets we need to mask it with the header target\n        e.g. (full & truncated) == truncated\n    */\n    /// @notice                 performs the bitcoin difficulty retarget\n    /// @dev                    implements the Bitcoin algorithm precisely\n    /// @param _previousTarget  the target of the previous period\n    /// @param _firstTimestamp  the timestamp of the first block in the difficulty period\n    /// @param _secondTimestamp the timestamp of the last block in the difficulty period\n    /// @return                 the new period's target threshold\n    function retargetAlgorithm(\n        uint256 _previousTarget,\n        uint256 _firstTimestamp,\n        uint256 _secondTimestamp\n    ) internal pure returns (uint256) {\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\n\n        // Normalize ratio to factor of 4 if very long or very short\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\n            _elapsedTime = RETARGET_PERIOD.div(4);\n        }\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\n            _elapsedTime = RETARGET_PERIOD.mul(4);\n        }\n\n        /*\n          NB: high targets e.g. ffff0020 can cause overflows here\n              so we divide it by 256**2, then multiply by 256**2 later\n              we know the target is evenly divisible by 256**2, so this isn't an issue\n        */\n\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\n    }\n}\n"
    },
    "@summa-tx/bitcoin-spv-sol/contracts/ValidateSPV.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title ValidateSPV*/\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {BTCUtils} from \"./BTCUtils.sol\";\n\n\nlibrary ValidateSPV {\n\n    using BTCUtils for bytes;\n    using BTCUtils for uint256;\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    enum InputTypes { NONE, LEGACY, COMPATIBILITY, WITNESS }\n    enum OutputTypes { NONE, WPKH, WSH, OP_RETURN, PKH, SH, NONSTANDARD }\n\n    uint256 constant ERR_BAD_LENGTH = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 constant ERR_INVALID_CHAIN = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\n    uint256 constant ERR_LOW_WORK = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd;\n\n    function getErrBadLength() internal pure returns (uint256) {\n        return ERR_BAD_LENGTH;\n    }\n\n    function getErrInvalidChain() internal pure returns (uint256) {\n        return ERR_INVALID_CHAIN;\n    }\n\n    function getErrLowWork() internal pure returns (uint256) {\n        return ERR_LOW_WORK;\n    }\n\n    /// @notice                     Validates a tx inclusion in the block\n    /// @dev                        `index` is not a reliable indicator of location within a block\n    /// @param _txid                The txid (LE)\n    /// @param _merkleRoot          The merkle root (as in the block header)\n    /// @param _intermediateNodes   The proof's intermediate nodes (digests between leaf and root)\n    /// @param _index               The leaf's index in the tree (0-indexed)\n    /// @return                     true if fully valid, false otherwise\n    function prove(\n        bytes32 _txid,\n        bytes32 _merkleRoot,\n        bytes memory _intermediateNodes,\n        uint _index\n    ) internal pure returns (bool) {\n        // Shortcut the empty-block case\n        if (_txid == _merkleRoot && _index == 0 && _intermediateNodes.length == 0) {\n            return true;\n        }\n\n        bytes memory _proof = abi.encodePacked(_txid, _intermediateNodes, _merkleRoot);\n        // If the Merkle proof failed, bubble up error\n        return _proof.verifyHash256Merkle(_index);\n    }\n\n    /// @notice             Hashes transaction to get txid\n    /// @dev                Supports Legacy and Witness\n    /// @param _version     4-bytes version\n    /// @param _vin         Raw bytes length-prefixed input vector\n    /// @param _vout        Raw bytes length-prefixed output vector\n    /// @param _locktime   4-byte tx locktime\n    /// @return             32-byte transaction id, little endian\n    function calculateTxId(\n        bytes memory _version,\n        bytes memory _vin,\n        bytes memory _vout,\n        bytes memory _locktime\n    ) internal pure returns (bytes32) {\n        // Get transaction hash double-Sha256(version + nIns + inputs + nOuts + outputs + locktime)\n        return abi.encodePacked(_version, _vin, _vout, _locktime).hash256();\n    }\n\n    /// @notice             Checks validity of header chain\n    /// @notice             Compares the hash of each header to the prevHash in the next header\n    /// @param _headers     Raw byte array of header chain\n    /// @return             The total accumulated difficulty of the header chain, or an error code\n    function validateHeaderChain(bytes memory _headers) internal view returns (uint256 _totalDifficulty) {\n\n        // Check header chain length\n        if (_headers.length % 80 != 0) {return ERR_BAD_LENGTH;}\n\n        // Initialize header start index\n        bytes32 _digest;\n\n        _totalDifficulty = 0;\n\n        for (uint256 _start = 0; _start < _headers.length; _start += 80) {\n\n            // ith header start index and ith header\n            bytes memory _header = _headers.slice(_start, 80);\n\n            // After the first header, check that headers are in a chain\n            if (_start != 0) {\n                if (!validateHeaderPrevHash(_header, _digest)) {return ERR_INVALID_CHAIN;}\n            }\n\n            // ith header target\n            uint256 _target = _header.extractTarget();\n\n            // Require that the header has sufficient work\n            _digest = _header.hash256View();\n            if(uint256(_digest).reverseUint256() > _target) {\n                return ERR_LOW_WORK;\n            }\n\n            // Add ith header difficulty to difficulty sum\n            _totalDifficulty = _totalDifficulty.add(_target.calculateDifficulty());\n        }\n    }\n\n    /// @notice             Checks validity of header work\n    /// @param _digest      Header digest\n    /// @param _target      The target threshold\n    /// @return             true if header work is valid, false otherwise\n    function validateHeaderWork(bytes32 _digest, uint256 _target) internal pure returns (bool) {\n        if (_digest == bytes32(0)) {return false;}\n        return (abi.encodePacked(_digest).reverseEndianness().bytesToUint() < _target);\n    }\n\n    /// @notice                     Checks validity of header chain\n    /// @dev                        Compares current header prevHash to previous header's digest\n    /// @param _header              The raw bytes header\n    /// @param _prevHeaderDigest    The previous header's digest\n    /// @return                     true if the connect is valid, false otherwise\n    function validateHeaderPrevHash(bytes memory _header, bytes32 _prevHeaderDigest) internal pure returns (bool) {\n\n        // Extract prevHash of current header\n        bytes32 _prevHash = _header.extractPrevBlockLE().toBytes32();\n\n        // Compare prevHash of current header to previous header's digest\n        if (_prevHash != _prevHeaderDigest) {return false;}\n\n        return true;\n    }\n}\n"
    },
    "solidity/contracts/test/DummyOnDemandSPV.sol": {
      "content": "pragma solidity ^0.5.10;\n\n/** @title OnDemandSPV */\n/** @author Summa (https://summa.one) */\n\nimport {ISPVConsumer} from \"../Interfaces.sol\";\nimport {OnDemandSPV} from \"../OnDemandSPV.sol\";\n\ncontract DummyConsumer is ISPVConsumer {\n    event Consumed(bytes32 indexed _txid, uint256 indexed _requestID, uint256 _gasLeft);\n\n    bool broken = false;\n\n    function setBroken(bool _b) external {\n        broken = _b;\n    }\n\n    function spv(\n        bytes32 _txid,\n        bytes calldata,\n        bytes calldata,\n        uint256 _requestID,\n        uint8,\n        uint8\n    ) external {\n        emit Consumed(_txid, _requestID, gasleft());\n        if (broken) {\n            revert(\"BORKED\");\n        }\n    }\n\n    function cancel(\n        uint256 _requestID,\n        address payable _odspv\n    ) external returns (bool) {\n        return OnDemandSPV(_odspv).cancelRequest(_requestID);\n    }\n}\n\ncontract DummyOnDemandSPV is OnDemandSPV {\n\n    constructor(\n        bytes memory _genesisHeader,\n        uint256 _height,\n        bytes32 _periodStart,\n        uint256 _firstID\n    ) OnDemandSPV(\n        _genesisHeader,\n        _height,\n        _periodStart,\n        _firstID\n    ) public {return ;}\n\n    bool callResult = false;\n\n    function requestTest(\n        uint256 _requestID,\n        bytes calldata _spends,\n        bytes calldata _pays,\n        uint64 _paysValue,\n        address _consumer,\n        uint8 _numConfs,\n        uint256 _notBefore\n    ) external returns (uint256) {\n        nextID = _requestID;\n        return _request(_spends, _pays, _paysValue, _consumer, _numConfs, _notBefore);\n    }\n\n    function setCallResult(bool _r) external {\n        callResult = _r;\n    }\n\n    function _isAncestor(bytes32, bytes32, uint256) internal view returns (bool) {\n        return callResult;\n    }\n\n    function getValidatedTx(bytes32 _txid) public view returns (bool) {\n        return validatedTxns[_txid];\n    }\n\n    function setValidatedTx(bytes32 _txid) public {\n        validatedTxns[_txid] = true;\n    }\n\n    function unsetValidatedTx(bytes32 _txid) public {\n        validatedTxns[_txid] = false;\n    }\n\n    function callCallback(\n        bytes32 _txid,\n        uint16 _reqIndices,\n        bytes calldata _vin,\n        bytes calldata _vout,\n        uint256 _requestID\n    ) external returns (bool) {\n        return _callCallback(_txid, _reqIndices, _vin, _vout, _requestID);\n    }\n\n    function checkInclusion(\n        bytes calldata _header,\n        bytes calldata _proof,\n        uint256 _index,\n        bytes32 _txid,\n        uint256 _requestID\n    ) external view returns (bool) {\n        return _checkInclusion(_header, _proof, _index, _txid, _requestID);\n    }\n\n    function _getConfs(bytes32 _header) internal view returns (uint8){\n        if (_header == bytes32(0)) {\n            return OnDemandSPV._getConfs(lastReorgCommonAncestor);\n        }\n        return 8;\n    }\n\n    function getConfsTest() external view returns (uint8) {\n        return _getConfs(bytes32(0));\n    }\n\n    function checkRequests(\n        uint16 _requestIndices,\n        bytes calldata _vin,\n        bytes calldata _vout,\n        uint256 _requestID\n    ) external view returns (bool) {\n        return _checkRequests(_requestIndices, _vin, _vout, _requestID);\n    }\n\n    function whatTimeIsItRightNowDotCom() external view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}