{"ERC20Interface.sol":{"content":"pragma solidity \u003e0.5.99 \u003c0.8.0;\n\nabstract contract  ERC20Interface {\n    function totalSupply() virtual public view returns (uint);\n    function balanceOf(address tokenOwner) virtual public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) virtual public view returns (uint remaining);\n    function transfer(address to, uint tokens) virtual public returns (bool success);\n    function approve(address spender, uint tokens) virtual public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) virtual public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n"},"Owner.sol":{"content":"pragma solidity \u003e0.5.99 \u003c0.8.0;\n\n    contract Owner\n    {\n        address private _owner;\n        mapping(address=\u003e bool) blacklist;\n        event AddToBlackList(address _blacklisted);\n        event RemoveFromBlackList(address _whitelisted);\n        constructor() public \n        {\n            _owner = msg.sender;\n        }\n        \n        function getOwner() public view returns(address) { return _owner; }\n        \n        modifier isOwner()\n        {\n            require(msg.sender == _owner,\u0027Your are not Authorized user\u0027);\n            _;\n            \n        }\n        \n        modifier isblacklisted(address holder)\n        {\n            require(blacklist[holder] == false,\"You are blacklisted\");\n            _;\n        }\n        \n        function chnageOwner(address newOwner) isOwner() external\n        {\n            _owner = newOwner;\n        }\n        \n        function addtoblacklist (address blacklistaddress) isOwner()  public\n        {\n            blacklist[blacklistaddress] = true;\n            emit AddToBlackList(blacklistaddress);\n        }\n        \n        function removefromblacklist (address whitelistaddress) isOwner()  public\n        {\n            blacklist[whitelistaddress]=false;\n            emit RemoveFromBlackList(whitelistaddress);\n        }\n        \n        function showstateofuser(address _address) public view returns (bool)\n        {\n            return blacklist[_address];\n        }\n    }\n"},"SafeMath.sol":{"content":"pragma solidity \u003e0.5.99 \u003c0.8.0;\n\ncontract SafeMath {\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c \u003e= a);\n    }\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\n        require(b \u003c= a);\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\n        require(b \u003e 0);\n        c = a / b;\n    }\n}\n"},"Tanga.sol":{"content":"pragma solidity \u003e0.5.99 \u003c0.8.0;\n\nimport \"./Owner.sol\";\nimport \"./SafeMath.sol\";\nimport \"./ERC20Interface.sol\";\n\ncontract Tanga is ERC20Interface,SafeMath,Owner\n{\n    string private Token;\n    string private Abbrivation;\n    uint256 private decimals;\n    uint256 private totalsupply;\n    \n    \n    mapping(address =\u003e uint256) Balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) allowed;\n    \n    constructor() public\n    {\n        Token = \"Tanga\";\n        Abbrivation = \"TGA\";\n        decimals = 2;\n        totalsupply = 23000000000;\n        Balances[getOwner()] = 23000000000;\n    }\n    \n    \n    function totalSupply() public view override returns (uint256)\n    {\n        return totalsupply;\n    }\n    \n    function balanceOf(address tokenOwner) public override view returns (uint balance)\n    {\n        return Balances[tokenOwner];\n    }\n    \n    function allowance(address from, address who) isblacklisted(from) public override view returns (uint remaining)\n    {\n        return allowed[from][who];\n    }\n    \n    function transfer(address to, uint tokens) isblacklisted(msg.sender) public override returns (bool success)\n    {\n        Balances[msg.sender] = safeSub(Balances[msg.sender],tokens);\n        Balances[to] = safeAdd(Balances[to],tokens);\n       emit Transfer(msg.sender,to,tokens);\n        return true;\n    }\n    \n    function approve(address to, uint tokens) isblacklisted(msg.sender) public override returns (bool success)\n    {\n        allowed[msg.sender][to] = tokens;\n        emit Approval(msg.sender,to,tokens);\n        return true;\n    }\n    function transferFrom(address from, address to, uint tokens) isblacklisted(from) public override returns (bool success)\n    {\n        require(allowed[from][msg.sender] \u003e= tokens ,\"Not sufficient allowance\");\n        Balances[from] = safeSub(Balances[from],tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender],tokens);\n        Balances[to] = safeAdd(Balances[to],tokens);\n        emit Transfer(from,to,tokens);\n        return true;\n    }\n}\n\n\n\n"}}