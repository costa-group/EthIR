{"sbGovernor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \u0027./sbVotesInterface.sol\u0027;\nimport \u0027./sbTimelockInterface.sol\u0027;\n\ncontract sbGovernor {\n  // The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n  function quorumVotes() public pure returns (uint256) {\n    return 400000e18;\n  } // 400,000 = 4% of STRONG\n\n  // The number of votes required in order for a voter to become a proposer\n  function proposalThreshold() public pure returns (uint256) {\n    return 100000e18;\n  } // 100,000 = 1% of STRONG\n\n  // The maximum number of actions that can be included in a proposal\n  function proposalMaxOperations() public pure returns (uint256) {\n    return 10;\n  } // 10 actions\n\n  // The delay before voting on a proposal may take place, once proposed\n  function votingDelay() public pure returns (uint256) {\n    return 1;\n  } // 1 block\n\n  // The duration of voting on a proposal, in blocks\n  function votingPeriod() public pure returns (uint256) {\n    return 17280;\n  } // ~3 days in blocks (assuming 15s blocks)\n\n  // The address of the StrongBlock Protocol Timelock\n  sbTimelockInterface public sbTimelock;\n\n  // The address of the sbVotes contract\n  sbVotesInterface public sbVotes;\n\n  // The address of the Governor Guardian\n  address public guardian;\n\n  // The total number of proposals\n  uint256 public proposalCount;\n\n  struct Proposal {\n    // Unique id for looking up a proposal\n    uint256 id;\n    // Creator of the proposal\n    address proposer;\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    // the ordered list of target addresses for calls to be made\n    address[] targets;\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    // The ordered list of function signatures to be called\n    string[] signatures;\n    // The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    // The block at which voting begins: holders must delegate their votes prior to this block\n    uint256 startBlock;\n    // The block at which voting ends: votes must be cast prior to this block\n    uint256 endBlock;\n    // Current number of votes in favor of this proposal\n    uint256 forVotes;\n    // Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    // Flag marking whether the proposal has been canceled\n    bool canceled;\n    // Flag marking whether the proposal has been executed\n    bool executed;\n    // Receipts of ballots for the entire set of voters\n    mapping(address =\u003e Receipt) receipts;\n  }\n\n  // Ballot receipt record for a voter\n  struct Receipt {\n    // Whether or not a vote has been cast\n    bool hasVoted;\n    // Whether or not the voter supports the proposal\n    bool support;\n    // The number of votes the voter had, which were cast\n    uint96 votes;\n  }\n\n  // Possible states that a proposal may be in\n  enum ProposalState { Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\n\n  // The official record of all proposals ever proposed\n  mapping(uint256 =\u003e Proposal) public proposals;\n\n  // The latest proposal for each proposer\n  mapping(address =\u003e uint256) public latestProposalIds;\n\n  // An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startBlock,\n    uint256 endBlock,\n    string description\n  );\n\n  // An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n  // An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint256 id);\n\n  // An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  // An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint256 id);\n\n  constructor(\n    address sbTimelockAddress,\n    address sbVotesAddress,\n    address guardian_\n  ) public {\n    sbTimelock = sbTimelockInterface(sbTimelockAddress);\n    sbVotes = sbVotesInterface(sbVotesAddress);\n    guardian = guardian_;\n  }\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description\n  ) public returns (uint256) {\n    require(\n      sbVotes.getPriorProposalVotes(msg.sender, sub256(block.number, 1)) \u003e proposalThreshold(),\n      \u0027sbGovernor::propose: proposer votes below proposal threshold\u0027\n    );\n    require(\n      targets.length == values.length \u0026\u0026 targets.length == signatures.length \u0026\u0026 targets.length == calldatas.length,\n      \u0027sbGovernor::propose: proposal function information arity mismatch\u0027\n    );\n    require(targets.length != 0, \u0027sbGovernor::propose: must provide actions\u0027);\n    require(targets.length \u003c= proposalMaxOperations(), \u0027sbGovernor::propose: too many actions\u0027);\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \u0027sbGovernor::propose: one live proposal per proposer, found an already active proposal\u0027\n      );\n      require(\n        proposersLatestProposalState != ProposalState.Pending,\n        \u0027sbGovernor::propose: one live proposal per proposer, found an already pending proposal\u0027\n      );\n    }\n\n    uint256 startBlock = add256(block.number, votingDelay());\n    uint256 endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startBlock: startBlock,\n      endBlock: endBlock,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      startBlock,\n      endBlock,\n      description\n    );\n    return newProposal.id;\n  }\n\n  function queue(uint256 proposalId) public {\n    require(\n      state(proposalId) == ProposalState.Succeeded,\n      \u0027sbGovernor::queue: proposal can only be queued if it is succeeded\u0027\n    );\n    Proposal storage proposal = proposals[proposalId];\n    uint256 eta = add256(block.timestamp, sbTimelock.delay());\n    for (uint256 i = 0; i \u003c proposal.targets.length; i++) {\n      _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n    }\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n  }\n\n  function _queueOrRevert(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) internal {\n    require(\n      !sbTimelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))),\n      \u0027sbGovernor::_queueOrRevert: proposal action already queued at eta\u0027\n    );\n    sbTimelock.queueTransaction(target, value, signature, data, eta);\n  }\n\n  function execute(uint256 proposalId) public payable {\n    require(\n      state(proposalId) == ProposalState.Queued,\n      \u0027sbGovernor::execute: proposal can only be executed if it is queued\u0027\n    );\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint256 i = 0; i \u003c proposal.targets.length; i++) {\n      sbTimelock.executeTransaction{ value: proposal.values[i] }(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n    emit ProposalExecuted(proposalId);\n  }\n\n  function cancel(uint256 proposalId) public {\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \u0027sbGovernor::cancel: cannot cancel executed proposal\u0027);\n\n    Proposal storage proposal = proposals[proposalId];\n    require(\n      msg.sender == guardian ||\n        sbVotes.getPriorProposalVotes(proposal.proposer, sub256(block.number, 1)) \u003c proposalThreshold(),\n      \u0027sbGovernor::cancel: proposer above threshold\u0027\n    );\n\n    proposal.canceled = true;\n    for (uint256 i = 0; i \u003c proposal.targets.length; i++) {\n      sbTimelock.cancelTransaction(\n        proposal.targets[i],\n        proposal.values[i],\n        proposal.signatures[i],\n        proposal.calldatas[i],\n        proposal.eta\n      );\n    }\n\n    emit ProposalCanceled(proposalId);\n  }\n\n  function getActions(uint256 proposalId)\n    public\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    )\n  {\n    Proposal storage p = proposals[proposalId];\n    return (p.targets, p.values, p.signatures, p.calldatas);\n  }\n\n  function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n    return proposals[proposalId].receipts[voter];\n  }\n\n  function state(uint256 proposalId) public view returns (ProposalState) {\n    require(proposalCount \u003e= proposalId \u0026\u0026 proposalId \u003e 0, \u0027sbGovernor::state: invalid proposal id\u0027);\n    Proposal storage proposal = proposals[proposalId];\n    if (proposal.canceled) {\n      return ProposalState.Canceled;\n    } else if (block.number \u003c= proposal.startBlock) {\n      return ProposalState.Pending;\n    } else if (block.number \u003c= proposal.endBlock) {\n      return ProposalState.Active;\n    } else if (proposal.forVotes \u003c= proposal.againstVotes || proposal.forVotes \u003c quorumVotes()) {\n      return ProposalState.Defeated;\n    } else if (proposal.eta == 0) {\n      return ProposalState.Succeeded;\n    } else if (proposal.executed) {\n      return ProposalState.Executed;\n    } else if (block.timestamp \u003e= add256(proposal.eta, sbTimelock.GRACE_PERIOD())) {\n      return ProposalState.Expired;\n    } else {\n      return ProposalState.Queued;\n    }\n  }\n\n  function castVote(uint256 proposalId, bool support) public {\n    return _castVote(msg.sender, proposalId, support);\n  }\n\n  function _castVote(\n    address voter,\n    uint256 proposalId,\n    bool support\n  ) internal {\n    require(state(proposalId) == ProposalState.Active, \u0027sbGovernor::_castVote: voting is closed\u0027);\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(receipt.hasVoted == false, \u0027sbGovernor::_castVote: voter already voted\u0027);\n    uint96 votes = sbVotes.getPriorProposalVotes(voter, proposal.startBlock);\n\n    if (support) {\n      proposal.forVotes = add256(proposal.forVotes, votes);\n    } else {\n      proposal.againstVotes = add256(proposal.againstVotes, votes);\n    }\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n  }\n\n  function __acceptAdmin() public {\n    require(msg.sender == guardian, \u0027sbGovernor::__acceptAdmin: sender must be gov guardian\u0027);\n    sbTimelock.acceptAdmin();\n  }\n\n  function __abdicate() public {\n    require(msg.sender == guardian, \u0027sbGovernor::__abdicate: sender must be gov guardian\u0027);\n    guardian = address(0);\n  }\n\n  function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \u0027sbGovernor::__queueSetTimelockPendingAdmin: sender must be gov guardian\u0027);\n    sbTimelock.queueTransaction(address(sbTimelock), 0, \u0027setPendingAdmin(address)\u0027, abi.encode(newPendingAdmin), eta);\n  }\n\n  function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n    require(msg.sender == guardian, \u0027sbGovernor::__executeSetTimelockPendingAdmin: sender must be gov guardian\u0027);\n    sbTimelock.executeTransaction(address(sbTimelock), 0, \u0027setPendingAdmin(address)\u0027, abi.encode(newPendingAdmin), eta);\n  }\n\n  function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \u0027addition overflow\u0027);\n    return c;\n  }\n\n  function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003c= a, \u0027subtraction underflow\u0027);\n    return a - b;\n  }\n}\n"},"sbTimelockInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbTimelockInterface {\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function acceptAdmin() external;\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n}\n"},"sbVotesInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbVotesInterface {\n  function getCommunityData(address community, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n  function receiveServiceRewards(uint256 day, uint256 amount) external;\n\n  function receiveVoterRewards(uint256 day, uint256 amount) external;\n\n  function updateVotes(\n    address staker,\n    uint256 rawAmount,\n    bool adding\n  ) external;\n}\n"}}