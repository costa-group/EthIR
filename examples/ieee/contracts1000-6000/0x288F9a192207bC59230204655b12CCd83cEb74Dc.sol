{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n\nlibrary Address {\n  function isContract(\n    address account\n  ) internal view returns (bool) {\n    uint256 size;\n    assembly { size := extcodesize(account) }\n    return size \u003e 0;\n  }\n\n  function sendValue(\n    address payable recipient,\n    uint256 amount\n  ) internal {\n    require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{ value: amount }(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data\n  ) internal returns (bytes memory) {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return _functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n    return _functionCallWithValue(target, data, value, errorMessage);\n  }\n\n  function _functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 weiValue,\n    string memory errorMessage\n  ) private returns (bytes memory) {\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n    if (success) {\n      return returndata;\n    } else {\n      if (returndata.length \u003e 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}"},"Burneable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/// @title Burneable\n///\n/// @notice This contract covers everything related\n/// to the burn functions\n///\ncontract Burneable {\n  /// @dev Declare a private bool {_burningEnabled}\n  ///\n  bool private _burningEnabled;\n\n  /// @dev Declare a public constant of type bytes32\n  ///\n  /// @return The bytes32 string of the role\n  ///\n  bytes32 public constant ROLE_BURNER = keccak256(\"BURNER\");\n\n  /// @dev Declare two events to expose when burning\n  /// is enabled or disabled, take the event\u0027s sender\n  /// as argument\n  ///\n  event BurningEnabled(address indexed _from);\n  event BurningDisabled(address indexed _from);\n\n  /// @dev Verify if the sender can burn, if yes,\n  /// enable burning\n  /// \n  /// Requirements:\n  /// {_hasRole} should be true\n  /// {_amount} should be superior to 0\n  /// {_burningEnabled} should be true\n  ///\n  modifier isBurneable(\n    uint256 _amount,\n    bool _hasRole\n  ) {\n    require(\n      _hasRole,\n      \"BC:500\"\n    );\n\n    require(\n      _amount \u003e 0,\n      \"BC:30\"\n    );\n\n    _enableBurning();\n\n    require(\n      burningEnabled(),\n      \"BC:210\"\n    );\n    _;\n  }\n\n  /// @dev By default, burning is disabled\n  ///\n  constructor()\n  internal {\n    _burningEnabled = false;\n  }\n\n  /// @notice Expose the state of {_burningEnabled}\n  ///\n  /// @return The state as a bool\n  ///\n  function burningEnabled()\n  public view returns (bool) {\n    return _burningEnabled;\n  }\n\n  /// @dev Enable burning by setting {_burningEnabled}\n  /// to true, then emit the related event\n  ///\n  function _enableBurning()\n  internal virtual {\n    _burningEnabled = true;\n    emit BurningEnabled(msg.sender);\n  }\n\n  /// @dev Disable burning by setting {_burningEnabled}\n  /// to false, then emit the related event\n  ///\n  function _disableBurning()\n  internal virtual {\n    _burningEnabled = false;\n    emit BurningDisabled(msg.sender);\n  }\n}\n"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\n\nlibrary EnumerableSet {\n  struct Set {\n    bytes32[] _values;\n    mapping (bytes32 =\u003e uint256) _indexes;\n  }\n\n  function _add(\n    Set storage set,\n    bytes32 value\n  ) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function _remove(\n    Set storage set,\n    bytes32 value\n  ) private returns (bool) {\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n      bytes32 lastvalue = set._values[lastIndex];\n      set._values[toDeleteIndex] = lastvalue;\n      set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n      set._values.pop();\n      delete set._indexes[value];\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function _contains(\n    Set storage set,\n    bytes32 value\n  ) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  function _length(\n    Set storage set\n  ) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  function _at(\n    Set storage set,\n    uint256 index\n  ) private view returns (bytes32) {\n    require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\n    return set._values[index];\n  }\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  function add(\n    AddressSet storage set,\n    address value\n  ) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(value)));\n  }\n\n  function remove(\n    AddressSet storage set,\n    address value\n  ) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(value)));\n  }\n\n  function contains(\n    AddressSet storage set,\n    address value\n  ) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(value)));\n  }\n\n  function length(\n    AddressSet storage set\n  ) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  function at(\n    AddressSet storage set,\n    uint256 index\n  ) internal view returns (address) {\n    return address(uint256(_at(set._inner, index)));\n  }\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  function add(\n    UintSet storage set,\n    uint256 value\n  ) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  function remove(\n    UintSet storage set,\n    uint256 value\n  ) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  function contains(\n    UintSet storage set,\n    uint256 value\n  ) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  function length(\n    UintSet storage set\n  ) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  function at(\n    UintSet storage set,\n    uint256 index\n  ) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"./SafeMath.sol\";\nimport \"./Address.sol\";\n\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\n\nabstract contract ERC20 is IERC20 {\n  using SafeMath for uint256;\n  using Address for address;\n\n  mapping (address =\u003e uint256) private _balances;\n\n  mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\n\n  uint256 private _initialSupply;\n  uint256 private _totalSupply;\n  uint256 private _totalSupplyCap;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor (\n    string memory name,\n    string memory symbol,\n    uint256 totalSupplyCap,\n    uint256 initialSupply\n  ) public {\n    _decimals = 8;\n\n    _name = name;\n    _symbol = symbol;\n    _totalSupplyCap = totalSupplyCap;\n    _initialSupply = initialSupply;\n  }\n\n  function name()\n  public view returns (string memory) {\n    return _name;\n  }\n\n  function symbol()\n  public view returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals()\n  public view returns (uint8) {\n    return _decimals;\n  }\n\n  function initialSupply()\n  public view override returns (uint256) {\n    return _initialSupply;\n  }\n\n  function totalSupply()\n  public view override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function totalSupplyCap()\n  public view override returns (uint256) {\n    return _totalSupplyCap;\n  }\n\n  function balanceOf(\n    address account\n  ) public view override returns (uint256) {\n    return _balances[account];\n  }\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _approve(msg.sender, spender, (amount * (10**8)));\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub((amount * (10**8)), \"ERC20:490\"));\n    return true;\n  }\n\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  ) public virtual returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add((addedValue * (10**8))));\n    return true;\n  }\n\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub((subtractedValue * (10**8)), \"ERC20:495\"));\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(\n      sender != address(0),\n      \"ERC20:410\"\n    );\n\n    require(\n      recipient != address(0),\n      \"ERC20:420\"\n    );\n\n    require(\n      amount \u003e 0,\n      \"ERC20:480\"\n    );\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20:470\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(\n    address account,\n    uint256 amount\n  ) internal virtual {\n    require(\n      account != address(0),\n      \"ERC20:120\"\n    );\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(\n    address account,\n    uint256 amount\n  ) internal virtual {\n    require(\n      account != address(0),\n      \"ERC20:220\"\n    );\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(amount, \"ERC20:230\");\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(\n      owner != address(0),\n      \"ERC20:450\"\n    );\n    require(\n      spender != address(0),\n      \"ERC20:460\"\n    );\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setupDecimals(\n    uint8 decimals_\n  ) internal {\n    _decimals = decimals_;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n\ninterface IERC20 {\n  function initialSupply()\n  external view returns (uint256);\n\n  function totalSupply()\n  external view returns (uint256);\n\n  function totalSupplyCap()\n  external view returns (uint256);\n\n  function balanceOf(\n    address account\n  ) external view returns (uint256);\n\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  function approve(\n    address spender,\n    uint256 amount\n  ) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}"},"Minteable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/// @title Minteable\n///\n/// @notice This contract covers everything related\n/// to the mint functions\n///\ncontract Minteable {\n  /// @dev Declare a private bool {_mintingEnabled}\n  ///\n  bool private _mintingEnabled;\n\n  /// @dev Declare a public constant of type bytes32\n  ///\n  /// @return The bytes32 string of the role\n  ///\n  bytes32 public constant ROLE_MINTER = keccak256(\"MINTER\");\n\n  /// @dev Declare two events to expose when minting\n  /// is enabled or disabled, take the event\u0027s sender\n  /// as argument\n  ///\n  event MintingEnabled(address indexed _from);\n  event MintingDisabled(address indexed _from);\n\n  /// @dev Verify if the sender can mint, if yes,\n  /// enable minting\n  /// \n  /// Requirements:\n  /// {_hasRole} should be true\n  /// {_amount} should be superior to 0\n  /// {_mintingEnabled} should be true\n  ///\n  modifier isMinteable(\n    uint256 _amount,\n    bool _hasRole\n  ) {\n    require(\n      _hasRole,\n      \"MC:500\"\n    );\n\n    require(\n      _amount \u003e 0,\n      \"MC:30\"\n    );\n\n    _enableMinting();\n\n    require(\n      mintingEnabled(),\n      \"MC:110\"\n    );\n    _;\n  }\n\n  /// @dev By default, minting is disabled\n  ///\n  constructor()\n  internal {\n    _mintingEnabled = false;\n  }\n\n  /// @notice Expose the state of {_mintingEnabled}\n  ///\n  /// @return The state as a bool\n  ///\n  function mintingEnabled()\n  public view returns (bool) {\n    return _mintingEnabled;\n  }\n\n  /// @dev Enable minting by setting {_mintingEnabled}\n  /// to true, then emit the related event\n  ///\n  function _enableMinting()\n  internal virtual {\n    _mintingEnabled = true;\n    emit MintingEnabled(msg.sender);\n  }\n\n  /// @dev Disable minting by setting {_mintingEnabled}\n  /// to false, then emit the related event\n  ///\n  function _disableMinting()\n  internal virtual {\n    _mintingEnabled = false;\n    emit MintingDisabled(msg.sender);\n  }\n}"},"Pauseable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \u0027./Roleplay.sol\u0027;\n\n/// @title Pauseable\n///\n/// @notice This contract covers everything related\n/// to the pause functions\n///\n/// @dev Inehrit {Roleplay}\n///\ncontract Pauseable is Roleplay {\n  /// @dev Declare a private bool {_paused}\n  ///\n  bool private _paused;\n  \n  /// @dev Declare two events to expose when pause\n  /// is enabled or disabled, take the event\u0027s sender\n  /// as argument\n  ///\n  event Paused(address indexed _from);\n  event Unpaused(address indexed _from);\n\n  /// @dev Verify if the contract is not paused\n  /// \n  /// Requirements:\n  /// {_paused} should be false\n  ///\n  modifier whenNotPaused() {\n    require(\n      !_paused,\n      \"PC:300\"\n    );\n    _;\n  }\n\n  /// @dev Verify if the contract is paused\n  /// \n  /// Requirements:\n  /// {_paused} should be true\n  ///\n  modifier whenPaused() {\n    require(\n      _paused,\n      \"PC:310\"\n    );\n    _;\n  }\n\n  /// @dev By default, pause is disabled\n  ///\n  constructor ()\n  internal {\n    _paused = false;\n  }\n\n  /// @notice Expose the state of {_paused}\n  ///\n  /// @return The state as a bool\n  ///\n  function paused()\n  public view returns (bool) {\n    return _paused;\n  }\n  \n  /// @dev Enable pause by setting {_paused}\n  /// to true, then emit the related event\n  ///\n  function pause()\n  public virtual whenNotPaused() onlyOwner() {\n    _paused = true;\n    emit Paused(msg.sender);\n  }\n\n  /// @dev Disable pause by setting {_paused}\n  /// to false, then emit the related event\n  ///\n  function unpause()\n  public virtual whenPaused() onlyOwner() {\n    _paused = false;\n    emit Unpaused(msg.sender);\n  }\n}"},"Roleplay.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./EnumerableSet.sol\";\n\n/// @title Roleplay\n///\n/// @notice This contract covers most functions about\n/// role and permission\u0027s managment\n///\nabstract contract Roleplay {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  /// @dev Structure declaration of {RoleData} data model\n  ///\n  struct RoleData {\n    EnumerableSet.AddressSet members;\n    bytes32 ownerRole;\n  }\n\n  mapping (bytes32 =\u003e RoleData) private _roles;\n\n  /// @dev Declare a public constant of type bytes32\n  ///\n  /// @return The bytes32 string of the role\n  ///\n  bytes32 public constant ROLE_OWNER = 0x00;\n\n  /// @dev Declare a public constant of type bytes32\n  ///\n  /// @return The bytes32 string of the role\n  ///\n  bytes32 public constant ROLE_MANAGER = keccak256(\"MANAGER\");\n\n  /// @dev Declare two events to expose role\n  /// modifications\n  ///\n  event RoleGranted(bytes32 indexed _role, address indexed _from, address indexed _sender);\n  event RoleRevoked(bytes32 indexed role, address indexed _from, address indexed _sender);\n\n  /// @dev Verify if the sender have Owner\u0027s role\n  /// \n  /// Requirements:\n  /// {_hasRole()} should be true\n  ///\n  modifier onlyOwner() {\n    require(\n      hasRole(ROLE_OWNER, msg.sender),\n      \"RPC:500\"\n    );\n    _;\n  }\n\n  /// @notice This function verify is the {_account}\n  /// has role {_role}\n  ///\n  /// @param _role - The bytes32 string of the role\n  /// @param _account - The address to verify\n  ///\n  /// @return true/false depending the result \n  ///\n  function hasRole(\n    bytes32 _role,\n    address _account\n  ) public view returns (bool) {\n    return _roles[_role].members.contains(_account);\n  }\n\n  /// @notice Expose the length of members[] for\n  /// a given {_role}\n  ///\n  /// @param _role - The bytes32 string of the role\n  ///\n  /// @return - The length of members\n  ///\n  function getRoleMembersLength(\n    bytes32 _role\n  ) public view returns (uint256) {\n    return _roles[_role].members.length();\n  }\n\n\n  /// @notice Expose the member address for\n  /// a given {_role} at the {_id} index\n  ///\n  /// @param _id - Index to watch for\n  /// @param _role - The bytes32 string of the role\n  ///\n  /// @return - The address of the member at {_id} index\n  ///\n  function exposeRoleMember(\n    bytes32 _role,\n    uint256 _id\n  ) public view returns (address) {\n    return _roles[_role].members.at(_id);\n  }\n\n  /// @notice This function allow the current Owner\n  /// to transfer his ownership\n  ///\n  /// @dev Requirements:\n  /// See {Roleplay::onlyOwner()}\n  ///\n  /// @param _to - Represent address of the receiver\n  ///\n  function transferOwnerRole(\n    address _to\n  ) public virtual onlyOwner() {\n    _grantRole(ROLE_OWNER, _to);\n    _revokeRole(ROLE_OWNER, msg.sender);\n  }\n\n  /// @notice This function allow the current Owner\n  /// to give the Manager Role to {_to} address\n  ///\n  /// @dev Requirements:\n  /// See {Roleplay::onlyOwner()}\n  ///\n  /// @param _to - Represent address of the receiver\n  ///\n  function grantManagerRole(\n    address _to\n  ) public virtual onlyOwner() {\n    _grantRole(ROLE_MANAGER, _to);\n  }\n\n  /// @notice This function allow a Manager to grant\n  /// role to a given address, it can\u0027t grant Owner role\n  ///\n  /// @dev Requirements:\n  /// {_hasRole()} should be true\n  /// {_role} should be different of ROLE_OWNER\n  ///\n  /// @param _role - The bytes32 string of the role\n  /// @param _to - Represent address of the receiver\n  ///\n  function grantRole(\n    bytes32 _role,\n    address _to\n  ) public virtual {\n    require(\n      hasRole(ROLE_MANAGER, msg.sender),\n      \"RPC:510\"\n    );\n\n    require(\n      _role != ROLE_OWNER,\n      \"RPC:520\"\n    );\n\n    if (!hasRole(ROLE_OWNER, msg.sender)) {\n      require(\n        _role == keccak256(\"CHAIRPERSON\"),\n        \"RPC:530\"\n      );\n    }\n\n    _grantRole(_role, _to);\n  }\n\n  /// @notice This function allow a Manager to revoke\n  /// role to a given address, it can\u0027t revoke Owner role\n  ///\n  /// @dev Requirements:\n  /// {_hasRole()} should be true\n  /// {_role} should be different of ROLE_OWNER\n  ///\n  /// @param _role - The bytes32 string of the role\n  /// @param _to - Represent address of the receiver\n  ///\n  function revokeRole(\n    bytes32 _role,\n    address _to\n  ) public virtual {\n    require(\n      hasRole(ROLE_MANAGER, msg.sender),\n      \"RPC:550\"\n    );\n\n    require(\n      _role != ROLE_OWNER,\n      \"RPC:540\"\n    );\n\n    if (!hasRole(ROLE_OWNER, msg.sender)) {\n      require(\n        _role == keccak256(\"CHAIRPERSON\"),\n        \"RPC:530\"\n      );\n    }\n\n    _revokeRole(_role, _to);\n  }\n\n  /// @notice This function allow anyone to revoke his\n  /// own role, even an Owner, use it carefully!\n  ///\n  /// @param _role - The bytes32 string of the role\n  ///\n  function renounceRole(\n    bytes32 _role\n  ) public virtual {\n    require(\n      _role != ROLE_OWNER,\n      \"RPC:540\"\n    );\n\n    require(\n      hasRole(_role, msg.sender),\n      \"RPC:570\"\n    );\n\n    _revokeRole(_role, msg.sender);\n  }\n\n  function _setupRole(\n    bytes32 _role,\n    address _to\n  ) internal virtual {\n    _grantRole(_role, _to);\n  }\n\n  function _grantRole(\n    bytes32 _role,\n    address _to\n  ) private {\n    if (_roles[_role].members.add(_to)) {\n      emit RoleGranted(_role, _to, msg.sender);\n    }\n  }\n\n  function _revokeRole(\n    bytes32 _role,\n    address _to\n  ) private {\n    if (_roles[_role].members.remove(_to)) {\n      emit RoleRevoked(_role, _to, msg.sender);\n    }\n  }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n\nlibrary SafeMath {\n  function add(\n    uint256 a,\n    uint256 b\n  ) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b\n  ) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction overflow\");\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function mul(\n    uint256 a,\n    uint256 b\n  ) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b\n  ) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b\n  ) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}"},"Stakeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./Roleplay.sol\u0027;\n\n/// @title Stakeable\n///\n/// @notice This contract covers most functions about\n/// staking and rewards\n///\nabstract contract Stakeable is Roleplay {\n  /// @dev Declare an internal variable of type uint256\n  ///\n  uint256 internal _totalStakedSupply;\n\n  /// @dev Declare an internal variable of type uint256\n  ///\n  uint256 internal _maxRewardRatio;\n  \n  /// @dev Structure declaration of {Stakeholder} data model\n  ///\n  struct Stakeholder {\n    address owner;\n    uint256 stake;\n    uint256 availableReward;\n    uint256 totalRewardEarned;\n    uint256 totalRewardSpent;\n    uint256 createdAt;\n    uint256 lastRewardCalculatedAt;\n  }\n\n  /// @dev Declare two events to expose when stake\n  /// or unstake is requested, take the event\u0027s\n  /// sender as argument and the requested amount\n  ///\n  event Staked(address indexed _from, uint256 _amount);\n  event Unstaked(address indexed _from, uint256 _amount);\n\n  /// @dev Declare an array of {Stakeholder}\n  ///\n  Stakeholder[] stakeholders;\n  \n  /// @dev Verify if the amount is superior to 0\n  /// \n  /// Requirements:\n  /// {_amount} should be superior to 0\n  ///\n  /// @param _amount - Represent the requested amount\n  ///\n  modifier isAmountNotZero(uint256 _amount) {\n    require(\n      _amount \u003e 0,\n      \"SC:630\"\n    );\n    _;\n  }\n\n  /// @dev Verify if the amount is a valid amount\n  /// \n  /// Requirements:\n  /// {_amount} should be inferior or equal to 10\n  ///\n  /// @param _amount - Represent the requested amount\n  /// @param _balance - Represent the sender balance\n  ///\n  modifier isAmountValid(uint256 _amount, uint256 _balance) {\n    require(\n      (_amount * (10**8)) \u003c= _balance,\n      \"SC:640\"\n    );\n    _;\n  }\n\n  /// @dev Verify if the amount is a valid amount to unstake\n  /// \n  /// Requirements:\n  /// {_amount} should be inferior or equal to staked value\n  ///\n  /// @param _amount - Represent the requested amount\n  ///\n  modifier isAbleToUnstake(uint256 _amount) {\n    Stakeholder memory stakeholder = exposeStakeholder(msg.sender); \n    require(\n      _amount \u003c= stakeholder.stake,\n      \"SC:640\"\n    );\n    _;\n  }\n\n  constructor() public {\n    _maxRewardRatio = 10;\n  }\n\n  /// @notice Expose the total staked supply\n  ///\n  /// @return The uint256 value of {_totalStakedSupply}\n  ///\n  function totalStakedSupply()\n  public view returns (uint256) {\n    return _totalStakedSupply;\n  }\n\n  /// @notice Expose the max reward ratio\n  ///\n  /// @return The uint256 value of {_maxRewardRatio}\n  ///\n  function maxRewardRatio()\n  public view returns (uint256) {\n    return _maxRewardRatio;\n  }\n\n  /// @notice Expose every Stakeholders\n  ///\n  /// @return A tuple of Stakeholders\n  ///\n  function exposeStakeholders()\n  public view returns (Stakeholder[] memory) {\n    return stakeholders;\n  }\n\n  /// @notice Expose a Stakeholder from the Owner address\n  ///\n  /// @param _owner - Represent the address of the stakeholder owner\n  ///\n  /// @return A tuple of Stakeholder\n  ///\n  function exposeStakeholder(\n    address _owner\n  ) public view returns (Stakeholder memory) {\n    uint256 i = 0;\n    uint256 len = stakeholders.length;\n    while (i \u003c len) {\n      if (stakeholders[i].owner == _owner) {\n        return stakeholders[i];\n      }\n      i++;\n    }\n  }\n\n  /// @notice Set the {_maxRewardRatio}\n  ///\n  /// @dev Only owner can use this function\n  ///\n  /// @param _amount - Represent the requested ratio\n  ///\n  function setMaxRewardRatio(\n    uint256 _amount\n  ) public virtual onlyOwner() {\n    _maxRewardRatio = _amount;\n  }\n\n  /// @notice Create a new {Stakeholder}\n  ///\n  /// @dev Owner is the sender\n  ///\n  /// @param _owner - Represent the owner of the Stakeholder\n  ///\n  function _createStakeholder(\n    address _owner\n  ) internal virtual {\n    stakeholders.push(Stakeholder({\n      owner: _owner,\n      stake: 0,\n      createdAt: now,\n      availableReward: 0,\n      totalRewardEarned: 0,\n      totalRewardSpent: 0,\n      lastRewardCalculatedAt: 0\n    }));\n  }\n\n  /// @notice This function compute the reward gained from staking\n  /// UnissouToken\n  ///\n  /// @dev The calculation is pretty simple, a {Stakeholder}\n  /// holds the date of the {Stakeholder}\u0027s creation. If the\n  /// reward hasn\u0027t been computed since the creation, the\n  /// algorithm will calculate them based on the number of\n  /// days passed since the creation of the stakeholding.\n  /// Then the calculation\u0027s date will be saved onto the\n  /// {Stakeholder} and when {_computeReward} will be called\n  /// again, the reward calculation will take this date in \n  /// consideration to compute the reward.\n  /// \n  /// The actual ratio is 1 Stake = 1 Reward.\n  /// With a maximum of 10 tokens per stake,\n  /// you can obtain a total of 10 rewards per day\n  ///\n  /// @param _id - Represent the Stakeholder index\n  ///\n  function _computeReward(\n    uint256 _id\n  ) internal virtual {\n    uint256 stake = stakeholders[_id].stake;\n    uint256 lastCalculatedReward = stakeholders[_id].lastRewardCalculatedAt;\n    uint256 createdAt = stakeholders[_id].createdAt;\n\n    if (lastCalculatedReward == 0) {\n      if (createdAt \u003c now) {\n        if ((now - createdAt) \u003e= 1 days) {\n          stakeholders[_id].availableReward += (((now - createdAt) / 1 days) * (\n            stake \u003c= _maxRewardRatio ?\n            stake : _maxRewardRatio\n          ));\n          stakeholders[_id].totalRewardEarned += (((now - createdAt) / 1 days) * (\n            stake \u003c= _maxRewardRatio ?\n            stake : _maxRewardRatio\n          ));\n          stakeholders[_id].lastRewardCalculatedAt = now;\n          return;\n        }\n      }\n    }\n\n    if (lastCalculatedReward != 0) {\n      if (lastCalculatedReward \u003c now) {\n        if ((now - lastCalculatedReward) \u003e= 1 days) {\n          stakeholders[_id].availableReward += (((now - lastCalculatedReward) / 1 days) * (\n            stake \u003c= _maxRewardRatio ?\n            stake : _maxRewardRatio\n          ));\n          stakeholders[_id].totalRewardEarned += (((now - lastCalculatedReward) / 1 days) * (\n            stake \u003c= _maxRewardRatio ?\n            stake : _maxRewardRatio\n          ));\n          stakeholders[_id].lastRewardCalculatedAt = now;\n          return;\n        }\n      }\n    }\n  }\n}"},"Unissou.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./UnissouDAO.sol\u0027;\nimport \u0027./UnissouDApp.sol\u0027;\n\n/// @title Unissou\n///\n/// @notice This is the main contract\n///\n/// @dev Inehrit {UnissouDAO} and {UnissouDApp}\n///\ncontract Unissou is UnissouDAO, UnissouDApp {\n\n  /// @notice Declare a public constant of type string\n  ///\n  /// @return The smart contract author\n  ///\n  string public constant CREATOR = \"unissou.com\";\n}"},"UnissouDAO.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./Voteable.sol\u0027;\nimport \u0027./UnissouDApp.sol\u0027;\n\n/// @title UnissouDAO\n///\n/// @notice This contract covers everything related\n/// to the organization of Unissou\n///\n/// @dev Inehrit {Voteable} and {UnissouToken}\n///\nabstract contract UnissouDAO is Voteable, UnissouToken {\n  \n  /// @notice ROLE_CHAIRPERSON is granted to the\n  /// original contract deployer\n  ///\n  /// @dev See {Roleplay::grantRole()}\n  ///\n  constructor() public {\n    grantRole(ROLE_CHAIRPERSON, msg.sender);\n  }\n\n  /// @notice This function allows the sender to vote\n  /// for a proposal, the vote can be positive or negative.\n  /// The sender has to complete the requirements to be\n  /// able to vote for a proposal.\n  ///\n  /// @dev Depending on the value of {_isPositiveVote}, add a\n  /// *positive/negative* vote to the proposal, identified\n  /// by its {_id}, then push the sender address into the\n  /// voters pool of the proposal\n  ///\n  /// Requirements:\n  /// See {Voteable::isValidVoter()} \n  /// See {Voteable::isVoteEnabled()} \n  ///\n  /// @param _id - Represent the proposal id\n  /// @param _isPositiveVote - Represent the vote type\n  ///\n  function voteForProposal(\n    uint256 _id,\n    bool _isPositiveVote\n  ) public virtual isValidVoter(\n    _id,\n    balanceOf(msg.sender)\n  ) isVoteEnabled(\n    _id\n  ) {\n    if (_isPositiveVote) {\n      proposals[_id].positiveVote += 1;\n      proposals[_id].positiveVoters.push(msg.sender);\n    }\n\n    if (!_isPositiveVote) {\n      proposals[_id].negativeVote += 1;\n      proposals[_id].negativeVoters.push(msg.sender);\n    }\n  }\n}"},"UnissouDApp.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./Stakeable.sol\u0027;\nimport \u0027./Roleplay.sol\u0027;\nimport \u0027./UnissouToken.sol\u0027;\n\n/// @title UnissouDApp\n///\n/// @notice This contract covers everything related\n/// to the DApp of Unissou\n///\n/// @dev Inehrit {Stakeable} and {UnissouToken}\n///\nabstract contract UnissouDApp is Roleplay, Stakeable, UnissouToken {\n\n  /// @notice This function allows the sender to stake\n  /// an amount (maximum 10) of UnissouToken, when the\n  /// token is staked, it is burned from the circulating\n  /// supply and placed into the staking pool\n  /// \n  /// @dev The function iterate through {stakeholders} to\n  /// know if the sender is already a stakeholder. If the\n  /// sender is already a stakeholder, then the requested amount\n  /// is staked into the pool and then burned from the sender wallet.\n  /// If the sender isn\u0027t a stakeholer, a new stakeholder is created,\n  /// and then the function is recall to stake the requested amount\n  ///\n  /// Requirements:\n  /// See {Stakeable::isAmountValid()}\n  ///\n  /// @param _amount - Represent the amount of token to be staked\n  ///\n  function stake(\n    uint256 _amount\n  ) public virtual isAmountValid(\n    _amount,\n    balanceOf(msg.sender)\n  ) isAmountNotZero(\n    _amount\n  ) {\n    uint256 i = 0;\n    bool isStakeholder = false;\n    uint256 len = stakeholders.length;\n    while (i \u003c len) {\n      if (stakeholders[i].owner == msg.sender) {\n        isStakeholder = true;\n        break;\n      }\n      i++;\n    }\n\n    if (isStakeholder) {\n      stakeholders[i].stake += _amount;\n      _burn(msg.sender, (_amount * (10**8)));\n      _totalStakedSupply += (_amount * (10**8));\n      emit Staked(msg.sender, _amount);\n    }\n\n    if (!isStakeholder) {\n      _createStakeholder(msg.sender);\n      stake(_amount);\n    }\n  }\n  \n  /// @notice This function unstacks the sender staked\n  /// balance depending on the requested {_amount}, if the\n  /// {_amount} exceeded the staked supply of the sender,\n  /// the whole staked supply of the sender will be unstacked\n  /// and withdrawn to the sender wallet without exceeding it.\n  ///\n  /// @dev Like stake() function do, this function iterate\n  /// over the stakeholders to identify if the sender is one \n  /// of them, in the case of the sender is identified as a\n  /// stakeholder, then the {_amount} is minted to the sender\n  /// wallet and sub from the staked supply.\n  ///\n  /// Requirements:\n  /// See {Stakeable::isAmountNotZero}\n  /// See {Stakeable::isAbleToUnstake}\n  ///\n  /// @param _amount - Represent the amount of token to be unstack\n  ///\n  function unstake(\n    uint256 _amount\n  ) public virtual isAmountNotZero(\n    _amount\n  ) isAbleToUnstake(\n    _amount\n  ) {\n    uint256 i = 0;\n    bool isStakeholder = false;\n    uint256 len = stakeholders.length;\n    while (i \u003c len) {\n      if (stakeholders[i].owner == msg.sender) {\n        isStakeholder = true;\n        break;\n      }\n      i++;\n    }\n\n    require(\n      isStakeholder,\n      \"SC:650\"\n    );\n\n    if (isStakeholder) {\n      if (_amount \u003c= stakeholders[i].stake) {\n        stakeholders[i].stake -= _amount;\n        _mint(msg.sender, (_amount * (10**8)));\n        _totalStakedSupply -= (_amount * (10**8));\n        emit Unstaked(msg.sender, _amount);\n      }\n    }\n  }\n  \n  /// @notice This function allows the sender to compute\n  /// his reward earned by staking {UnissouToken}. When you\n  /// request a withdraw, the function updates the reward\u0027s\n  /// value of the sender stakeholding onto the Ethereum\n  /// blockchain, allowing him to spend the reward for NFTs.\n  ///\n  /// @dev The same principe as other functions is applied here,\n  /// iteration over stakeholders, when found, execute the action.\n  /// See {Stakeable::_computeReward()}\n  ///\n  function withdraw()\n  public virtual {\n    uint256 i = 0;\n    bool isStakeholder = false;\n    uint256 len = stakeholders.length;\n    while (i \u003c len) {\n      if (stakeholders[i].owner == msg.sender) {\n        isStakeholder = true;\n        break;\n      }\n      i++;\n    }\n\n    require(\n      isStakeholder,\n      \"SC:650\"\n    );\n\n    if (isStakeholder) {\n      _computeReward(i);\n    }\n  }\n\n  /// @notice This function allows the owner to spend {_amount} \n  /// of the target rewards gained from his stake.\n  ///\n  /// @dev To reduce the potential numbers of transaction, the\n  /// {_computeReward()} function is also executed into this function.\n  ///\n  /// @param _amount - Represent the amount of reward to spend\n  /// @param _target - Represent the address of the stakeholder owner\n  ///\n  function spend(\n    uint256 _amount,\n    address _target\n  ) public virtual onlyOwner() {\n    uint256 i = 0;\n    bool isStakeholder = false;\n    uint256 len = stakeholders.length;\n    while (i \u003c len) {\n      if (stakeholders[i].owner == _target) {\n        isStakeholder = true;\n        break;\n      }\n      i++;\n    }\n\n    require(\n      isStakeholder,\n      \"SC:650\"\n    );\n\n    if (isStakeholder) {\n      _computeReward(i);\n      require(\n        _amount \u003c= stakeholders[i].availableReward,\n        \"SC:660\"\n      );\n\n      stakeholders[i].availableReward -= _amount;\n      stakeholders[i].totalRewardSpent += _amount;\n    }\n  }\n}"},"UnissouToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \u0027./ERC20.sol\u0027;\nimport \u0027./Roleplay.sol\u0027;\nimport \u0027./Pauseable.sol\u0027;\nimport \u0027./Minteable.sol\u0027;\nimport \u0027./Burneable.sol\u0027;\n\n/// @title UnissouToken\n///\n/// @notice This contract covers everything related\n/// to the Unissou ERC20\n///\n/// @dev Inehrit {ERC20}, {Roleplay}, {Pauseable},\n/// {Minteable} and {Burneable}\n///\nabstract contract UnissouToken is \nERC20, Roleplay, Pauseable, Minteable, Burneable {\n\n  /// @notice Original contract\u0027s deployer are granted\n  /// with Owner role and Manager role and the initial\n  /// supply are minted onto his wallet.\n  ///\n  /// @dev See {ERC20}\n  ///\n  constructor()\n  public ERC20(\n    \"Unissou\",\n    \"YTG\",\n    384400 * (10**8),\n    96100 * (10**8)\n  ) {\n    _setupRole(ROLE_OWNER, msg.sender);\n    _setupRole(ROLE_MANAGER, msg.sender);\n    _mint(msg.sender, initialSupply());\n  }\n  \n  /// @notice This function allows to transfer tokens to multiple\n  /// addresses in only one transaction, that help to reduce fees.\n  /// The amount cannot be dynamic and is constant for all transfer\n  ///\n  /// @param _receivers - Represent an array of address\n  /// @param _amount - Represent the amount of token to transfer\n  ///\n  function transferBatch(\n    address[] memory _receivers,\n    uint256 _amount\n  ) public virtual {\n    uint256 i = 0;\n    uint256 len = _receivers.length;\n\n    require(\n      balanceOf(msg.sender) \u003e= (_amount * len),\n      \"UT:470\"\n    );\n\n    while (i \u003c len) {\n      transfer(_receivers[i], _amount);\n      i++;\n    }\n  } \n\n  /// @notice This function allows the sender to mint\n  /// an {_amount} of token unless the {_amount}\n  /// exceed the total supply cap\n  ///\n  /// @dev Once the minting is down, minting is disabled\n  ///\n  /// Requirements:\n  /// See {Minteable::isMinteable()}\n  ///\n  /// @param _amount - Represent the amount of token\n  /// to be minted\n  ///\n  function mint(\n    uint256 _amount\n  ) public virtual isMinteable(\n    _amount,\n    hasRole(ROLE_MINTER, msg.sender)\n  ) {\n    _mint(msg.sender, _amount);\n    _disableMinting();\n  }\n\n  /// @notice This function allows the sender to mint\n  /// an {_amount} of token directly onto the address {_to}\n  /// unless the {_amount} exceed the total supply cap\n  ///\n  /// @dev Once the minting is down, minting is disabled\n  ///\n  /// Requirements:\n  /// See {Minteable::isMinteable()}\n  ///\n  /// @param _to - Represent the token\u0027s receiver\n  /// @param _amount - Represent the amount of token\n  /// to be minted\n  ///\n  function mintTo(\n    address _to,\n    uint256 _amount\n  ) public virtual isMinteable(\n    _amount,\n    hasRole(ROLE_MINTER, msg.sender)\n  ) {\n    _mint(_to, _amount);\n    _disableMinting();\n  }\n\n  /// @notice This function allows the sender to burn\n  /// an {_amount} of token\n  ///\n  /// @dev Once the burning is down, burning is disabled\n  ///\n  /// Requirements:\n  /// See {Burneable::isBurneable()}\n  ///\n  /// @param _amount - Represent the amount of token\n  /// to be burned\n  ///\n  function burn(\n    uint256 _amount\n  ) public virtual isBurneable(\n    _amount,\n    hasRole(ROLE_BURNER, msg.sender)\n  ) {\n    _burn(msg.sender, _amount);\n    _disableBurning();\n  }\n\n  /// @notice This function allows the sender to burn\n  /// an {_amount} of token directly from the address {_from}\n  /// only if the token allowance is superior or equal\n  /// to the requested {_amount}\n  ///\n  /// @dev Once the burning is down, burning is disabled\n  ///\n  /// Requirements:\n  /// See {Burneable::isBurneable()}\n  ///\n  /// @param _from - Represent the token\u0027s receiver\n  /// @param _amount - Represent the amount of token\n  /// to be burned\n  ///\n  function burnFrom(\n    address _from,\n    uint256 _amount\n  ) public virtual isBurneable(\n    _amount,\n    hasRole(ROLE_BURNER, msg.sender)\n  ) {\n    uint256 decreasedAllowance = allowance(_from, msg.sender).sub(_amount);\n    _approve(_from, msg.sender, decreasedAllowance);\n    _burn(_from, _amount);\n    _disableBurning();\n  }\n\n  /// @notice This function does verification before\n  /// any token transfer. The actual verification are:\n  /// - If the total supply don\u0027t exceed the total\n  /// supply cap (for example, when token are minted),\n  /// - If the token\u0027s transfer are not paused\n  ///\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual override {\n    super._beforeTokenTransfer(from, to, amount);\n\n    if (from == address(0)) {\n      require(\n        totalSupply().add(amount) \u003c= totalSupplyCap(),\n        \"UT:20\"\n      );\n    }\n\n    require(\n      !paused(),\n      \"UT:400\"\n    );\n  }\n}"},"Voteable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \u0027./Roleplay.sol\u0027;\n\n/// @title Voteable\n///\n/// @notice This contract covers most functions about\n/// proposals and votings\n///\n/// @dev Inehrit {Roleplay}\n///\nabstract contract Voteable is Roleplay {\n  /// @dev Declare an internal variable of type uint256\n  ///\n  uint256 internal _minVoteBalance;\n\n  /// @dev Structure declaration of {Proposal} data model\n  ///\n  struct Proposal {\n    address creator;\n    string name;\n    string metadataURI;\n    bool votingEnabled;\n    uint256 positiveVote;\n    uint256 negativeVote;\n    address[] positiveVoters;\n    address[] negativeVoters;\n  }\n\n  /// @dev Declare a public constant of type bytes32\n  ///\n  /// @return The bytes32 string of the role\n  ///\n  bytes32 public constant ROLE_CHAIRPERSON = keccak256(\"CHAIRPERSON\");\n\n  /// @dev Declare an array of {Proposal}\n  ///\n  Proposal[] proposals;\n\n  /// @dev Verify if the sender have the chairperson role\n  /// \n  /// Requirements:\n  /// {_hasRole} should be true\n  ///\n  modifier isChairperson() {\n    require(\n      hasRole(ROLE_CHAIRPERSON, msg.sender),\n      \"VC:500\"\n    );\n    _;\n  }\n\n  /// @dev Verify if the sender is a valid voter\n  ///\n  /// Requirements:\n  /// {_balance} should be superior to 1\n  /// {_voter} should haven\u0027t already voted\n  ///\n  /// @param _id - Represent the proposal index\n  /// @param _balance - Represent the sender balance\n  ///\n  modifier isValidVoter(\n    uint256 _id,\n    uint256 _balance\n  ) {\n    require(\n      _balance \u003e= (_minVoteBalance * (10**8)),\n      \"VC:1010\"\n    );\n\n    bool positiveVote = _checkSenderHasVoted(proposals[_id].positiveVoters, msg.sender);\n    bool negativeVote = _checkSenderHasVoted(proposals[_id].negativeVoters, msg.sender);\n\n    require(\n      !positiveVote \u0026\u0026 !negativeVote,\n      \"VC:1020\"\n    );\n    _;\n  }\n\n  /// @dev Verify if the proposal have voting enabled\n  ///\n  /// Requirements:\n  /// {proposals[_id]} should have voting enabled\n  ///\n  /// @param _id - Represent the proposal index\n  ///\n  modifier isVoteEnabled(\n    uint256 _id\n  ) {\n    require(\n      proposals[_id].votingEnabled,\n      \"VC:1030\"\n    );\n    _;\n  }\n\n  constructor() public {\n    _minVoteBalance = 100;\n  }\n\n  /// @notice Expose the min balance required to vote\n  ///\n  /// @return The uint256 value of {_minVoteBalance}\n  ///\n  function minVoteBalance()\n  public view returns (uint256) {\n    return _minVoteBalance;\n  }\n\n  /// @notice Set the {_minVoteBalance}\n  ///\n  /// @dev Only owner can use this function\n  ///\n  /// @param _amount - Represent the requested ratio\n  ///\n  function setMinVoteBalance(\n    uint256 _amount\n  ) public virtual onlyOwner() {\n    _minVoteBalance = _amount;\n  }\n\n  /// @notice Allow a chairperson to create a new {Proposal}\n  ///\n  /// @dev Sender should be a chairperson\n  ///\n  /// Requirements:\n  /// See {Voteable::isChairperson()}\n  ///\n  /// @param _name - Represent the Proposal name\n  /// @param _uri - Represent the Proposal metadata uri\n  /// @param _enable - Represent if vote is enable/disable\n  ///\n  function createProposal(\n    string memory _name,\n    string memory _uri,\n    bool _enable\n  ) public virtual isChairperson() {\n    proposals.push(\n      Proposal({\n        creator: msg.sender,\n        name: _name,\n        metadataURI: _uri,\n        votingEnabled: _enable,\n        positiveVote: 0,\n        negativeVote: 0,\n        positiveVoters: new address[](0),\n        negativeVoters: new address[](0)\n      })\n    );\n  }\n  \n  /// @notice Allow a chairperson to enable/disable voting\n  /// for a proposal\n  ///\n  /// @dev Sender should be a chairperson\n  ///\n  /// Requirements:\n  /// See {Voteable::isChairperson()}\n  ///\n  /// @param _id - Represent a proposal index\n  ///\n  function enableProposal(\n    uint256 _id\n  ) public virtual isChairperson() {\n    proposals[_id].votingEnabled ?\n    proposals[_id].votingEnabled = false :\n    proposals[_id].votingEnabled = true;\n  }\n\n  /// @notice Expose all proposals\n  ///\n  /// @return A tuple of Proposal\n  ///\n  function exposeProposals()\n  public view returns (Proposal[] memory) {\n    return proposals;\n  }\n\n  /// @notice Verify if the sender have already voted\n  /// for a proposal\n  ///\n  /// @dev The function iterate hover the {_voters}\n  /// to know if the sender have already voted\n  ///\n  /// @param _voters - Represent the positive/negative\n  /// voters of a proposal\n  ///\n  function _checkSenderHasVoted(\n    address[] memory _voters,\n    address _voter\n  ) private pure returns (bool) {\n    uint256 i = 0;\n    bool voted = false;\n    uint256 len = _voters.length;\n    while (i \u003c len) {\n      if (_voters[i] == _voter) {\n        voted = true;\n        break;\n      }\n      i++;\n    }\n\n    return voted;\n  }\n}"}}