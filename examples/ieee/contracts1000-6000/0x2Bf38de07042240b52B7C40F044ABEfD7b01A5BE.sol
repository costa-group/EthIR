{"BaseFeature.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.s\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./SafeMath.sol\";\nimport \"./IWallet.sol\";\nimport \"./IModuleRegistry.sol\";\nimport \"./ILockStorage.sol\";\nimport \"./IFeature.sol\";\nimport \"./ERC20.sol\";\nimport \"./IVersionManager.sol\";\n\n/**\n * @title BaseFeature\n * @notice Base Feature contract that contains methods common to all Feature contracts.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e, Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ncontract BaseFeature is IFeature {\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n    // Mock token address for ETH\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    // The address of the Lock storage\n    ILockStorage internal lockStorage;\n    // The address of the Version Manager\n    IVersionManager internal versionManager;\n\n    event FeatureCreated(bytes32 name);\n\n    /**\n     * @notice Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(address _wallet) {\n        require(!lockStorage.isLocked(_wallet), \"BF: wallet locked\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the VersionManager.\n     */\n    modifier onlyVersionManager() {\n        require(msg.sender == address(versionManager), \"BF: caller must be VersionManager\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the owner of the target wallet.\n     */\n    modifier onlyWalletOwner(address _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BF: must be wallet owner\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not an authorised feature of the target wallet.\n     */\n    modifier onlyWalletFeature(address _wallet) {\n        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), \"BF: must be a wallet feature\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the owner of the target wallet or the feature itself.\n     */\n    modifier onlyWalletOwnerOrFeature(address _wallet) {\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\n        _;\n    }\n\n    constructor(\n        ILockStorage _lockStorage,\n        IVersionManager _versionManager,\n        bytes32 _name\n    ) public {\n        lockStorage = _lockStorage;\n        versionManager = _versionManager;\n        emit FeatureCreated(_name);\n    }\n\n    /**\n    * @inheritdoc IFeature\n    */\n    function recoverToken(address _token) external virtual override {\n        uint total = ERC20(_token).balanceOf(address(this));\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));\n    }\n\n    /**\n     * @notice Inits the feature for a wallet by doing nothing.\n     * @dev !! Overriding methods need make sure `init()` can only be called by the VersionManager !!\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external virtual override  {}\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {\n        revert(\"BF: disabled method\");\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {\n        return versionManager.isFeatureAuthorised(_wallet, _feature);\n    }\n\n    /**\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\n    * @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\n        require(_data.length \u003e= 36, \"RM: Invalid dataWallet\");\n        address dataWallet = abi.decode(_data[4:], (address));\n        return dataWallet == _wallet;\n    }\n    \n     /**\n     * @notice Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(address _wallet, address _addr) internal view returns (bool) {\n        return IWallet(_wallet).owner() == _addr;\n    }\n\n    /**\n     * @notice Verify that the caller is an authorised feature or the wallet owner.\n     * @param _wallet The target wallet.\n     * @param _sender The caller.\n     */\n    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {\n        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), \"BF: must be owner or feature\");\n    }\n\n    /**\n     * @notice Helper method to invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)\n        internal\n        returns (bytes memory _res) \n    {\n        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);\n    }\n\n}"},"DSMath.sol":{"content":"/// source: https://github.com/dapphub/ds-math/\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\npragma solidity \u003e0.4.13;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) \u003e= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) \u003c= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x \u003c= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x \u003e= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x \u003c= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x \u003e= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    //rounds to zero if x*y \u003c WAD / 2\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    //rounds to zero if x*y \u003c WAD / 2\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    //rounds to zero if x*y \u003c WAD / 2\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    //rounds to zero if x*y \u003c RAY / 2\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It\u0027s O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}"},"ERC20.sol":{"content":"pragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * ERC20 contract interface.\n */\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n}"},"IFeature.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IFeature\n * @notice Interface for a Feature.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e, Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ninterface IFeature {\n\n    enum OwnerSignature {\n        Anyone,             // Anyone\n        Required,           // Owner required\n        Optional,           // Owner and/or guardians\n        Disallowed          // guardians only\n    }\n\n    /**\n    * @notice Utility method to recover any ERC20 token that was sent to the Feature by mistake.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n\n    /**\n     * @notice Inits a Feature for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external;\n\n    /**\n     * @notice Helper method to check if an address is an authorised feature of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _feature The address.\n     */\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);\n\n    /**\n    * @notice Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the wallet owner signature requirement.\n    */\n    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);\n\n    /**\n    * @notice Gets the list of static call signatures that this feature responds to on behalf of wallets\n    */\n    function getStaticCallSignatures() external view returns (bytes4[] memory);\n}"},"ILimitStorage.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ILimitStorage\n * @notice LimitStorage interface\n */\ninterface ILimitStorage {\n\n    struct Limit {\n        // the current limit\n        uint128 current;\n        // the pending limit if any\n        uint128 pending;\n        // when the pending limit becomes the current limit\n        uint64 changeAfter;\n    }\n\n    struct DailySpent {\n        // The amount already spent during the current period\n        uint128 alreadySpent;\n        // The end of the current period\n        uint64 periodEnd;\n    }\n\n    function setLimit(address _wallet, Limit memory _limit) external;\n\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\n\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\n\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\n\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\n\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\n}"},"ILockStorage.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\ninterface ILockStorage {\n    function isLocked(address _wallet) external view returns (bool);\n\n    function getLock(address _wallet) external view returns (uint256);\n\n    function getLocker(address _wallet) external view returns (address);\n\n    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;\n}"},"IMakerRegistry.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\nimport \"./MakerInterfaces.sol\";\n/**\n * @title IMakerRegistry\n * @notice Interface for the MakerRegistry\n */\ninterface IMakerRegistry {\n    function collaterals(address _collateral) external view returns (bool exists, uint128 index, JoinLike join, bytes32 ilk);\n    function addCollateral(JoinLike _joinAdapter) external;\n    function removeCollateral(address _token) external;\n    function getCollateralTokens() external view returns (address[] memory _tokens);\n    function getIlk(address _token) external view returns (bytes32 _ilk);\n    function getCollateral(bytes32 _ilk) external view returns (JoinLike _join, GemLike _token);\n}"},"IModuleRegistry.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"},"IUniswapExchange.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\ninterface IUniswapExchange {\n    function getEthToTokenOutputPrice(uint256 _tokensBought) external view returns (uint256);\n    function getEthToTokenInputPrice(uint256 _ethSold) external view returns (uint256);\n    function getTokenToEthOutputPrice(uint256 _ethBought) external view returns (uint256);\n    function getTokenToEthInputPrice(uint256 _tokensSold) external view returns (uint256);\n}"},"IUniswapFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\ninterface IUniswapFactory {\n    function getExchange(address _token) external view returns(address);\n}"},"IVersionManager.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ILimitStorage.sol\";\n\n/**\n * @title IVersionManager\n * @notice Interface for the VersionManager module.\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ninterface IVersionManager {\n    /**\n     * @notice Returns true if the feature is authorised for the wallet\n     * @param _wallet The target wallet.\n     * @param _feature The feature.\n     */\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\n\n    /**\n     * @notice Lets a feature (caller) invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function checkAuthorisedFeatureAndInvokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory _res);\n\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _wallet, address _newOwner) external;\n\n    /**\n     * @notice Lets a feature write data to a storage contract.\n     * @param _wallet The target wallet.\n     * @param _storage The storage contract.\n     * @param _data The data of the call\n     */\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\n\n    /**\n     * @notice Upgrade a wallet to a new version.\n     * @param _wallet the wallet to upgrade\n     * @param _toVersion the new version\n     */\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\n \n}"},"IWallet.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IWallet\n * @notice Interface for the BaseWallet\n */\ninterface IWallet {\n    /**\n     * @notice Returns the wallet owner.\n     * @return The wallet owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint);\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Checks if a module is authorised on the wallet.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible for a static call redirection.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external;\n\n    /**\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external;\n}"},"MakerInterfaces.sol":{"content":"pragma solidity \u003e=0.5.4 \u003c0.7.0;\n\ninterface GemLike {\n    function balanceOf(address) external view returns (uint);\n    function transferFrom(address, address, uint) external returns (bool);\n    function approve(address, uint) external returns (bool success);\n    function decimals() external view returns (uint);\n    function transfer(address,uint) external returns (bool);\n}\n\ninterface DSTokenLike {\n    function mint(address,uint) external;\n    function burn(address,uint) external;\n}\n\ninterface VatLike {\n    function can(address, address) external view returns (uint);\n    function dai(address) external view returns (uint);\n    function hope(address) external;\n    function wards(address) external view returns (uint);\n    function ilks(bytes32) external view returns (uint Art, uint rate, uint spot, uint line, uint dust);\n    function urns(bytes32, address) external view returns (uint ink, uint art);\n    function frob(bytes32, address, address, address, int, int) external;\n    function slip(bytes32,address,int) external;\n    function move(address,address,uint) external;\n    function fold(bytes32,address,int) external;\n    function suck(address,address,uint256) external;\n    function flux(bytes32, address, address, uint) external;\n    function fork(bytes32, address, address, int, int) external;\n}\n\ninterface JoinLike {\n    function ilk() external view returns (bytes32);\n    function gem() external view returns (GemLike);\n    function dai() external view returns (GemLike);\n    function join(address, uint) external;\n    function exit(address, uint) external;\n    function vat() external returns (VatLike);\n    function live() external returns (uint);\n}\n\ninterface ManagerLike {\n    function vat() external view returns (address);\n    function urns(uint) external view returns (address);\n    function open(bytes32, address) external returns (uint);\n    function frob(uint, int, int) external;\n    function give(uint, address) external;\n    function move(uint, address, uint) external;\n    function flux(uint, address, uint) external;\n    function shift(uint, uint) external;\n    function ilks(uint) external view returns (bytes32);\n    function owns(uint) external view returns (address);\n}\n\ninterface ScdMcdMigrationLike {\n    function swapSaiToDai(uint) external;\n    function swapDaiToSai(uint) external;\n    function migrate(bytes32) external returns (uint);\n    function saiJoin() external returns (JoinLike);\n    function wethJoin() external returns (JoinLike);\n    function daiJoin() external returns (JoinLike);\n    function cdpManager() external returns (ManagerLike);\n    function tub() external returns (SaiTubLike);\n}\n\ninterface ValueLike {\n    function peek() external returns (uint, bool);\n}\n\ninterface SaiTubLike {\n    function skr() external view returns (GemLike);\n    function gem() external view returns (GemLike);\n    function gov() external view returns (GemLike);\n    function sai() external view returns (GemLike);\n    function pep() external view returns (ValueLike);\n    function bid(uint) external view returns (uint);\n    function ink(bytes32) external view returns (uint);\n    function tab(bytes32) external returns (uint);\n    function rap(bytes32) external returns (uint);\n    function shut(bytes32) external;\n    function exit(uint) external;\n}\n\ninterface VoxLike {\n    function par() external returns (uint);\n}\n\ninterface JugLike {\n    function drip(bytes32) external;\n}\n\ninterface PotLike {\n    function chi() external view returns (uint);\n    function pie(address) external view returns (uint);\n    function drip() external;\n}"},"MakerV2Base.sol":{"content":"// Copyright (C) 2019  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./BaseFeature.sol\";\nimport \"./IMakerRegistry.sol\";\nimport \"./MakerInterfaces.sol\";\nimport \"./DSMath.sol\";\n\n/**\n * @title MakerV2Base\n * @notice Common base to MakerV2Invest and MakerV2Loan.\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\nabstract contract MakerV2Base is DSMath, BaseFeature {\n\n    bytes32 constant private NAME = \"MakerV2Manager\";\n\n    // The address of the (MCD) DAI token\n    GemLike internal daiToken;\n    // The address of the SAI \u003c-\u003e DAI migration contract\n    address internal scdMcdMigration;\n    // The address of the Dai Adapter\n    JoinLike internal daiJoin;\n    // The address of the Vat\n    VatLike internal vat;\n\n    using SafeMath for uint256;\n\n    // *************** Constructor ********************** //\n\n    constructor(\n        ILockStorage _lockStorage,\n        ScdMcdMigrationLike _scdMcdMigration,\n        IVersionManager _versionManager\n    )\n        BaseFeature(_lockStorage, _versionManager, NAME)\n        public\n    {\n        scdMcdMigration = address(_scdMcdMigration);\n        daiJoin = _scdMcdMigration.daiJoin();\n        daiToken = daiJoin.dai();\n        vat = daiJoin.vat();\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getRequiredSignatures(address, bytes calldata) external view override returns (uint256, OwnerSignature) {\n        return (1, OwnerSignature.Required);\n    }\n}"},"MakerV2Invest.sol":{"content":"// Copyright (C) 2019  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./MakerV2Base.sol\";\n\n/**\n * @title MakerV2Invest\n * @notice Module to lock/unlock MCD DAI into/from Maker\u0027s Pot\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\nabstract contract MakerV2Invest is MakerV2Base {\n\n    // The address of the Pot\n    PotLike internal pot;\n\n    // *************** Events ********************** //\n\n    // WARNING: in a previous version of this module, the third parameter of `InvestmentRemoved`\n    // represented the *fraction* (out of 10000) of the investment withdrawn, not the absolute amount withdrawn\n    event InvestmentRemoved(address indexed _wallet, address _token, uint256 _amount);\n    event InvestmentAdded(address indexed _wallet, address _token, uint256 _amount, uint256 _period);\n\n    // *************** Constructor ********************** //\n\n    constructor(PotLike _pot) public {\n        pot = _pot;\n    }\n\n    // *************** External/Public Functions ********************* //\n\n    /**\n    * @notice Lets the wallet owner deposit MCD DAI into the DSR Pot.\n    * @param _wallet The target wallet.\n    * @param _amount The amount of DAI to deposit\n    */\n    function joinDsr(\n        address _wallet,\n        uint256 _amount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        // Execute drip to get the chi rate updated to rho == block.timestamp, otherwise join will fail\n        pot.drip();\n        // Approve DAI adapter to take the DAI amount\n        invokeWallet(\n            _wallet,\n            address(daiToken),\n            0,\n            abi.encodeWithSignature(\"approve(address,uint256)\", address(daiJoin), _amount)\n        );\n        // Join DAI into the vat (_amount of external DAI is burned and the vat transfers _amount of internal DAI from the adapter to the _wallet)\n        invokeWallet(\n            _wallet,\n            address(daiJoin),\n            0,\n            abi.encodeWithSignature(\"join(address,uint256)\", address(_wallet), _amount)\n        );\n        // Approve the pot to take out (internal) DAI from the wallet\u0027s balance in the vat\n        grantVatAccess(_wallet, address(pot));\n        // Compute the pie value in the pot\n        uint256 pie = _amount.mul(RAY) / pot.chi();\n        // Join the pie value to the pot\n        invokeWallet(_wallet, address(pot), 0, abi.encodeWithSignature(\"join(uint256)\", pie));\n        // Emitting event\n        emit InvestmentAdded(_wallet, address(daiToken), _amount, 0);\n    }\n\n    /**\n    * @notice Lets the wallet owner withdraw MCD DAI from the DSR pot.\n    * @param _wallet The target wallet.\n    * @param _amount The amount of DAI to withdraw.\n    */\n    function exitDsr(\n        address _wallet,\n        uint256 _amount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        // Execute drip to count the savings accumulated until this moment\n        pot.drip();\n        // Calculates the pie value in the pot equivalent to the DAI wad amount\n        uint256 pie = _amount.mul(RAY) / pot.chi();\n        // Exit DAI from the pot\n        invokeWallet(_wallet, address(pot), 0, abi.encodeWithSignature(\"exit(uint256)\", pie)\n        );\n        // Allow adapter to access the _wallet\u0027s DAI balance in the vat\n        grantVatAccess(_wallet, address(daiJoin));\n        // Check the actual balance of DAI in the vat after the pot exit\n        uint bal = vat.dai(_wallet);\n        // It is necessary to check if due to rounding the exact _amount can be exited by the adapter.\n        // Otherwise it will do the maximum DAI balance in the vat\n        uint256 withdrawn = bal \u003e= _amount.mul(RAY) ? _amount : bal / RAY;\n        invokeWallet(\n            _wallet,\n            address(daiJoin),\n            0,\n            abi.encodeWithSignature(\"exit(address,uint256)\", address(_wallet), withdrawn)\n        );\n        // Emitting event\n        emit InvestmentRemoved(_wallet, address(daiToken), withdrawn);\n    }\n\n    /**\n    * @notice Lets the wallet owner withdraw their entire MCD DAI balance from the DSR pot.\n    * @param _wallet The target wallet.\n    */\n    function exitAllDsr(\n        address _wallet\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        // Execute drip to count the savings accumulated until this moment\n        pot.drip();\n        // Gets the total pie belonging to the _wallet\n        uint256 pie = pot.pie(_wallet);\n        // Exit DAI from the pot\n        invokeWallet(_wallet, address(pot), 0, abi.encodeWithSignature(\"exit(uint256)\", pie));\n        // Allow adapter to access the _wallet\u0027s DAI balance in the vat\n        grantVatAccess(_wallet, address(daiJoin));\n        // Exits the DAI amount corresponding to the value of pie\n        uint256 withdrawn = pot.chi().mul(pie) / RAY;\n        invokeWallet(\n            _wallet,\n            address(daiJoin),\n            0,\n            abi.encodeWithSignature(\"exit(address,uint256)\", address(_wallet), withdrawn)\n        );\n        // Emitting event\n        emit InvestmentRemoved(_wallet, address(daiToken), withdrawn);\n    }\n\n    /**\n    * @notice Returns the amount of DAI currently held in the DSR pot.\n    * @param _wallet The target wallet.\n    * @return _balance The DSR balance.\n    */\n    function dsrBalance(address _wallet) external view returns (uint256 _balance) {\n        return pot.chi().mul(pot.pie(_wallet)) / RAY;\n    }\n\n    /* ****************************************** Internal method ******************************************* */\n\n    /**\n    * @notice Grant access to the wallet\u0027s internal DAI balance in the VAT to an operator.\n    * @param _wallet The target wallet.\n    * @param _operator The grantee of the access\n    */\n    function grantVatAccess(address _wallet, address _operator) internal {\n        if (vat.can(_wallet, _operator) == 0) {\n            invokeWallet(_wallet, address(vat), 0, abi.encodeWithSignature(\"hope(address)\", _operator));\n        }\n    }\n}"},"MakerV2Loan.sol":{"content":"// Copyright (C) 2019  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./MakerV2Base.sol\";\nimport \"./IUniswapExchange.sol\";\nimport \"./IUniswapFactory.sol\";\n\n/**\n * @title MakerV2Loan\n * @notice Module to migrate old CDPs and open and manage new vaults. The vaults managed by\n * this module are directly owned by the module. This is to prevent a compromised wallet owner\n * from being able to use `TransferManager.callContract()` to transfer ownership of a vault\n * (a type of asset NOT protected by a wallet\u0027s daily limit) to another account.\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\nabstract contract MakerV2Loan is MakerV2Base {\n\n    bytes4 private constant IS_NEW_VERSION = bytes4(keccak256(\"isNewVersion(address)\"));\n\n    // The address of the MKR token\n    GemLike internal mkrToken;\n    // The address of the WETH token\n    GemLike internal wethToken;\n    // The address of the WETH Adapter\n    JoinLike internal wethJoin;\n    // The address of the Jug\n    JugLike internal jug;\n    // The address of the Vault Manager (referred to as \u0027CdpManager\u0027 to match Maker\u0027s naming)\n    ManagerLike internal cdpManager;\n    // The address of the SCD Tub\n    SaiTubLike internal tub;\n    // The Maker Registry in which all supported collateral tokens and their adapters are stored\n    IMakerRegistry internal makerRegistry;\n    // The Uniswap Exchange contract for DAI\n    IUniswapExchange internal daiUniswap;\n    // The Uniswap Exchange contract for MKR\n    IUniswapExchange internal mkrUniswap;\n    // Mapping [wallet][ilk] -\u003e loanId, that keeps track of cdp owners\n    // while also enforcing a maximum of one loan per token (ilk) and per wallet\n    // (which will make future upgrades of the module easier)\n    mapping(address =\u003e mapping(bytes32 =\u003e bytes32)) public loanIds;\n    // Lock used by nonReentrant()\n    bool private _notEntered = true;\n\n    // ****************** Events *************************** //\n\n    // Vault management events\n    event LoanOpened(\n        address indexed _wallet,\n        bytes32 indexed _loanId,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _debtToken,\n        uint256 _debtAmount\n    );\n    event LoanAcquired(address indexed _wallet, bytes32 indexed _loanId);\n    event LoanClosed(address indexed _wallet, bytes32 indexed _loanId);\n    event CollateralAdded(address indexed _wallet, bytes32 indexed _loanId, address _collateral, uint256 _collateralAmount);\n    event CollateralRemoved(address indexed _wallet, bytes32 indexed _loanId, address _collateral, uint256 _collateralAmount);\n    event DebtAdded(address indexed _wallet, bytes32 indexed _loanId, address _debtToken, uint256 _debtAmount);\n    event DebtRemoved(address indexed _wallet, bytes32 indexed _loanId, address _debtToken, uint256 _debtAmount);\n\n\n    // *************** Modifiers *************************** //\n\n    /**\n     * @notice Prevents call reentrancy\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"MV2: reentrant call\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n    }\n\n    modifier onlyNewVersion() {\n        (bool success, bytes memory res) = msg.sender.call(abi.encodeWithSignature(\"isNewVersion(address)\", address(this)));\n        require(success \u0026\u0026 abi.decode(res, (bytes4)) == IS_NEW_VERSION , \"MV2: not a new version\");\n        _;\n    }\n\n    // *************** Constructor ********************** //\n\n    constructor(\n        JugLike _jug,\n        IMakerRegistry _makerRegistry,\n        IUniswapFactory _uniswapFactory\n    )\n        public\n    {\n        cdpManager = ScdMcdMigrationLike(scdMcdMigration).cdpManager();\n        tub = ScdMcdMigrationLike(scdMcdMigration).tub();\n        wethJoin = ScdMcdMigrationLike(scdMcdMigration).wethJoin();\n        wethToken = wethJoin.gem();\n        mkrToken = tub.gov();\n        jug = _jug;\n        makerRegistry = _makerRegistry;\n        daiUniswap = IUniswapExchange(_uniswapFactory.getExchange(address(daiToken)));\n        mkrUniswap = IUniswapExchange(_uniswapFactory.getExchange(address(mkrToken)));\n        // Authorize daiJoin to exit DAI from the module\u0027s internal balance in the vat\n        vat.hope(address(daiJoin));\n    }\n\n    // *************** External/Public Functions ********************* //\n\n    /* ********************************** Implementation of Loan ************************************* */\n\n   /**\n     * @notice Opens a collateralized loan.\n     * @param _wallet The target wallet.\n     * @param _collateral The token used as a collateral.\n     * @param _collateralAmount The amount of collateral token provided.\n     * @param _debtToken The token borrowed (must be the address of the DAI contract).\n     * @param _debtAmount The amount of tokens borrowed.\n     * @return _loanId The ID of the created vault.\n     */\n    function openLoan(\n        address _wallet,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _debtToken,\n        uint256 _debtAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n        returns (bytes32 _loanId)\n    {\n        verifySupportedCollateral(_collateral);\n        require(_debtToken == address(daiToken), \"MV2: debt token not DAI\");\n        _loanId = bytes32(openVault(_wallet, _collateral, _collateralAmount, _debtAmount));\n        emit LoanOpened(_wallet, _loanId, _collateral, _collateralAmount, _debtToken, _debtAmount);\n    }\n\n    /**\n     * @notice Adds collateral to a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     * @param _collateral The token used as a collateral.\n     * @param _collateralAmount The amount of collateral to add.\n     */\n    function addCollateral(\n        address _wallet,\n        bytes32 _loanId,\n        address _collateral,\n        uint256 _collateralAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        verifyLoanOwner(_wallet, _loanId);\n        addCollateral(_wallet, uint256(_loanId), _collateralAmount);\n        emit CollateralAdded(_wallet, _loanId, _collateral, _collateralAmount);\n    }\n\n    /**\n     * @notice Removes collateral from a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     * @param _collateral The token used as a collateral.\n     * @param _collateralAmount The amount of collateral to remove.\n     */\n    function removeCollateral(\n        address _wallet,\n        bytes32 _loanId,\n        address _collateral,\n        uint256 _collateralAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        verifyLoanOwner(_wallet, _loanId);\n        removeCollateral(_wallet, uint256(_loanId), _collateralAmount);\n        emit CollateralRemoved(_wallet, _loanId, _collateral, _collateralAmount);\n    }\n\n    /**\n     * @notice Increases the debt by borrowing more token from a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     * @param _debtToken The token borrowed (must be the address of the DAI contract).\n     * @param _debtAmount The amount of token to borrow.\n     */\n    function addDebt(\n        address _wallet,\n        bytes32 _loanId,\n        address _debtToken,\n        uint256 _debtAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        verifyLoanOwner(_wallet, _loanId);\n        addDebt(_wallet, uint256(_loanId), _debtAmount);\n        emit DebtAdded(_wallet, _loanId, _debtToken, _debtAmount);\n    }\n\n    /**\n     * @notice Decreases the debt by repaying some token from a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     * @param _debtToken The token to repay (must be the address of the DAI contract).\n     * @param _debtAmount The amount of token to repay.\n     */\n    function removeDebt(\n        address _wallet,\n        bytes32 _loanId,\n        address _debtToken,\n        uint256 _debtAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        verifyLoanOwner(_wallet, _loanId);\n        updateStabilityFee(uint256(_loanId));\n        removeDebt(_wallet, uint256(_loanId), _debtAmount);\n        emit DebtRemoved(_wallet, _loanId, _debtToken, _debtAmount);\n    }\n\n    /**\n     * @notice Closes a collateralized loan by repaying all debts (plus interest) and redeeming all collateral.\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     */\n    function closeLoan(\n        address _wallet,\n        bytes32 _loanId\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        verifyLoanOwner(_wallet, _loanId);\n        updateStabilityFee(uint256(_loanId));\n        closeVault(_wallet, uint256(_loanId));\n        emit LoanClosed(_wallet, _loanId);\n    }\n\n    /* *************************************** Other vault methods ***************************************** */\n\n    /**\n     * @notice Lets a vault owner transfer their vault from their wallet to the present module so the vault\n     * can be managed by the module.\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     */\n    function acquireLoan(\n        address _wallet,\n        bytes32 _loanId\n    )\n        external\n        nonReentrant\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        require(cdpManager.owns(uint256(_loanId)) == _wallet, \"MV2: wrong vault owner\");\n        // Transfer the vault from the wallet to the module\n        invokeWallet(\n            _wallet,\n            address(cdpManager),\n            0,\n            abi.encodeWithSignature(\"give(uint256,address)\", uint256(_loanId), address(this))\n        );\n        require(cdpManager.owns(uint256(_loanId)) == address(this), \"MV2: failed give\");\n        // Mark the incoming vault as belonging to the wallet (or merge it into the existing vault if there is one)\n        assignLoanToWallet(_wallet, _loanId);\n        emit LoanAcquired(_wallet, _loanId);\n    }\n\n    /**\n     * @notice Lets a future upgrade of this module transfer a vault to itself\n     * @param _wallet The target wallet.\n     * @param _loanId The ID of the target vault.\n     */\n    function giveVault(\n        address _wallet,\n        bytes32 _loanId\n    )\n        external\n        onlyWalletFeature(_wallet)\n        onlyNewVersion\n        onlyWhenUnlocked(_wallet)\n    {\n        verifyLoanOwner(_wallet, _loanId);\n        cdpManager.give(uint256(_loanId), msg.sender);\n        clearLoanOwner(_wallet, _loanId);\n    }\n\n    /* ************************************** Internal Functions ************************************** */\n\n    function toInt(uint256 _x) internal pure returns (int _y) {\n        _y = int(_x);\n        require(_y \u003e= 0, \"MV2: int overflow\");\n    }\n\n    function assignLoanToWallet(address _wallet, bytes32 _loanId) internal returns (bytes32 _assignedLoanId) {\n        bytes32 ilk = cdpManager.ilks(uint256(_loanId));\n        // Check if the user already holds a vault in the MakerV2Manager\n        bytes32 existingLoanId = loanIds[_wallet][ilk];\n        if (existingLoanId \u003e 0) {\n            // Merge the new loan into the existing loan\n            cdpManager.shift(uint256(_loanId), uint256(existingLoanId));\n            return existingLoanId;\n        }\n        // Record the new vault as belonging to the wallet\n        loanIds[_wallet][ilk] = _loanId;\n        return _loanId;\n    }\n\n    function clearLoanOwner(address _wallet, bytes32 _loanId) internal {\n        delete loanIds[_wallet][cdpManager.ilks(uint256(_loanId))];\n    }\n\n    function verifyLoanOwner(address _wallet, bytes32 _loanId) internal view {\n        require(loanIds[_wallet][cdpManager.ilks(uint256(_loanId))] == _loanId, \"MV2: unauthorized loanId\");\n    }\n\n    function verifySupportedCollateral(address _collateral) internal view {\n        if (_collateral != ETH_TOKEN) {\n            (bool collateralSupported,,,) = makerRegistry.collaterals(_collateral);\n            require(collateralSupported, \"MV2: unsupported collateral\");\n        }\n    }\n\n    function joinCollateral(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _collateralAmount,\n        bytes32 _ilk\n    )\n        internal\n    {\n        // Get the adapter and collateral token for the vault\n        (JoinLike gemJoin, GemLike collateral) = makerRegistry.getCollateral(_ilk);\n        // Convert ETH to WETH if needed\n        if (gemJoin == wethJoin) {\n            invokeWallet(_wallet, address(wethToken), _collateralAmount, abi.encodeWithSignature(\"deposit()\"));\n        }\n        // Send the collateral to the module\n        invokeWallet(\n            _wallet,\n            address(collateral),\n            0,\n            abi.encodeWithSignature(\"transfer(address,uint256)\", address(this), _collateralAmount)\n        );\n        // Approve the adapter to pull the collateral from the module\n        collateral.approve(address(gemJoin), _collateralAmount);\n        // Join collateral to the adapter. The first argument to `join` is the address that *technically* owns the vault\n        gemJoin.join(cdpManager.urns(_cdpId), _collateralAmount);\n    }\n\n    function joinDebt(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _debtAmount //  art.mul(rate).div(RAY) === [wad]*[ray]/[ray]=[wad]\n    )\n        internal\n    {\n        // Send the DAI to the module\n        invokeWallet(\n            _wallet,\n            address(daiToken),\n            0,\n            abi.encodeWithSignature(\"transfer(address,uint256)\", address(this), _debtAmount)\n        );\n        // Approve the DAI adapter to burn DAI from the module\n        daiToken.approve(address(daiJoin), _debtAmount);\n        // Join DAI to the adapter. The first argument to `join` is the address that *technically* owns the vault\n        // To avoid rounding issues, we substract one wei to the amount joined\n        daiJoin.join(cdpManager.urns(_cdpId), _debtAmount.sub(1));\n    }\n\n    function drawAndExitDebt(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _debtAmount,\n        uint256 _collateralAmount,\n        bytes32 _ilk\n    )\n        internal\n    {\n        // Get the accumulated rate for the collateral type\n        (, uint rate,,,) = vat.ilks(_ilk);\n        // Express the debt in the RAD units used internally by the vat\n        uint daiDebtInRad = _debtAmount.mul(RAY);\n        // Lock the collateral and draw the debt. To avoid rounding issues we add an extra wei of debt\n        cdpManager.frob(_cdpId, toInt(_collateralAmount), toInt(daiDebtInRad.div(rate) + 1));\n        // Transfer the (internal) DAI debt from the cdp\u0027s urn to the module.\n        cdpManager.move(_cdpId, address(this), daiDebtInRad);\n        // Mint the DAI token and exit it to the user\u0027s wallet\n        daiJoin.exit(_wallet, _debtAmount);\n    }\n\n    function updateStabilityFee(\n        uint256 _cdpId\n    )\n        internal\n    {\n        jug.drip(cdpManager.ilks(_cdpId));\n    }\n\n    function debt(\n        uint256 _cdpId\n    )\n        internal\n        view\n        returns (uint256 _fullRepayment, uint256 _maxNonFullRepayment)\n    {\n        bytes32 ilk = cdpManager.ilks(_cdpId);\n        (, uint256 art) = vat.urns(ilk, cdpManager.urns(_cdpId));\n        if (art \u003e 0) {\n            (, uint rate,,, uint dust) = vat.ilks(ilk);\n            _maxNonFullRepayment = art.mul(rate).sub(dust).div(RAY);\n            _fullRepayment = art.mul(rate).div(RAY)\n                .add(1) // the amount approved is 1 wei more than the amount repaid, to avoid rounding issues\n                .add(art-art.mul(rate).div(RAY).mul(RAY).div(rate)); // adding 1 extra wei if further rounding issues are expected\n        }\n    }\n\n    function collateral(\n        uint256 _cdpId\n    )\n        internal\n        view\n        returns (uint256 _collateralAmount)\n    {\n        (_collateralAmount,) = vat.urns(cdpManager.ilks(_cdpId), cdpManager.urns(_cdpId));\n    }\n\n    function verifyValidRepayment(\n        uint256 _cdpId,\n        uint256 _debtAmount\n    )\n        internal\n        view\n    {\n        (uint256 fullRepayment, uint256 maxRepayment) = debt(_cdpId);\n        require(_debtAmount \u003c= maxRepayment || _debtAmount == fullRepayment, \"MV2: repay less or full\");\n    }\n\n     /**\n     * @notice Lets the owner of a wallet open a new vault. The owner must have enough collateral\n     * in their wallet.\n     * @param _wallet The target wallet\n     * @param _collateral The token to use as collateral in the vault.\n     * @param _collateralAmount The amount of collateral to lock in the vault.\n     * @param _debtAmount The amount of DAI to draw from the vault\n     * @return _cdpId The id of the created vault.\n     */\n    function openVault(\n        address _wallet,\n        address _collateral,\n        uint256 _collateralAmount,\n        uint256 _debtAmount\n    )\n        internal\n        returns (uint256 _cdpId)\n    {\n        // Continue with WETH as collateral instead of ETH if needed\n        if (_collateral == ETH_TOKEN) {\n            _collateral = address(wethToken);\n        }\n        // Get the ilk for the collateral\n        bytes32 ilk = makerRegistry.getIlk(_collateral);\n        // Open a vault if there isn\u0027t already one for the collateral type (the vault owner will effectively be the module)\n        _cdpId = uint256(loanIds[_wallet][ilk]);\n        if (_cdpId == 0) {\n            _cdpId = cdpManager.open(ilk, address(this));\n            // Mark the vault as belonging to the wallet\n            loanIds[_wallet][ilk] = bytes32(_cdpId);\n        }\n        // Move the collateral from the wallet to the vat\n        joinCollateral(_wallet, _cdpId, _collateralAmount, ilk);\n        // Draw the debt and exit it to the wallet\n        if (_debtAmount \u003e 0) {\n            drawAndExitDebt(_wallet, _cdpId, _debtAmount, _collateralAmount, ilk);\n        }\n    }\n\n    /**\n     * @notice Lets the owner of a vault add more collateral to their vault. The owner must have enough of the\n     * collateral token in their wallet.\n     * @param _wallet The target wallet\n     * @param _cdpId The id of the vault.\n     * @param _collateralAmount The amount of collateral to add to the vault.\n     */\n    function addCollateral(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _collateralAmount\n    )\n        internal\n    {\n        // Move the collateral from the wallet to the vat\n        joinCollateral(_wallet, _cdpId, _collateralAmount, cdpManager.ilks(_cdpId));\n        // Lock the collateral\n        cdpManager.frob(_cdpId, toInt(_collateralAmount), 0);\n    }\n\n    /**\n     * @notice Lets the owner of a vault remove some collateral from their vault\n     * @param _wallet The target wallet\n     * @param _cdpId The id of the vault.\n     * @param _collateralAmount The amount of collateral to remove from the vault.\n     */\n    function removeCollateral(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _collateralAmount\n    )\n        internal\n    {\n        // Unlock the collateral\n        cdpManager.frob(_cdpId, -toInt(_collateralAmount), 0);\n        // Transfer the (internal) collateral from the cdp\u0027s urn to the module.\n        cdpManager.flux(_cdpId, address(this), _collateralAmount);\n        // Get the adapter for the collateral\n        (JoinLike gemJoin,) = makerRegistry.getCollateral(cdpManager.ilks(_cdpId));\n        // Exit the collateral from the adapter.\n        gemJoin.exit(_wallet, _collateralAmount);\n        // Convert WETH to ETH if needed\n        if (gemJoin == wethJoin) {\n            invokeWallet(_wallet, address(wethToken), 0, abi.encodeWithSignature(\"withdraw(uint256)\", _collateralAmount));\n        }\n    }\n\n    /**\n     * @notice Lets the owner of a vault draw more DAI from their vault.\n     * @param _wallet The target wallet\n     * @param _cdpId The id of the vault.\n     * @param _amount The amount of additional DAI to draw from the vault.\n     */\n    function addDebt(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _amount\n    )\n        internal\n    {\n        // Draw and exit the debt to the wallet\n        drawAndExitDebt(_wallet, _cdpId, _amount, 0, cdpManager.ilks(_cdpId));\n    }\n\n    /**\n     * @notice Lets the owner of a vault partially repay their debt. The repayment is made up of\n     * the outstanding DAI debt plus the DAI stability fee.\n     * The method will use the user\u0027s DAI tokens in priority and will, if needed, convert the required\n     * amount of ETH to cover for any missing DAI tokens.\n     * @param _wallet The target wallet\n     * @param _cdpId The id of the vault.\n     * @param _amount The amount of DAI debt to repay.\n     */\n    function removeDebt(\n        address _wallet,\n        uint256 _cdpId,\n        uint256 _amount\n    )\n        internal\n    {\n        verifyValidRepayment(_cdpId, _amount);\n        // Move the DAI from the wallet to the vat.\n        joinDebt(_wallet, _cdpId, _amount);\n        // Get the accumulated rate for the collateral type\n        (, uint rate,,,) = vat.ilks(cdpManager.ilks(_cdpId));\n        // Repay the debt. To avoid rounding issues we reduce the repayment by one wei\n        cdpManager.frob(_cdpId, 0, -toInt(_amount.sub(1).mul(RAY).div(rate)));\n    }\n\n    /**\n     * @notice Lets the owner of a vault close their vault. The method will:\n     * 1) repay all debt and fee\n     * 2) free all collateral\n     * @param _wallet The target wallet\n     * @param _cdpId The id of the CDP.\n     */\n    function closeVault(\n        address _wallet,\n        uint256 _cdpId\n    )\n        internal\n    {\n        (uint256 fullRepayment,) = debt(_cdpId);\n        // Repay the debt\n        if (fullRepayment \u003e 0) {\n            removeDebt(_wallet, _cdpId, fullRepayment);\n        }\n        // Remove the collateral\n        uint256 ink = collateral(_cdpId);\n        if (ink \u003e 0) {\n            removeCollateral(_wallet, _cdpId, ink);\n        }\n    }\n\n}"},"MakerV2Manager.sol":{"content":"// Copyright (C) 2019  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./MakerV2Base.sol\";\nimport \"./MakerV2Invest.sol\";\nimport \"./MakerV2Loan.sol\";\n\n/**\n * @title MakerV2Manager\n * @notice Module to lock/unlock MCD DAI into/from Maker\u0027s Pot,\n * migrate old CDPs and open and manage new CDPs.\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ncontract MakerV2Manager is MakerV2Base, MakerV2Invest, MakerV2Loan {\n\n    // *************** Constructor ********************** //\n\n    constructor(\n        ILockStorage _lockStorage,\n        ScdMcdMigrationLike _scdMcdMigration,\n        PotLike _pot,\n        JugLike _jug,\n        IMakerRegistry _makerRegistry,\n        IUniswapFactory _uniswapFactory,\n        IVersionManager _versionManager\n    )\n        MakerV2Base(_lockStorage, _scdMcdMigration, _versionManager)\n        MakerV2Invest(_pot)\n        MakerV2Loan(_jug, _makerRegistry, _uniswapFactory)\n        public\n    {\n    }\n\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}