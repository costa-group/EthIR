{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"sbCommunity.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./sbTokensInterface.sol\u0027;\nimport \u0027./sbControllerInterface.sol\u0027;\nimport \u0027./sbStrongPoolInterface.sol\u0027;\nimport \u0027./sbVotesInterface.sol\u0027;\n\ncontract sbCommunity {\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n  event NewAdmin(address oldAdmin, address newAdmin);\n  event MinerRewardsPercentageUpdated(uint256 percentage);\n  event RewardsReceived(uint256 indexed day, uint256 amount);\n  event ETHMined(address indexed miner, uint256 amount, uint256 indexed day);\n  event ETHUnmined(address indexed miner, uint256 amount, uint256 indexed day);\n  event ERC20Mined(address indexed miner, address indexed token, uint256 amount, uint256 indexed day);\n  event ERC20Unmined(address indexed miner, address indexed token, uint256 amount, uint256 indexed day);\n  event Claimed(address indexed miner, uint256 amount, uint256 indexed day);\n  event ServiceAdded(address indexed service, string tag);\n  event TagAddedForService(address indexed service, string tag);\n\n  using SafeMath for uint256;\n  bool internal initDone;\n  address internal constant ETH = address(0);\n  string internal name;\n  uint256 internal minerRewardPercentage;\n\n  IERC20 internal strongToken;\n  sbTokensInterface internal sbTokens;\n  sbControllerInterface internal sbController;\n  sbStrongPoolInterface internal sbStrongPool;\n  sbVotesInterface internal sbVotes;\n  address internal sbTimelock;\n  address internal admin;\n  address internal pendingAdmin;\n\n  mapping(address =\u003e mapping(address =\u003e uint256[])) internal minerTokenDays;\n  mapping(address =\u003e mapping(address =\u003e uint256[])) internal minerTokenAmounts;\n  mapping(address =\u003e mapping(address =\u003e uint256[])) internal minerTokenMineSeconds;\n\n  mapping(address =\u003e uint256[]) internal tokenDays;\n  mapping(address =\u003e uint256[]) internal tokenAmounts;\n  mapping(address =\u003e uint256[]) internal tokenMineSeconds;\n\n  mapping(address =\u003e uint256) internal minerDayLastClaimedFor;\n  mapping(uint256 =\u003e uint256) internal dayServiceRewards;\n\n  address[] internal services;\n  mapping(address =\u003e string[]) internal serviceTags;\n\n  function init(\n    address adminAddress,\n    address sbControllerAddress,\n    address strongTokenAddress,\n    address sbTokensAddress,\n    address sbStrongPoolAddress,\n    address sbVotesAddress,\n    address sbTimelockAddress,\n    uint256 minerRewardPercent,\n    string memory communityName\n  ) public {\n    require(!initDone, \u0027init done\u0027);\n    strongToken = IERC20(strongTokenAddress);\n    sbTokens = sbTokensInterface(sbTokensAddress);\n    sbController = sbControllerInterface(sbControllerAddress);\n    sbStrongPool = sbStrongPoolInterface(sbStrongPoolAddress);\n    sbVotes = sbVotesInterface(sbVotesAddress);\n    sbTimelock = sbTimelockAddress;\n    minerRewardPercentage = minerRewardPercent;\n    name = communityName;\n    admin = adminAddress;\n\n    initDone = true;\n  }\n\n  function updateMinerRewardPercentage(uint256 percentage) external {\n    require(msg.sender == sbTimelock, \u0027not sbTimelock\u0027);\n    require(percentage \u003c= 100, \u0027greater than 100\u0027);\n    minerRewardPercentage = percentage;\n    emit MinerRewardsPercentageUpdated(percentage);\n  }\n\n  function getTokenData(address token, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    require(sbTokens.tokenAccepted(token), \u0027invalid token\u0027);\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return _getTokenData(token, day);\n  }\n\n  function serviceAccepted(address service) external view returns (bool) {\n    return _serviceExists(service);\n  }\n\n  function receiveRewards(uint256 day, uint256 amount) external {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(msg.sender == address(sbController), \u0027not sbController\u0027);\n    strongToken.transferFrom(address(sbController), address(this), amount);\n    uint256 oneHundred = 100;\n    uint256 serviceReward = oneHundred.sub(minerRewardPercentage).mul(amount).div(oneHundred);\n    (, , uint256 communityVoteSeconds) = sbVotes.getCommunityData(address(this), day);\n    if (communityVoteSeconds != 0 \u0026\u0026 serviceReward != 0) {\n      dayServiceRewards[day] = serviceReward;\n      strongToken.approve(address(sbVotes), serviceReward);\n      sbVotes.receiveServiceRewards(day, serviceReward);\n    }\n    emit RewardsReceived(day, amount.sub(serviceReward));\n  }\n\n  function getMinerRewardPercentage() external view returns (uint256) {\n    return minerRewardPercentage;\n  }\n\n  function addService(address service, string memory tag) public {\n    require(msg.sender == admin, \u0027not admin\u0027);\n    require(\n      sbStrongPool.serviceMinMined(service),\n      \u0027not min mined\u0027\n    );\n    require(service != address(0), \u0027service not zero address\u0027);\n    require(!_serviceExists(service), \u0027service exists\u0027);\n    services.push(service);\n    serviceTags[service].push(tag);\n    emit ServiceAdded(service, tag);\n  }\n\n  function getServices() public view returns (address[] memory) {\n    return services;\n  }\n\n  function getServiceTags(address service) public view returns (string[] memory) {\n    require(_serviceExists(service), \u0027invalid service\u0027);\n    return serviceTags[service];\n  }\n\n  function addTag(address service, string memory tag) public {\n    require(msg.sender == admin, \u0027not admin\u0027);\n    require(_serviceExists(service), \u0027invalid service\u0027);\n    require(!_serviceTagExists(service, tag), \u0027tag exists\u0027);\n    serviceTags[service].push(tag);\n    emit TagAddedForService(service, tag);\n  }\n\n  function setPendingAdmin(address newPendingAdmin) public {\n    require(msg.sender == admin, \u0027not admin\u0027);\n    address oldPendingAdmin = pendingAdmin;\n    pendingAdmin = newPendingAdmin;\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n  }\n\n  function acceptAdmin() public {\n    require(\n      msg.sender == pendingAdmin \u0026\u0026 msg.sender != address(0),\n      \u0027not pendingAdmin\u0027\n    );\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n    admin = pendingAdmin;\n    pendingAdmin = address(0);\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n  }\n\n  function getAdminAddressUsed() public view returns (address) {\n    return admin;\n  }\n\n  function getPendingAdminAddressUsed() public view returns (address) {\n    return pendingAdmin;\n  }\n\n  function getSbControllerAddressUsed() public view returns (address) {\n    return address(sbController);\n  }\n\n  function getStrongAddressUsed() public view returns (address) {\n    return address(strongToken);\n  }\n\n  function getSbTokensAddressUsed() public view returns (address) {\n    return address(sbTokens);\n  }\n\n  function getSbStrongPoolAddressUsed() public view returns (address) {\n    return address(sbStrongPool);\n  }\n\n  function getSbVotesAddressUsed() public view returns (address) {\n    return address(sbVotes);\n  }\n\n  function getSbTimelockAddressUsed() public view returns (address) {\n    return sbTimelock;\n  }\n\n  function getDayServiceRewards(uint256 day) public view returns (uint256) {\n    return dayServiceRewards[day];\n  }\n\n  function getName() public view returns (string memory) {\n    return name;\n  }\n\n  function getCurrentDay() public view returns (uint256) {\n    return _getCurrentDay();\n  }\n\n  function mineETH() public payable {\n    require(msg.value \u003e 0, \u0027zero\u0027);\n    require(sbTokens.tokenAccepted(ETH), \u0027invalid token\u0027);\n    uint256 currentDay = _getCurrentDay();\n    uint256 startDay = sbController.getStartDay();\n    uint256 MAX_YEARS = sbController.getMaxYears();\n    uint256 year = _getYearDayIsIn(currentDay, startDay);\n    require(year \u003c= MAX_YEARS, \u0027invalid year\u0027);\n    require(sbStrongPool.minerMinMined(msg.sender), \u0027not min mined\u0027);\n    _updateMinerTokenData(msg.sender, ETH, msg.value, true, currentDay);\n    _updateTokenData(ETH, msg.value, true, currentDay);\n    emit ETHMined(msg.sender, msg.value, currentDay);\n  }\n\n  function mineERC20(address token, uint256 amount) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(token != ETH, \u0027no mine ETH\u0027);\n    require(sbTokens.tokenAccepted(token), \u0027invalid token\u0027);\n    IERC20(token).transferFrom(msg.sender, address(this), amount);\n    uint256 currentDay = _getCurrentDay();\n    uint256 startDay = sbController.getStartDay();\n    uint256 MAX_YEARS = sbController.getMaxYears();\n    uint256 year = _getYearDayIsIn(currentDay, startDay);\n    require(year \u003c= MAX_YEARS, \u0027invalid year\u0027);\n    require(sbStrongPool.minerMinMined(msg.sender), \u0027not min mined\u0027);\n    _updateMinerTokenData(msg.sender, token, amount, true, currentDay);\n    _updateTokenData(token, amount, true, currentDay);\n    emit ERC20Mined(msg.sender, token, amount, currentDay);\n  }\n\n  function unmine(address token, uint256 amount) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(sbTokens.tokenAccepted(token), \u0027invalid token\u0027);\n\n    uint256 currentDay = _getCurrentDay();\n    _updateMinerTokenData(msg.sender, token, amount, false, currentDay);\n    _updateTokenData(token, amount, false, currentDay);\n\n    if (token == ETH) {\n      msg.sender.transfer(amount);\n      emit ETHUnmined(msg.sender, amount, currentDay);\n    } else {\n      IERC20(token).transfer(msg.sender, amount);\n      emit ERC20Unmined(msg.sender, token, amount, currentDay);\n    }\n  }\n\n  function claimAll() public {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[msg.sender];\n    require(currentDay \u003e dayLastClaimedFor.add(1), \u0027already claimed\u0027);\n    require(sbTokens.upToDate(), \u0027need token prices\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    _claim(currentDay, msg.sender, dayLastClaimedFor);\n  }\n\n  function claimUpTo(uint256 day) public {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[msg.sender];\n    require(day \u003e dayLastClaimedFor.add(1), \u0027already claimed\u0027);\n    require(sbTokens.upToDate(), \u0027need token prices\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    _claim(day, msg.sender, dayLastClaimedFor);\n  }\n\n  function getRewardsDueAll(address miner) public view returns (uint256) {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[miner] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[miner];\n    if (!(currentDay \u003e dayLastClaimedFor.add(1))) {\n      return 0;\n    }\n    require(sbTokens.upToDate(), \u0027need token prices\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getRewardsDue(currentDay, miner, dayLastClaimedFor);\n  }\n\n  function getRewardsDueUpTo(uint256 day, address miner) public view returns (uint256) {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[miner] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[miner];\n    if (!(day \u003e dayLastClaimedFor.add(1))) {\n      return 0;\n    }\n    require(sbTokens.upToDate(), \u0027need token prices\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getRewardsDue(day, miner, dayLastClaimedFor);\n  }\n\n\n\n  function getMinerDayLastClaimedFor(address miner) public view returns (uint256) {\n    return minerDayLastClaimedFor[miner] == 0 ? sbController.getStartDay().sub(1) : minerDayLastClaimedFor[miner];\n  }\n\n  function getMinerTokenData(\n    address miner,\n    address token,\n    uint256 day\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    require(sbTokens.tokenAccepted(token), \u0027invalid token\u0027);\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return _getMinerTokenData(miner, token, day);\n  }\n\n  function _getMinerTokenData(\n    address miner,\n    address token,\n    uint256 day\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256[] memory _Days = minerTokenDays[miner][token];\n    uint256[] memory _Amounts = minerTokenAmounts[miner][token];\n    uint256[] memory _UnitSeconds = minerTokenMineSeconds[miner][token];\n    return _get(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _getTokenData(address token, uint256 day)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256[] memory _Days = tokenDays[token];\n    uint256[] memory _Amounts = tokenAmounts[token];\n    uint256[] memory _UnitSeconds = tokenMineSeconds[token];\n    return _get(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _updateMinerTokenData(\n    address miner,\n    address token,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256[] storage _Days = minerTokenDays[miner][token];\n    uint256[] storage _Amounts = minerTokenAmounts[miner][token];\n    uint256[] storage _UnitSeconds = minerTokenMineSeconds[miner][token];\n    _update(_Days, _Amounts, _UnitSeconds, amount, adding, currentDay);\n  }\n\n  function _updateTokenData(\n    address token,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256[] storage _Days = tokenDays[token];\n    uint256[] storage _Amounts = tokenAmounts[token];\n    uint256[] storage _UnitSeconds = tokenMineSeconds[token];\n    _update(_Days, _Amounts, _UnitSeconds, amount, adding, currentDay);\n  }\n\n  function _get(\n    uint256[] memory _Days,\n    uint256[] memory _Amounts,\n    uint256[] memory _UnitSeconds,\n    uint256 day\n  )\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 len = _Days.length;\n    if (len == 0) {\n      return (day, 0, 0);\n    }\n    if (day \u003c _Days[0]) {\n      return (day, 0, 0);\n    }\n    uint256 lastIndex = len.sub(1);\n    uint256 lastMinedDay = _Days[lastIndex];\n    if (day == lastMinedDay) {\n      return (day, _Amounts[lastIndex], _UnitSeconds[lastIndex]);\n    } else if (day \u003e lastMinedDay) {\n      return (day, _Amounts[lastIndex], _Amounts[lastIndex].mul(1 days));\n    }\n    return _find(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _find(\n    uint256[] memory _Days,\n    uint256[] memory _Amounts,\n    uint256[] memory _UnitSeconds,\n    uint256 day\n  )\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 left = 0;\n    uint256 right = _Days.length.sub(1);\n    uint256 middle = right.add(left).div(2);\n    while (left \u003c right) {\n      if (_Days[middle] == day) {\n        return (day, _Amounts[middle], _UnitSeconds[middle]);\n      } else if (_Days[middle] \u003e day) {\n        if (middle \u003e 0 \u0026\u0026 _Days[middle.sub(1)] \u003c day) {\n          return (day, _Amounts[middle.sub(1)], _Amounts[middle.sub(1)].mul(1 days));\n        }\n        if (middle == 0) {\n          return (day, 0, 0);\n        }\n        right = middle.sub(1);\n      } else if (_Days[middle] \u003c day) {\n        if (middle \u003c _Days.length.sub(1) \u0026\u0026 _Days[middle.add(1)] \u003e day) {\n          return (day, _Amounts[middle], _Amounts[middle].mul(1 days));\n        }\n        left = middle.add(1);\n      }\n      middle = right.add(left).div(2);\n    }\n    if (_Days[middle] != day) {\n      return (day, 0, 0);\n    } else {\n      return (day, _Amounts[middle], _UnitSeconds[middle]);\n    }\n  }\n\n  function _update(\n    uint256[] storage _Days,\n    uint256[] storage _Amounts,\n    uint256[] storage _UnitSeconds,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256 len = _Days.length;\n    uint256 secondsInADay = 1 days;\n    uint256 secondsSinceStartOfDay = block.timestamp % secondsInADay;\n    uint256 secondsUntilEndOfDay = secondsInADay.sub(secondsSinceStartOfDay);\n\n    if (len == 0) {\n      if (adding) {\n        _Days.push(currentDay);\n        _Amounts.push(amount);\n        _UnitSeconds.push(amount.mul(secondsUntilEndOfDay));\n      } else {\n        require(false, \u00271: not enough mine\u0027);\n      }\n    } else {\n      uint256 lastIndex = len.sub(1);\n      uint256 lastMinedDay = _Days[lastIndex];\n      uint256 lastMinedAmount = _Amounts[lastIndex];\n      uint256 lastUnitSeconds = _UnitSeconds[lastIndex];\n\n      uint256 newAmount;\n      uint256 newUnitSeconds;\n\n      if (lastMinedDay == currentDay) {\n        if (adding) {\n          newAmount = lastMinedAmount.add(amount);\n          newUnitSeconds = lastUnitSeconds.add(amount.mul(secondsUntilEndOfDay));\n        } else {\n          require(lastMinedAmount \u003e= amount, \u00272: not enough mine\u0027);\n          newAmount = lastMinedAmount.sub(amount);\n          newUnitSeconds = lastUnitSeconds.sub(amount.mul(secondsUntilEndOfDay));\n        }\n        _Amounts[lastIndex] = newAmount;\n        _UnitSeconds[lastIndex] = newUnitSeconds;\n      } else {\n        if (adding) {\n          newAmount = lastMinedAmount.add(amount);\n          newUnitSeconds = lastMinedAmount.mul(1 days).add(amount.mul(secondsUntilEndOfDay));\n        } else {\n          require(lastMinedAmount \u003e= amount, \u00273: not enough mine\u0027);\n          newAmount = lastMinedAmount.sub(amount);\n          newUnitSeconds = lastMinedAmount.mul(1 days).sub(amount.mul(secondsUntilEndOfDay));\n        }\n        _Days.push(currentDay);\n        _Amounts.push(newAmount);\n        _UnitSeconds.push(newUnitSeconds);\n      }\n    }\n  }\n\n  function _claim(\n    uint256 upToDay,\n    address miner,\n    uint256 dayLastClaimedFor\n  ) internal {\n    uint256 rewards = _getRewardsDue(upToDay, miner, dayLastClaimedFor);\n    require(rewards \u003e 0, \u0027no rewards\u0027);\n    minerDayLastClaimedFor[miner] = upToDay.sub(1);\n    strongToken.approve(address(sbStrongPool), rewards);\n    sbStrongPool.mineFor(miner, rewards);\n    emit Claimed(miner, rewards, _getCurrentDay());\n  }\n\n  function _getRewardsDue(\n    uint256 upToDay,\n    address miner,\n    uint256 dayLastClaimedFor\n  ) internal view returns (uint256) {\n    address[] memory tokens = sbTokens.getTokens();\n    uint256 rewards;\n    for (uint256 day = dayLastClaimedFor.add(1); day \u003c= upToDay.sub(1); day++) {\n      uint256 communityDayMineSecondsUSD = sbController.getCommunityDayMineSecondsUSD(address(this), day);\n      if (communityDayMineSecondsUSD == 0) {\n        continue;\n      }\n      uint256 minerDayMineSecondsUSD = 0;\n      uint256[] memory tokenPrices = sbTokens.getTokenPrices(day);\n      for (uint256 i = 0; i \u003c tokens.length; i++) {\n        address token = tokens[i];\n        (, , uint256 minerMineSeconds) = _getMinerTokenData(miner, token, day);\n        uint256 amount = minerMineSeconds.mul(tokenPrices[i]).div(1e18);\n        minerDayMineSecondsUSD = minerDayMineSecondsUSD.add(amount);\n      }\n      uint256 communityDayRewards = sbController.getCommunityDayRewards(address(this), day).sub(dayServiceRewards[day]);\n      uint256 amount = communityDayRewards.mul(minerDayMineSecondsUSD).div(communityDayMineSecondsUSD);\n      rewards = rewards.add(amount);\n    }\n    return rewards;\n  }\n\n  function _serviceExists(address service) internal view returns (bool) {\n    return serviceTags[service].length \u003e 0;\n  }\n\n  function _serviceTagExists(address service, string memory tag) internal view returns (bool) {\n    for (uint256 i = 0; i \u003c serviceTags[service].length; i++) {\n      if (keccak256(abi.encode(tag)) == keccak256(abi.encode(serviceTags[service][i]))) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _getYearDayIsIn(uint256 day, uint256 startDay) internal pure returns (uint256) {\n    return day.sub(startDay).div(366).add(1); // dividing by 366 makes day 1 and 365 be in year 1\n  }\n\n  function _getCurrentDay() internal view returns (uint256) {\n    return block.timestamp.div(1 days).add(1);\n  }\n}\n"},"sbControllerInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbControllerInterface {\n  function getDayMineSecondsUSDTotal(uint256 day) external view returns (uint256);\n\n  function getCommunityDayMineSecondsUSD(address community, uint256 day) external view returns (uint256);\n\n  function getCommunityDayRewards(address community, uint256 day) external view returns (uint256);\n\n  function getStartDay() external view returns (uint256);\n\n  function getMaxYears() external view returns (uint256);\n\n  function getStrongPoolDailyRewards(uint256 day) external view returns (uint256);\n\n  function communityAccepted(address community) external view returns (bool);\n\n  function getCommunities() external view returns (address[] memory);\n\n  function upToDate() external view returns (bool);\n}\n"},"sbStrongPoolInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbStrongPoolInterface {\n  function serviceMinMined(address miner) external view returns (bool);\n\n  function minerMinMined(address miner) external view returns (bool);\n\n  function mineFor(address miner, uint256 amount) external;\n\n  function getMineData(uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function receiveRewards(uint256 day, uint256 amount) external;\n}\n"},"sbTokensInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbTokensInterface {\n  function getTokens() external view returns (address[] memory);\n\n  function getTokenPrices(uint256 day) external view returns (uint256[] memory);\n\n  function tokenAccepted(address token) external view returns (bool);\n\n  function upToDate() external view returns (bool);\n\n  function getTokenPrice(address token, uint256 day) external view returns (uint256);\n}\n"},"sbVotesInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbVotesInterface {\n  function getCommunityData(address community, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n  function receiveServiceRewards(uint256 day, uint256 amount) external;\n\n  function receiveVoterRewards(uint256 day, uint256 amount) external;\n\n  function updateVotes(\n    address staker,\n    uint256 rawAmount,\n    bool adding\n  ) external;\n}\n"}}