{"LionToken.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.7.0;\n\nimport \"./SafeMath.sol\";\n\n/**\n    Cryptoenter - Blockchain based based infrastructure for digital banking + social network for investors\n    build date: August 31 2020 @ 19:41:37\n\n    Copyright (C) 2017 - 2020 Smart Block Laboratory Inc.\n\n        Version: 0.4.1\n        Build: 2020.1980\n\n    May the Force be with us !\n    Alquimista\n\n    \u003e. Launch (Y/N) - Y\n    \u003e. Hello World!\n    \u003e. _\n*/\ncontract Lion {\n\n    using SafeMath for uint256;\n\n    string public constant name = \"Cryptoenter LION token\";\n\n    string public constant symbol = \"LION\";\n\n    uint8 public constant decimals = 8;\n\n    uint256 public constant decimals_multiplier = 100_000_000;\n\n    address adminAddress = address(0x0);\n\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n    event Transfer(address indexed from, address indexed to, uint tokens);\n\n    mapping(address =\u003e uint256) balances;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) allowed;\n\n    mapping(address =\u003e bool) tempNotLockedAccounts;\n\n    uint256 totalSupply_;\n\n    uint temporarilyLockDate = 0;\n\n    bool suspended = false;\n\n    mapping(address =\u003e bool) suspendedAccounts;\n\n    struct Issue {\n        uint availableFromTimestamp;\n        uint256 amount;\n        bool complete;\n    }\n\n    struct IssueStage {\n        uint currentN;\n        uint count30;\n        uint count;\n    }\n\n    mapping(uint =\u003e Issue[3]) issuePeriods;\n\n    IssueStage issueStage = IssueStage(0, 0, 0);\n\n    modifier enabled() {\n        require(((block.timestamp \u003e temporarilyLockDate || tempNotLockedAccounts[msg.sender] == true) \u0026\u0026 !suspended \u0026\u0026 suspendedAccounts[msg.sender] != true) || msg.sender == adminAddress);\n        _;\n    }\n\n    /**\n    * @dev Fix for the ERC20 short address attack.\n    */\n    modifier onlyPayloadSize(uint size) {\n        require(msg.data.length \u003e= size + 4);\n        _;\n    }\n\n    constructor(uint256 totalSupply, uint lockDate) public {\n        totalSupply_ = totalSupply.mul(decimals_multiplier);\n        temporarilyLockDate = lockDate;\n        balances[msg.sender] = totalSupply_;\n        adminAddress = msg.sender;\n\n//        167099833\n//        issuePeriods[0][0] = Issue(1599868800, 128538333, false);\n//        issuePeriods[0][1] = Issue(1599868800, 25707667, false);\n//        issuePeriods[0][2] = Issue(1599868800, 12853833, false);\n\n        issuePeriods[0][0] = Issue(1638316800, 403815084, false);\n        issuePeriods[0][1] = Issue(1633046400, 80763017, false);\n        issuePeriods[0][2] = Issue(1633046400, 40381508, false);\n\n        issuePeriods[1][0] = Issue(1701648000, 1268622500, false);\n        issuePeriods[1][1] = Issue(1696377600, 253724500, false);\n        issuePeriods[1][2] = Issue(1696377600, 126862250, false);\n\n        issuePeriods[2][0] = Issue(1764547200, 3985495127, false);\n        issuePeriods[2][1] = Issue(1759276800, 797099025, false);\n        issuePeriods[2][2] = Issue(1759276800, 398549513, false);\n\n        issuePeriods[3][0] = Issue(1827619200, 12520802212, false);\n        issuePeriods[3][1] = Issue(1822348800, 2504160442, false);\n        issuePeriods[3][2] = Issue(1822348800, 1252080221, false);\n\n        issuePeriods[4][0] = Issue(1890950400, 39335260244, false);\n        issuePeriods[4][1] = Issue(1885680000, 7867052049, false);\n        issuePeriods[4][2] = Issue(1885680000, 3933526024, false);\n\n        issuePeriods[5][0] = Issue(1985472000, 123575364606, false);\n        issuePeriods[5][1] = Issue(1980201600, 24715072921, false);\n        issuePeriods[5][2] = Issue(1980201600, 12357536461, false);\n\n        issuePeriods[6][0] = Issue(2080252800, 388223457599, false);\n        issuePeriods[6][1] = Issue(2074982400, 77644691520, false);\n        issuePeriods[6][2] = Issue(2074982400, 38822345760, false);\n\n        issuePeriods[7][0] = Issue(2206483200, 1219639962308, false);\n        issuePeriods[7][1] = Issue(2201212800, 243927992462, false);\n        issuePeriods[7][2] = Issue(2201212800, 121963996231, false);\n\n        issuePeriods[8][0] = Issue(2364163200, 2005198000000, false);\n        issuePeriods[8][1] = Issue(2358892800, 401039600000, false);\n        issuePeriods[8][2] = Issue(2358892800, 200519800000, false);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint) {\n        return balances[tokenOwner];\n    }\n\n    function transfer(address receiver, uint numTokens) enabled onlyPayloadSize(2 * 32) public returns (bool) {\n        require(numTokens \u003c= balances[msg.sender]);\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\n        balances[receiver] = balances[receiver].add(numTokens);\n        emit Transfer(msg.sender, receiver, numTokens);\n        return true;\n    }\n\n    function approve(address delegate, uint numTokens) enabled public returns (bool) {\n        allowed[msg.sender][delegate] = numTokens;\n        emit Approval(msg.sender, delegate, numTokens);\n        return true;\n    }\n\n    function allowance(address owner, address delegate) public view returns (uint) {\n        return allowed[owner][delegate];\n    }\n\n    function transferFrom(address owner, address buyer, uint numTokens) enabled onlyPayloadSize(2 * 32) public returns (bool) {\n        require(numTokens \u003c= balances[owner]);\n        require(numTokens \u003c= allowed[owner][msg.sender]);\n\n        balances[owner] = balances[owner].sub(numTokens);\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\n        balances[buyer] = balances[buyer].add(numTokens);\n        emit Transfer(owner, buyer, numTokens);\n        return true;\n    }\n\n    //Admin functions\n\n    modifier fromAdmin() {\n        require(msg.sender == adminAddress);\n        _;\n    }\n\n    function addTotalSupply(uint256 amount) fromAdmin private returns (uint256) {\n\n        totalSupply_ = totalSupply_.add(amount);\n        balances[msg.sender] = balances[msg.sender].add(amount);\n\n        return totalSupply_;\n    }\n\n    function tempNotLockedAccount(address account) fromAdmin public returns (bool) {\n        tempNotLockedAccounts[account] = !tempNotLockedAccounts[account];\n        return tempNotLockedAccounts[account];\n    }\n\n    function setTemporarilyLockDate(uint date) fromAdmin public returns (uint) {\n        temporarilyLockDate = date;\n        return temporarilyLockDate;\n    }\n\n    function suspend() fromAdmin public returns (bool) {\n        suspended = !suspended;\n        return suspended;\n    }\n\n    function suspendAccount(address account) fromAdmin public returns (bool) {\n        suspendedAccounts[account] = !suspendedAccounts[account];\n        return suspendedAccounts[account];\n    }\n\n    function issuePlanned() fromAdmin public returns (uint256) {\n\n        if (issueStage.count == 3) {\n            issueStage.currentN += 1;\n            issueStage.count30 = 0;\n            issueStage.count = 0;\n        }\n\n        require(issueStage.currentN \u003c 9, \"All issues completed\");\n\n        uint256 amount = 0;\n        uint countBefore = issueStage.count;\n        Issue[3] storage issues = issuePeriods[issueStage.currentN];\n        for (uint i = 0; i \u003c issues.length; i++) {\n            if (!issues[i].complete) {\n                if (block.timestamp \u003e= issues[i].availableFromTimestamp) {\n                    issueStage.count += 1;\n                    issues[i].complete = true;\n                    amount += issues[i].amount;\n                }\n            }\n        }\n\n        require(countBefore \u003c issueStage.count, \"Too early to issue\");\n\n        addTotalSupply(amount.mul(decimals_multiplier));\n\n        return totalSupply_;\n    }\n\n    function issue30Percent() fromAdmin public returns (uint256) {\n        require(issueStage.count30 \u003c 5, \"The fifth 30 percent issue completed\");\n\n        uint256 amount = totalSupply_.div(100).mul(30);\n\n        addTotalSupply(amount);\n\n        issueStage.count30 += 1;\n\n        return totalSupply_;\n    }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}