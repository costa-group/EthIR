{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"sbCommunityInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbCommunityInterface {\n  function getTokenData(address token, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function receiveRewards(uint256 day, uint256 amount) external;\n\n  function serviceAccepted(address service) external view returns (bool);\n\n  function getMinerRewardPercentage() external view returns (uint256);\n}\n"},"sbController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./sbTokensInterface.sol\u0027;\nimport \u0027./sbCommunityInterface.sol\u0027;\nimport \u0027./sbStrongPoolInterface.sol\u0027;\nimport \u0027./sbVotesInterface.sol\u0027;\n\ncontract sbController {\n  event CommunityAdded(address indexed community);\n  event RewardsReleased(address indexed receiver, uint256 amount, uint256 indexed day);\n\n  using SafeMath for uint256;\n\n  bool internal initDone;\n\n  address internal sbTimelock;\n  IERC20 internal strongToken;\n  sbTokensInterface internal sbTokens;\n  sbStrongPoolInterface internal sbStrongPool;\n  sbVotesInterface internal sbVotes;\n  uint256 internal startDay;\n\n  mapping(uint256 =\u003e uint256) internal COMMUNITY_DAILY_REWARDS_BY_YEAR;\n  mapping(uint256 =\u003e uint256) internal STRONGPOOL_DAILY_REWARDS_BY_YEAR;\n  mapping(uint256 =\u003e uint256) internal VOTER_DAILY_REWARDS_BY_YEAR;\n  uint256 internal MAX_YEARS;\n\n  address[] internal communities;\n\n  mapping(uint256 =\u003e uint256) internal dayMineSecondsUSDTotal;\n  mapping(address =\u003e mapping(uint256 =\u003e uint256)) internal communityDayMineSecondsUSD;\n  mapping(address =\u003e mapping(uint256 =\u003e uint256)) internal communityDayRewards;\n  mapping(address =\u003e uint256) internal communityDayStart;\n  uint256 internal dayLastReleasedRewardsFor;\n\n  function init(\n    address sbTimelockAddress,\n    address strongTokenAddress,\n    address sbTokensAddress,\n    address sbStrongPoolAddress,\n    address sbCommunityAddress,\n    address sbVotesAddress\n  ) public {\n    require(!initDone, \u0027init done\u0027);\n    uint256 currentDay = _getCurrentDay();\n    sbTimelock = sbTimelockAddress;\n    strongToken = IERC20(strongTokenAddress);\n    sbTokens = sbTokensInterface(sbTokensAddress);\n    sbStrongPool = sbStrongPoolInterface(sbStrongPoolAddress);\n    sbVotes = sbVotesInterface(sbVotesAddress);\n    startDay = currentDay;\n    dayLastReleasedRewardsFor = currentDay.sub(1);\n\n    communities.push(sbCommunityAddress);\n    communityDayStart[sbCommunityAddress] = currentDay;\n\n    MAX_YEARS = 4;\n    COMMUNITY_DAILY_REWARDS_BY_YEAR[1] = 2888e18;\n    COMMUNITY_DAILY_REWARDS_BY_YEAR[2] = 2088e18;\n    COMMUNITY_DAILY_REWARDS_BY_YEAR[3] = 1288e18;\n    COMMUNITY_DAILY_REWARDS_BY_YEAR[4] = 888e18;\n\n    STRONGPOOL_DAILY_REWARDS_BY_YEAR[1] = 800e18;\n    STRONGPOOL_DAILY_REWARDS_BY_YEAR[2] = 1000e18;\n    STRONGPOOL_DAILY_REWARDS_BY_YEAR[3] = 1100e18;\n    STRONGPOOL_DAILY_REWARDS_BY_YEAR[4] = 1200e18;\n\n    VOTER_DAILY_REWARDS_BY_YEAR[1] = 88e18;\n    VOTER_DAILY_REWARDS_BY_YEAR[2] = 88e18;\n    VOTER_DAILY_REWARDS_BY_YEAR[3] = 88e18;\n    VOTER_DAILY_REWARDS_BY_YEAR[4] = 88e18;\n\n    initDone = true;\n  }\n\n  function upToDate() external view returns (bool) {\n    return dayLastReleasedRewardsFor == _getCurrentDay().sub(1);\n  }\n\n  function addCommunity(address community) external {\n    require(msg.sender == sbTimelock, \u0027not sbTimelock\u0027);\n    require(community != address(0), \u0027community not zero address\u0027);\n    require(!_communityExists(community), \u0027community exists\u0027);\n    communities.push(community);\n    communityDayStart[community] = _getCurrentDay();\n    emit CommunityAdded(community);\n  }\n\n  function getCommunities() external view returns (address[] memory) {\n    return communities;\n  }\n\n  function getDayMineSecondsUSDTotal(uint256 day) external view returns (uint256) {\n    require(day \u003e= startDay, \u00271: invalid day\u0027);\n    require(day \u003c= dayLastReleasedRewardsFor, \u00272: invalid day\u0027);\n    return dayMineSecondsUSDTotal[day];\n  }\n\n  function getCommunityDayMineSecondsUSD(address community, uint256 day) external view returns (uint256) {\n    require(_communityExists(community), \u0027invalid community\u0027);\n    require(\n      day \u003e= communityDayStart[community],\n      \u00271: invalid day\u0027\n    );\n    require(day \u003c= dayLastReleasedRewardsFor, \u00272: invalid day\u0027);\n    return communityDayMineSecondsUSD[community][day];\n  }\n\n  function getCommunityDayRewards(address community, uint256 day) external view returns (uint256) {\n    require(_communityExists(community), \u0027invalid community\u0027);\n    require(\n      day \u003e= communityDayStart[community],\n      \u00271: invalid day\u0027\n    );\n    require(day \u003c= dayLastReleasedRewardsFor, \u00272: invalid day\u0027);\n    return communityDayRewards[community][day];\n  }\n\n  function getCommunityDailyRewards(uint256 day) external view returns (uint256) {\n    require(day \u003e= startDay, \u0027invalid day\u0027);\n    uint256 year = _getYearDayIsIn(day);\n    require(year \u003c= MAX_YEARS, \u0027invalid year\u0027);\n    return COMMUNITY_DAILY_REWARDS_BY_YEAR[year];\n  }\n\n  function getStrongPoolDailyRewards(uint256 day) external view returns (uint256) {\n    require(day \u003e= startDay, \u0027invalid day\u0027);\n    uint256 year = _getYearDayIsIn(day);\n    require(year \u003c= MAX_YEARS, \u0027invalid year\u0027);\n    return STRONGPOOL_DAILY_REWARDS_BY_YEAR[year];\n  }\n\n  function getVoterDailyRewards(uint256 day) external view returns (uint256) {\n    require(day \u003e= startDay, \u0027invalid day\u0027);\n    uint256 year = _getYearDayIsIn(day);\n    require(year \u003c= MAX_YEARS, \u0027invalid year\u0027);\n    return VOTER_DAILY_REWARDS_BY_YEAR[year];\n  }\n\n  function getStartDay() external view returns (uint256) {\n    return startDay;\n  }\n\n  function communityAccepted(address community) external view returns (bool) {\n    return _communityExists(community);\n  }\n\n  function getMaxYears() public view returns (uint256) {\n    return MAX_YEARS;\n  }\n\n  function getCommunityDayStart(address community) public view returns (uint256) {\n    require(_communityExists(community), \u0027invalid community\u0027);\n    return communityDayStart[community];\n  }\n\n  function getSbTimelockAddressUsed() public view returns (address) {\n    return sbTimelock;\n  }\n\n  function getStrongAddressUsed() public view returns (address) {\n    return address(strongToken);\n  }\n\n  function getSbTokensAddressUsed() public view returns (address) {\n    return address(sbTokens);\n  }\n\n  function getSbStrongPoolAddressUsed() public view returns (address) {\n    return address(sbStrongPool);\n  }\n\n  function getSbVotesAddressUsed() public view returns (address) {\n    return address(sbVotes);\n  }\n\n  function getCurrentYear() public view returns (uint256) {\n    uint256 day = _getCurrentDay().sub(startDay);\n    return _getYearDayIsIn(day == 0 ? startDay : day);\n  }\n\n  function getYearDayIsIn(uint256 day) public view returns (uint256) {\n    require(day \u003e= startDay, \u0027invalid day\u0027);\n    return _getYearDayIsIn(day);\n  }\n\n  function getCurrentDay() public view returns (uint256) {\n    return _getCurrentDay();\n  }\n\n  function getDayLastReleasedRewardsFor() public view returns (uint256) {\n    return dayLastReleasedRewardsFor;\n  }\n\n  function releaseRewards() public {\n    uint256 currentDay = _getCurrentDay();\n    require(\n      currentDay \u003e dayLastReleasedRewardsFor.add(1),\n      \u0027already released\u0027\n    );\n    require(sbTokens.upToDate(), \u0027need token prices\u0027);\n    dayLastReleasedRewardsFor = dayLastReleasedRewardsFor.add(1);\n    uint256 year = _getYearDayIsIn(dayLastReleasedRewardsFor);\n    require(year \u003c= MAX_YEARS, \u0027invalid year\u0027);\n    address[] memory tokenAddresses = sbTokens.getTokens();\n    uint256[] memory tokenPrices = sbTokens.getTokenPrices(dayLastReleasedRewardsFor);\n    for (uint256 i = 0; i \u003c communities.length; i++) {\n      address community = communities[i];\n      uint256 sum = 0;\n      for (uint256 j = 0; j \u003c tokenAddresses.length; j++) {\n        address token = tokenAddresses[j];\n        (, , uint256 minedSeconds) = sbCommunityInterface(community).getTokenData(token, dayLastReleasedRewardsFor);\n        uint256 tokenPrice = tokenPrices[j];\n        uint256 minedSecondsUSD = tokenPrice.mul(minedSeconds).div(1e18);\n        sum = sum.add(minedSecondsUSD);\n      }\n      communityDayMineSecondsUSD[community][dayLastReleasedRewardsFor] = sum;\n      dayMineSecondsUSDTotal[dayLastReleasedRewardsFor] = dayMineSecondsUSDTotal[dayLastReleasedRewardsFor].add(sum);\n    }\n    for (uint256 i = 0; i \u003c communities.length; i++) {\n      address community = communities[i];\n      if (communityDayMineSecondsUSD[community][dayLastReleasedRewardsFor] == 0) {\n        continue;\n      }\n      communityDayRewards[community][dayLastReleasedRewardsFor] = communityDayMineSecondsUSD[community][dayLastReleasedRewardsFor]\n        .mul(COMMUNITY_DAILY_REWARDS_BY_YEAR[year])\n        .div(dayMineSecondsUSDTotal[dayLastReleasedRewardsFor]);\n\n      uint256 amount = communityDayRewards[community][dayLastReleasedRewardsFor];\n      strongToken.approve(community, amount);\n      sbCommunityInterface(community).receiveRewards(dayLastReleasedRewardsFor, amount);\n      emit RewardsReleased(community, amount, currentDay);\n    }\n    (,, uint256 strongPoolMineSeconds) = sbStrongPool.getMineData(dayLastReleasedRewardsFor);\n    if (strongPoolMineSeconds != 0) {\n      strongToken.approve(address(sbStrongPool), STRONGPOOL_DAILY_REWARDS_BY_YEAR[year]);\n      sbStrongPool.receiveRewards(dayLastReleasedRewardsFor, STRONGPOOL_DAILY_REWARDS_BY_YEAR[year]);\n      emit RewardsReleased(address(sbStrongPool), STRONGPOOL_DAILY_REWARDS_BY_YEAR[year], currentDay);\n    }\n    bool hasVoteSeconds = false;\n    for (uint256 i = 0; i \u003c communities.length; i++) {\n      address community = communities[i];\n      (, , uint256 voteSeconds) = sbVotes.getCommunityData(community, dayLastReleasedRewardsFor);\n      if (voteSeconds \u003e 0) {\n        hasVoteSeconds = true;\n        break;\n      }\n    }\n    if (hasVoteSeconds) {\n      strongToken.approve(address(sbVotes), VOTER_DAILY_REWARDS_BY_YEAR[year]);\n      sbVotes.receiveVoterRewards(dayLastReleasedRewardsFor, VOTER_DAILY_REWARDS_BY_YEAR[year]);\n      emit RewardsReleased(address(sbVotes), VOTER_DAILY_REWARDS_BY_YEAR[year], currentDay);\n    }\n  }\n\n  function _getCurrentDay() internal view returns (uint256) {\n    return block.timestamp.div(1 days).add(1);\n  }\n\n  function _communityExists(address community) internal view returns (bool) {\n    for (uint256 i = 0; i \u003c communities.length; i++) {\n      if (communities[i] == community) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _getYearDayIsIn(uint256 day) internal view returns (uint256) {\n    return day.sub(startDay).div(366).add(1); // dividing by 366 makes day 1 and 365 be in year 1\n  }\n}"},"sbStrongPoolInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbStrongPoolInterface {\n  function serviceMinMined(address miner) external view returns (bool);\n\n  function minerMinMined(address miner) external view returns (bool);\n\n  function mineFor(address miner, uint256 amount) external;\n\n  function getMineData(uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function receiveRewards(uint256 day, uint256 amount) external;\n}\n"},"sbTokensInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbTokensInterface {\n  function getTokens() external view returns (address[] memory);\n\n  function getTokenPrices(uint256 day) external view returns (uint256[] memory);\n\n  function tokenAccepted(address token) external view returns (bool);\n\n  function upToDate() external view returns (bool);\n\n  function getTokenPrice(address token, uint256 day) external view returns (uint256);\n}\n"},"sbVotesInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbVotesInterface {\n  function getCommunityData(address community, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n  function receiveServiceRewards(uint256 day, uint256 amount) external;\n\n  function receiveVoterRewards(uint256 day, uint256 amount) external;\n\n  function updateVotes(\n    address staker,\n    uint256 rawAmount,\n    bool adding\n  ) external;\n}\n"}}