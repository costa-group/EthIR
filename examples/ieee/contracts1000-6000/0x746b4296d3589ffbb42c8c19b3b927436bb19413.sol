{"ECDH.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\n\n/*\n    ECDH.sol - SKALE Manager\n    Copyright (C) 2018-Present SKALE Labs\n    @author Artem Payvin\n\n    SKALE Manager is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License as published\n    by the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    SKALE Manager is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR _A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with SKALE Manager.  If not, see \u003chttps://www.gnu.org/licenses/\u003e.\n*/\n\npragma solidity 0.6.10;\nimport \"./SafeMath.sol\";\n\n\ncontract ECDH {\n    using SafeMath for uint256;\n\n    uint256 constant private _GX = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\n    uint256 constant private _GY = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\n    uint256 constant private _N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n    uint256 constant private _A = 0;\n\n    function publicKey(uint256 privKey) external pure returns (uint256 qx, uint256 qy) {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n        (x, y, z) = ecMul(\n            privKey,\n            _GX,\n            _GY,\n            1\n        );\n        z = inverse(z);\n        qx = mulmod(x, z, _N);\n        qy = mulmod(y, z, _N);\n    }\n\n    function deriveKey(\n        uint256 privKey,\n        uint256 pubX,\n        uint256 pubY\n    )\n        external\n        pure\n        returns (uint256 qx, uint256 qy)\n    {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n        (x, y, z) = ecMul(\n            privKey,\n            pubX,\n            pubY,\n            1\n        );\n        z = inverse(z);\n        qx = mulmod(x, z, _N);\n        qy = mulmod(y, z, _N);\n    }\n\n    function jAdd(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {\n        (x3, z3) = (addmod(mulmod(z2, x1, _N), mulmod(x2, z1, _N), _N), mulmod(z1, z2, _N));\n    }\n\n    function jSub(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {\n        (x3, z3) = (addmod(mulmod(z2, x1, _N), mulmod(_N.sub(x2), z1, _N), _N), mulmod(z1, z2, _N));\n    }\n\n    function jMul(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {\n        (x3, z3) = (mulmod(x1, x2, _N), mulmod(z1, z2, _N));\n    }\n\n    function jDiv(\n        uint256 x1,\n        uint256 z1,\n        uint256 x2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 z3)\n    {\n        (x3, z3) = (mulmod(x1, z2, _N), mulmod(z1, x2, _N));\n    }\n\n    function inverse(uint256 a) public pure returns (uint256 invA) {\n        uint256 t = 0;\n        uint256 newT = 1;\n        uint256 r = _N;\n        uint256 newR = a;\n        uint256 q;\n        while (newR != 0) {\n            q = r.div(newR);\n            (t, newT) = (newT, addmod(t, (_N.sub(mulmod(q, newT, _N))), _N));\n            (r, newR) = (newR, r % newR);\n        }\n        return t;\n    }\n\n    function ecAdd(\n        uint256 x1,\n        uint256 y1,\n        uint256 z1,\n        uint256 x2,\n        uint256 y2,\n        uint256 z2\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {\n        uint256 ln;\n        uint256 lz;\n        uint256 da;\n        uint256 db;\n\n        if ((x1 == 0) \u0026\u0026 (y1 == 0)) {\n            return (x2, y2, z2);\n        }\n\n        if ((x2 == 0) \u0026\u0026 (y2 == 0)) {\n            return (x1, y1, z1);\n        }\n\n        if ((x1 == x2) \u0026\u0026 (y1 == y2)) {\n            (ln, lz) = jMul(x1, z1, x1, z1);\n            (ln, lz) = jMul(ln,lz,3,1);\n            (ln, lz) = jAdd(ln,lz,_A,1);\n            (da, db) = jMul(y1,z1,2,1);\n        } else {\n            (ln, lz) = jSub(y2,z2,y1,z1);\n            (da, db) = jSub(x2,z2,x1,z1);\n        }\n        (ln, lz) = jDiv(ln,lz,da,db);\n\n        (x3, da) = jMul(ln,lz,ln,lz);\n        (x3, da) = jSub(x3,da,x1,z1);\n        (x3, da) = jSub(x3,da,x2,z2);\n\n        (y3, db) = jSub(x1,z1,x3,da);\n        (y3, db) = jMul(y3,db,ln,lz);\n        (y3, db) = jSub(y3,db,y1,z1);\n\n        if (da != db) {\n            x3 = mulmod(x3, db, _N);\n            y3 = mulmod(y3, da, _N);\n            z3 = mulmod(da, db, _N);\n        } else {\n            z3 = da;\n        }\n    }\n\n    function ecDouble(\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {\n        (x3, y3, z3) = ecAdd(\n            x1,\n            y1,\n            z1,\n            x1,\n            y1,\n            z1\n        );\n    }\n\n    function ecMul(\n        uint256 d,\n        uint256 x1,\n        uint256 y1,\n        uint256 z1\n    )\n        public\n        pure\n        returns (uint256 x3, uint256 y3, uint256 z3)\n    {\n        uint256 remaining = d;\n        uint256 px = x1;\n        uint256 py = y1;\n        uint256 pz = z1;\n        uint256 acx = 0;\n        uint256 acy = 0;\n        uint256 acz = 1;\n\n        if (d == 0) {\n            return (0, 0, 1);\n        }\n\n        while (remaining != 0) {\n            if ((remaining \u0026 1) != 0) {\n                (acx, acy, acz) = ecAdd(\n                    acx,\n                    acy,\n                    acz,\n                    px,\n                    py,\n                    pz\n                );\n            }\n            remaining = remaining.div(2);\n            (px, py, pz) = ecDouble(px, py, pz);\n        }\n\n        (x3, y3, z3) = (acx, acy, acz);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}