{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"sbControllerInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbControllerInterface {\n  function getDayMineSecondsUSDTotal(uint256 day) external view returns (uint256);\n\n  function getCommunityDayMineSecondsUSD(address community, uint256 day) external view returns (uint256);\n\n  function getCommunityDayRewards(address community, uint256 day) external view returns (uint256);\n\n  function getStartDay() external view returns (uint256);\n\n  function getMaxYears() external view returns (uint256);\n\n  function getStrongPoolDailyRewards(uint256 day) external view returns (uint256);\n\n  function communityAccepted(address community) external view returns (bool);\n\n  function getCommunities() external view returns (address[] memory);\n\n  function upToDate() external view returns (bool);\n}\n"},"sbStrongPool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./sbControllerInterface.sol\u0027;\nimport \u0027./sbVotesInterface.sol\u0027;\n\ncontract sbStrongPool {\n  event ServiceMinMineUpdated(uint256 amount);\n  event MinerMinMineUpdated(uint256 amount);\n  event MinedFor(address indexed miner, address indexed receiver, uint256 amount, uint256 indexed day);\n  event RewardsReceived(uint256 indexed day, uint256 amount);\n  event Mined(address indexed miner, uint256 amount, uint256 indexed day);\n  event Unmined(address indexed miner, uint256 amount, uint256 indexed day);\n  event MinedForVotesOnly(address indexed miner, uint256 amount, uint256 indexed day);\n  event UnminedForVotesOnly(address indexed miner, uint256 amount, uint256 indexed day);\n  event Claimed(address indexed miner, uint256 amount, uint256 indexed day);\n\n  using SafeMath for uint256;\n\n  bool internal initDone;\n\n  IERC20 internal strongToken;\n  sbControllerInterface internal sbController;\n  sbVotesInterface internal sbVotes;\n  address internal sbTimelock;\n\n  uint256 internal serviceMinMine;\n  uint256 internal minerMinMine;\n\n  mapping(address =\u003e uint256[]) internal minerMineDays;\n  mapping(address =\u003e uint256[]) internal minerMineAmounts;\n  mapping(address =\u003e uint256[]) internal minerMineMineSeconds;\n\n  uint256[] internal mineDays;\n  uint256[] internal mineAmounts;\n  uint256[] internal mineMineSeconds;\n\n  mapping(address =\u003e uint256) internal minerDayLastClaimedFor;\n  mapping(uint256 =\u003e uint256) internal dayRewards;\n\n  mapping(address =\u003e uint256) internal mineForVotes;\n\n  function init(\n    address sbControllerAddress,\n    address strongTokenAddress,\n    address sbVotesAddress,\n    address sbTimelockAddress,\n    uint256 serviceMinMineAmount,\n    uint256 minerMinMineAmount\n  ) public {\n    require(!initDone, \u0027init done\u0027);\n    require(serviceMinMineAmount \u003e 0, \u00271: zero\u0027);\n    require(minerMinMineAmount \u003e 0, \u00272: zero\u0027);\n    sbController = sbControllerInterface(sbControllerAddress);\n    strongToken = IERC20(strongTokenAddress);\n    sbVotes = sbVotesInterface(sbVotesAddress);\n    sbTimelock = sbTimelockAddress;\n    serviceMinMine = serviceMinMineAmount;\n    minerMinMine = minerMinMineAmount;\n    initDone = true;\n  }\n\n  function serviceMinMined(address miner) external view returns (bool) {\n    uint256 currentDay = _getCurrentDay();\n    (, uint256 twoDaysAgoMine, ) = _getMinerMineData(miner, currentDay.sub(2));\n    (, uint256 oneDayAgoMine, ) = _getMinerMineData(miner, currentDay.sub(1));\n    (, uint256 todayMine, ) = _getMinerMineData(miner, currentDay);\n    return twoDaysAgoMine \u003e= serviceMinMine \u0026\u0026 oneDayAgoMine \u003e= serviceMinMine \u0026\u0026 todayMine \u003e= serviceMinMine;\n  }\n\n  function minerMinMined(address miner) external view returns (bool) {\n    (, uint256 todayMine, ) = _getMinerMineData(miner, _getCurrentDay());\n    return todayMine \u003e= minerMinMine;\n  }\n\n  function updateServiceMinMine(uint256 serviceMinMineAmount) external {\n    require(serviceMinMineAmount \u003e 0, \u0027zero\u0027);\n    require(\n      msg.sender == sbTimelock,\n      \u0027not sbTimelock\u0027\n    );\n    serviceMinMine = serviceMinMineAmount;\n    emit ServiceMinMineUpdated(serviceMinMineAmount);\n  }\n\n  function updateMinerMinMine(uint256 minerMinMineAmount) external {\n    require(minerMinMineAmount \u003e 0, \u0027zero\u0027);\n    require(\n      msg.sender == sbTimelock,\n      \u0027not sbTimelock\u0027\n    );\n    minerMinMine = minerMinMineAmount;\n    emit MinerMinMineUpdated(minerMinMineAmount);\n  }\n\n  function mineFor(address miner, uint256 amount) external {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(miner != address(0), \u0027zero address\u0027);\n    if (msg.sender != address(this)) {\n      strongToken.transferFrom(msg.sender, address(this), amount);\n    }\n    uint256 currentDay = _getCurrentDay();\n    uint256 startDay = sbController.getStartDay();\n    uint256 MAX_YEARS = sbController.getMaxYears();\n    uint256 year = _getYearDayIsIn(currentDay, startDay);\n    require(year \u003c= MAX_YEARS, \u0027year limit met\u0027);\n    _update(minerMineDays[miner], minerMineAmounts[miner], minerMineMineSeconds[miner], amount, true, currentDay);\n    _update(mineDays, mineAmounts, mineMineSeconds, amount, true, currentDay);\n    sbVotes.updateVotes(miner, amount, true);\n    emit MinedFor(msg.sender, miner, amount, currentDay);\n  }\n\n  function getMineData(uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return _getMineData(day);\n  }\n\n  function receiveRewards(uint256 day, uint256 amount) external {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(\n      msg.sender == address(sbController),\n      \u0027not sbController\u0027\n    );\n    strongToken.transferFrom(address(sbController), address(this), amount);\n    dayRewards[day] = dayRewards[day].add(amount);\n    emit RewardsReceived(day, amount);\n  }\n\n  function getDayRewards(uint256 day) public view returns (uint256) {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return dayRewards[day];\n  }\n\n  function mine(uint256 amount) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    strongToken.transferFrom(msg.sender, address(this), amount);\n    uint256 currentDay = _getCurrentDay();\n    uint256 startDay = sbController.getStartDay();\n    uint256 MAX_YEARS = sbController.getMaxYears();\n    uint256 year = _getYearDayIsIn(currentDay, startDay);\n    require(year \u003c= MAX_YEARS, \u0027year limit met\u0027);\n    _update(\n      minerMineDays[msg.sender],\n      minerMineAmounts[msg.sender],\n      minerMineMineSeconds[msg.sender],\n      amount,\n      true,\n      currentDay\n    );\n    _update(mineDays, mineAmounts, mineMineSeconds, amount, true, currentDay);\n    sbVotes.updateVotes(msg.sender, amount, true);\n    emit Mined(msg.sender, amount, currentDay);\n  }\n\n  function unmine(uint256 amount) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    uint256 currentDay = _getCurrentDay();\n    _update(\n      minerMineDays[msg.sender],\n      minerMineAmounts[msg.sender],\n      minerMineMineSeconds[msg.sender],\n      amount,\n      false,\n      currentDay\n    );\n    _update(mineDays, mineAmounts, mineMineSeconds, amount, false, currentDay);\n    sbVotes.updateVotes(msg.sender, amount, false);\n    strongToken.transfer(msg.sender, amount);\n    emit Unmined(msg.sender, amount, currentDay);\n  }\n\n  function mineForVotesOnly(uint256 amount) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    strongToken.transferFrom(msg.sender, address(this), amount);\n    uint256 currentDay = _getCurrentDay();\n    uint256 startDay = sbController.getStartDay();\n    uint256 MAX_YEARS = sbController.getMaxYears();\n    uint256 year = _getYearDayIsIn(currentDay, startDay);\n    require(year \u003c= MAX_YEARS, \u0027year limit met\u0027);\n    mineForVotes[msg.sender] = mineForVotes[msg.sender].add(amount);\n    sbVotes.updateVotes(msg.sender, amount, true);\n    emit MinedForVotesOnly(msg.sender, amount, currentDay);\n  }\n\n  function unmineForVotesOnly(uint256 amount) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(mineForVotes[msg.sender] \u003e= amount, \u0027not enough mine\u0027);\n    mineForVotes[msg.sender] = mineForVotes[msg.sender].sub(amount);\n    sbVotes.updateVotes(msg.sender, amount, false);\n    strongToken.transfer(msg.sender, amount);\n    emit UnminedForVotesOnly(msg.sender, amount, _getCurrentDay());\n  }\n\n  function getMineForVotesOnly(address miner) public view returns (uint256) {\n    return mineForVotes[miner];\n  }\n\n  function getServiceMinMineAmount() public view returns (uint256) {\n    return serviceMinMine;\n  }\n\n  function getMinerMinMineAmount() public view returns (uint256) {\n    return minerMinMine;\n  }\n\n  function getSbControllerAddressUsed() public view returns (address) {\n    return address(sbController);\n  }\n\n  function getStrongAddressUsed() public view returns (address) {\n    return address(strongToken);\n  }\n\n  function getSbVotesAddressUsed() public view returns (address) {\n    return address(sbVotes);\n  }\n\n  function getSbTimelockAddressUsed() public view returns (address) {\n    return sbTimelock;\n  }\n\n  function getMinerDayLastClaimedFor(address miner) public view returns (uint256) {\n    return minerDayLastClaimedFor[miner] == 0 ? sbController.getStartDay().sub(1) : minerDayLastClaimedFor[miner];\n  }\n\n  function claimAll() public {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[msg.sender];\n    require(currentDay \u003e dayLastClaimedFor.add(7), \u0027already claimed\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    _claim(currentDay, msg.sender, dayLastClaimedFor);\n  }\n\n  function claimUpTo(uint256 day) public {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[msg.sender];\n    require(day \u003e dayLastClaimedFor.add(7), \u0027already claimed\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    _claim(day, msg.sender, dayLastClaimedFor);\n  }\n\n  function getRewardsDueAll(address miner) public view returns (uint256) {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[miner] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[miner];\n    if (!(currentDay \u003e dayLastClaimedFor.add(7))) {\n      return 0;\n    }\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getRewardsDue(currentDay, miner, dayLastClaimedFor);\n  }\n\n  function getRewardsDueUpTo(uint256 day, address miner) public view returns (uint256) {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = minerDayLastClaimedFor[miner] == 0\n      ? sbController.getStartDay().sub(1)\n      : minerDayLastClaimedFor[miner];\n    if (!(day \u003e dayLastClaimedFor.add(7))) {\n      return 0;\n    }\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getRewardsDue(day, miner, dayLastClaimedFor);\n  }\n\n  function getMinerMineData(address miner, uint256 day)\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return _getMinerMineData(miner, day);\n  }\n\n  function _getMineData(uint256 day)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return _get(mineDays, mineAmounts, mineMineSeconds, day);\n  }\n\n  function _getMinerMineData(address miner, uint256 day)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256[] memory _Days = minerMineDays[miner];\n    uint256[] memory _Amounts = minerMineAmounts[miner];\n    uint256[] memory _UnitSeconds = minerMineMineSeconds[miner];\n    return _get(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _get(\n    uint256[] memory _Days,\n    uint256[] memory _Amounts,\n    uint256[] memory _UnitSeconds,\n    uint256 day\n  )\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 len = _Days.length;\n    if (len == 0) {\n      return (day, 0, 0);\n    }\n    if (day \u003c _Days[0]) {\n      return (day, 0, 0);\n    }\n    uint256 lastIndex = len.sub(1);\n    uint256 lastMinedDay = _Days[lastIndex];\n    if (day == lastMinedDay) {\n      return (day, _Amounts[lastIndex], _UnitSeconds[lastIndex]);\n    } else if (day \u003e lastMinedDay) {\n      return (day, _Amounts[lastIndex], _Amounts[lastIndex].mul(1 days));\n    }\n    return _find(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _find(\n    uint256[] memory _Days,\n    uint256[] memory _Amounts,\n    uint256[] memory _UnitSeconds,\n    uint256 day\n  )\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 left = 0;\n    uint256 right = _Days.length.sub(1);\n    uint256 middle = right.add(left).div(2);\n    while (left \u003c right) {\n      if (_Days[middle] == day) {\n        return (day, _Amounts[middle], _UnitSeconds[middle]);\n      } else if (_Days[middle] \u003e day) {\n        if (middle \u003e 0 \u0026\u0026 _Days[middle.sub(1)] \u003c day) {\n          return (day, _Amounts[middle.sub(1)], _Amounts[middle.sub(1)].mul(1 days));\n        }\n        if (middle == 0) {\n          return (day, 0, 0);\n        }\n        right = middle.sub(1);\n      } else if (_Days[middle] \u003c day) {\n        if (middle \u003c _Days.length.sub(1) \u0026\u0026 _Days[middle.add(1)] \u003e day) {\n          return (day, _Amounts[middle], _Amounts[middle].mul(1 days));\n        }\n        left = middle.add(1);\n      }\n      middle = right.add(left).div(2);\n    }\n    if (_Days[middle] != day) {\n      return (day, 0, 0);\n    } else {\n      return (day, _Amounts[middle], _UnitSeconds[middle]);\n    }\n  }\n\n  function _update(\n    uint256[] storage _Days,\n    uint256[] storage _Amounts,\n    uint256[] storage _UnitSeconds,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256 len = _Days.length;\n    uint256 secondsInADay = 1 days;\n    uint256 secondsSinceStartOfDay = block.timestamp % secondsInADay;\n    uint256 secondsUntilEndOfDay = secondsInADay.sub(secondsSinceStartOfDay);\n\n    if (len == 0) {\n      if (adding) {\n        _Days.push(currentDay);\n        _Amounts.push(amount);\n        _UnitSeconds.push(amount.mul(secondsUntilEndOfDay));\n      } else {\n        require(false, \u00271: not enough mine\u0027);\n      }\n    } else {\n      uint256 lastIndex = len.sub(1);\n      uint256 lastMinedDay = _Days[lastIndex];\n      uint256 lastMinedAmount = _Amounts[lastIndex];\n      uint256 lastUnitSeconds = _UnitSeconds[lastIndex];\n\n      uint256 newAmount;\n      uint256 newUnitSeconds;\n\n      if (lastMinedDay == currentDay) {\n        if (adding) {\n          newAmount = lastMinedAmount.add(amount);\n          newUnitSeconds = lastUnitSeconds.add(amount.mul(secondsUntilEndOfDay));\n        } else {\n          require(lastMinedAmount \u003e= amount, \u00272: not enough mine\u0027);\n          newAmount = lastMinedAmount.sub(amount);\n          newUnitSeconds = lastUnitSeconds.sub(amount.mul(secondsUntilEndOfDay));\n        }\n        _Amounts[lastIndex] = newAmount;\n        _UnitSeconds[lastIndex] = newUnitSeconds;\n      } else {\n        if (adding) {\n          newAmount = lastMinedAmount.add(amount);\n          newUnitSeconds = lastMinedAmount.mul(1 days).add(amount.mul(secondsUntilEndOfDay));\n        } else {\n          require(lastMinedAmount \u003e= amount, \u00273: not enough mine\u0027);\n          newAmount = lastMinedAmount.sub(amount);\n          newUnitSeconds = lastMinedAmount.mul(1 days).sub(amount.mul(secondsUntilEndOfDay));\n        }\n        _Days.push(currentDay);\n        _Amounts.push(newAmount);\n        _UnitSeconds.push(newUnitSeconds);\n      }\n    }\n  }\n\n  function _getCurrentDay() internal view returns (uint256) {\n    return block.timestamp.div(1 days).add(1);\n  }\n\n  function _claim(\n    uint256 upToDay,\n    address miner,\n    uint256 dayLastClaimedFor\n  ) internal {\n    uint256 rewards = _getRewardsDue(upToDay, miner, dayLastClaimedFor);\n    require(rewards \u003e 0, \u0027no rewards\u0027);\n    minerDayLastClaimedFor[miner] = upToDay.sub(7);\n    this.mineFor(miner, rewards);\n    emit Claimed(miner, rewards, _getCurrentDay());\n  }\n\n  function _getRewardsDue(\n    uint256 upToDay,\n    address miner,\n    uint256 dayLastClaimedFor\n  ) internal view returns (uint256) {\n    uint256 rewards;\n    for (uint256 day = dayLastClaimedFor.add(1); day \u003c= upToDay.sub(7); day++) {\n      (, , uint256 minerMineSecondsForDay) = _getMinerMineData(miner, day);\n      (, , uint256 mineSecondsForDay) = _getMineData(day);\n      if (mineSecondsForDay == 0) {\n        continue;\n      }\n      uint256 strongPoolDayRewards = dayRewards[day];\n      uint256 amount = strongPoolDayRewards.mul(minerMineSecondsForDay).div(mineSecondsForDay);\n      rewards = rewards.add(amount);\n    }\n    return rewards;\n  }\n\n  function _getYearDayIsIn(uint256 day, uint256 startDay) internal pure returns (uint256) {\n    return day.sub(startDay).div(366).add(1); // dividing by 366 makes day 1 and 365 be in year 1\n  }\n}\n"},"sbVotesInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbVotesInterface {\n  function getCommunityData(address community, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96);\n\n  function receiveServiceRewards(uint256 day, uint256 amount) external;\n\n  function receiveVoterRewards(uint256 day, uint256 amount) external;\n\n  function updateVotes(\n    address staker,\n    uint256 rawAmount,\n    bool adding\n  ) external;\n}\n"}}