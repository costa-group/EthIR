{"BaseFeature.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.s\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./SafeMath.sol\";\nimport \"./IWallet.sol\";\nimport \"./IModuleRegistry.sol\";\nimport \"./ILockStorage.sol\";\nimport \"./IFeature.sol\";\nimport \"./ERC20.sol\";\nimport \"./IVersionManager.sol\";\n\n/**\n * @title BaseFeature\n * @notice Base Feature contract that contains methods common to all Feature contracts.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e, Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ncontract BaseFeature is IFeature {\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n    // Mock token address for ETH\n    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    // The address of the Lock storage\n    ILockStorage internal lockStorage;\n    // The address of the Version Manager\n    IVersionManager internal versionManager;\n\n    event FeatureCreated(bytes32 name);\n\n    /**\n     * @notice Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(address _wallet) {\n        require(!lockStorage.isLocked(_wallet), \"BF: wallet locked\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the VersionManager.\n     */\n    modifier onlyVersionManager() {\n        require(msg.sender == address(versionManager), \"BF: caller must be VersionManager\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the owner of the target wallet.\n     */\n    modifier onlyWalletOwner(address _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BF: must be wallet owner\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not an authorised feature of the target wallet.\n     */\n    modifier onlyWalletFeature(address _wallet) {\n        require(versionManager.isFeatureAuthorised(_wallet, msg.sender), \"BF: must be a wallet feature\");\n        _;\n    }\n\n    /**\n     * @notice Throws if the sender is not the owner of the target wallet or the feature itself.\n     */\n    modifier onlyWalletOwnerOrFeature(address _wallet) {\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\n        _;\n    }\n\n    constructor(\n        ILockStorage _lockStorage,\n        IVersionManager _versionManager,\n        bytes32 _name\n    ) public {\n        lockStorage = _lockStorage;\n        versionManager = _versionManager;\n        emit FeatureCreated(_name);\n    }\n\n    /**\n    * @inheritdoc IFeature\n    */\n    function recoverToken(address _token) external virtual override {\n        uint total = ERC20(_token).balanceOf(address(this));\n        _token.call(abi.encodeWithSelector(ERC20(_token).transfer.selector, address(versionManager), total));\n    }\n\n    /**\n     * @notice Inits the feature for a wallet by doing nothing.\n     * @dev !! Overriding methods need make sure `init()` can only be called by the VersionManager !!\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external virtual override  {}\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getRequiredSignatures(address, bytes calldata) external virtual view override returns (uint256, OwnerSignature) {\n        revert(\"BF: disabled method\");\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getStaticCallSignatures() external virtual override view returns (bytes4[] memory _sigs) {}\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) public override view returns (bool) {\n        return versionManager.isFeatureAuthorised(_wallet, _feature);\n    }\n\n    /**\n    * @notice Checks that the wallet address provided as the first parameter of _data matches _wallet\n    * @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes calldata _data) internal pure returns (bool) {\n        require(_data.length \u003e= 36, \"RM: Invalid dataWallet\");\n        address dataWallet = abi.decode(_data[4:], (address));\n        return dataWallet == _wallet;\n    }\n    \n     /**\n     * @notice Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(address _wallet, address _addr) internal view returns (bool) {\n        return IWallet(_wallet).owner() == _addr;\n    }\n\n    /**\n     * @notice Verify that the caller is an authorised feature or the wallet owner.\n     * @param _wallet The target wallet.\n     * @param _sender The caller.\n     */\n    function verifyOwnerOrAuthorisedFeature(address _wallet, address _sender) internal view {\n        require(isFeatureAuthorisedInVersionManager(_wallet, _sender) || isOwner(_wallet, _sender), \"BF: must be owner or feature\");\n    }\n\n    /**\n     * @notice Helper method to invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data)\n        internal\n        returns (bytes memory _res) \n    {\n        _res = versionManager.checkAuthorisedFeatureAndInvokeWallet(_wallet, _to, _value, _data);\n    }\n\n}"},"CompoundManager.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\n\nimport \"./BaseFeature.sol\";\nimport \"./ICompoundRegistry.sol\";\n\ninterface IComptroller {\n    function enterMarkets(address[] calldata _cTokens) external returns (uint[] memory);\n    function exitMarket(address _cToken) external returns (uint);\n    function getAssetsIn(address _account) external view returns (address[] memory);\n    function getAccountLiquidity(address _account) external view returns (uint, uint, uint);\n    function checkMembership(address account, ICToken cToken) external view returns (bool);\n}\n\ninterface ICToken {\n    function comptroller() external view returns (address);\n    function underlying() external view returns (address);\n    function symbol() external view returns (string memory);\n    function exchangeRateCurrent() external returns (uint256);\n    function exchangeRateStored() external view returns (uint256);\n    function balanceOf(address _account) external view returns (uint256);\n    function borrowBalanceCurrent(address _account) external returns (uint256);\n    function borrowBalanceStored(address _account) external view returns (uint256);\n}\n\n/**\n * @title CompoundManager\n * @notice Module to invest and borrow tokens with CompoundV2\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e\n */\ncontract CompoundManager is BaseFeature{\n\n    bytes32 constant NAME = \"CompoundManager\";\n\n    // The Compound IComptroller contract\n    IComptroller public comptroller;\n    // The registry mapping underlying with cTokens\n    ICompoundRegistry public compoundRegistry;\n\n    event InvestmentAdded(address indexed _wallet, address _token, uint256 _invested, uint256 _period);\n    event InvestmentRemoved(address indexed _wallet, address _token, uint256 _fraction);\n    event LoanOpened(\n        address indexed _wallet,\n        bytes32 indexed _loanId,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _debtToken,\n        uint256 _debtAmount);\n    event LoanClosed(address indexed _wallet, bytes32 indexed _loanId);\n    event CollateralAdded(address indexed _wallet, bytes32 indexed _loanId, address _collateral, uint256 _collateralAmount);\n    event CollateralRemoved(address indexed _wallet, bytes32 indexed _loanId, address _collateral, uint256 _collateralAmount);\n    event DebtAdded(address indexed _wallet, bytes32 indexed _loanId, address _debtToken, uint256 _debtAmount);\n    event DebtRemoved(address indexed _wallet, bytes32 indexed _loanId, address _debtToken, uint256 _debtAmount);\n\n    using SafeMath for uint256;\n\n    constructor(\n        ILockStorage _lockStorage,\n        IComptroller _comptroller,\n        ICompoundRegistry _compoundRegistry,\n        IVersionManager _versionManager\n    )\n        BaseFeature(_lockStorage, _versionManager, NAME)\n        public\n    {\n        comptroller = _comptroller;\n        compoundRegistry = _compoundRegistry;\n    }\n\n    /**\n     * @inheritdoc IFeature\n     */\n    function getRequiredSignatures(address, bytes calldata) external view override returns (uint256, OwnerSignature) {\n        return (1, OwnerSignature.Required);\n    }\n\n    /* ********************************** Implementation of Loan ************************************* */\n\n    /**\n     * @notice Opens a collateralized loan.\n     * @param _wallet The target wallet.\n     * @param _collateral The token used as a collateral.\n     * @param _collateralAmount The amount of collateral token provided.\n     * @param _debtToken The token borrowed.\n     * @param _debtAmount The amount of tokens borrowed.\n     * @return _loanId bytes32(0) as Compound does not allow the creation of multiple loans.\n     */\n    function openLoan(\n        address _wallet,\n        address _collateral,\n        uint256 _collateralAmount,\n        address _debtToken,\n        uint256 _debtAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n        returns (bytes32 _loanId)\n    {\n        address[] memory markets = new address[](2);\n        markets[0] = compoundRegistry.getCToken(_collateral);\n        markets[1] = compoundRegistry.getCToken(_debtToken);\n        invokeWallet(_wallet, address(comptroller), 0, abi.encodeWithSignature(\"enterMarkets(address[])\", markets));\n        mint(_wallet, markets[0], _collateral, _collateralAmount);\n        borrow(_wallet, _debtToken, markets[1], _debtAmount);\n        emit LoanOpened(_wallet, _loanId, _collateral, _collateralAmount, _debtToken, _debtAmount);\n    }\n\n    /**\n     * @notice Closes the collateralized loan in all markets by repaying all debts (plus interest). Note that it does not redeem the collateral.\n     * @param _wallet The target wallet.\n     * @param _loanId bytes32(0) as Compound does not allow the creation of multiple loans.\n     */\n    function closeLoan(\n        address _wallet,\n        bytes32 _loanId\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        address[] memory markets = comptroller.getAssetsIn(_wallet);\n        for (uint i = 0; i \u003c markets.length; i++) {\n            address cToken = markets[i];\n            uint debt = ICToken(cToken).borrowBalanceCurrent(_wallet);\n            if (debt \u003e 0) {\n                repayBorrow(_wallet, cToken, debt);\n                uint collateral = ICToken(cToken).balanceOf(_wallet);\n                if (collateral == 0) {\n                    invokeWallet(\n                        _wallet,\n                        address(comptroller),\n                        0,\n                        abi.encodeWithSignature(\"exitMarket(address)\", address(cToken))\n                    );\n                }\n            }\n        }\n        emit LoanClosed(_wallet, _loanId);\n    }\n\n    /**\n     * @notice Adds collateral to a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId bytes32(0) as Compound does not allow the creation of multiple loans.\n     * @param _collateral The token used as a collateral.\n     * @param _collateralAmount The amount of collateral to add.\n     */\n    function addCollateral(\n        address _wallet,\n        bytes32 _loanId,\n        address _collateral,\n        uint256 _collateralAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        address cToken = compoundRegistry.getCToken(_collateral);\n        enterMarketIfNeeded(_wallet, cToken, address(comptroller));\n        mint(_wallet, cToken, _collateral, _collateralAmount);\n        emit CollateralAdded(_wallet, _loanId, _collateral, _collateralAmount);\n    }\n\n    /**\n     * @notice Removes collateral from a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId bytes32(0) as Compound does not allow the creation of multiple loans.\n     * @param _collateral The token used as a collateral.\n     * @param _collateralAmount The amount of collateral to remove.\n     */\n    function removeCollateral(\n        address _wallet,\n        bytes32 _loanId,\n        address _collateral,\n        uint256 _collateralAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        address cToken = compoundRegistry.getCToken(_collateral);\n        redeemUnderlying(_wallet, cToken, _collateralAmount);\n        exitMarketIfNeeded(_wallet, cToken, address(comptroller));\n        emit CollateralRemoved(_wallet, _loanId, _collateral, _collateralAmount);\n    }\n\n    /**\n     * @notice Increases the debt by borrowing more token from a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId bytes32(0) as Compound does not allow the creation of multiple loans.\n     * @param _debtToken The token borrowed.\n     * @param _debtAmount The amount of token to borrow.\n     */\n    function addDebt(\n        address _wallet,\n        bytes32 _loanId,\n        address _debtToken,\n        uint256 _debtAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        address dToken = compoundRegistry.getCToken(_debtToken);\n        enterMarketIfNeeded(_wallet, dToken, address(comptroller));\n        borrow(_wallet, _debtToken, dToken, _debtAmount);\n        emit DebtAdded(_wallet, _loanId, _debtToken, _debtAmount);\n    }\n\n    /**\n     * @notice Decreases the debt by repaying some token from a loan identified by its ID.\n     * @param _wallet The target wallet.\n     * @param _loanId bytes32(0) as Compound does not allow the creation of multiple loans.\n     * @param _debtToken The token to repay.\n     * @param _debtAmount The amount of token to repay.\n     */\n    function removeDebt(\n        address _wallet,\n        bytes32 _loanId,\n        address _debtToken,\n        uint256 _debtAmount\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        address dToken = compoundRegistry.getCToken(_debtToken);\n        repayBorrow(_wallet, dToken, _debtAmount);\n        exitMarketIfNeeded(_wallet, dToken, address(comptroller));\n        emit DebtRemoved(_wallet, _loanId, _debtToken, _debtAmount);\n    }\n\n    /**\n     * @notice Gets information about the loan status on Compound.\n     * @param _wallet The target wallet.\n     * @return _status Status [0: no loan, 1: loan is safe, 2: loan is unsafe and can be liquidated]\n     * @return _ethValue Value (in ETH) representing the value that could still be borrowed when status = 1; or the value of the collateral\n     * that should be added to avoid liquidation when status = 2.\n     */\n    function getLoan(\n        address _wallet,\n        bytes32 /* _loanId */\n    )\n        external\n        view\n        returns (uint8 _status, uint256 _ethValue)\n    {\n        (uint error, uint liquidity, uint shortfall) = comptroller.getAccountLiquidity(_wallet);\n        require(error == 0, \"CM: failed to get account liquidity\");\n        if (liquidity \u003e 0) {\n            return (1, liquidity);\n        }\n        if (shortfall \u003e 0) {\n            return (2, shortfall);\n        }\n        return (0,0);\n    }\n\n    /* ********************************** Implementation of Invest ************************************* */\n\n    /**\n     * @notice Invest tokens for a given period.\n     * @param _wallet The target wallet.\n     * @param _token The token address.\n     * @param _amount The amount of tokens to invest.\n     * @param _period The period over which the tokens may be locked in the investment (optional).\n     * @return _invested The exact amount of tokens that have been invested.\n     */\n    function addInvestment(\n        address _wallet,\n        address _token,\n        uint256 _amount,\n        uint256 _period\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n        returns (uint256 _invested)\n    {\n        address cToken = compoundRegistry.getCToken(_token);\n        mint(_wallet, cToken, _token, _amount);\n        _invested = _amount;\n        emit InvestmentAdded(_wallet, _token, _amount, _period);\n    }\n\n    /**\n     * @notice Exit invested postions.\n     * @param _wallet The target wallet.\n     * @param _token The token address.\n     * @param _fraction The fraction of invested tokens to exit in per 10000.\n     */\n    function removeInvestment(\n        address _wallet,\n        address _token,\n        uint256 _fraction\n    )\n        external\n        onlyWalletOwnerOrFeature(_wallet)\n        onlyWhenUnlocked(_wallet)\n    {\n        require(_fraction \u003c= 10000, \"CM: invalid fraction value\");\n        address cToken = compoundRegistry.getCToken(_token);\n        uint shares = ICToken(cToken).balanceOf(_wallet);\n        redeem(_wallet, cToken, shares.mul(_fraction).div(10000));\n        emit InvestmentRemoved(_wallet, _token, _fraction);\n    }\n\n    /**\n     * @notice Get the amount of investment in a given token.\n     * @param _wallet The target wallet.\n     * @param _token The token address.\n     * @return _tokenValue The value in tokens of the investment (including interests).\n     * @return _periodEnd The time at which the investment can be removed.\n     */\n    function getInvestment(\n        address _wallet,\n        address _token\n    )\n        external\n        view\n        returns (uint256 _tokenValue, uint256 _periodEnd)\n    {\n        address cToken = compoundRegistry.getCToken(_token);\n        uint amount = ICToken(cToken).balanceOf(_wallet);\n        uint exchangeRateMantissa = ICToken(cToken).exchangeRateStored();\n        _tokenValue = amount.mul(exchangeRateMantissa).div(10 ** 18);\n        _periodEnd = 0;\n    }\n\n    /* ****************************************** Compound wrappers ******************************************* */\n\n    /**\n     * @notice Adds underlying tokens to a cToken contract.\n     * @param _wallet The target wallet.\n     * @param _cToken The cToken contract.\n     * @param _token The underlying token.\n     * @param _amount The amount of underlying token to add.\n     */\n    function mint(address _wallet, address _cToken, address _token, uint256 _amount) internal {\n        require(_cToken != address(0), \"CM: No market for target token\");\n        require(_amount \u003e 0, \"CM: amount cannot be 0\");\n        uint256 initialCTokenAmount = ERC20(_cToken).balanceOf(_wallet);\n        if (_token == ETH_TOKEN) {\n            invokeWallet(_wallet, _cToken, _amount, abi.encodeWithSignature(\"mint()\"));\n        } else {\n            invokeWallet(_wallet, _token, 0, abi.encodeWithSignature(\"approve(address,uint256)\", _cToken, _amount));\n            invokeWallet(_wallet, _cToken, 0, abi.encodeWithSignature(\"mint(uint256)\", _amount));\n        }\n        require(ERC20(_cToken).balanceOf(_wallet) \u003e initialCTokenAmount, \"CM: mint failed\");\n    }\n\n    /**\n     * @notice Redeems underlying tokens from a cToken contract.\n     * @param _wallet The target wallet.\n     * @param _cToken The cToken contract.\n     * @param _amount The amount of cToken to redeem.\n     */\n    function redeem(address _wallet, address _cToken, uint256 _amount) internal {\n        // The following commented `require()` is not necessary as `ICToken(cToken).balanceOf(_wallet)` in `removeInvestment()`\n        // would have reverted if `_cToken == address(0)`\n        // It is however left as a comment as a reminder to include it if `removeInvestment()` is changed to use amounts instead of fractions.\n        // require(_cToken != address(0), \"CM: No market for target token\");\n        require(_amount \u003e 0, \"CM: amount cannot be 0\");\n        uint256 initialCTokenAmount = ERC20(_cToken).balanceOf(_wallet);\n        invokeWallet(_wallet, _cToken, 0, abi.encodeWithSignature(\"redeem(uint256)\", _amount));\n        require(ERC20(_cToken).balanceOf(_wallet) \u003c initialCTokenAmount, \"CM: redeem failed\");\n    }\n\n    /**\n     * @notice Redeems underlying tokens from a cToken contract.\n     * @param _wallet The target wallet.\n     * @param _cToken The cToken contract.\n     * @param _amount The amount of underlying token to redeem.\n     */\n    function redeemUnderlying(address _wallet, address _cToken, uint256 _amount) internal {\n        require(_cToken != address(0), \"CM: No market for target token\");\n        require(_amount \u003e 0, \"CM: amount cannot be 0\");\n        uint256 initialCTokenAmount = ERC20(_cToken).balanceOf(_wallet);\n        invokeWallet(_wallet, _cToken, 0, abi.encodeWithSignature(\"redeemUnderlying(uint256)\", _amount));\n        require(ERC20(_cToken).balanceOf(_wallet) \u003c initialCTokenAmount, \"CM: redeemUnderlying failed\");\n    }\n\n    /**\n     * @notice Borrows underlying tokens from a cToken contract.\n     * @param _wallet The target wallet.\n     * @param _token The token contract.\n     * @param _cToken The cToken contract.\n     * @param _amount The amount of underlying tokens to borrow.\n     */\n    function borrow(address _wallet, address _token, address _cToken, uint256 _amount) internal {\n        require(_cToken != address(0), \"CM: No market for target token\");\n        require(_amount \u003e 0, \"CM: amount cannot be 0\");\n        uint256 initialTokenAmount = _token == ETH_TOKEN ? _wallet.balance : ERC20(_token).balanceOf(_wallet);\n        invokeWallet(_wallet, _cToken, 0, abi.encodeWithSignature(\"borrow(uint256)\", _amount));\n        uint256 finalTokenAmount = _token == ETH_TOKEN ? _wallet.balance : ERC20(_token).balanceOf(_wallet);\n        require(finalTokenAmount \u003e initialTokenAmount, \"CM: borrow failed\");\n    }\n\n    /**\n     * @notice Repays some borrowed underlying tokens to a cToken contract.\n     * @param _wallet The target wallet.\n     * @param _cToken The cToken contract.\n     * @param _amount The amount of underlying to repay.\n     */\n    function repayBorrow(address _wallet, address _cToken, uint256 _amount) internal {\n        require(_cToken != address(0), \"CM: No market for target token\");\n        require(_amount \u003e 0, \"CM: amount cannot be 0\");\n        string memory symbol = ICToken(_cToken).symbol();\n        uint256 initialTokenAmount;\n        uint256 finalTokenAmount;\n        if (keccak256(abi.encodePacked(symbol)) == keccak256(abi.encodePacked(\"cETH\"))) {\n            initialTokenAmount = _wallet.balance;\n            invokeWallet(_wallet, _cToken, _amount, abi.encodeWithSignature(\"repayBorrow()\"));\n            finalTokenAmount = _wallet.balance;\n        } else {\n            address token = ICToken(_cToken).underlying();\n            initialTokenAmount = ERC20(token).balanceOf(_wallet);\n            invokeWallet(_wallet, token, 0, abi.encodeWithSignature(\"approve(address,uint256)\", _cToken, _amount));\n            invokeWallet(_wallet, _cToken, 0, abi.encodeWithSignature(\"repayBorrow(uint256)\", _amount));\n            finalTokenAmount = ERC20(token).balanceOf(_wallet);\n        }\n        require(finalTokenAmount \u003c initialTokenAmount, \"CM: repayBorrow failed\");\n    }\n\n    /**\n     * @notice Enters a cToken market if it was not entered before.\n     * @param _wallet The target wallet.\n     * @param _cToken The cToken contract.\n     * @param _comptroller The comptroller contract.\n     */\n    function enterMarketIfNeeded(address _wallet, address _cToken, address _comptroller) internal {\n        bool isEntered = IComptroller(_comptroller).checkMembership(_wallet, ICToken(_cToken));\n        if (!isEntered) {\n            address[] memory market = new address[](1);\n            market[0] = _cToken;\n            invokeWallet(_wallet, _comptroller, 0, abi.encodeWithSignature(\"enterMarkets(address[])\", market));\n        }\n    }\n\n    /**\n     * @notice Exits a cToken market if there is no more collateral and debt.\n     * @param _wallet The target wallet.\n     * @param _cToken The cToken contract.\n     * @param _comptroller The comptroller contract.\n     */\n    function exitMarketIfNeeded(address _wallet, address _cToken, address _comptroller) internal {\n        uint collateral = ICToken(_cToken).balanceOf(_wallet);\n        uint debt = ICToken(_cToken).borrowBalanceStored(_wallet);\n        if (collateral == 0 \u0026\u0026 debt == 0) {\n            invokeWallet(_wallet, _comptroller, 0, abi.encodeWithSignature(\"exitMarket(address)\", _cToken));\n        }\n    }\n}\n"},"ERC20.sol":{"content":"pragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * ERC20 contract interface.\n */\ninterface ERC20 {\n    function totalSupply() external view returns (uint);\n    function decimals() external view returns (uint);\n    function balanceOf(address tokenOwner) external view returns (uint balance);\n    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n    function transfer(address to, uint tokens) external returns (bool success);\n    function approve(address spender, uint tokens) external returns (bool success);\n    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n}"},"ICompoundRegistry.sol":{"content":"// Copyright (C) 2020 Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title ICompoundRegistry\n * @notice Interface for CompoundRegistry\n */\ninterface ICompoundRegistry {\n    function addCToken(address _underlying, address _cToken) external;\n\n    function removeCToken(address _underlying) external;\n\n    function getCToken(address _underlying) external view returns (address);\n\n    function listUnderlyings() external view returns (address[] memory);\n}"},"IFeature.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IFeature\n * @notice Interface for a Feature.\n * @author Julien Niset - \u003cjulien@argent.xyz\u003e, Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ninterface IFeature {\n\n    enum OwnerSignature {\n        Anyone,             // Anyone\n        Required,           // Owner required\n        Optional,           // Owner and/or guardians\n        Disallowed          // guardians only\n    }\n\n    /**\n    * @notice Utility method to recover any ERC20 token that was sent to the Feature by mistake.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n\n    /**\n     * @notice Inits a Feature for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(address _wallet) external;\n\n    /**\n     * @notice Helper method to check if an address is an authorised feature of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _feature The address.\n     */\n    function isFeatureAuthorisedInVersionManager(address _wallet, address _feature) external view returns (bool);\n\n    /**\n    * @notice Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the wallet owner signature requirement.\n    */\n    function getRequiredSignatures(address _wallet, bytes calldata _data) external view returns (uint256, OwnerSignature);\n\n    /**\n    * @notice Gets the list of static call signatures that this feature responds to on behalf of wallets\n    */\n    function getStaticCallSignatures() external view returns (bytes4[] memory);\n}"},"ILimitStorage.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ILimitStorage\n * @notice LimitStorage interface\n */\ninterface ILimitStorage {\n\n    struct Limit {\n        // the current limit\n        uint128 current;\n        // the pending limit if any\n        uint128 pending;\n        // when the pending limit becomes the current limit\n        uint64 changeAfter;\n    }\n\n    struct DailySpent {\n        // The amount already spent during the current period\n        uint128 alreadySpent;\n        // The end of the current period\n        uint64 periodEnd;\n    }\n\n    function setLimit(address _wallet, Limit memory _limit) external;\n\n    function getLimit(address _wallet) external view returns (Limit memory _limit);\n\n    function setDailySpent(address _wallet, DailySpent memory _dailySpent) external;\n\n    function getDailySpent(address _wallet) external view returns (DailySpent memory _dailySpent);\n\n    function setLimitAndDailySpent(address _wallet, Limit memory _limit, DailySpent memory _dailySpent) external;\n\n    function getLimitAndDailySpent(address _wallet) external view returns (Limit memory _limit, DailySpent memory _dailySpent);\n}"},"ILockStorage.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\ninterface ILockStorage {\n    function isLocked(address _wallet) external view returns (bool);\n\n    function getLock(address _wallet) external view returns (uint256);\n\n    function getLocker(address _wallet) external view returns (address);\n\n    function setLock(address _wallet, address _locker, uint256 _releaseAfter) external;\n}"},"IModuleRegistry.sol":{"content":"// Copyright (C) 2020  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IModuleRegistry\n * @notice Interface for the registry of authorised modules.\n */\ninterface IModuleRegistry {\n    function registerModule(address _module, bytes32 _name) external;\n\n    function deregisterModule(address _module) external;\n\n    function registerUpgrader(address _upgrader, bytes32 _name) external;\n\n    function deregisterUpgrader(address _upgrader) external;\n\n    function recoverToken(address _token) external;\n\n    function moduleInfo(address _module) external view returns (bytes32);\n\n    function upgraderInfo(address _upgrader) external view returns (bytes32);\n\n    function isRegisteredModule(address _module) external view returns (bool);\n\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool);\n\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool);\n}"},"IVersionManager.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ILimitStorage.sol\";\n\n/**\n * @title IVersionManager\n * @notice Interface for the VersionManager module.\n * @author Olivier VDB - \u003colivier@argent.xyz\u003e\n */\ninterface IVersionManager {\n    /**\n     * @notice Returns true if the feature is authorised for the wallet\n     * @param _wallet The target wallet.\n     * @param _feature The feature.\n     */\n    function isFeatureAuthorised(address _wallet, address _feature) external view returns (bool);\n\n    /**\n     * @notice Lets a feature (caller) invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function checkAuthorisedFeatureAndInvokeWallet(\n        address _wallet,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes memory _res);\n\n    /* ******* Backward Compatibility with old Storages and BaseWallet *************** */\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _wallet, address _newOwner) external;\n\n    /**\n     * @notice Lets a feature write data to a storage contract.\n     * @param _wallet The target wallet.\n     * @param _storage The storage contract.\n     * @param _data The data of the call\n     */\n    function invokeStorage(address _wallet, address _storage, bytes calldata _data) external;\n\n    /**\n     * @notice Upgrade a wallet to a new version.\n     * @param _wallet the wallet to upgrade\n     * @param _toVersion the new version\n     */\n    function upgradeWallet(address _wallet, uint256 _toVersion) external;\n \n}"},"IWallet.sol":{"content":"// Copyright (C) 2018  Argent Labs Ltd. \u003chttps://argent.xyz\u003e\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity \u003e=0.5.4 \u003c0.7.0;\n\n/**\n * @title IWallet\n * @notice Interface for the BaseWallet\n */\ninterface IWallet {\n    /**\n     * @notice Returns the wallet owner.\n     * @return The wallet owner address.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the number of authorised modules.\n     * @return The number of authorised modules.\n     */\n    function modules() external view returns (uint);\n\n    /**\n     * @notice Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external;\n\n    /**\n     * @notice Checks if a module is authorised on the wallet.\n     * @param _module The module address to check.\n     * @return `true` if the module is authorised, otherwise `false`.\n     */\n    function authorised(address _module) external view returns (bool);\n\n    /**\n     * @notice Returns the module responsible for a static call redirection.\n     * @param _sig The signature of the static call.\n     * @return the module doing the redirection\n     */\n    function enabled(bytes4 _sig) external view returns (address);\n\n    /**\n     * @notice Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to `true` to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external;\n\n    /**\n    * @notice Enables a static method by specifying the target module to which the call must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external;\n}"},"SafeMath.sol":{"content":"pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"}}