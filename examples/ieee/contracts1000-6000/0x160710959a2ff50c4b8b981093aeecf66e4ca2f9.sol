{"AggregatorV3Interface.sol":{"content":"pragma solidity \u003e=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"},"SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Wrappers over Solidity\u0027s uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity\u0027s `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value \u003c 2**128, \"SafeCast: value doesn\\\u0027t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity\u0027s `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value \u003c 2**64, \"SafeCast: value doesn\\\u0027t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity\u0027s `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value \u003c 2**32, \"SafeCast: value doesn\\\u0027t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity\u0027s `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value \u003c 2**16, \"SafeCast: value doesn\\\u0027t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity\u0027s `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value \u003c 2**8, \"SafeCast: value doesn\\\u0027t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value \u003e= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity\u0027s `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value \u003e= -2**127 \u0026\u0026 value \u003c 2**127, \"SafeCast: value doesn\\\u0027t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity\u0027s `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value \u003e= -2**63 \u0026\u0026 value \u003c 2**63, \"SafeCast: value doesn\\\u0027t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity\u0027s `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value \u003e= -2**31 \u0026\u0026 value \u003c 2**31, \"SafeCast: value doesn\\\u0027t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity\u0027s `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value \u003e= -2**15 \u0026\u0026 value \u003c 2**15, \"SafeCast: value doesn\\\u0027t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity\u0027s `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value \u003e= -2**7 \u0026\u0026 value \u003c 2**7, \"SafeCast: value doesn\\\u0027t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value \u003c 2**255, \"SafeCast: value doesn\u0027t fit in an int256\");\n        return int256(value);\n    }\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"sbTokens.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./SafeCast.sol\u0027;\nimport \u0027./AggregatorV3Interface.sol\u0027;\n\ncontract sbTokens {\n  event TokenAdded(address indexed token, address indexed oracle);\n  event TokenPricesRecorded(uint256 indexed day);\n\n  using SafeCast for int256;\n  using SafeMath for uint256;\n\n  bool internal initDone;\n\n  uint16 internal constant PHASE_OFFSET = 64;\n\n  address internal sbTimelock;\n\n  address[] internal tokens;\n  address[] internal oracles;\n  mapping(address =\u003e uint16) internal oraclePhase;\n\n  mapping(address =\u003e AggregatorV3Interface) internal priceFeeds;\n\n  mapping(address =\u003e mapping(uint256 =\u003e uint256)) internal tokenDayPrice;\n  mapping(address =\u003e uint64) internal tokenRoundLatest;\n  mapping(address =\u003e uint256) internal tokenDayStart;\n  uint256 internal dayLastRecordedPricesFor;\n\n  function init(\n    address sbTimelockAddress,\n    address[] memory tokenAddresses,\n    address[] memory oracleAddresses\n  ) public {\n    require(!initDone, \u0027init done\u0027);\n    // NOTE: ETH will be address(0)\n    require(tokenAddresses.length == oracleAddresses.length, \u0027mismatch array lengths\u0027);\n    require(tokenAddresses.length \u003e 0, \u0027zero\u0027);\n    sbTimelock = sbTimelockAddress;\n    dayLastRecordedPricesFor = _getCurrentDay().sub(1);\n    for (uint256 i = 0; i \u003c tokenAddresses.length; i++) {\n      _addToken(tokenAddresses[i], oracleAddresses[i]);\n    }\n    initDone = true;\n  }\n\n  function upToDate() external view returns (bool) {\n    return dayLastRecordedPricesFor == _getCurrentDay().sub(1);\n  }\n\n  function addToken(address token, address oracle) external {\n    require(msg.sender == sbTimelock, \u0027not sbTimelock\u0027);\n    require(token != address(0), \u0027token not zero address\u0027);\n    require(oracle != address(0), \u0027oracle not zero address\u0027);\n    require(oracle != token, \u0027token oracle not same\u0027);\n    require(!_tokenExists(token), \u0027token exists\u0027);\n    require(!_oracleExists(oracle), \u0027oracle exists\u0027);\n    _addToken(token, oracle);\n  }\n\n  function getTokens() external view returns (address[] memory) {\n    return tokens;\n  }\n\n  function getTokenPrices(uint256 day) external view returns (uint256[] memory) {\n    require(day \u003c= dayLastRecordedPricesFor, \u0027invalid day\u0027);\n    uint256[] memory prices = new uint256[](tokens.length);\n    for (uint256 i = 0; i \u003c tokens.length; i++) {\n      address token = tokens[i];\n      prices[i] = tokenDayPrice[token][day];\n    }\n    return prices;\n  }\n\n  function tokenAccepted(address token) external view returns (bool) {\n    return _tokenExists(token);\n  }\n\n  function getTokenPrice(address token, uint256 day) external view returns (uint256) {\n    require(_tokenExists(token), \u0027invalid token\u0027);\n    require(day \u003e= tokenDayStart[token], \u00271: invalid day\u0027);\n    require(day \u003c= dayLastRecordedPricesFor, \u00272: invalid day\u0027);\n    return tokenDayPrice[token][day];\n  }\n\n  function getOracles() public view returns (address[] memory) {\n    return oracles;\n  }\n\n  function getDayLastRecordedPricesFor() public view returns (uint256) {\n    return dayLastRecordedPricesFor;\n  }\n\n  function getSbTimelockAddressUsed() public view returns (address) {\n    return sbTimelock;\n  }\n\n  function getTokenRoundLatest(address token) public view returns (uint80) {\n    require(_tokenExists(token), \u0027invalid token\u0027);\n    return _makeCombinedId(oraclePhase[token], tokenRoundLatest[token]);\n  }\n\n  function getTokenDayStart(address token) public view returns (uint256) {\n    require(_tokenExists(token), \u0027invalid token\u0027);\n    return tokenDayStart[token];\n  }\n\n  function getCurrentDay() public view returns (uint256) {\n    return _getCurrentDay();\n  }\n\n  function recordTokenPrices() public {\n    require(_getCurrentDay() \u003e dayLastRecordedPricesFor.add(1), \u0027already recorded\u0027);\n    dayLastRecordedPricesFor = dayLastRecordedPricesFor.add(1);\n    for (uint256 i = 0; i \u003c tokens.length; i++) {\n      (uint80 roundId, , , , ) = priceFeeds[tokens[i]].latestRoundData();\n      (uint16 phase, ) = _getPhaseIdRoundId(roundId);\n\n      if (oraclePhase[tokens[i]] != phase) {\n        oraclePhase[tokens[i]] = phase;\n        _cacheToken(tokens[i], _dayToTimestamp(dayLastRecordedPricesFor));\n      }\n\n      tokenDayPrice[tokens[i]][dayLastRecordedPricesFor] = _getDayClosingPrice(tokens[i], dayLastRecordedPricesFor);\n    }\n    emit TokenPricesRecorded(dayLastRecordedPricesFor);\n  }\n\n  function _addToken(address token, address oracle) internal {\n    tokens.push(token);\n    oracles.push(oracle);\n    priceFeeds[token] = AggregatorV3Interface(oracle);\n    (uint80 roundId, , , , ) = priceFeeds[token].latestRoundData();\n    (uint16 phaseId, ) = _getPhaseIdRoundId(roundId);\n    oraclePhase[token] = phaseId;\n    uint256 currentDay = _getCurrentDay();\n    tokenDayStart[token] = currentDay;\n    uint256 timestamp = _dayToTimestamp(currentDay.sub(1));\n    _cacheToken(token, timestamp);\n    emit TokenAdded(token, oracle);\n  }\n\n  function _cacheToken(address token, uint256 timestamp) internal {\n    tokenRoundLatest[token] = 1;\n    uint64 roundId = _getRoundBeforeTimestamp(token, timestamp);\n    tokenRoundLatest[token] = roundId;\n  }\n\n  function _getRoundBeforeTimestamp(address token, uint256 timestamp) internal view returns (uint64) {\n    uint64 left = tokenRoundLatest[token];\n    (uint80 roundId, , , , ) = priceFeeds[token].latestRoundData();\n    (, uint64 right) = _getPhaseIdRoundId(roundId);\n    uint64 middle = (right + left) / 2;\n    while (left \u003c= right) {\n      roundId = _makeCombinedId(oraclePhase[token], middle);\n      (, , , uint256 roundTimestamp, ) = priceFeeds[token].getRoundData(roundId);\n      if (roundTimestamp == timestamp) {\n        return middle - 1;\n      } else if (roundTimestamp \u003c timestamp) {\n        left = middle + 1;\n      } else {\n        right = middle - 1;\n      }\n      middle = (right + left) / 2;\n    }\n    return middle;\n  }\n\n  function _getDayClosingPrice(address token, uint256 day) internal returns (uint256) {\n    uint256 timestamp = _dayToTimestamp(day);\n    uint64 roundId = _getRoundBeforeTimestamp(token, timestamp);\n    tokenRoundLatest[token] = roundId;\n    uint80 combinedId = _makeCombinedId(oraclePhase[token], roundId);\n    (, int256 price, , , ) = priceFeeds[token].getRoundData(combinedId);\n    uint256 priceUint256 = price.toUint256();\n    uint8 decimals = priceFeeds[token].decimals();\n    for (uint8 i = decimals; i \u003c 18; i++) {\n      priceUint256 = priceUint256.mul(10);\n    }\n    return priceUint256;\n  }\n\n  function _getCurrentDay() internal view returns (uint256) {\n    return block.timestamp.div(1 days).add(1);\n  }\n\n  function _dayToTimestamp(uint256 day) internal pure returns (uint256) {\n    return day.mul(1 days);\n  }\n\n  function _tokenExists(address token) internal view returns (bool) {\n    for (uint256 i = 0; i \u003c tokens.length; i++) {\n      if (token == tokens[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _oracleExists(address oracle) internal view returns (bool) {\n    for (uint256 i = 0; i \u003c oracles.length; i++) {\n      if (oracle == oracles[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _getPhaseIdRoundId(uint256 combinedId) internal pure returns (uint16, uint64) {\n    return (uint16(combinedId \u003e\u003e PHASE_OFFSET), uint64(combinedId));\n  }\n\n  function _makeCombinedId(uint80 phaseId, uint64 roundId) internal pure returns (uint80) {\n    return (phaseId \u003c\u003c PHASE_OFFSET) | roundId;\n  }\n}\n"}}