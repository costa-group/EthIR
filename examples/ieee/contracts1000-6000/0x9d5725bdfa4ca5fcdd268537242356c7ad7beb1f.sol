{"Invite.sol":{"content":"pragma solidity ^0.5.0;\nimport \"./SafeMath.sol\";\n\ncontract AffiliateStorage {\n\tusing SafeMath for uint;\n\n\tmapping(uint=\u003eaddress) public codeToAddressMap;\n\tmapping(address=\u003euint) public addressToCodeMap;\n\tmapping(address=\u003euint) public addressToFatherCode;\n\tuint private constant maxCode = 100000000;\n\tbytes public constant baseString = \"0123456789abcdefghjklmnpqrstuvwxyz\";\n\n\n\t/**\n\t* code is the last 6 digt of user\n\t**/\n\tfunction newCode(address user) public returns(uint) {\n\t\trequire(addressToCodeMap[user] == 0, \"user existed\");\n\n\t\tuint code = uint(user);\n\t\tcode = code.sub(code.div(maxCode).mul(maxCode));\n\n\t\trequire(code !=0, \"code must \u003e 0\");\n\n\t\twhile(codeToAddressMap[code]!=address(0)) {\n\t\t\tcode = code.add(7);\n\t\t}\n\t\tcodeToAddressMap[code] = user;\n\t\taddressToCodeMap[user] = code;\n\t\treturn code;\n\n\t}\n\n\tfunction getCode(address user) public view returns(uint) {\n\t\tuint code = addressToCodeMap[user];\n\t\tif(code != 0)\n\t\t\treturn code;\n\t}\n\n\tfunction getUser(uint code) public view returns(address) {\n\t\treturn codeToAddressMap[code];\n\t}\n\t\n\tfunction setFather(uint code) public {\n\t    require(codeToAddressMap[code] != address(0), \"inviteCode not existed\");\n\t    addressToFatherCode[msg.sender] = code;\n\t}\n\t\n\tfunction getFatherCode(address userAddress) public view returns (uint){\n\t    uint FatherCode = addressToFatherCode[userAddress];\n\t    return FatherCode;\n\t}\n\t\n\tfunction getFather(address userAddress) public view returns(address){\n        uint FatherCode = addressToFatherCode[userAddress];\n        if(FatherCode != 0 ){\n        address FatherAddress = getUser(FatherCode);\n        return  FatherAddress;\n        }\n        //require(addressToFatherCode[userAddress]!=0,\"FatherCode not existed\");\n\t}\n\t\n} "},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"}}