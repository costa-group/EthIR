{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n\r\nlibrary Address {\r\n  function isContract(\r\n    address account\r\n  ) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(account) }\r\n    return size \u003e 0;\r\n  }\r\n\r\n  function sendValue(\r\n    address payable recipient,\r\n    uint256 amount\r\n  ) internal {\r\n    require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success, ) = recipient.call{ value: amount }(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data\r\n  ) internal returns (bytes memory) {\r\n    return functionCall(target, data, \"Address: low-level call failed\");\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return _functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n    return _functionCallWithValue(target, data, value, errorMessage);\r\n  }\r\n\r\n  function _functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 weiValue,\r\n    string memory errorMessage\r\n  ) private returns (bytes memory) {\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length \u003e 0) {\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}"},"Burnable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/// @title Burnable\r\n///\r\n/// @notice This contract covers everything related\r\n/// to the burn functions\r\n///\r\ncontract Burnable {\r\n  /// @dev Declare a private bool {_burningEnabled}\r\n  ///\r\n  bool private _burningEnabled;\r\n\r\n  /// @dev Declare a public constant of type bytes32\r\n  ///\r\n  /// @return The bytes32 string of the role\r\n  ///\r\n  bytes32 public constant ROLE_BURNER = keccak256(\"BURNER\");\r\n\r\n  /// @dev Declare two events to expose when burning\r\n  /// is enabled or disabled, take the event\u0027s sender\r\n  /// as argument\r\n  ///\r\n  event BurningEnabled(address indexed _from);\r\n  event BurningDisabled(address indexed _from);\r\n\r\n  /// @dev Verify if the sender can burn, if yes,\r\n  /// enable burning\r\n  /// \r\n  /// Requirements:\r\n  /// {_hasRole} should be true\r\n  /// {_amount} should be superior to 0\r\n  /// {_burningEnabled} should be true\r\n  ///\r\n  modifier isBurnable(\r\n    uint256 _amount,\r\n    bool _hasRole\r\n  ) {\r\n    require(\r\n      _hasRole,\r\n      \"BC:500\"\r\n    );\r\n\r\n    require(\r\n      _amount \u003e 0,\r\n      \"BC:30\"\r\n    );\r\n\r\n    _enableBurning();\r\n\r\n    require(\r\n      burningEnabled(),\r\n      \"BC:210\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev By default, burning is disabled\r\n  ///\r\n  constructor()\r\n  internal {\r\n    _burningEnabled = false;\r\n  }\r\n\r\n  /// @notice Expose the state of {_burningEnabled}\r\n  ///\r\n  /// @return The state as a bool\r\n  ///\r\n  function burningEnabled()\r\n  public view returns (bool) {\r\n    return _burningEnabled;\r\n  }\r\n\r\n  /// @dev Enable burning by setting {_burningEnabled}\r\n  /// to true, then emit the related event\r\n  ///\r\n  function _enableBurning()\r\n  internal virtual {\r\n    _burningEnabled = true;\r\n    emit BurningEnabled(msg.sender);\r\n  }\r\n\r\n  /// @dev Disable burning by setting {_burningEnabled}\r\n  /// to false, then emit the related event\r\n  ///\r\n  function _disableBurning()\r\n  internal virtual {\r\n    _burningEnabled = false;\r\n    emit BurningDisabled(msg.sender);\r\n  }\r\n}\r\n"},"CreationEngine.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \u0027./CreationEngineDAO.sol\u0027;\r\nimport \u0027./CreationEngineDApp.sol\u0027;\r\n\r\n/// Creation Engine is a full suite ERC20 token compatible with all modern functionalities.\r\n/// Staking, Farming, NFTs, DAO, DApps, Burn function, Governance. This token does it all.\r\n/// Will you explore the stars with your very own Creation Engine?\r\n/// t.me/CreationEngine\r\n/// t.me/CreationEngineCommunity\r\n///\r\n///                                  ...,...                                  \r\n///                             .......:o;........                               \r\n///                         ..........;dko\u0027............                         \r\n///                    ...............cxdd:................                     \r\n///                ..................;ol:oo,.................                 \r\n///               ..................\u0027lo,\u0027:oc...................               \r\n///            .....................:o:..\u0027co;....................             \r\n///          ......................;ol\u0027...,ol\u0027.....................           \r\n///        .......................,oo;,:c;,:dc\u0027......................         \r\n///       .......................,lo::ooool;cdc\u0027......................        \r\n///      ..............;,\u0027......,odccol,,;oo:ldl\u0027......\u0027;,..............      \r\n///     ...............cddl:,...;lloddc,,;ldollc,..\u0027,cldd;..............      \r\n///    .................:ddollc:;,,:ddddododd:,,;:llooxd;.................    \r\n///    ..................:dl;;:lodlodllxOxcodllool:;;oo;..................    \r\n///   ...................\u0027:dl,,:odlldooxkxlodcldl;\u0027;lo;....................   \r\n///  ................\u0027;cc,\u0027:ddooxxoodxolcldddooxxoodo;\u0027,cc,................   \r\n///  ............\u0027;clloodc,,ldl:oxl:coo:;:oo::odl:ldc,,ldollc:;\u0027............  \r\n///........\u0027;:cclllc:;:lddooooooddl:;:ooodo:;:oddooooloddl:;:cllccc:,\u0027....... \r\n///.\u0027;:ccllllc:,\u0027..;lolcclddoodddlloooodddoooolldddodddc:lloc,..\u0027;:cllllcc:;\u0027.\r\n///.,:cloollc:;\u0027...;lolc:cddddddocloooddddooolccdxddddoc:cool,...,;cclloolc;\u0027.\r\n///.......\u0027,:cccccc:;;:lddooooooddl:;:odddl:;coddooooooddl:;;:cclcc:;,\u0027...... \r\n///  ...........\u0027;:clllodc,;loc:odc;:oo:;col;;ldl:loc;,ldolllc:,\u0027............ \r\n///   ...............,:ol,\u0027:ddooxxooddoc:cdxoldxxoodo;\u0027;ll:\u0027................  \r\n///   ...................\u0027:ol,,:ddcldooxxxoddcldo:,;oo;....................   \r\n///   ...................:ol,,;lddoodllxOdcodlodoc;,;oo;...................   \r\n///    .................:ddllllc:,,cddddddddo;,,:cllloxo;................     \r\n///     ...............:ddoc;\u0027.\u0027;cllddc;,;lddllc,..\u0027;coxd;...............     \r\n///      .............\u0027:;,......;dxccol,\u0027;lo:lxl,......,:;..............      \r\n///      ........................,oo::ooloo::dl\u0027.......................       \r\n///         ......................,ol,,cc:,;ol\u0027.......................        \r\n///          ......................;oc\u0027...\u0027lo,.....................           \r\n///            .....................co;...co;.....................            \r\n///             ....................\u0027ol,\u0027;oc...................               \r\n///                 .................:ol;lo,................                  \r\n///                    ..............\u0027ldddc...............                    \r\n///                         ..........;dko,..........                         \r\n///                             .  ....co:.....                               \r\n///                                  ..\u0027;\u0027..     \r\n///\r\ncontract CreationEngine is CreationEngineDAO, CreationEngineDApp {\r\n\r\n  /// @notice Declare a public constant of type string\r\n  ///\r\n  /// @return The smart contract author\r\n  ///\r\n  string public constant CREATOR = \"t.me/CreationEngine\";\r\n}"},"CreationEngineDAO.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \u0027./Voteable.sol\u0027;\r\nimport \u0027./CreationEngineDApp.sol\u0027;\r\n\r\n/// @title CreationEngineDAO\r\n///\r\n/// @notice This contract covers everything related\r\n/// to the organization of Creation Engine\r\n///\r\n/// @dev Inehrit {Voteable} and {CreationEngineToken}\r\n///\r\nabstract contract CreationEngineDAO is Voteable, CreationEngineToken {\r\n  \r\n  /// @notice ROLE_CHAIRPERSON is granted to the\r\n  /// original contract deployer\r\n  ///\r\n  /// @dev See {Roleplay::grantRole()}\r\n  ///\r\n  constructor() public {\r\n    grantRole(ROLE_CHAIRPERSON, msg.sender);\r\n  }\r\n\r\n  /// @notice This function allows the sender to vote\r\n  /// for a proposal, the vote can be positive or negative.\r\n  /// The sender has to complete the requirements to be\r\n  /// able to vote for a proposal.\r\n  ///\r\n  /// @dev Depending on the value of {_isPositiveVote}, add a\r\n  /// *positive/negative* vote to the proposal, identified\r\n  /// by its {_id}, then push the sender address into the\r\n  /// voters pool of the proposal\r\n  ///\r\n  /// Requirements:\r\n  /// See {Voteable::isValidVoter()} \r\n  /// See {Voteable::isVoteEnabled()} \r\n  ///\r\n  /// @param _id - Represent the proposal id\r\n  /// @param _isPositiveVote - Represent the vote type\r\n  ///\r\n  function voteForProposal(\r\n    uint256 _id,\r\n    bool _isPositiveVote\r\n  ) public virtual isValidVoter(\r\n    _id,\r\n    balanceOf(msg.sender)\r\n  ) isVoteEnabled(\r\n    _id\r\n  ) {\r\n    if (_isPositiveVote) {\r\n      proposals[_id].positiveVote += 1;\r\n      proposals[_id].positiveVoters.push(msg.sender);\r\n    }\r\n\r\n    if (!_isPositiveVote) {\r\n      proposals[_id].negativeVote += 1;\r\n      proposals[_id].negativeVoters.push(msg.sender);\r\n    }\r\n  }\r\n}"},"CreationEngineDApp.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \u0027./Stakeable.sol\u0027;\r\nimport \u0027./Roleplay.sol\u0027;\r\nimport \u0027./CreationEngineToken.sol\u0027;\r\n\r\n/// @title CreationEngineDApp\r\n///\r\n/// @notice This contract covers everything related\r\n/// to the DApp of Creation Engine\r\n///\r\n/// @dev Inehrit {Stakeable} and {CreationEngineToken}\r\n///\r\nabstract contract CreationEngineDApp is Roleplay, Stakeable, CreationEngineToken {\r\n\r\n  /// @notice This function allows the sender to stake\r\n  /// an amount (maximum 10) of CreationEngineToken, when the\r\n  /// token is staked, it is burned from the circulating\r\n  /// supply and placed into the staking pool\r\n  /// \r\n  /// @dev The function iterate through {stakeholders} to\r\n  /// know if the sender is already a stakeholder. If the\r\n  /// sender is already a stakeholder, then the requested amount\r\n  /// is staked into the pool and then burned from the sender wallet.\r\n  /// If the sender isn\u0027t a stakeholer, a new stakeholder is created,\r\n  /// and then the function is recall to stake the requested amount\r\n  ///\r\n  /// Requirements:\r\n  /// See {Stakeable::isAmountValid()}\r\n  ///\r\n  /// @param _amount - Represent the amount of token to be staked\r\n  ///\r\n  function stake(\r\n    uint256 _amount\r\n  ) public virtual isAmountValid(\r\n    _amount,\r\n    balanceOf(msg.sender)\r\n  ) isAmountNotZero(\r\n    _amount\r\n  ) {\r\n    uint256 i = 0;\r\n    bool isStakeholder = false;\r\n    uint256 len = stakeholders.length;\r\n    while (i \u003c len) {\r\n      if (stakeholders[i].owner == msg.sender) {\r\n        isStakeholder = true;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    if (isStakeholder) {\r\n      stakeholders[i].stake += _amount;\r\n      _burn(msg.sender, (_amount * (10**8)));\r\n      _totalStakedSupply += (_amount * (10**8));\r\n      emit Staked(msg.sender, _amount);\r\n    }\r\n\r\n    if (!isStakeholder) {\r\n      _createStakeholder(msg.sender);\r\n      stake(_amount);\r\n    }\r\n  }\r\n  \r\n  /// @notice This function unstacks the sender staked\r\n  /// balance depending on the requested {_amount}, if the\r\n  /// {_amount} exceeded the staked supply of the sender,\r\n  /// the whole staked supply of the sender will be unstacked\r\n  /// and withdrawn to the sender wallet without exceeding it.\r\n  ///\r\n  /// @dev Like stake() function do, this function iterate\r\n  /// over the stakeholders to identify if the sender is one \r\n  /// of them, in the case of the sender is identified as a\r\n  /// stakeholder, then the {_amount} is minted to the sender\r\n  /// wallet and sub from the staked supply.\r\n  ///\r\n  /// Requirements:\r\n  /// See {Stakeable::isAmountNotZero}\r\n  /// See {Stakeable::isAbleToUnstake}\r\n  ///\r\n  /// @param _amount - Represent the amount of token to be unstack\r\n  ///\r\n  function unstake(\r\n    uint256 _amount\r\n  ) public virtual isAmountNotZero(\r\n    _amount\r\n  ) isAbleToUnstake(\r\n    _amount\r\n  ) {\r\n    uint256 i = 0;\r\n    bool isStakeholder = false;\r\n    uint256 len = stakeholders.length;\r\n    while (i \u003c len) {\r\n      if (stakeholders[i].owner == msg.sender) {\r\n        isStakeholder = true;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    require(\r\n      isStakeholder,\r\n      \"SC:650\"\r\n    );\r\n\r\n    if (isStakeholder) {\r\n      if (_amount \u003c= stakeholders[i].stake) {\r\n        stakeholders[i].stake -= _amount;\r\n        _mint(msg.sender, (_amount * (10**8)));\r\n        _totalStakedSupply -= (_amount * (10**8));\r\n        emit Unstaked(msg.sender, _amount);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /// @notice This function allows the sender to compute\r\n  /// his reward earned by staking {UnissouToken}. When you\r\n  /// request a withdraw, the function updates the reward\u0027s\r\n  /// value of the sender stakeholding onto the Ethereum\r\n  /// blockchain, allowing him to spend the reward for NFTs.\r\n  ///\r\n  /// @dev The same principe as other functions is applied here,\r\n  /// iteration over stakeholders, when found, execute the action.\r\n  /// See {Stakeable::_computeReward()}\r\n  ///\r\n  function withdraw()\r\n  public virtual {\r\n    uint256 i = 0;\r\n    bool isStakeholder = false;\r\n    uint256 len = stakeholders.length;\r\n    while (i \u003c len) {\r\n      if (stakeholders[i].owner == msg.sender) {\r\n        isStakeholder = true;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    require(\r\n      isStakeholder,\r\n      \"SC:650\"\r\n    );\r\n\r\n    if (isStakeholder) {\r\n      _computeReward(i);\r\n    }\r\n  }\r\n\r\n  /// @notice This function allows the owner to spend {_amount} \r\n  /// of the target rewards gained from his stake.\r\n  ///\r\n  /// @dev To reduce the potential numbers of transaction, the\r\n  /// {_computeReward()} function is also executed into this function.\r\n  ///\r\n  /// @param _amount - Represent the amount of reward to spend\r\n  /// @param _target - Represent the address of the stakeholder owner\r\n  ///\r\n  function spend(\r\n    uint256 _amount,\r\n    address _target\r\n  ) public virtual onlyOwner() {\r\n    uint256 i = 0;\r\n    bool isStakeholder = false;\r\n    uint256 len = stakeholders.length;\r\n    while (i \u003c len) {\r\n      if (stakeholders[i].owner == _target) {\r\n        isStakeholder = true;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    require(\r\n      isStakeholder,\r\n      \"SC:650\"\r\n    );\r\n\r\n    if (isStakeholder) {\r\n      _computeReward(i);\r\n      require(\r\n        _amount \u003c= stakeholders[i].availableReward,\r\n        \"SC:660\"\r\n      );\r\n\r\n      stakeholders[i].availableReward -= _amount;\r\n      stakeholders[i].totalRewardSpent += _amount;\r\n    }\r\n  }\r\n}"},"CreationEngineToken.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport \u0027./ERC20.sol\u0027;\r\nimport \u0027./Roleplay.sol\u0027;\r\nimport \u0027./Pauseable.sol\u0027;\r\nimport \u0027./Mintable.sol\u0027;\r\nimport \u0027./Burnable.sol\u0027;\r\n\r\n/// @title CreationEngineToken\r\n///\r\n/// @notice This contract covers everything related\r\n/// to the Creation Engine ERC20\r\n///\r\n/// @dev Inehrit {ERC20}, {Roleplay}, {Pauseable},\r\n/// {Mintable} and {Burnable}\r\n///\r\nabstract contract CreationEngineToken is \r\nERC20, Roleplay, Pauseable, Minteable, Burnable {\r\n\r\n  /// @notice Original contract\u0027s deployer are granted\r\n  /// with Owner role and Manager role and the initial\r\n  /// supply are minted onto his wallet.\r\n  ///\r\n  /// @dev See {ERC20}\r\n  ///\r\n  constructor()\r\n  public ERC20(\r\n    \"Creation Engine Token\",\r\n    \"CET\",\r\n    40000 * (10**8),\r\n    1000 * (10**8)\r\n  ) {\r\n    _setupRole(ROLE_OWNER, msg.sender);\r\n    _setupRole(ROLE_MANAGER, msg.sender);\r\n    _mint(msg.sender, initialSupply());\r\n  }\r\n  \r\n  /// @notice This function allows to transfer tokens to multiple\r\n  /// addresses in only one transaction, that help to reduce fees.\r\n  /// The amount cannot be dynamic and is constant for all transfer\r\n  ///\r\n  /// @param _receivers - Represent an array of address\r\n  /// @param _amount - Represent the amount of token to transfer\r\n  ///\r\n  function transferBatch(\r\n    address[] memory _receivers,\r\n    uint256 _amount\r\n  ) public virtual {\r\n    uint256 i = 0;\r\n    uint256 len = _receivers.length;\r\n\r\n    require(\r\n      balanceOf(msg.sender) \u003e= (_amount * len),\r\n      \"UT:470\"\r\n    );\r\n\r\n    while (i \u003c len) {\r\n      transfer(_receivers[i], _amount);\r\n      i++;\r\n    }\r\n  } \r\n\r\n  /// @notice This function allows the sender to mint\r\n  /// an {_amount} of token unless the {_amount}\r\n  /// exceed the total supply cap\r\n  ///\r\n  /// @dev Once the minting is down, minting is disabled\r\n  ///\r\n  /// Requirements:\r\n  /// See {Mintable::isMintable()}\r\n  ///\r\n  /// @param _amount - Represent the amount of token\r\n  /// to be minted\r\n  ///\r\n  function mint(\r\n    uint256 _amount\r\n  ) public virtual isMintable(\r\n    _amount,\r\n    hasRole(ROLE_MINTER, msg.sender)\r\n  ) {\r\n    _mint(msg.sender, _amount);\r\n    _disableMinting();\r\n  }\r\n\r\n  /// @notice This function allows the sender to mint\r\n  /// an {_amount} of token directly onto the address {_to}\r\n  /// unless the {_amount} exceed the total supply cap\r\n  ///\r\n  /// @dev Once the minting is down, minting is disabled\r\n  ///\r\n  /// Requirements:\r\n  /// See {Minteable::isMinteable()}\r\n  ///\r\n  /// @param _to - Represent the token\u0027s receiver\r\n  /// @param _amount - Represent the amount of token\r\n  /// to be minted\r\n  ///\r\n  function mintTo(\r\n    address _to,\r\n    uint256 _amount\r\n  ) public virtual isMintable(\r\n    _amount,\r\n    hasRole(ROLE_MINTER, msg.sender)\r\n  ) {\r\n    _mint(_to, _amount);\r\n    _disableMinting();\r\n  }\r\n\r\n  /// @notice This function allows the sender to burn\r\n  /// an {_amount} of token\r\n  ///\r\n  /// @dev Once the burning is down, burning is disabled\r\n  ///\r\n  /// Requirements:\r\n  /// See {Burneable::isBurneable()}\r\n  ///\r\n  /// @param _amount - Represent the amount of token\r\n  /// to be burned\r\n  ///\r\n  function burn(\r\n    uint256 _amount\r\n  ) public virtual isBurnable(\r\n    _amount,\r\n    hasRole(ROLE_BURNER, msg.sender)\r\n  ) {\r\n    _burn(msg.sender, _amount);\r\n    _disableBurning();\r\n  }\r\n\r\n  /// @notice This function allows the sender to burn\r\n  /// an {_amount} of token directly from the address {_from}\r\n  /// only if the token allowance is superior or equal\r\n  /// to the requested {_amount}\r\n  ///\r\n  /// @dev Once the burning is down, burning is disabled\r\n  ///\r\n  /// Requirements:\r\n  /// See {Burneable::isBurneable()}\r\n  ///\r\n  /// @param _from - Represent the token\u0027s receiver\r\n  /// @param _amount - Represent the amount of token\r\n  /// to be burned\r\n  ///\r\n  function burnFrom(\r\n    address _from,\r\n    uint256 _amount\r\n  ) public virtual isBurnable(\r\n    _amount,\r\n    hasRole(ROLE_BURNER, msg.sender)\r\n  ) {\r\n    uint256 decreasedAllowance = allowance(_from, msg.sender).sub(_amount);\r\n    _approve(_from, msg.sender, decreasedAllowance);\r\n    _burn(_from, _amount);\r\n    _disableBurning();\r\n  }\r\n\r\n  /// @notice This function does verification before\r\n  /// any token transfer. The actual verification are:\r\n  /// - If the total supply don\u0027t exceed the total\r\n  /// supply cap (for example, when token are minted),\r\n  /// - If the token\u0027s transfer are not paused\r\n  ///\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual override {\r\n    super._beforeTokenTransfer(from, to, amount);\r\n\r\n    if (from == address(0)) {\r\n      require(\r\n        totalSupply().add(amount) \u003c= totalSupplyCap(),\r\n        \"UT:20\"\r\n      );\r\n    }\r\n\r\n    require(\r\n      !paused(),\r\n      \"UT:400\"\r\n    );\r\n  }\r\n}"},"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\r\n\r\nlibrary EnumerableSet {\r\n  struct Set {\r\n    bytes32[] _values;\r\n    mapping (bytes32 =\u003e uint256) _indexes;\r\n  }\r\n\r\n  function _add(\r\n    Set storage set,\r\n    bytes32 value\r\n  ) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function _remove(\r\n    Set storage set,\r\n    bytes32 value\r\n  ) private returns (bool) {\r\n    uint256 valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      uint256 toDeleteIndex = valueIndex - 1;\r\n      uint256 lastIndex = set._values.length - 1;\r\n      bytes32 lastvalue = set._values[lastIndex];\r\n      set._values[toDeleteIndex] = lastvalue;\r\n      set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n      set._values.pop();\r\n      delete set._indexes[value];\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function _contains(\r\n    Set storage set,\r\n    bytes32 value\r\n  ) private view returns (bool) {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  function _length(\r\n    Set storage set\r\n  ) private view returns (uint256) {\r\n    return set._values.length;\r\n  }\r\n\r\n  function _at(\r\n    Set storage set,\r\n    uint256 index\r\n  ) private view returns (bytes32) {\r\n    require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\r\n    return set._values[index];\r\n  }\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  function add(\r\n    AddressSet storage set,\r\n    address value\r\n  ) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint256(value)));\r\n  }\r\n\r\n  function remove(\r\n    AddressSet storage set,\r\n    address value\r\n  ) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(uint256(value)));\r\n  }\r\n\r\n  function contains(\r\n    AddressSet storage set,\r\n    address value\r\n  ) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(uint256(value)));\r\n  }\r\n\r\n  function length(\r\n    AddressSet storage set\r\n  ) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  function at(\r\n    AddressSet storage set,\r\n    uint256 index\r\n  ) internal view returns (address) {\r\n    return address(uint256(_at(set._inner, index)));\r\n  }\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  function add(\r\n    UintSet storage set,\r\n    uint256 value\r\n  ) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  function remove(\r\n    UintSet storage set,\r\n    uint256 value\r\n  ) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  function contains(\r\n    UintSet storage set,\r\n    uint256 value\r\n  ) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  function length(\r\n    UintSet storage set\r\n  ) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  function at(\r\n    UintSet storage set,\r\n    uint256 index\r\n  ) internal view returns (uint256) {\r\n    return uint256(_at(set._inner, index));\r\n  }\r\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol\r\n\r\nabstract contract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  mapping (address =\u003e uint256) private _balances;\r\n\r\n  mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n  uint256 private _initialSupply;\r\n  uint256 private _totalSupply;\r\n  uint256 private _totalSupplyCap;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor (\r\n    string memory name,\r\n    string memory symbol,\r\n    uint256 totalSupplyCap,\r\n    uint256 initialSupply\r\n  ) public {\r\n    _decimals = 8;\r\n\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _totalSupplyCap = totalSupplyCap;\r\n    _initialSupply = initialSupply;\r\n  }\r\n\r\n  function name()\r\n  public view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol()\r\n  public view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals()\r\n  public view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function initialSupply()\r\n  public view override returns (uint256) {\r\n    return _initialSupply;\r\n  }\r\n\r\n  function totalSupply()\r\n  public view override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function totalSupplyCap()\r\n  public view override returns (uint256) {\r\n    return _totalSupplyCap;\r\n  }\r\n\r\n  function balanceOf(\r\n    address account\r\n  ) public view override returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  function transfer(\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _transfer(msg.sender, recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  ) public view virtual override returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  function approve(\r\n    address spender,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _approve(msg.sender, spender, (amount * (10**8)));\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, msg.sender, _allowances[sender][msg.sender].sub((amount * (10**8)), \"ERC20:490\"));\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  ) public virtual returns (bool) {\r\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add((addedValue * (10**8))));\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  ) public virtual returns (bool) {\r\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub((subtractedValue * (10**8)), \"ERC20:495\"));\r\n    return true;\r\n  }\r\n\r\n  function _transfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(\r\n      sender != address(0),\r\n      \"ERC20:410\"\r\n    );\r\n\r\n    require(\r\n      recipient != address(0),\r\n      \"ERC20:420\"\r\n    );\r\n\r\n    require(\r\n      amount \u003e 0,\r\n      \"ERC20:480\"\r\n    );\r\n\r\n    _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20:470\");\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  function _mint(\r\n    address account,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(\r\n      account != address(0),\r\n      \"ERC20:120\"\r\n    );\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  function _burn(\r\n    address account,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(\r\n      account != address(0),\r\n      \"ERC20:220\"\r\n    );\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    _balances[account] = _balances[account].sub(amount, \"ERC20:230\");\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(\r\n      owner != address(0),\r\n      \"ERC20:450\"\r\n    );\r\n    require(\r\n      spender != address(0),\r\n      \"ERC20:460\"\r\n    );\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  function _setupDecimals(\r\n    uint8 decimals_\r\n  ) internal {\r\n    _decimals = decimals_;\r\n  }\r\n\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n}"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\r\n\r\ninterface IERC20 {\r\n  function initialSupply()\r\n  external view returns (uint256);\r\n\r\n  function totalSupply()\r\n  external view returns (uint256);\r\n\r\n  function totalSupplyCap()\r\n  external view returns (uint256);\r\n\r\n  function balanceOf(\r\n    address account\r\n  ) external view returns (uint256);\r\n\r\n  function transfer(\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  ) external view returns (uint256);\r\n\r\n  function approve(\r\n    address spender,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}"},"Mintable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/// @title Mintable\r\n///\r\n/// @notice This contract covers everything related\r\n/// to the mint functions\r\n///\r\ncontract Minteable {\r\n  /// @dev Declare a private bool {_mintingEnabled}\r\n  ///\r\n  bool private _mintingEnabled;\r\n\r\n  /// @dev Declare a public constant of type bytes32\r\n  ///\r\n  /// @return The bytes32 string of the role\r\n  ///\r\n  bytes32 public constant ROLE_MINTER = keccak256(\"MINTER\");\r\n\r\n  /// @dev Declare two events to expose when minting\r\n  /// is enabled or disabled, take the event\u0027s sender\r\n  /// as argument\r\n  ///\r\n  event MintingEnabled(address indexed _from);\r\n  event MintingDisabled(address indexed _from);\r\n\r\n  /// @dev Verify if the sender can mint, if yes,\r\n  /// enable minting\r\n  /// \r\n  /// Requirements:\r\n  /// {_hasRole} should be true\r\n  /// {_amount} should be superior to 0\r\n  /// {_mintingEnabled} should be true\r\n  ///\r\n  modifier isMintable(\r\n    uint256 _amount,\r\n    bool _hasRole\r\n  ) {\r\n    require(\r\n      _hasRole,\r\n      \"MC:500\"\r\n    );\r\n\r\n    require(\r\n      _amount \u003e 0,\r\n      \"MC:30\"\r\n    );\r\n\r\n    _enableMinting();\r\n\r\n    require(\r\n      mintingEnabled(),\r\n      \"MC:110\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev By default, minting is disabled\r\n  ///\r\n  constructor()\r\n  internal {\r\n    _mintingEnabled = false;\r\n  }\r\n\r\n  /// @notice Expose the state of {_mintingEnabled}\r\n  ///\r\n  /// @return The state as a bool\r\n  ///\r\n  function mintingEnabled()\r\n  public view returns (bool) {\r\n    return _mintingEnabled;\r\n  }\r\n\r\n  /// @dev Enable minting by setting {_mintingEnabled}\r\n  /// to true, then emit the related event\r\n  ///\r\n  function _enableMinting()\r\n  internal virtual {\r\n    _mintingEnabled = true;\r\n    emit MintingEnabled(msg.sender);\r\n  }\r\n\r\n  /// @dev Disable minting by setting {_mintingEnabled}\r\n  /// to false, then emit the related event\r\n  ///\r\n  function _disableMinting()\r\n  internal virtual {\r\n    _mintingEnabled = false;\r\n    emit MintingDisabled(msg.sender);\r\n  }\r\n}"},"Pauseable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport \u0027./Roleplay.sol\u0027;\r\n\r\n/// @title Pauseable\r\n///\r\n/// @notice This contract covers everything related\r\n/// to the pause functions\r\n///\r\n/// @dev Inehrit {Roleplay}\r\n///\r\ncontract Pauseable is Roleplay {\r\n  /// @dev Declare a private bool {_paused}\r\n  ///\r\n  bool private _paused;\r\n  \r\n  /// @dev Declare two events to expose when pause\r\n  /// is enabled or disabled, take the event\u0027s sender\r\n  /// as argument\r\n  ///\r\n  event Paused(address indexed _from);\r\n  event Unpaused(address indexed _from);\r\n\r\n  /// @dev Verify if the contract is not paused\r\n  /// \r\n  /// Requirements:\r\n  /// {_paused} should be false\r\n  ///\r\n  modifier whenNotPaused() {\r\n    require(\r\n      !_paused,\r\n      \"PC:300\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Verify if the contract is paused\r\n  /// \r\n  /// Requirements:\r\n  /// {_paused} should be true\r\n  ///\r\n  modifier whenPaused() {\r\n    require(\r\n      _paused,\r\n      \"PC:310\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev By default, pause is disabled\r\n  ///\r\n  constructor ()\r\n  internal {\r\n    _paused = false;\r\n  }\r\n\r\n  /// @notice Expose the state of {_paused}\r\n  ///\r\n  /// @return The state as a bool\r\n  ///\r\n  function paused()\r\n  public view returns (bool) {\r\n    return _paused;\r\n  }\r\n  \r\n  /// @dev Enable pause by setting {_paused}\r\n  /// to true, then emit the related event\r\n  ///\r\n  function pause()\r\n  public virtual whenNotPaused() onlyOwner() {\r\n    _paused = true;\r\n    emit Paused(msg.sender);\r\n  }\r\n\r\n  /// @dev Disable pause by setting {_paused}\r\n  /// to false, then emit the related event\r\n  ///\r\n  function unpause()\r\n  public virtual whenPaused() onlyOwner() {\r\n    _paused = false;\r\n    emit Unpaused(msg.sender);\r\n  }\r\n}"},"Roleplay.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\nimport \"./EnumerableSet.sol\";\r\n\r\n/// @title Roleplay\r\n///\r\n/// @notice This contract covers most functions about\r\n/// role and permission\u0027s managment\r\n///\r\nabstract contract Roleplay {\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  /// @dev Structure declaration of {RoleData} data model\r\n  ///\r\n  struct RoleData {\r\n    EnumerableSet.AddressSet members;\r\n    bytes32 ownerRole;\r\n  }\r\n\r\n  mapping (bytes32 =\u003e RoleData) private _roles;\r\n\r\n  /// @dev Declare a public constant of type bytes32\r\n  ///\r\n  /// @return The bytes32 string of the role\r\n  ///\r\n  bytes32 public constant ROLE_OWNER = 0x00;\r\n\r\n  /// @dev Declare a public constant of type bytes32\r\n  ///\r\n  /// @return The bytes32 string of the role\r\n  ///\r\n  bytes32 public constant ROLE_MANAGER = keccak256(\"MANAGER\");\r\n\r\n  /// @dev Declare two events to expose role\r\n  /// modifications\r\n  ///\r\n  event RoleGranted(bytes32 indexed _role, address indexed _from, address indexed _sender);\r\n  event RoleRevoked(bytes32 indexed role, address indexed _from, address indexed _sender);\r\n\r\n  /// @dev Verify if the sender have Owner\u0027s role\r\n  /// \r\n  /// Requirements:\r\n  /// {_hasRole()} should be true\r\n  ///\r\n  modifier onlyOwner() {\r\n    require(\r\n      hasRole(ROLE_OWNER, msg.sender),\r\n      \"RPC:500\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @notice This function verify is the {_account}\r\n  /// has role {_role}\r\n  ///\r\n  /// @param _role - The bytes32 string of the role\r\n  /// @param _account - The address to verify\r\n  ///\r\n  /// @return true/false depending the result \r\n  ///\r\n  function hasRole(\r\n    bytes32 _role,\r\n    address _account\r\n  ) public view returns (bool) {\r\n    return _roles[_role].members.contains(_account);\r\n  }\r\n\r\n  /// @notice Expose the length of members[] for\r\n  /// a given {_role}\r\n  ///\r\n  /// @param _role - The bytes32 string of the role\r\n  ///\r\n  /// @return - The length of members\r\n  ///\r\n  function getRoleMembersLength(\r\n    bytes32 _role\r\n  ) public view returns (uint256) {\r\n    return _roles[_role].members.length();\r\n  }\r\n\r\n\r\n  /// @notice Expose the member address for\r\n  /// a given {_role} at the {_id} index\r\n  ///\r\n  /// @param _id - Index to watch for\r\n  /// @param _role - The bytes32 string of the role\r\n  ///\r\n  /// @return - The address of the member at {_id} index\r\n  ///\r\n  function exposeRoleMember(\r\n    bytes32 _role,\r\n    uint256 _id\r\n  ) public view returns (address) {\r\n    return _roles[_role].members.at(_id);\r\n  }\r\n\r\n  /// @notice This function allow the current Owner\r\n  /// to transfer his ownership\r\n  ///\r\n  /// @dev Requirements:\r\n  /// See {Roleplay::onlyOwner()}\r\n  ///\r\n  /// @param _to - Represent address of the receiver\r\n  ///\r\n  function transferOwnerRole(\r\n    address _to\r\n  ) public virtual onlyOwner() {\r\n    _grantRole(ROLE_OWNER, _to);\r\n    _revokeRole(ROLE_OWNER, msg.sender);\r\n  }\r\n\r\n  /// @notice This function allow the current Owner\r\n  /// to give the Manager Role to {_to} address\r\n  ///\r\n  /// @dev Requirements:\r\n  /// See {Roleplay::onlyOwner()}\r\n  ///\r\n  /// @param _to - Represent address of the receiver\r\n  ///\r\n  function grantManagerRole(\r\n    address _to\r\n  ) public virtual onlyOwner() {\r\n    _grantRole(ROLE_MANAGER, _to);\r\n  }\r\n\r\n  /// @notice This function allow a Manager to grant\r\n  /// role to a given address, it can\u0027t grant Owner role\r\n  ///\r\n  /// @dev Requirements:\r\n  /// {_hasRole()} should be true\r\n  /// {_role} should be different of ROLE_OWNER\r\n  ///\r\n  /// @param _role - The bytes32 string of the role\r\n  /// @param _to - Represent address of the receiver\r\n  ///\r\n  function grantRole(\r\n    bytes32 _role,\r\n    address _to\r\n  ) public virtual {\r\n    require(\r\n      hasRole(ROLE_MANAGER, msg.sender),\r\n      \"RPC:510\"\r\n    );\r\n\r\n    require(\r\n      _role != ROLE_OWNER,\r\n      \"RPC:520\"\r\n    );\r\n\r\n    if (!hasRole(ROLE_OWNER, msg.sender)) {\r\n      require(\r\n        _role == keccak256(\"CHAIRPERSON\"),\r\n        \"RPC:530\"\r\n      );\r\n    }\r\n\r\n    _grantRole(_role, _to);\r\n  }\r\n\r\n  /// @notice This function allow a Manager to revoke\r\n  /// role to a given address, it can\u0027t revoke Owner role\r\n  ///\r\n  /// @dev Requirements:\r\n  /// {_hasRole()} should be true\r\n  /// {_role} should be different of ROLE_OWNER\r\n  ///\r\n  /// @param _role - The bytes32 string of the role\r\n  /// @param _to - Represent address of the receiver\r\n  ///\r\n  function revokeRole(\r\n    bytes32 _role,\r\n    address _to\r\n  ) public virtual {\r\n    require(\r\n      hasRole(ROLE_MANAGER, msg.sender),\r\n      \"RPC:550\"\r\n    );\r\n\r\n    require(\r\n      _role != ROLE_OWNER,\r\n      \"RPC:540\"\r\n    );\r\n\r\n    if (!hasRole(ROLE_OWNER, msg.sender)) {\r\n      require(\r\n        _role == keccak256(\"CHAIRPERSON\"),\r\n        \"RPC:530\"\r\n      );\r\n    }\r\n\r\n    _revokeRole(_role, _to);\r\n  }\r\n\r\n  /// @notice This function allow anyone to revoke his\r\n  /// own role, even an Owner, use it carefully!\r\n  ///\r\n  /// @param _role - The bytes32 string of the role\r\n  ///\r\n  function renounceRole(\r\n    bytes32 _role\r\n  ) public virtual {\r\n    require(\r\n      _role != ROLE_OWNER,\r\n      \"RPC:540\"\r\n    );\r\n\r\n    require(\r\n      hasRole(_role, msg.sender),\r\n      \"RPC:570\"\r\n    );\r\n\r\n    _revokeRole(_role, msg.sender);\r\n  }\r\n\r\n  function _setupRole(\r\n    bytes32 _role,\r\n    address _to\r\n  ) internal virtual {\r\n    _grantRole(_role, _to);\r\n  }\r\n\r\n  function _grantRole(\r\n    bytes32 _role,\r\n    address _to\r\n  ) private {\r\n    if (_roles[_role].members.add(_to)) {\r\n      emit RoleGranted(_role, _to, msg.sender);\r\n    }\r\n  }\r\n\r\n  function _revokeRole(\r\n    bytes32 _role,\r\n    address _to\r\n  ) private {\r\n    if (_roles[_role].members.remove(_to)) {\r\n      emit RoleRevoked(_role, _to, msg.sender);\r\n    }\r\n  }\r\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\n\r\n/// Know more: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\r\n\r\nlibrary SafeMath {\r\n  function add(\r\n    uint256 a,\r\n    uint256 b\r\n  ) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b\r\n  ) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b \u003c= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(\r\n    uint256 a,\r\n    uint256 b\r\n  ) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b\r\n  ) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b \u003e 0, errorMessage);\r\n    uint256 c = a / b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b\r\n  ) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}"},"Stakeable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \u0027./Roleplay.sol\u0027;\r\n\r\n/// @title Stakeable\r\n///\r\n/// @notice This contract covers most functions about\r\n/// staking and rewards\r\n///\r\nabstract contract Stakeable is Roleplay {\r\n  /// @dev Declare an internal variable of type uint256\r\n  ///\r\n  uint256 internal _totalStakedSupply;\r\n\r\n  /// @dev Declare an internal variable of type uint256\r\n  ///\r\n  uint256 internal _maxRewardRatio;\r\n  \r\n  /// @dev Structure declaration of {Stakeholder} data model\r\n  ///\r\n  struct Stakeholder {\r\n    address owner;\r\n    uint256 stake;\r\n    uint256 availableReward;\r\n    uint256 totalRewardEarned;\r\n    uint256 totalRewardSpent;\r\n    uint256 createdAt;\r\n    uint256 lastRewardCalculatedAt;\r\n  }\r\n\r\n  /// @dev Declare two events to expose when stake\r\n  /// or unstake is requested, take the event\u0027s\r\n  /// sender as argument and the requested amount\r\n  ///\r\n  event Staked(address indexed _from, uint256 _amount);\r\n  event Unstaked(address indexed _from, uint256 _amount);\r\n\r\n  /// @dev Declare an array of {Stakeholder}\r\n  ///\r\n  Stakeholder[] stakeholders;\r\n  \r\n  /// @dev Verify if the amount is superior to 0\r\n  /// \r\n  /// Requirements:\r\n  /// {_amount} should be superior to 0\r\n  ///\r\n  /// @param _amount - Represent the requested amount\r\n  ///\r\n  modifier isAmountNotZero(uint256 _amount) {\r\n    require(\r\n      _amount \u003e 0,\r\n      \"SC:630\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Verify if the amount is a valid amount\r\n  /// \r\n  /// Requirements:\r\n  /// {_amount} should be inferior or equal to 10\r\n  ///\r\n  /// @param _amount - Represent the requested amount\r\n  /// @param _balance - Represent the sender balance\r\n  ///\r\n  modifier isAmountValid(uint256 _amount, uint256 _balance) {\r\n    require(\r\n      (_amount * (10**8)) \u003c= _balance,\r\n      \"SC:640\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Verify if the amount is a valid amount to unstake\r\n  /// \r\n  /// Requirements:\r\n  /// {_amount} should be inferior or equal to staked value\r\n  ///\r\n  /// @param _amount - Represent the requested amount\r\n  ///\r\n  modifier isAbleToUnstake(uint256 _amount) {\r\n    Stakeholder memory stakeholder = exposeStakeholder(msg.sender); \r\n    require(\r\n      _amount \u003c= stakeholder.stake,\r\n      \"SC:640\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    _maxRewardRatio = 10;\r\n  }\r\n\r\n  /// @notice Expose the total staked supply\r\n  ///\r\n  /// @return The uint256 value of {_totalStakedSupply}\r\n  ///\r\n  function totalStakedSupply()\r\n  public view returns (uint256) {\r\n    return _totalStakedSupply;\r\n  }\r\n\r\n  /// @notice Expose the max reward ratio\r\n  ///\r\n  /// @return The uint256 value of {_maxRewardRatio}\r\n  ///\r\n  function maxRewardRatio()\r\n  public view returns (uint256) {\r\n    return _maxRewardRatio;\r\n  }\r\n\r\n  /// @notice Expose every Stakeholders\r\n  ///\r\n  /// @return A tuple of Stakeholders\r\n  ///\r\n  function exposeStakeholders()\r\n  public view returns (Stakeholder[] memory) {\r\n    return stakeholders;\r\n  }\r\n\r\n  /// @notice Expose a Stakeholder from the Owner address\r\n  ///\r\n  /// @param _owner - Represent the address of the stakeholder owner\r\n  ///\r\n  /// @return A tuple of Stakeholder\r\n  ///\r\n  function exposeStakeholder(\r\n    address _owner\r\n  ) public view returns (Stakeholder memory) {\r\n    uint256 i = 0;\r\n    uint256 len = stakeholders.length;\r\n    while (i \u003c len) {\r\n      if (stakeholders[i].owner == _owner) {\r\n        return stakeholders[i];\r\n      }\r\n      i++;\r\n    }\r\n  }\r\n\r\n  /// @notice Set the {_maxRewardRatio}\r\n  ///\r\n  /// @dev Only owner can use this function\r\n  ///\r\n  /// @param _amount - Represent the requested ratio\r\n  ///\r\n  function setMaxRewardRatio(\r\n    uint256 _amount\r\n  ) public virtual onlyOwner() {\r\n    _maxRewardRatio = _amount;\r\n  }\r\n\r\n  /// @notice Create a new {Stakeholder}\r\n  ///\r\n  /// @dev Owner is the sender\r\n  ///\r\n  /// @param _owner - Represent the owner of the Stakeholder\r\n  ///\r\n  function _createStakeholder(\r\n    address _owner\r\n  ) internal virtual {\r\n    stakeholders.push(Stakeholder({\r\n      owner: _owner,\r\n      stake: 0,\r\n      createdAt: now,\r\n      availableReward: 0,\r\n      totalRewardEarned: 0,\r\n      totalRewardSpent: 0,\r\n      lastRewardCalculatedAt: 0\r\n    }));\r\n  }\r\n\r\n  /// @notice This function compute the reward gained from staking\r\n  /// CreationEngineToken\r\n  ///\r\n  /// @dev The calculation is pretty simple, a {Stakeholder}\r\n  /// holds the date of the {Stakeholder}\u0027s creation. If the\r\n  /// reward hasn\u0027t been computed since the creation, the\r\n  /// algorithm will calculate them based on the number of\r\n  /// days passed since the creation of the stakeholding.\r\n  /// Then the calculation\u0027s date will be saved onto the\r\n  /// {Stakeholder} and when {_computeReward} will be called\r\n  /// again, the reward calculation will take this date in \r\n  /// consideration to compute the reward.\r\n  /// \r\n  /// The actual ratio is 1 Stake = 1 Reward.\r\n  /// With a maximum of 10 tokens per stake,\r\n  /// you can obtain a total of 10 rewards per day\r\n  ///\r\n  /// @param _id - Represent the Stakeholder index\r\n  ///\r\n  function _computeReward(\r\n    uint256 _id\r\n  ) internal virtual {\r\n    uint256 stake = stakeholders[_id].stake;\r\n    uint256 lastCalculatedReward = stakeholders[_id].lastRewardCalculatedAt;\r\n    uint256 createdAt = stakeholders[_id].createdAt;\r\n\r\n    if (lastCalculatedReward == 0) {\r\n      if (createdAt \u003c now) {\r\n        if ((now - createdAt) \u003e= 1 days) {\r\n          stakeholders[_id].availableReward += (((now - createdAt) / 1 days) * (\r\n            stake \u003c= _maxRewardRatio ?\r\n            stake : _maxRewardRatio\r\n          ));\r\n          stakeholders[_id].totalRewardEarned += (((now - createdAt) / 1 days) * (\r\n            stake \u003c= _maxRewardRatio ?\r\n            stake : _maxRewardRatio\r\n          ));\r\n          stakeholders[_id].lastRewardCalculatedAt = now;\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (lastCalculatedReward != 0) {\r\n      if (lastCalculatedReward \u003c now) {\r\n        if ((now - lastCalculatedReward) \u003e= 1 days) {\r\n          stakeholders[_id].availableReward += (((now - lastCalculatedReward) / 1 days) * (\r\n            stake \u003c= _maxRewardRatio ?\r\n            stake : _maxRewardRatio\r\n          ));\r\n          stakeholders[_id].totalRewardEarned += (((now - lastCalculatedReward) / 1 days) * (\r\n            stake \u003c= _maxRewardRatio ?\r\n            stake : _maxRewardRatio\r\n          ));\r\n          stakeholders[_id].lastRewardCalculatedAt = now;\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n}"},"Voteable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \u0027./Roleplay.sol\u0027;\r\n\r\n/// @title Voteable\r\n///\r\n/// @notice This contract covers most functions about\r\n/// proposals and votings\r\n///\r\n/// @dev Inehrit {Roleplay}\r\n///\r\nabstract contract Voteable is Roleplay {\r\n  /// @dev Declare an internal variable of type uint256\r\n  ///\r\n  uint256 internal _minVoteBalance;\r\n\r\n  /// @dev Structure declaration of {Proposal} data model\r\n  ///\r\n  struct Proposal {\r\n    address creator;\r\n    string name;\r\n    string metadataURI;\r\n    bool votingEnabled;\r\n    uint256 positiveVote;\r\n    uint256 negativeVote;\r\n    address[] positiveVoters;\r\n    address[] negativeVoters;\r\n  }\r\n\r\n  /// @dev Declare a public constant of type bytes32\r\n  ///\r\n  /// @return The bytes32 string of the role\r\n  ///\r\n  bytes32 public constant ROLE_CHAIRPERSON = keccak256(\"CHAIRPERSON\");\r\n\r\n  /// @dev Declare an array of {Proposal}\r\n  ///\r\n  Proposal[] proposals;\r\n\r\n  /// @dev Verify if the sender have the chairperson role\r\n  /// \r\n  /// Requirements:\r\n  /// {_hasRole} should be true\r\n  ///\r\n  modifier isChairperson() {\r\n    require(\r\n      hasRole(ROLE_CHAIRPERSON, msg.sender),\r\n      \"VC:500\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Verify if the sender is a valid voter\r\n  ///\r\n  /// Requirements:\r\n  /// {_balance} should be superior to 1\r\n  /// {_voter} should haven\u0027t already voted\r\n  ///\r\n  /// @param _id - Represent the proposal index\r\n  /// @param _balance - Represent the sender balance\r\n  ///\r\n  modifier isValidVoter(\r\n    uint256 _id,\r\n    uint256 _balance\r\n  ) {\r\n    require(\r\n      _balance \u003e= (_minVoteBalance * (10**8)),\r\n      \"VC:1010\"\r\n    );\r\n\r\n    bool positiveVote = _checkSenderHasVoted(proposals[_id].positiveVoters, msg.sender);\r\n    bool negativeVote = _checkSenderHasVoted(proposals[_id].negativeVoters, msg.sender);\r\n\r\n    require(\r\n      !positiveVote \u0026\u0026 !negativeVote,\r\n      \"VC:1020\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /// @dev Verify if the proposal have voting enabled\r\n  ///\r\n  /// Requirements:\r\n  /// {proposals[_id]} should have voting enabled\r\n  ///\r\n  /// @param _id - Represent the proposal index\r\n  ///\r\n  modifier isVoteEnabled(\r\n    uint256 _id\r\n  ) {\r\n    require(\r\n      proposals[_id].votingEnabled,\r\n      \"VC:1030\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    _minVoteBalance = 100;\r\n  }\r\n\r\n  /// @notice Expose the min balance required to vote\r\n  ///\r\n  /// @return The uint256 value of {_minVoteBalance}\r\n  ///\r\n  function minVoteBalance()\r\n  public view returns (uint256) {\r\n    return _minVoteBalance;\r\n  }\r\n\r\n  /// @notice Set the {_minVoteBalance}\r\n  ///\r\n  /// @dev Only owner can use this function\r\n  ///\r\n  /// @param _amount - Represent the requested ratio\r\n  ///\r\n  function setMinVoteBalance(\r\n    uint256 _amount\r\n  ) public virtual onlyOwner() {\r\n    _minVoteBalance = _amount;\r\n  }\r\n\r\n  /// @notice Allow a chairperson to create a new {Proposal}\r\n  ///\r\n  /// @dev Sender should be a chairperson\r\n  ///\r\n  /// Requirements:\r\n  /// See {Voteable::isChairperson()}\r\n  ///\r\n  /// @param _name - Represent the Proposal name\r\n  /// @param _uri - Represent the Proposal metadata uri\r\n  /// @param _enable - Represent if vote is enable/disable\r\n  ///\r\n  function createProposal(\r\n    string memory _name,\r\n    string memory _uri,\r\n    bool _enable\r\n  ) public virtual isChairperson() {\r\n    proposals.push(\r\n      Proposal({\r\n        creator: msg.sender,\r\n        name: _name,\r\n        metadataURI: _uri,\r\n        votingEnabled: _enable,\r\n        positiveVote: 0,\r\n        negativeVote: 0,\r\n        positiveVoters: new address[](0),\r\n        negativeVoters: new address[](0)\r\n      })\r\n    );\r\n  }\r\n  \r\n  /// @notice Allow a chairperson to enable/disable voting\r\n  /// for a proposal\r\n  ///\r\n  /// @dev Sender should be a chairperson\r\n  ///\r\n  /// Requirements:\r\n  /// See {Voteable::isChairperson()}\r\n  ///\r\n  /// @param _id - Represent a proposal index\r\n  ///\r\n  function enableProposal(\r\n    uint256 _id\r\n  ) public virtual isChairperson() {\r\n    proposals[_id].votingEnabled ?\r\n    proposals[_id].votingEnabled = false :\r\n    proposals[_id].votingEnabled = true;\r\n  }\r\n\r\n  /// @notice Expose all proposals\r\n  ///\r\n  /// @return A tuple of Proposal\r\n  ///\r\n  function exposeProposals()\r\n  public view returns (Proposal[] memory) {\r\n    return proposals;\r\n  }\r\n\r\n  /// @notice Verify if the sender have already voted\r\n  /// for a proposal\r\n  ///\r\n  /// @dev The function iterate hover the {_voters}\r\n  /// to know if the sender have already voted\r\n  ///\r\n  /// @param _voters - Represent the positive/negative\r\n  /// voters of a proposal\r\n  ///\r\n  function _checkSenderHasVoted(\r\n    address[] memory _voters,\r\n    address _voter\r\n  ) private pure returns (bool) {\r\n    uint256 i = 0;\r\n    bool voted = false;\r\n    uint256 len = _voters.length;\r\n    while (i \u003c len) {\r\n      if (_voters[i] == _voter) {\r\n        voted = true;\r\n        break;\r\n      }\r\n      i++;\r\n    }\r\n\r\n    return voted;\r\n  }\r\n}"}}