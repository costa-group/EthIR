{"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity\u0027s `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003c= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity\u0027s `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b \u003e 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"sbCommunityInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbCommunityInterface {\n  function getTokenData(address token, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function receiveRewards(uint256 day, uint256 amount) external;\n\n  function serviceAccepted(address service) external view returns (bool);\n\n  function getMinerRewardPercentage() external view returns (uint256);\n}\n"},"sbControllerInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbControllerInterface {\n  function getDayMineSecondsUSDTotal(uint256 day) external view returns (uint256);\n\n  function getCommunityDayMineSecondsUSD(address community, uint256 day) external view returns (uint256);\n\n  function getCommunityDayRewards(address community, uint256 day) external view returns (uint256);\n\n  function getStartDay() external view returns (uint256);\n\n  function getMaxYears() external view returns (uint256);\n\n  function getStrongPoolDailyRewards(uint256 day) external view returns (uint256);\n\n  function communityAccepted(address community) external view returns (bool);\n\n  function getCommunities() external view returns (address[] memory);\n\n  function upToDate() external view returns (bool);\n}\n"},"sbStrongPoolInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface sbStrongPoolInterface {\n  function serviceMinMined(address miner) external view returns (bool);\n\n  function minerMinMined(address miner) external view returns (bool);\n\n  function mineFor(address miner, uint256 amount) external;\n\n  function getMineData(uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function receiveRewards(uint256 day, uint256 amount) external;\n}\n"},"sbVotes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \u0027./SafeMath.sol\u0027;\nimport \u0027./IERC20.sol\u0027;\nimport \u0027./sbControllerInterface.sol\u0027;\nimport \u0027./sbStrongPoolInterface.sol\u0027;\nimport \u0027./sbCommunityInterface.sol\u0027;\n\ncontract sbVotes {\n  event VotesUpdated(address indexed voter, uint256 amount, bool indexed adding);\n  event RewardsReceivedForCommunity(address indexed community, uint256 indexed day, uint256 amount);\n  event RewardsReceivedForVoters(uint256 indexed day, uint256 amount);\n  event Voted(address indexed voter, address community, address indexed service, uint256 amount, uint256 indexed day);\n  event VoteRecalled(\n    address indexed voter,\n    address community,\n    address indexed service,\n    uint256 amount,\n    uint256 indexed day\n  );\n  event ServiceDropped(address indexed voter, address community, address indexed service, uint256 indexed day);\n  event Claimed(address indexed service, uint256 amount, uint256 indexed day);\n\n  using SafeMath for uint256;\n\n  bool internal initDone;\n\n  sbControllerInterface internal sbController;\n  sbStrongPoolInterface internal sbStrongPool;\n  IERC20 internal strongToken;\n\n  mapping(address =\u003e uint96) internal balances;\n  mapping(address =\u003e address) public delegates;\n\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n  mapping(address =\u003e mapping(uint32 =\u003e Checkpoint)) public checkpoints;\n  mapping(address =\u003e uint32) public numCheckpoints;\n\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n  event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n  event AddVotes(address indexed staker, uint256 amount);\n  event SubVotes(address indexed staker, uint256 amount);\n\n  mapping(address =\u003e mapping(address =\u003e address[])) internal voterCommunityServices;\n  mapping(address =\u003e mapping(address =\u003e mapping(address =\u003e uint256[]))) internal voterCommunityServiceDays;\n  mapping(address =\u003e mapping(address =\u003e mapping(address =\u003e uint256[]))) internal voterCommunityServiceAmounts;\n  mapping(address =\u003e mapping(address =\u003e mapping(address =\u003e uint256[]))) internal voterCommunityServiceVoteSeconds;\n  mapping(address =\u003e uint256) internal voterDayLastClaimedFor;\n  mapping(address =\u003e uint256) internal voterVotesOut;\n  mapping(uint256 =\u003e uint256) internal dayVoterRewards;\n\n  mapping(address =\u003e mapping(address =\u003e uint256[])) internal serviceCommunityDays;\n  mapping(address =\u003e mapping(address =\u003e uint256[])) internal serviceCommunityAmounts;\n  mapping(address =\u003e mapping(address =\u003e uint256[])) internal serviceCommunityVoteSeconds;\n  mapping(address =\u003e uint256) internal serviceDayLastClaimedFor;\n\n  mapping(address =\u003e uint256[]) internal communityDays;\n  mapping(address =\u003e uint256[]) internal communityAmounts;\n  mapping(address =\u003e uint256[]) internal communityVoteSeconds;\n\n  mapping(address =\u003e mapping(uint256 =\u003e uint256)) internal communityDayRewards;\n\n  function init(\n    address sbControllerAddress,\n    address sbStrongPoolAddress,\n    address strongTokenAddress\n  ) public {\n    require(!initDone, \u0027init done\u0027);\n    sbController = sbControllerInterface(sbControllerAddress);\n    sbStrongPool = sbStrongPoolInterface(sbStrongPoolAddress);\n    strongToken = IERC20(strongTokenAddress);\n    initDone = true;\n  }\n\n  function updateVotes(\n    address voter,\n    uint256 rawAmount,\n    bool adding\n  ) external {\n    require(msg.sender == address(sbStrongPool), \u0027not sbStrongPool\u0027);\n    uint96 amount = _safe96(rawAmount, \u0027amount exceeds 96 bits\u0027);\n    if (adding) {\n      _addVotes(voter, amount);\n    } else {\n      require(voter == delegates[voter], \u0027must delegate to self\u0027);\n      require(_getAvailableServiceVotes(voter) \u003e= amount, \u0027must recall votes\u0027);\n      _subVotes(voter, amount);\n    }\n    emit VotesUpdated(voter, amount, adding);\n  }\n\n  function getCurrentProposalVotes(address account) external view returns (uint96) {\n    return _getCurrentProposalVotes(account);\n  }\n\n  function getPriorProposalVotes(address account, uint256 blockNumber) external view returns (uint96) {\n    require(blockNumber \u003c block.number, \u0027not yet determined\u0027);\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n    if (checkpoints[account][nCheckpoints - 1].fromBlock \u003c= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n    if (checkpoints[account][0].fromBlock \u003e blockNumber) {\n      return 0;\n    }\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper \u003e lower) {\n      uint32 center = upper - (upper - lower) / 2;\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock \u003c blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function getCommunityData(address community, uint256 day)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return _getCommunityData(community, day);\n  }\n\n  function receiveServiceRewards(uint256 day, uint256 amount) external {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(sbController.communityAccepted(msg.sender), \u0027invalid community\u0027);\n    strongToken.transferFrom(msg.sender, address(this), amount);\n    communityDayRewards[msg.sender][day] = communityDayRewards[msg.sender][day].add(amount);\n    emit RewardsReceivedForCommunity(msg.sender, day, amount);\n  }\n\n  function receiveVoterRewards(uint256 day, uint256 amount) external {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(msg.sender == address(sbController), \u0027not sbController\u0027);\n    strongToken.transferFrom(msg.sender, address(this), amount);\n    dayVoterRewards[day] = dayVoterRewards[day].add(amount);\n    emit RewardsReceivedForVoters(day, amount);\n  }\n\n  function getServiceDayLastClaimedFor(address service) public view returns (uint256) {\n    return\n      serviceDayLastClaimedFor[service] == 0 ? sbController.getStartDay().sub(1) : serviceDayLastClaimedFor[service];\n  }\n\n  function getVoterDayLastClaimedFor(address voter) public view returns (uint256) {\n    return voterDayLastClaimedFor[voter] == 0 ? sbController.getStartDay().sub(1) : voterDayLastClaimedFor[voter];\n  }\n\n  function getSbControllerAddressUsed() public view returns (address) {\n    return address(sbController);\n  }\n\n  function getSbStrongPoolAddressUsed() public view returns (address) {\n    return address(sbStrongPool);\n  }\n\n  function getStrongAddressUsed() public view returns (address) {\n    return address(strongToken);\n  }\n\n  function getCommunityDayRewards(address community, uint256 day) public view returns (uint256) {\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return communityDayRewards[community][day];\n  }\n\n  function getDayVoterRewards(uint256 day) public view returns (uint256) {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return dayVoterRewards[day];\n  }\n\n  function recallAllVotes() public {\n    require(voterVotesOut[msg.sender] \u003e 0, \u0027no votes out\u0027);\n    _recallAllVotes((msg.sender));\n  }\n\n  function delegate(address delegatee) public {\n    address currentDelegate = delegates[msg.sender];\n    if (currentDelegate != delegatee \u0026\u0026 voterVotesOut[currentDelegate] \u003e 0) {\n      _recallAllVotes(currentDelegate);\n    }\n    _delegate(msg.sender, delegatee);\n  }\n\n  function getDelegate(address delegator) public view returns (address) {\n    return delegates[delegator];\n  }\n\n  function getAvailableServiceVotes(address account) public view returns (uint96) {\n    return _getAvailableServiceVotes(account);\n  }\n\n  function getVoterCommunityServices(address voter, address community) public view returns (address[] memory) {\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    return voterCommunityServices[voter][community];\n  }\n\n  function vote(\n    address community,\n    address service,\n    uint256 amount\n  ) public {\n    require(amount \u003e 0, \u00271: zero\u0027);\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(100 - sbCommunityInterface(community).getMinerRewardPercentage() != 0, \u00272: zero.\u0027);\n    require(sbCommunityInterface(community).serviceAccepted(service), \u0027invalid service\u0027);\n    require(sbStrongPool.serviceMinMined(service), \u0027not min mined\u0027);\n    require(voterCommunityServices[msg.sender][community].length \u003c 10, \u0027limit met\u0027);\n    require(uint256(_getAvailableServiceVotes(msg.sender)) \u003e= amount, \u0027not enough votes\u0027);\n    if (!_voterCommunityServiceExists(msg.sender, community, service)) {\n      voterCommunityServices[msg.sender][community].push(service);\n    }\n    uint256 currentDay = _getCurrentDay();\n    _updateVoterCommunityServiceData(msg.sender, community, service, amount, true, currentDay);\n    _updateServiceCommunityData(service, community, amount, true, currentDay);\n    _updateCommunityData(community, amount, true, currentDay);\n    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].add(amount);\n    emit Voted(msg.sender, community, service, amount, currentDay);\n  }\n\n  function recallVote(\n    address community,\n    address service,\n    uint256 amount\n  ) public {\n    require(amount \u003e 0, \u0027zero\u0027);\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(sbCommunityInterface(community).serviceAccepted(service), \u0027invalid service\u0027);\n    require(_voterCommunityServiceExists(msg.sender, community, service), \u0027not found\u0027);\n    uint256 currentDay = _getCurrentDay();\n    (, uint256 votes, ) = _getVoterCommunityServiceData(msg.sender, community, service, currentDay);\n    require(votes \u003e= amount, \u0027not enough votes\u0027);\n    _updateVoterCommunityServiceData(msg.sender, community, service, amount, false, currentDay);\n    _updateServiceCommunityData(service, community, amount, false, currentDay);\n    _updateCommunityData(community, amount, false, currentDay);\n    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].sub(amount);\n    emit VoteRecalled(msg.sender, community, service, amount, currentDay);\n  }\n\n  function dropService(address community, address service) public {\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(sbCommunityInterface(community).serviceAccepted(service), \u0027invalid service\u0027);\n    require(_voterCommunityServiceExists(msg.sender, community, service), \u0027not found\u0027);\n    uint256 currentDay = _getCurrentDay();\n    (, uint256 votes, ) = _getVoterCommunityServiceData(msg.sender, community, service, currentDay);\n    _updateVoterCommunityServiceData(msg.sender, community, service, votes, false, currentDay);\n    _updateServiceCommunityData(service, community, votes, false, currentDay);\n    _updateCommunityData(community, votes, false, currentDay);\n    voterVotesOut[msg.sender] = voterVotesOut[msg.sender].sub(votes);\n    uint256 index = _findIndexOfAddress(voterCommunityServices[msg.sender][community], service);\n    _deleteArrayElement(index, voterCommunityServices[msg.sender][community]);\n    emit ServiceDropped(msg.sender, community, service, currentDay);\n  }\n\n  function serviceClaimAll() public {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = serviceDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : serviceDayLastClaimedFor[msg.sender];\n    require(currentDay \u003e dayLastClaimedFor.add(7), \u0027already claimed\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    require(sbStrongPool.serviceMinMined(msg.sender), \u0027not min mined\u0027);\n    _serviceClaim(currentDay, msg.sender, dayLastClaimedFor);\n  }\n\n  function serviceClaimUpTo(uint256 day) public {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = serviceDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : serviceDayLastClaimedFor[msg.sender];\n    require(day \u003e dayLastClaimedFor.add(7), \u0027already claimed\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    require(sbStrongPool.serviceMinMined(msg.sender), \u0027not min mined\u0027);\n    _serviceClaim(day, msg.sender, dayLastClaimedFor);\n  }\n\n  function voterClaimAll() public {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = voterDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : voterDayLastClaimedFor[msg.sender];\n    require(currentDay \u003e dayLastClaimedFor.add(7), \u0027already claimed\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    _voterClaim(currentDay, msg.sender, dayLastClaimedFor);\n  }\n\n  function voterClaimUpTo(uint256 day) public {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = voterDayLastClaimedFor[msg.sender] == 0\n      ? sbController.getStartDay().sub(1)\n      : voterDayLastClaimedFor[msg.sender];\n    require(day \u003e dayLastClaimedFor.add(7), \u0027already claimed\u0027);\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    _voterClaim(day, msg.sender, dayLastClaimedFor);\n  }\n\n  function getServiceRewardsDueAll(address service) public view returns (uint256) {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = serviceDayLastClaimedFor[service] == 0\n      ? sbController.getStartDay().sub(1)\n      : serviceDayLastClaimedFor[service];\n    if (!(currentDay \u003e dayLastClaimedFor.add(7))) {\n      return 0;\n    }\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getServiceRewardsDue(currentDay, service, dayLastClaimedFor);\n  }\n\n  function getServiceRewardsDueUpTo(uint256 day, address service) public view returns (uint256) {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = serviceDayLastClaimedFor[service] == 0\n      ? sbController.getStartDay().sub(1)\n      : serviceDayLastClaimedFor[service];\n    if (!(day \u003e dayLastClaimedFor.add(7))) {\n      return 0;\n    }\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getServiceRewardsDue(day, service, dayLastClaimedFor);\n  }\n\n  function getVoterRewardsDueAll(address voter) public view returns (uint256) {\n    uint256 currentDay = _getCurrentDay();\n    uint256 dayLastClaimedFor = voterDayLastClaimedFor[voter] == 0\n      ? sbController.getStartDay().sub(1)\n      : voterDayLastClaimedFor[voter];\n    if (!(currentDay \u003e dayLastClaimedFor.add(7))) {\n      return 0;\n    }\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getVoterRewardsDue(currentDay, voter, dayLastClaimedFor);\n  }\n\n  function getVoterRewardsDueUpTo(uint256 day, address voter) public view returns (uint256) {\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    uint256 dayLastClaimedFor = voterDayLastClaimedFor[voter] == 0\n      ? sbController.getStartDay().sub(1)\n      : voterDayLastClaimedFor[voter];\n    if (!(day \u003e dayLastClaimedFor.add(7))) {\n      return 0;\n    }\n    require(sbController.upToDate(), \u0027need rewards released\u0027);\n    return _getVoterRewardsDue(day, voter, dayLastClaimedFor);\n  }\n\n  function getVoterCommunityServiceData(\n    address voter,\n    address community,\n    address service,\n    uint256 day\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(sbCommunityInterface(community).serviceAccepted(service), \u0027invalid service\u0027);\n    if (!_voterCommunityServiceExists(voter, community, service)) {\n      return (day, 0, 0);\n    }\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return _getVoterCommunityServiceData(voter, community, service, day);\n  }\n\n  function getServiceCommunityData(\n    address service,\n    address community,\n    uint256 day\n  )\n    public\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    require(sbController.communityAccepted(community), \u0027invalid community\u0027);\n    require(sbCommunityInterface(community).serviceAccepted(service), \u0027invalid service\u0027);\n    require(day \u003c= _getCurrentDay(), \u0027invalid day\u0027);\n    return _getServiceCommunityData(service, community, day);\n  }\n\n  function _getVoterCommunityServiceData(\n    address voter,\n    address community,\n    address service,\n    uint256 day\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256[] memory _Days = voterCommunityServiceDays[voter][community][service];\n    uint256[] memory _Amounts = voterCommunityServiceAmounts[voter][community][service];\n    uint256[] memory _UnitSeconds = voterCommunityServiceVoteSeconds[voter][community][service];\n    return _get(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _getServiceCommunityData(\n    address service,\n    address community,\n    uint256 day\n  )\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256[] memory _Days = serviceCommunityDays[service][community];\n    uint256[] memory _Amounts = serviceCommunityAmounts[service][community];\n    uint256[] memory _UnitSeconds = serviceCommunityVoteSeconds[service][community];\n    return _get(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _getCommunityData(address community, uint256 day)\n    internal\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256[] memory _Days = communityDays[community];\n    uint256[] memory _Amounts = communityAmounts[community];\n    uint256[] memory _UnitSeconds = communityVoteSeconds[community];\n    return _get(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _updateVoterCommunityServiceData(\n    address voter,\n    address community,\n    address service,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256[] storage _Days = voterCommunityServiceDays[voter][community][service];\n    uint256[] storage _Amounts = voterCommunityServiceAmounts[voter][community][service];\n    uint256[] storage _UnitSeconds = voterCommunityServiceVoteSeconds[voter][community][service];\n    _update(_Days, _Amounts, _UnitSeconds, amount, adding, currentDay);\n  }\n\n  function _updateServiceCommunityData(\n    address service,\n    address community,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256[] storage _Days = serviceCommunityDays[service][community];\n    uint256[] storage _Amounts = serviceCommunityAmounts[service][community];\n    uint256[] storage _UnitSeconds = serviceCommunityVoteSeconds[service][community];\n    _update(_Days, _Amounts, _UnitSeconds, amount, adding, currentDay);\n  }\n\n  function _updateCommunityData(\n    address community,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256[] storage _Days = communityDays[community];\n    uint256[] storage _Amounts = communityAmounts[community];\n    uint256[] storage _UnitSeconds = communityVoteSeconds[community];\n    _update(_Days, _Amounts, _UnitSeconds, amount, adding, currentDay);\n  }\n\n  function _get(\n    uint256[] memory _Days,\n    uint256[] memory _Amounts,\n    uint256[] memory _UnitSeconds,\n    uint256 day\n  )\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 len = _Days.length;\n    if (len == 0) {\n      return (day, 0, 0);\n    }\n    if (day \u003c _Days[0]) {\n      return (day, 0, 0);\n    }\n    uint256 lastIndex = len.sub(1);\n    uint256 lastMinedDay = _Days[lastIndex];\n    if (day == lastMinedDay) {\n      return (day, _Amounts[lastIndex], _UnitSeconds[lastIndex]);\n    } else if (day \u003e lastMinedDay) {\n      return (day, _Amounts[lastIndex], _Amounts[lastIndex].mul(1 days));\n    }\n    return _find(_Days, _Amounts, _UnitSeconds, day);\n  }\n\n  function _find(\n    uint256[] memory _Days,\n    uint256[] memory _Amounts,\n    uint256[] memory _UnitSeconds,\n    uint256 day\n  )\n    internal\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 left = 0;\n    uint256 right = _Days.length.sub(1);\n    uint256 middle = right.add(left).div(2);\n    while (left \u003c right) {\n      if (_Days[middle] == day) {\n        return (day, _Amounts[middle], _UnitSeconds[middle]);\n      } else if (_Days[middle] \u003e day) {\n        if (middle \u003e 0 \u0026\u0026 _Days[middle.sub(1)] \u003c day) {\n          return (day, _Amounts[middle.sub(1)], _Amounts[middle.sub(1)].mul(1 days));\n        }\n        if (middle == 0) {\n          return (day, 0, 0);\n        }\n        right = middle.sub(1);\n      } else if (_Days[middle] \u003c day) {\n        if (middle \u003c _Days.length.sub(1) \u0026\u0026 _Days[middle.add(1)] \u003e day) {\n          return (day, _Amounts[middle], _Amounts[middle].mul(1 days));\n        }\n        left = middle.add(1);\n      }\n      middle = right.add(left).div(2);\n    }\n    if (_Days[middle] != day) {\n      return (day, 0, 0);\n    } else {\n      return (day, _Amounts[middle], _UnitSeconds[middle]);\n    }\n  }\n\n  function _update(\n    uint256[] storage _Days,\n    uint256[] storage _Amounts,\n    uint256[] storage _UnitSeconds,\n    uint256 amount,\n    bool adding,\n    uint256 currentDay\n  ) internal {\n    uint256 len = _Days.length;\n    uint256 secondsInADay = 1 days;\n    uint256 secondsSinceStartOfDay = block.timestamp % secondsInADay;\n    uint256 secondsUntilEndOfDay = secondsInADay.sub(secondsSinceStartOfDay);\n\n    if (len == 0) {\n      if (adding) {\n        _Days.push(currentDay);\n        _Amounts.push(amount);\n        _UnitSeconds.push(amount.mul(secondsUntilEndOfDay));\n      } else {\n        require(false, \u00271: not enough mine\u0027);\n      }\n    } else {\n      uint256 lastIndex = len.sub(1);\n      uint256 lastMinedDay = _Days[lastIndex];\n      uint256 lastMinedAmount = _Amounts[lastIndex];\n      uint256 lastUnitSeconds = _UnitSeconds[lastIndex];\n\n      uint256 newAmount;\n      uint256 newUnitSeconds;\n\n      if (lastMinedDay == currentDay) {\n        if (adding) {\n          newAmount = lastMinedAmount.add(amount);\n          newUnitSeconds = lastUnitSeconds.add(amount.mul(secondsUntilEndOfDay));\n        } else {\n          require(lastMinedAmount \u003e= amount, \u00272: not enough mine\u0027);\n          newAmount = lastMinedAmount.sub(amount);\n          newUnitSeconds = lastUnitSeconds.sub(amount.mul(secondsUntilEndOfDay));\n        }\n        _Amounts[lastIndex] = newAmount;\n        _UnitSeconds[lastIndex] = newUnitSeconds;\n      } else {\n        if (adding) {\n          newAmount = lastMinedAmount.add(amount);\n          newUnitSeconds = lastMinedAmount.mul(1 days).add(amount.mul(secondsUntilEndOfDay));\n        } else {\n          require(lastMinedAmount \u003e= amount, \u00273: not enough mine\u0027);\n          newAmount = lastMinedAmount.sub(amount);\n          newUnitSeconds = lastMinedAmount.mul(1 days).sub(amount.mul(secondsUntilEndOfDay));\n        }\n        _Days.push(currentDay);\n        _Amounts.push(newAmount);\n        _UnitSeconds.push(newUnitSeconds);\n      }\n    }\n  }\n\n  function _addVotes(address voter, uint96 amount) internal {\n    require(voter != address(0), \u0027zero address\u0027);\n    balances[voter] = _add96(balances[voter], amount, \u0027vote amount overflows\u0027);\n    _addDelegates(voter, amount);\n    emit AddVotes(voter, amount);\n  }\n\n  function _subVotes(address voter, uint96 amount) internal {\n    balances[voter] = _sub96(balances[voter], amount, \u0027vote amount exceeds balance\u0027);\n    _subtactDelegates(voter, amount);\n    emit SubVotes(voter, amount);\n  }\n\n  function _addDelegates(address staker, uint96 amount) internal {\n    if (delegates[staker] == address(0)) {\n      delegates[staker] = staker;\n    }\n    address currentDelegate = delegates[staker];\n    _moveDelegates(address(0), currentDelegate, amount);\n  }\n\n  function _subtactDelegates(address staker, uint96 amount) internal {\n    address currentDelegate = delegates[staker];\n    _moveDelegates(currentDelegate, address(0), amount);\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _moveDelegates(\n    address srcRep,\n    address dstRep,\n    uint96 amount\n  ) internal {\n    if (srcRep != dstRep \u0026\u0026 amount \u003e 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum \u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n        uint96 srcRepNew = _sub96(srcRepOld, amount, \u0027vote amount underflows\u0027);\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum \u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n        uint96 dstRepNew = _add96(dstRepOld, amount, \u0027vote amount overflows\u0027);\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(\n    address delegatee,\n    uint32 nCheckpoints,\n    uint96 oldVotes,\n    uint96 newVotes\n  ) internal {\n    uint32 blockNumber = _safe32(block.number, \u0027block number exceeds 32 bits\u0027);\n    if (nCheckpoints \u003e 0 \u0026\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function _safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n    require(n \u003c 2**32, errorMessage);\n    return uint32(n);\n  }\n\n  function _safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n    require(n \u003c 2**96, errorMessage);\n    return uint96(n);\n  }\n\n  function _add96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c \u003e= a, errorMessage);\n    return c;\n  }\n\n  function _sub96(\n    uint96 a,\n    uint96 b,\n    string memory errorMessage\n  ) internal pure returns (uint96) {\n    require(b \u003c= a, errorMessage);\n    return a - b;\n  }\n\n  function _getCurrentProposalVotes(address account) internal view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints \u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  function _getAvailableServiceVotes(address account) internal view returns (uint96) {\n    uint96 proposalVotes = _getCurrentProposalVotes(account);\n    return\n      proposalVotes == 0\n        ? 0\n        : proposalVotes -\n          _safe96(voterVotesOut[account], \u0027voterVotesOut exceeds 96 bits\u0027);\n  }\n\n  function _voterCommunityServiceExists(\n    address voter,\n    address community,\n    address service\n  ) internal view returns (bool) {\n    for (uint256 i = 0; i \u003c voterCommunityServices[voter][community].length; i++) {\n      if (voterCommunityServices[voter][community][i] == service) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _recallAllVotes(address voter) internal {\n    uint256 currentDay = _getCurrentDay();\n    address[] memory communities = sbController.getCommunities();\n    for (uint256 i = 0; i \u003c communities.length; i++) {\n      address community = communities[i];\n      address[] memory services = voterCommunityServices[voter][community];\n      for (uint256 j = 0; j \u003c services.length; j++) {\n        address service = services[j];\n        (, uint256 amount, ) = _getVoterCommunityServiceData(voter, community, service, currentDay);\n        _updateVoterCommunityServiceData(msg.sender, community, service, amount, false, currentDay);\n        _updateServiceCommunityData(service, community, amount, false, currentDay);\n        _updateCommunityData(community, amount, false, currentDay);\n        voterVotesOut[msg.sender] = voterVotesOut[msg.sender].sub(amount);\n      }\n    }\n  }\n\n  function _serviceClaim(\n    uint256 upToDay,\n    address service,\n    uint256 dayLastClaimedFor\n  ) internal {\n    uint256 rewards = _getServiceRewardsDue(upToDay, service, dayLastClaimedFor);\n    require(rewards \u003e 0, \u0027no rewards\u0027);\n    serviceDayLastClaimedFor[service] = upToDay.sub(7);\n    strongToken.approve(address(sbStrongPool), rewards);\n    sbStrongPool.mineFor(service, rewards);\n    emit Claimed(service, rewards, _getCurrentDay());\n  }\n\n  function _getServiceRewardsDue(\n    uint256 upToDay,\n    address service,\n    uint256 dayLastClaimedFor\n  ) internal view returns (uint256) {\n    uint256 rewards;\n    for (uint256 day = dayLastClaimedFor.add(1); day \u003c= upToDay.sub(7); day++) {\n      address[] memory communities = sbController.getCommunities();\n      for (uint256 i = 0; i \u003c communities.length; i++) {\n        address community = communities[i];\n        (, , uint256 communityVoteSecondsForDay) = _getCommunityData(community, day);\n        if (communityVoteSecondsForDay == 0) {\n          continue;\n        }\n        (, , uint256 serviceVoteSeconds) = _getServiceCommunityData(service, community, day);\n        uint256 availableRewards = communityDayRewards[community][day];\n        uint256 amount = availableRewards.mul(serviceVoteSeconds).div(communityVoteSecondsForDay);\n        rewards = rewards.add(amount);\n      }\n    }\n    return rewards;\n  }\n\n  function _voterClaim(\n    uint256 upToDay,\n    address voter,\n    uint256 dayLastClaimedFor\n  ) internal {\n    uint256 rewards = _getVoterRewardsDue(upToDay, voter, dayLastClaimedFor);\n    require(rewards \u003e 0, \u0027no rewards\u0027);\n    voterDayLastClaimedFor[voter] = upToDay.sub(7);\n    strongToken.approve(address(sbStrongPool), rewards);\n    sbStrongPool.mineFor(voter, rewards);\n    emit Claimed(voter, rewards, _getCurrentDay());\n  }\n\n  function _getVoterRewardsDue(\n    uint256 upToDay,\n    address voter,\n    uint256 dayLastClaimedFor\n  ) internal view returns (uint256) {\n    uint256 rewards;\n    for (uint256 day = dayLastClaimedFor.add(1); day \u003c= upToDay.sub(7); day++) {\n      address[] memory communities = sbController.getCommunities();\n      for (uint256 i = 0; i \u003c communities.length; i++) {\n        address community = communities[i];\n        (, , uint256 communityVoteSecondsForDay) = _getCommunityData(community, day);\n        if (communityVoteSecondsForDay == 0) {\n          continue;\n        }\n        address[] memory services = voterCommunityServices[voter][community];\n        uint256 voterCommunityVoteSeconds;\n        for (uint256 j = 0; j \u003c services.length; j++) {\n          address service = services[j];\n          (, , uint256 voterVoteSeconds) = _getVoterCommunityServiceData(voter, community, service, day);\n          voterCommunityVoteSeconds = voterCommunityVoteSeconds.add(voterVoteSeconds);\n        }\n        uint256 availableRewards = dayVoterRewards[day];\n        uint256 amount = availableRewards.mul(voterCommunityVoteSeconds).div(communityVoteSecondsForDay);\n        rewards = rewards.add(amount);\n      }\n    }\n    return rewards;\n  }\n\n  function _getCurrentDay() internal view returns (uint256) {\n    return block.timestamp.div(1 days).add(1);\n  }\n\n  function _deleteArrayElement(uint256 index, address[] storage array) internal {\n    if (index == array.length.sub(1)) {\n      array.pop();\n    } else {\n      array[index] = array[array.length.sub(1)];\n      delete array[array.length.sub(1)];\n      array.pop();\n    }\n  }\n\n  function _findIndexOfAddress(address[] memory array, address element) internal pure returns (uint256) {\n    uint256 index;\n    for (uint256 i = 0; i \u003c array.length; i++) {\n      if (array[i] == element) {\n        index = i;\n      }\n    }\n    return index;\n  }\n}\n"}}