{"creamY.sol":{"content":"pragma solidity 0.5.17;\n\nimport \u0027./safeMath.sol\u0027;\nimport \u0027./normalizer.sol\u0027;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n    function balanceOf(address account) external view returns (uint);\n    function transfer(address recipient, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function approve(address spender, uint amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Context {\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n}\n\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint;\n\n    mapping (address =\u003e uint) private _balances;\n\n    mapping (address =\u003e mapping (address =\u003e uint)) private _allowances;\n\n    uint private _totalSupply;\n    function totalSupply() public view returns (uint) {\n        return _totalSupply;\n    }\n    function balanceOf(address account) public view returns (uint) {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender) public view returns (uint) {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n    function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n    function _transfer(address sender, address recipient, uint amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n    function _mint(address account, uint amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n    function _burn(address account, uint amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n    function _approve(address owner, address spender, uint amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != 0x0 \u0026\u0026 codehash != accountHash);\n    }\n}\n\nlibrary SafeERC20 {\n    using SafeMath for uint;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    function safeApprove(IERC20 token, address spender, uint value) internal {\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length \u003e 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 \u0026\u0026 b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 \u0026\u0026 a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b \u003e= 0 \u0026\u0026 c \u003c= a) || (b \u003c 0 \u0026\u0026 c \u003e a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b \u003e= 0 \u0026\u0026 c \u003e= a) || (b \u003c 0 \u0026\u0026 c \u003c a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n    function sqrt(int256 x) internal pure returns (int256) {\n        int256 z = add(x / 2, 1);\n        int256 y = x;\n        while (z \u003c y)\n        {\n            y = z;\n            z = ((add((x / z), z)) / 2);\n        }\n        return y;\n    }\n}\n\ncontract CreamY is ERC20, ERC20Detailed {\n\n    event LOG_SWAP(\n        address indexed caller,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint            tokenAmountIn,\n        uint            tokenAmountOut\n    );\n\n    event LOG_JOIN(\n        address indexed caller,\n        address indexed tokenIn,\n        uint            tokenAmountIn\n    );\n\n    event LOG_EXIT(\n        address indexed caller,\n        address indexed tokenOut,\n        uint            tokenAmountOut\n    );\n\n    using SafeMath for uint;\n    using SignedSafeMath for int256;\n    using SafeERC20 for IERC20;\n\n    mapping(address =\u003e bool) public coins;\n    mapping(address =\u003e bool) public pause;\n    IERC20[] public allCoins;\n    Normalizer public normalizer;\n    address public governance;\n    address public reservePool;\n\n    constructor(address _normalizer, address _reservePool) public ERC20Detailed(\"CreamY USD\", \"cyUSD\", 18) {\n        governance = msg.sender;\n        normalizer = Normalizer(_normalizer);\n        reservePool = _reservePool;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setNormalizer(address _normalizer) external {\n        require(msg.sender == governance, \"!governance\");\n        normalizer = Normalizer(_normalizer);\n    }\n\n    function setReservePool(address _reservePool) external {\n        require(msg.sender == governance, \"!governance\");\n        require(_reservePool != address(0), \"invalid reserve pool\");\n        reservePool = _reservePool;\n    }\n\n    function setFees(uint _fee, uint _reserveRatio) external {\n        require(msg.sender == governance, \u0027!governance\u0027);\n        require(_fee \u003c 1e18 \u0026\u0026 _fee \u003e= 0.99e18, \u0027Invalid fee\u0027); // 0 \u003c fee \u003c= 1%\n        if (_reserveRatio \u003e 0) {\n            require(_reserveRatio \u003c= 1e18, \u0027Invalid reserve ratio\u0027); // reserve ratio \u003c= 100% fee\n        }\n        fee = _fee;\n        reserveRatio = _reserveRatio;\n    }\n\n    function approveCoins(address _coin) external {\n        require(msg.sender == governance, \"!governance\");\n        require(coins[_coin] == false, \"Already approved\");\n        coins[_coin] = true;\n        allCoins.push(IERC20(_coin));\n    }\n\n    function setPause(address _coin, bool _pause) external {\n        require(msg.sender == governance, \"!governance\");\n        pause[_coin] = _pause;\n    }\n\n    function setA(uint _A) external {\n        require(msg.sender == governance, \"!governance\");\n        require(_A \u003e 0 \u0026\u0026 _A \u003c= 1e18, \"Invalid A\");\n        // When A is close to 1, it becomes the fixed price model (x + y = k).\n        // When A is close to 0, it degenerates to Uniswap (x * y = k).\n        // However, A couldn\u0027t be exactly 0 since it will break the f function.\n        A = _A;\n    }\n\n    function seize(IERC20 token, uint amount) external {\n        require(msg.sender == governance, \"!governance\");\n        require(!tokens[address(token)], \"can\u0027t seize liquidity\");\n\n        uint bal = token.balanceOf(address(this));\n        require(amount \u003c= bal);\n\n        token.safeTransfer(reservePool, amount);\n    }\n\n    uint public fee = 0.99965e18;\n    uint public reserveRatio = 1e18;\n    uint public constant BASE = 1e18;\n\n    uint public A = 0.7e18;\n    uint public count = 0;\n    mapping(address =\u003e bool) tokens;\n\n    function f(int256 _x, int256 x, int256 y) internal view returns (int256 _y) {\n        int256 k;\n        int256 c;\n        {\n            int256 u = x.add(y.mul(int256(A)).div(1e18));\n            int256 v = y.add(x.mul(int256(A)).div(1e18));\n            k = u.mul(v);\n            c = _x.mul(_x).sub(k.mul(1e18).div(int256(A)));\n        }\n\n        int256 cst = int256(A).add(int256(1e36).div(int256(A)));\n        int256 _b = _x.mul(cst).div(1e18);\n\n        int256 D = _b.mul(_b).sub(c.mul(4));\n\n        require(D \u003e= 0, \"!root\");\n\n        _y = (-_b).add(D.sqrt()).div(2);\n    }\n\n    function collectReserve(IERC20 from, uint input) internal {\n        if (reserveRatio \u003e 0) {\n            uint _fee = input.mul(BASE.sub(fee)).div(BASE);\n            uint _reserve = _fee.mul(reserveRatio).div(BASE);\n            from.safeTransfer(reservePool, _reserve);\n        }\n    }\n\n    // Get all support coins\n    function getAllCoins() public view returns (IERC20[] memory) {\n        return allCoins;\n    }\n\n    // Calculate total pool value in USD\n    function calcTotalValue() public view returns (uint value) {\n        uint totalValue = uint(0);\n        for (uint i = 0; i \u003c allCoins.length; i++) {\n            totalValue = totalValue.add(balance(allCoins[i]));\n        }\n        return totalValue;\n    }\n\n    // Calculate _x given x, y, _y\n    function getX(int256 output, int256 x, int256 y) internal view returns (int256 input) {\n        int256 _y = y.sub(output);\n        int256 _x = f(_y, y, x);\n        input = _x.sub(x);\n    }\n\n    // Calculate _y given x, y, _x\n    function getY(int256 input, int256 x, int256 y) internal view returns (int256 output) {\n        int256 _x = x.add(input);\n        int256 _y = f(_x, x, y);\n        output = y.sub(_y);\n    }\n\n    // Calculate output given exact input\n    function getOutExactIn(IERC20 from, IERC20 to, uint input, int256 x, int256 y) public view returns (uint output) {\n        uint inputInUsd = normalize1e18(from, input).mul(normalizer.getPrice(address(from))).div(1e18);\n        uint inputAfterFeeInUsd = inputInUsd.mul(fee).div(BASE);\n\n        uint outputInUsd = uint(getY(i(inputAfterFeeInUsd), x, y));\n\n        output = normalize(to, outputInUsd.mul(1e18).div(normalizer.getPrice(address(to))));\n    }\n\n    // Calculate input given exact output\n    function getInExactOut(IERC20 from, IERC20 to, uint output, int256 x, int256 y) public view returns (uint input) {\n        uint outputInUsd = normalize1e18(to, output).mul(normalizer.getPrice(address(to))).div(1e18);\n\n        uint inputBeforeFeeInUsd = uint(getX(i(outputInUsd), x, y));\n        uint inputInUsd = inputBeforeFeeInUsd.mul(BASE).div(fee);\n\n        input = normalize(from, inputInUsd.mul(1e18).div(normalizer.getPrice(address(from))));\n    }\n\n    // Normalize coin to 1e18\n    function normalize1e18(IERC20 token, uint _amount) internal view returns (uint) {\n        uint _decimals = ERC20Detailed(address(token)).decimals();\n        if (_decimals == uint(18)) {\n            return _amount;\n        } else {\n            return _amount.mul(1e18).div(uint(10)**_decimals);\n        }\n    }\n\n    // Normalize coin to original decimals\n    function normalize(IERC20 token, uint _amount) internal view returns (uint) {\n        uint _decimals = ERC20Detailed(address(token)).decimals();\n        if (_decimals == uint(18)) {\n            return _amount;\n        } else {\n            return _amount.mul(uint(10)**_decimals).div(1e18);\n        }\n    }\n\n    // Contract balance of coin normalized to 1e18\n    function balance(IERC20 token) public view returns (uint) {\n        address _token = address(token);\n        uint _balance = IERC20(_token).balanceOf(address(this));\n        uint _balanceInUsd = _balance.mul(normalizer.getPrice(_token)).div(1e18);\n        return normalize1e18(token, _balanceInUsd);\n    }\n\n    // Converter helper to int256\n    function i(uint x) public pure returns (int256) {\n        int256 value = int256(x);\n        require(value \u003e= 0, \u0027overflow\u0027);\n        return value;\n    }\n\n    function swapExactAmountIn(IERC20 from, IERC20 to, uint input, uint minOutput, uint deadline) external returns (uint output) {\n        require(coins[address(from)] == true, \"!coin\");\n        require(pause[address(from)] == false, \"pause\");\n        require(coins[address(to)] == true, \"!coin\");\n        require(pause[address(to)] == false, \"pause\");\n        require(normalizer.getPrice(address(from)) \u003e 0, \"zero price\");\n        require(normalizer.getPrice(address(to)) \u003e 0, \"zero price\");\n\n        require(block.timestamp \u003c= deadline, \"expired\");\n\n        output = getOutExactIn(from, to, input, i(balance(from)), i(balance(to)));\n\n        require(balance(to) \u003e= output, \"insufficient output liquidity\");\n        require(output \u003e= minOutput, \"slippage\");\n\n        emit LOG_SWAP(msg.sender, address(from), address(to), input, output);\n\n        from.safeTransferFrom(msg.sender, address(this), input);\n        to.safeTransfer(msg.sender, output);\n        collectReserve(from, input);\n        return output;\n    }\n\n    function swapExactAmountOut(IERC20 from, IERC20 to, uint maxInput, uint output, uint deadline) external returns (uint input) {\n        require(coins[address(from)] == true, \"!coin\");\n        require(pause[address(from)] == false, \"pause\");\n        require(coins[address(to)] == true, \"!coin\");\n        require(pause[address(to)] == false, \"pause\");\n        require(normalizer.getPrice(address(from)) \u003e 0, \"zero price\");\n        require(normalizer.getPrice(address(to)) \u003e 0, \"zero price\");\n\n        require(block.timestamp \u003c= deadline, \"expired\");\n        require(balance(to) \u003e= output, \"insufficient output liquidity\");\n\n        input = getInExactOut(from, to, output, i(balance(from)), i(balance(to)));\n\n        require(input \u003c= maxInput, \"slippage\");\n\n        emit LOG_SWAP(msg.sender, address(from), address(to), input, output);\n\n        from.safeTransferFrom(msg.sender, address(this), input);\n        to.safeTransfer(msg.sender, output);\n        collectReserve(from, input);\n        return input;\n    }\n\n    function addLiquidityExactIn(IERC20 from, uint input, uint minOutput, uint deadline) external returns (uint output) {\n        require(coins[address(from)] == true, \"!coin\");\n        require(pause[address(from)] == false, \"pause\");\n        require(block.timestamp \u003c= deadline, \"expired\");\n        require(input \u003e 0, \"zero input\");\n        require(normalizer.getPrice(address(from)) \u003e 0, \"zero price\");\n        require(normalizer.getPrice(address(this)) \u003e 0, \"zero price\");\n\n        if (totalSupply() == 0) {\n            uint inputAfterFee = input.mul(fee).div(BASE);\n            output = normalize1e18(from, inputAfterFee.mul(normalizer.getPrice(address(from))).div(1e18));\n        } else {\n            output = getOutExactIn(from, this, input, i(balance(from)), i(totalSupply().div(count)));\n        }\n\n        require(output \u003e= minOutput, \"slippage\");\n\n        emit LOG_JOIN(msg.sender, address(from), output);\n\n        from.safeTransferFrom(msg.sender, address(this), input);\n        _mint(msg.sender, output);\n\n        if (!tokens[address(from)] \u0026\u0026 balance(from) \u003e 0) {\n            tokens[address(from)] = true;\n            count = count.add(1);\n        }\n    }\n\n    function addLiquidityExactOut(IERC20 from, uint maxInput, uint output, uint deadline) external returns (uint input) {\n        require(coins[address(from)] == true, \"!coin\");\n        require(pause[address(from)] == false, \"pause\");\n        require(block.timestamp \u003c= deadline, \"expired\");\n        require(output \u003e 0, \"zero output\");\n        require(normalizer.getPrice(address(from)) \u003e 0, \"zero price\");\n        require(normalizer.getPrice(address(this)) \u003e 0, \"zero price\");\n\n        if (totalSupply() == 0) {\n            uint inputAfterFee = normalize(from, output.mul(1e18).div(normalizer.getPrice(address(from))));\n            input = inputAfterFee.mul(BASE).divCeil(fee);\n        } else {\n            input = getInExactOut(from, this, output, i(balance(from)), i(totalSupply().div(count)));\n        }\n\n        require(input \u003c= maxInput, \"slippage\");\n\n        emit LOG_JOIN(msg.sender, address(from), output);\n\n        from.safeTransferFrom(msg.sender, address(this), input);\n        _mint(msg.sender, output);\n\n        if (!tokens[address(from)] \u0026\u0026 balance(from) \u003e 0) {\n            tokens[address(from)] = true;\n            count = count.add(1);\n        }\n    }\n\n    function removeLiquidityExactIn(IERC20 to, uint input, uint minOutput, uint deadline) external returns (uint output) {\n        require(block.timestamp \u003c= deadline, \"expired\");\n        require(coins[address(to)] == true, \"!coin\");\n        require(input \u003e 0, \"zero input\");\n        require(normalizer.getPrice(address(this)) \u003e 0, \"zero price\");\n        require(normalizer.getPrice(address(to)) \u003e 0, \"zero price\");\n\n        output = getOutExactIn(this, to, input, i(totalSupply().div(count)), i(balance(to)));\n\n        require(output \u003e= minOutput, \"slippage\");\n\n        emit LOG_EXIT(msg.sender, address(to), output);\n\n        _burn(msg.sender, input);\n        to.safeTransfer(msg.sender, output);\n\n        if (balance(to) == 0) {\n            tokens[address(to)] = false;\n            count = count.sub(1);\n        }\n    }\n\n    function removeLiquidityExactOut(IERC20 to, uint maxInput, uint output, uint deadline) external returns (uint input) {\n        require(block.timestamp \u003c= deadline, \"expired\");\n        require(coins[address(to)] == true, \"!coin\");\n        require(output \u003e 0, \"zero output\");\n        require(normalizer.getPrice(address(this)) \u003e 0, \"zero price\");\n        require(normalizer.getPrice(address(to)) \u003e 0, \"zero price\");\n\n        input = getInExactOut(this, to, output, i(totalSupply().div(count)), i(balance(to)));\n\n        require(input \u003c= maxInput, \"slippage\");\n\n        emit LOG_EXIT(msg.sender, address(to), output);\n\n        _burn(msg.sender, input);\n        to.safeTransfer(msg.sender, output);\n\n        if (balance(to) == 0) {\n            tokens[address(to)] = false;\n            count = count.sub(1);\n        }\n    }\n}\n"},"normalizer.sol":{"content":"pragma solidity 0.5.17;\n\nimport \u0027./safeMath.sol\u0027;\n\ninterface Curve {\n    function get_virtual_price() external view returns (uint);\n}\n\ninterface Yearn {\n    function getPricePerFullShare() external view returns (uint);\n}\n\ninterface UnderlyingToken {\n    function decimals() external view returns (uint8);\n}\n\ninterface Compound {\n    function exchangeRateStored() external view returns (uint);\n    function underlying() external view returns (address);\n}\n\ninterface Cream {\n    function exchangeRateStored() external view returns (uint);\n    function underlying() external view returns (address);\n}\n\ncontract Normalizer {\n    using SafeMath for uint;\n\n    address public governance;\n    address public creamY;\n    mapping(address =\u003e bool) public native;\n    mapping(address =\u003e bool) public yearn;\n    mapping(address =\u003e bool) public curve;\n    mapping(address =\u003e address) public curveSwap;\n    mapping(address =\u003e bool) public vaults;\n    mapping(address =\u003e bool) public compound;\n    mapping(address =\u003e bool) public cream;\n    mapping(address =\u003e uint) public underlyingDecimals;\n\n    constructor() public {\n        governance = msg.sender;\n\n        native[0xdAC17F958D2ee523a2206206994597C13D831ec7] = true; // USDT\n        native[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] = true; // USDC\n        native[0x4Fabb145d64652a948d72533023f6E7A623C7C53] = true; // BUSD\n        native[0x0000000000085d4780B73119b644AE5ecd22b376] = true; // TUSD\n\n        yearn[0xACd43E627e64355f1861cEC6d3a6688B31a6F952] = true; // vault yDAI\n        yearn[0x37d19d1c4E1fa9DC47bD1eA12f742a0887eDa74a] = true; // vault yTUSD\n        yearn[0x597aD1e0c13Bfe8025993D9e79C69E1c0233522e] = true; // vault yUSDC\n        yearn[0x2f08119C6f07c006695E079AAFc638b8789FAf18] = true; // vault yUSDT\n\n        yearn[0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01] = true; // yDAI\n        yearn[0xd6aD7a6750A7593E092a9B218d66C0A814a3436e] = true; // yUSDC\n        yearn[0x83f798e925BcD4017Eb265844FDDAbb448f1707D] = true; // yUSDT\n        yearn[0x73a052500105205d34Daf004eAb301916DA8190f] = true; // yTUSD\n        yearn[0xF61718057901F84C4eEC4339EF8f0D86D2B45600] = true; // ySUSD\n\n        yearn[0xC2cB1040220768554cf699b0d863A3cd4324ce32] = true; // bDAI\n        yearn[0x26EA744E5B887E5205727f55dFBE8685e3b21951] = true; // bUSDC\n        yearn[0xE6354ed5bC4b393a5Aad09f21c46E101e692d447] = true; // bUSDT\n        yearn[0x04bC0Ab673d88aE9dbC9DA2380cB6B79C4BCa9aE] = true; // bBUSD\n\n        curve[0x845838DF265Dcd2c412A1Dc9e959c7d08537f8a2] = true; // cCompound\n        curveSwap[0x845838DF265Dcd2c412A1Dc9e959c7d08537f8a2] = 0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56;\n        curve[0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8] = true; // cYearn\n        curveSwap[0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8] = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;\n        curve[0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B] = true; // cBUSD\n        curveSwap[0x3B3Ac5386837Dc563660FB6a0937DFAa5924333B] = 0x79a8C46DeA5aDa233ABaFFD40F3A0A2B1e5A4F27;\n        curve[0xC25a3A3b969415c80451098fa907EC722572917F] = true; // cSUSD\n        curveSwap[0xC25a3A3b969415c80451098fa907EC722572917F] = 0xA5407eAE9Ba41422680e2e00537571bcC53efBfD;\n        curve[0xD905e2eaeBe188fc92179b6350807D8bd91Db0D8] = true; // cPAX\n        curveSwap[0xD905e2eaeBe188fc92179b6350807D8bd91Db0D8] = 0x06364f10B501e868329afBc005b3492902d6C763;\n\n        compound[0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643] = true; // cDAI\n        underlyingDecimals[0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643] = 1e18;\n        compound[0x39AA39c021dfbaE8faC545936693aC917d5E7563] = true; // cUSDC\n        underlyingDecimals[0x39AA39c021dfbaE8faC545936693aC917d5E7563] = 1e6;\n        compound[0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9] = true; // cUSDT\n        underlyingDecimals[0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9] = 1e6;\n\n        cream[0x44fbeBd2F576670a6C33f6Fc0B00aA8c5753b322] = true; // crUSDC\n        underlyingDecimals[0x44fbeBd2F576670a6C33f6Fc0B00aA8c5753b322] = 1e6;\n        cream[0x797AAB1ce7c01eB727ab980762bA88e7133d2157] = true; // crUSDT\n        underlyingDecimals[0x797AAB1ce7c01eB727ab980762bA88e7133d2157] = 1e6;\n        cream[0x1FF8CDB51219a8838b52E9cAc09b71e591BC998e] = true; // crBUSD\n        underlyingDecimals[0x1FF8CDB51219a8838b52E9cAc09b71e591BC998e] = 1e18;\n    }\n\n    function setGovernance(address _governance) external {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setCreamY(address _creamY) external {\n        require(msg.sender == governance, \"!governance\");\n        creamY = _creamY;\n    }\n\n    function getPrice(address token) external view returns (uint) {\n        if (native[token] || token == creamY) {\n            return 1e18;\n        } else if (yearn[token]) {\n            return Yearn(token).getPricePerFullShare();\n        } else if (curve[token]) {\n            return Curve(curveSwap[token]).get_virtual_price();\n        } else if (compound[token]) {\n            return getCompoundPrice(token);\n        } else if (cream[token]) {\n            return getCreamPrice(token);\n        } else {\n            return uint(0);\n        }\n    }\n\n    function getCompoundPrice(address token) public view returns (uint) {\n        address underlying = Compound(token).underlying();\n        uint8 decimals = UnderlyingToken(underlying).decimals();\n        return Compound(token).exchangeRateStored().mul(1e8).div(uint(10) ** decimals);\n    }\n\n    function getCreamPrice(address token) public view returns (uint) {\n        address underlying = Cream(token).underlying();\n        uint8 decimals = UnderlyingToken(underlying).decimals();\n        return Cream(token).exchangeRateStored().mul(1e8).div(uint(10) ** decimals);\n    }\n}\n"},"safeMath.sol":{"content":"pragma solidity 0.5.17;\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c \u003e= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n    function sub(uint a, uint b) internal pure returns (uint) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        require(b \u003c= a, errorMessage);\n        uint c = a - b;\n\n        return c;\n    }\n    function mul(uint a, uint b) internal pure returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n    function div(uint a, uint b) internal pure returns (uint) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, errorMessage);\n        uint c = a / b;\n\n        return c;\n    }\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0);\n        uint256 c = a / b;\n        if(a % b != 0)\n            c = c + 1;\n        return c;\n    }\n}\n"}}