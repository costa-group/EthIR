{"EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.9;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n\n    struct AddressSet {\n        // Storage of set values\n        address[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (address =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        if (!contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        // We read and store the value\u0027s index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as \u0027swap and pop\u0027).\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an \u0027if\u0027 statement.\n\n            address lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        require(set._values.length \u003e index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n}\n"},"Governance.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.9;\r\n\r\n// After deploy and setup necessaries rules and addresses, need to change the Owner address to the GovernanceProxy address.\r\nimport \"./Ownable.sol\";\r\nimport \"./EnumerableSet.sol\";\r\n\r\ninterface IWhitelist {\r\n    function address_belongs(address _who) external view returns (address);\r\n    function getUserWallets(address _which) external view returns (address[] memory);\r\n}\r\n\r\ninterface IERC20Token {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\n// The GovernanceProxy contract address should be the Owner of other contracts which setting we will change.\r\ninterface IGovernanceProxy {\r\n    function trigger(address contr, bytes calldata params) external;\r\n    function acceptGovernanceAddress() external;\r\n}\r\n\r\ncontract Governance is Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    EnumerableSet.AddressSet walletsCEO;    // wallets of CEO. It should participate in votes with Absolute majority, otherwise Escrowed wallets will not be counted.\r\n    uint256 public requiredCEO;             // number COE wallets require to participate in vote\r\n\r\n    IGovernanceProxy public governanceProxy;\r\n    IERC20Token[4] public tokenContract; // tokenContract[0] = MainToken, tokenContract[1] = ETN, tokenContract[2] = STOCK\r\n    IERC20Token[4] public escrowContract; // contract that hold (lock) investor\u0027s pre-minted tokens (0-Main, 1-ETN, 2-STOCK)\r\n    uint256[4] public circulationSupply;   // Circulation Supply of according tokens\r\n    uint256[4] public circulationSupplyUpdated; // timestamp when Circulation Supply was updated\r\n    IWhitelist public whitelist;    // whitelist contract\r\n    uint256 public closeTime;   // timestamp when votes will close\r\n    uint256 public expeditedLevel = 10; // user who has this percentage of Main token circulation supply can expedite voting\r\n    uint256 public absoluteLevel = 90; // this percentage of participants voting power considering as Absolute Majority\r\n\r\n    enum Vote {None, Yea, Nay}\r\n    enum Status {New, Canceled, Approved, Rejected, Pending}\r\n\r\n    struct Rule {\r\n        address contr;      // contract address which have to be triggered\r\n        uint8[4] majority;  // require more than this percentage of participants voting power (in according tokens).\r\n        string funcAbi;     // function ABI (ex. \"setGroupBonusRatio(uint256)\")\r\n    }\r\n\r\n    Rule[] rules;\r\n\r\n    struct Ballot {\r\n        uint256 closeVote; // timestamp when vote will close\r\n        uint256 ruleId; // rule which edit\r\n        bytes args; // ABI encoded arguments for proposal which is required to call appropriate function\r\n        Status status;\r\n        address creator;    // wallet address of ballot creator.\r\n        uint256[4] votesYea;  // YEA votes according communities (tokens)\r\n        uint256[4] totalVotes;  // The total voting power od all participant according communities (tokens)\r\n        address[] participant;  // the users who voted (primary address)\r\n        uint256 processedParticipants; // The number of participant that was verified. Uses to split verification on many transactions\r\n        mapping (address =\u003e Vote) votes; //Vote: Yea or Nay. If None -the user did not vote.\r\n        mapping (address =\u003e mapping (uint256 =\u003e uint256)) power;   // Voting power. primary address =\u003e community index =\u003e voting power\r\n        uint256 ceoParticipate; //number of ceo wallets participated at voting\r\n    }\r\n\r\n    Ballot[] ballots;\r\n\r\n    uint256 public unprocessedBallot; // The start index of ballots which are unprocessed and maybe ready for vote.\r\n\r\n    mapping (address =\u003e bool) public blockedWallets;    // The wallets which are excluded from voting\r\n    mapping (uint256 =\u003e mapping(address =\u003e bool)) public isInEscrow;    // The wallets which may has pre-minted tokens. Token index =\u003e wallet\r\n    mapping (uint256 =\u003e address[]) excluded; // The list of address that should be subtracted from TotalSupply to calculate Circulation Supply.\r\n                                             // ex. Company wallet, Downside protection, Vault smart contract.\r\n\r\n    event AddRule(address indexed contractAddress, string funcAbi, uint8[4] majorMain);\r\n    event SetNewAddress(address indexed previousAddress, address indexed newAddress);\r\n    event BlockWallet(address indexed walletAddress, bool isAdded);\r\n    event AddBallot(address indexed creator, uint256 indexed ruleId, uint256 indexed ballotId);\r\n    event ExpeditedBallot(uint256 indexed ballotId, uint256 indexed closeTime);\r\n    event ApplyBallot(uint256 indexed ruleId, uint256 indexed ballotId);\r\n    event NewVote(address indexed voter, address indexed primary, uint256 indexed ballotId);\r\n    event ChangeVote(address indexed voter, address indexed primary, uint256 indexed ballotId);\r\n    event PosableMajority(uint256 indexed ballotId);\r\n    event CEOWallet(address indexed wallet, bool add);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the one of COE wallets.\r\n     */\r\n    modifier onlyCEO() {\r\n        require(walletsCEO.contains(msg.sender),\"Not CEO\");\r\n        _;\r\n    }\r\n\r\n    constructor(address CEO_wallet) public {\r\n        require(CEO_wallet != address(0),\"Zero address not allowed\");\r\n        // add rule with Absolute majority (above 90% participants) which allow to add another rules\r\n        rules.push(Rule(address(this), [90,0,0,0], \"addRule(address,uint8[4],string)\"));\r\n        walletsCEO.add(CEO_wallet);\r\n        requiredCEO = 1;\r\n    }\r\n\r\n\r\n    function addCEOWallet(address CEO_wallet) external onlyCEO {\r\n        require(CEO_wallet != address(0),\"Zero address not allowed\");\r\n        walletsCEO.add(CEO_wallet);\r\n        requiredCEO = walletsCEO.length();\r\n        emit CEOWallet(CEO_wallet, true);\r\n    }\r\n\r\n    function removeCEOWallet(address CEO_wallet) external onlyCEO {\r\n        require(CEO_wallet != address(0),\"Zero address not allowed\");\r\n        require(walletsCEO.length() \u003e 1, \"Should left at least one CEO wallet\");\r\n        walletsCEO.remove(CEO_wallet);\r\n        requiredCEO = walletsCEO.length();\r\n        emit CEOWallet(CEO_wallet, false);\r\n    }\r\n\r\n    function setRequiredCEO(uint256 req) external onlyCEO {\r\n        require(req \u003c= walletsCEO.length(),\"More then added wallets\");\r\n        requiredCEO = req;\r\n    }\r\n\r\n    function getWalletsCEO() external view returns(address[] memory wallets) {\r\n        return walletsCEO._values;\r\n    }\r\n\r\n    /**\r\n     * @dev Accept Governance in case changing voting contract.\r\n     */    \r\n    function acceptGovernanceAddress() external onlyOwner {\r\n        governanceProxy.acceptGovernanceAddress();\r\n    }\r\n\r\n    /**\r\n     * @dev Calculation Supply = Total Supply - Total balance on Excluded wallets.\r\n     * @param index The index of token (0 - Main, 1 - ETN, 2 - STOCK).\r\n     * @return list of excluded address.\r\n     */\r\n    function getExcluded(uint256 index) external view returns(address[] memory) {\r\n        require(index \u003e= 0 \u0026\u0026 index \u003c 4, \"Wrong index\");\r\n        return excluded[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Add addresses to excluded list\r\n     * @param index The index of token (0 - Main, 1 - ETN, 2 - STOCK).\r\n     * @param wallet List of addresses to add\r\n     */\r\n    function addExcluded(uint256 index, address[] memory wallet) external onlyOwner {\r\n        require(index \u003e= 0 \u0026\u0026 index \u003c 4, \"Wrong index\");\r\n        for (uint i = 0; i \u003c wallet.length; i++) {\r\n            require(wallet[i] != address(0),\"Zero address not allowed\");\r\n            excluded[index].push(wallet[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Remove addresses from excluded list\r\n     * @param index The index of token (0 - Main, 1 - ETN, 2 - STOCK).\r\n     * @param wallet The address to remove\r\n     */\r\n    function removeExcluded(uint256 index, address wallet) external onlyOwner {\r\n        require(index \u003e= 0 \u0026\u0026 index \u003c 4, \"Wrong index\");\r\n        require(wallet != address(0),\"Zero address not allowed\");\r\n        uint len = excluded[index].length;\r\n        for (uint i = 0; i \u003c len; i++) {\r\n            if (excluded[index][i] == wallet) {\r\n                excluded[index][i] = excluded[index][len-1];\r\n                excluded[index].pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set percentage of participants voting power considering as Absolute Majority\r\n     * @param level The percentage\r\n     */\r\n    function setAbsoluteLevel(uint256 level) external onlyOwner {\r\n        require(level \u003e 50 \u0026\u0026 level \u003c= 100, \"Wrong level\");\r\n        absoluteLevel = level;\r\n    }\r\n\r\n    /**\r\n     * @dev Set percentage of total circulation that allows user to expedite proposal\r\n     * @param level The percentage\r\n     */\r\n    function setExpeditedLevel(uint256 level) external onlyOwner {\r\n        require(level \u003e= 1 \u0026\u0026 level \u003c= 100, \"Wrong level\");\r\n        expeditedLevel = level;\r\n    }\r\n\r\n    /**\r\n     * @dev Add/Remove address from the list of wallets which is disallowed to vote.\r\n     * @param wallet The address to add or remove.\r\n     * @param add Add to the list if true (1) or remove from the list if false (0).\r\n     */\r\n    function manageBlockedWallet(address wallet, bool add) external onlyOwner {\r\n        emit BlockWallet(wallet, add);\r\n        blockedWallets[wallet] = add;\r\n    }\r\n\r\n    /**\r\n     * @dev Set token contract address.\r\n     * @param token The address of token contract.\r\n     * @param index The index of token: 0 - Main, 1 - ETN, 2 - STOCK.\r\n     */\r\n    function setTokenContract(IERC20Token token, uint index) external onlyOwner {\r\n        require(token != IERC20Token(0) \u0026\u0026 tokenContract[index] == IERC20Token(0),\"Change address not allowed\");\r\n        tokenContract[index] = token;\r\n    }\r\n\r\n    /**\r\n     * @dev Set Escrow contract address, where pre-minted tokens locked (index of token: 0 - Main, 1 - ETN, 2 - STOCK).\r\n     * @param escrow The address of token contract.\r\n     * @param index The index of token: 0 - Main, 1 - ETN, 2 - STOCK.\r\n     */\r\n    function setEscrowContract(IERC20Token escrow, uint index) external onlyOwner {\r\n        require(escrow != IERC20Token(0),\"Change address not allowed\");\r\n        escrowContract[index] = escrow;\r\n    }\r\n\r\n    /**\r\n     * @dev Set whitelist contract address to a newAddr.\r\n     * @param newAddr The address of whitelist contract.\r\n     */\r\n    function setWhitelist(address newAddr) external onlyOwner {\r\n        require(newAddr != address(0),\"Zero address not allowed\");\r\n        emit SetNewAddress(address(whitelist), newAddr);\r\n        whitelist = IWhitelist(newAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev Set Governance Proxy contract address to a newAddr.\r\n     * @param newAddr The address of Governance Proxy contract.\r\n     */\r\n    function setGovernanceProxy(address newAddr) external onlyOwner {\r\n        require(newAddr != address(0),\"Zero address not allowed\");\r\n        emit SetNewAddress(address(governanceProxy), newAddr);\r\n        governanceProxy = IGovernanceProxy(newAddr);\r\n    }\r\n\r\n    /**\r\n     * @dev Update time when new votes will close. Should be called after 00:00:00 UTC 1st day of each month\r\n     */\r\n    function updateCloseTime() external {\r\n        require(closeTime \u003c block.timestamp, \"Wait for 1st day of month\"); // close time is not passed\r\n        (uint year, uint month, uint day) = timestampToDate(block.timestamp);\r\n        day = 1;\r\n        if (month == 12) {\r\n            year++;\r\n            month = 1;\r\n        }\r\n        else {\r\n            month++;\r\n        }\r\n        closeTime = timestampFromDateTime(year, month, day, 0, 0, 0);    // 1st day of each month at 00:00:00 UTC\r\n        uint len = ballots.length;\r\n        for (uint i = unprocessedBallot; i \u003c len; i++) {\r\n            if (ballots[i].status == Status.Pending) {\r\n                if(ballots[i].closeVote == 0)\r\n                    ballots[i].closeVote = closeTime;\r\n                else\r\n                    ballots[i].closeVote += closeTime; // Expedited vote\r\n                ballots[i].status = Status.New;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add wallet that received pre-minted tokens.\r\n     * @param wallet The address of wallet.\r\n     * @return true if address added.\r\n     */\r\n    function addPremintedWallet(address wallet) external returns(bool){\r\n        for (uint i = 0; i \u003c 4; i++ ) {\r\n            if(address(escrowContract[i]) == msg.sender) {\r\n                isInEscrow[i][wallet] = true;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Add new rule - function that call target contract to change setting.\r\n     * @param contr The contract address which have to be triggered\r\n     * @param majority The majority level (%) for the tokens (index: 0 - Main, 1 - ETN, 2 - STOCK).\r\n     * @param funcAbi The function ABI (ex. \"setGroupBonusRatio(uint256)\")\r\n     */\r\n    function addRule(\r\n            address contr,\r\n            uint8[4] memory majority,\r\n            string memory funcAbi\r\n        ) external onlyOwner {\r\n        require(contr != address(0), \"Zero address\");\r\n        rules.push(Rule(contr, majority, funcAbi));\r\n        emit AddRule(contr, funcAbi, majority);\r\n    }\r\n\r\n    /**\r\n     * @dev Change majority levels of rules.\r\n     * @param ruleId The rules index\r\n     * @param majority The majority level (%) for the tokens (index: 0 - Main, 1 - ETN, 2 - STOCK).\r\n     */\r\n    function changeRuleMajority(uint256 ruleId, uint8[4] memory majority) external onlyOwner {\r\n        Rule storage r = rules[ruleId];\r\n        r.majority = majority;\r\n    }\r\n\r\n    /**\r\n     * @dev Change destination contract address of rules.\r\n     * @param ruleId The rules index\r\n     * @param contr The new contract address of selected rule.\r\n     */\r\n    function changeRuleAddress(uint256 ruleId, address contr) external onlyOwner {\r\n        require(contr != address(0), \"Zero address\");\r\n        Rule storage r = rules[ruleId];\r\n        r.contr = contr;\r\n    }\r\n\r\n    /**\r\n     * @dev Get total number of rules.\r\n     * @return The total number of rules.\r\n     */\r\n    function getTotalRules() external view returns(uint256) {\r\n        return rules.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get rules details.\r\n     * @param ruleId The rules index\r\n     * @return contr The contract address\r\n     * @return majority The level of majority in according tokens\r\n     * @return funcAbi The function Abi\r\n     */\r\n    function getRule(uint256 ruleId) external view\r\n        returns(address contr,\r\n        uint8[4] memory majority,\r\n        string memory funcAbi)\r\n    {\r\n        Rule storage r = rules[ruleId];\r\n        return (r.contr, r.majority, r.funcAbi);\r\n    }\r\n\r\n    /**\r\n     * @dev Get total number of ballots.\r\n     * @return The total number of ballots.\r\n     */\r\n    function getTotalBallots() external view returns(uint256) {\r\n        return ballots.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get ballot details. Uses to show the list of available proposal for voting\r\n     * @param ballotId The ballot index\r\n     * @return closeVote\r\n     * @return ruleId\r\n     * @return args\r\n     * @return status\r\n     * @return creator\r\n     * @return totalVotes\r\n     * @return votesYea\r\n     */\r\n    function getBallot(uint256 ballotId)\r\n        external view returns(\r\n        uint256 closeVote,\r\n        uint256 ruleId,\r\n        bytes memory args,\r\n        Status status,\r\n        address creator,\r\n        uint256[4] memory totalVotes,\r\n        uint256[4] memory votesYea)\r\n    {\r\n        Ballot storage b = ballots[ballotId];\r\n        return (b.closeVote, b.ruleId, b.args, b.status, b.creator,b.totalVotes,b.votesYea);\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of participants who vote for ballot.\r\n     * @param ballotId The ballot index\r\n     * @return number of participants who take pert in voting\r\n     */\r\n    function getParticipantsNumber(uint256 ballotId) external view returns(uint256) {\r\n        return ballots[ballotId].participant.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of participant who vote for ballot.\r\n     * @param ballotId The ballot index\r\n     * @param start The start position (index) to return data.\r\n     * @param number The number of records (positions) to return.\r\n     * @return participants The list of participant primary addresses\r\n     * @return mainVotes The ist of voting power in main (JNTR) tokens\r\n     * @return etnVotes The ist of voting power in ETN tokens\r\n     * @return stockVotes The ist of voting power in Stock tokens\r\n     * @return votes The list of votes (1 -Yea, 2 -Nay).\r\n     */\r\n    function getParticipants(uint256 ballotId, uint256 start, uint256 number) external view\r\n        returns(address[] memory participants,\r\n        uint256[] memory mainVotes,\r\n        uint256[] memory etnVotes,\r\n        uint256[] memory stockVotes,\r\n        Vote[] memory votes)\r\n    {\r\n        Ballot storage b = ballots[ballotId];\r\n        participants = new address[](number);\r\n        mainVotes = new uint256[](number);\r\n        etnVotes = new uint256[](number);\r\n        stockVotes = new uint256[](number);\r\n        votes = new Vote[](number);\r\n        uint256 len = number;\r\n        if (start + number \u003e b.participant.length)\r\n            len = b.participant.length - start;\r\n        for(uint i = 0; i \u003c len; i++) {\r\n            participants[i] = b.participant[start + i];\r\n            mainVotes[i] = b.power[participants[i]][0]; // voting power in community A (Main token)\r\n            etnVotes[i] = b.power[participants[i]][1]; // voting power in community B (ETN token)\r\n            stockVotes[i] = b.power[participants[i]][2]; // voting power in community C (STOCK token)\r\n            votes[i] = b.votes[participants[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Create new proposal (ballot)\r\n     * @param ruleId The rule id which parameter propose to change.\r\n     * @param args The list of parameters.\r\n     * @param isExpedited The proposal should be expedited if user have more then 10% of circulation supply.\r\n     */\r\n    function createBallot(uint256 ruleId, bytes memory args, bool isExpedited) external {\r\n        require(ruleId \u003c rules.length,\"Wrong rule ID\");\r\n        Rule storage r = rules[ruleId];\r\n        _getCirculation(r.majority);   //require update circulationSupply of Main token\r\n        (address primary, uint256[4] memory power) = _getVotingPower(msg.sender, r.majority, false, true);\r\n        uint256 highestPercentage;\r\n        for (uint i = 0; i \u003c 4; i++) {\r\n            if (circulationSupply[i] \u003e 0) {\r\n                uint256 percentage = power[i] * 100 / circulationSupply[i]; // ownership percentage of token\r\n                if (percentage \u003e highestPercentage) highestPercentage = percentage;\r\n            }\r\n        }\r\n        require(highestPercentage \u003e 0, \"Less then 1% of circulationSupply\");\r\n        uint256 ballotId = ballots.length;\r\n        Ballot memory b;\r\n        b.ruleId = ruleId;\r\n        b.args = args;\r\n        b.creator = msg.sender;\r\n        b.votesYea = power;\r\n        b.totalVotes = power;\r\n\r\n        if(highestPercentage \u003e= expeditedLevel \u0026\u0026 isExpedited \u0026\u0026 r.majority[0] \u003c absoluteLevel) {\r\n            // proposal can be expedited if user has 10% of Main token circulation supply\r\n            // and requiring majority is less then 90%\r\n            b.closeVote = 24 hours;\r\n        }\r\n\r\n        if (block.timestamp + 24 hours \u003c= closeTime) {\r\n            if(b.closeVote == 0)\r\n                b.closeVote = closeTime;\r\n            else {\r\n                b.closeVote += block.timestamp; // Expedited vote\r\n                emit ExpeditedBallot(ballotId, b.closeVote);\r\n            }\r\n        }\r\n        else {\r\n            b.status = Status.Pending;\r\n        }\r\n        ballots.push(b);\r\n        emit AddBallot(msg.sender, ruleId, ballotId);\r\n        // Add vote Yea\r\n        ballots[ballotId].participant.push(primary); // add creator primary address as participant\r\n        ballots[ballotId].votes[primary] = Vote.Yea;\r\n        for (uint i = 0; i \u003c 4; i++) {\r\n            if (power[i] \u003e 0) {\r\n                ballots[ballotId].power[primary][i] = power[i];\r\n            }\r\n        }\r\n        emit NewVote(msg.sender, primary, ballotId);\r\n\r\n        if (highestPercentage \u003e= 50) {\r\n            // Check creator voting power for majority 50%+1 of total circulation supply\r\n            if (_checkMajority(r.majority, power, power, false) == Vote.Yea) { // check Instant execution\r\n                ballots[ballotId].status = Status.Approved;\r\n                _executeBallot(ballotId);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel proposal.\r\n     * @param ballotId The ballot index\r\n     */\r\n    function cancelBallot(uint256 ballotId) external {\r\n        require(ballotId \u003c ballots.length,\"Wrong ballot ID\");\r\n        Ballot storage b = ballots[ballotId];\r\n        require(msg.sender == b.creator,\"Only creator can cancel\");\r\n        b.closeVote = block.timestamp;\r\n        b.status = Status.Canceled;\r\n        if (unprocessedBallot == ballotId) unprocessedBallot++;\r\n    }\r\n\r\n    /**\r\n     * @dev Vote for proposal.\r\n     * @param ballotId The ballot index\r\n     * @param v The user vote (1 - Yea, 2 - Nay)\r\n     */\r\n    function vote(uint256 ballotId, Vote v) external {\r\n        require(ballotId \u003c ballots.length,\"Wrong ballot ID\");\r\n        Ballot storage b = ballots[ballotId];\r\n        require(v != Vote.None, \"Should vote Yea or Nay\");\r\n        require(b.status == Status.New, \"Voting for disallowed\");\r\n        require(b.closeVote \u003e block.timestamp, \"Ballot expired\");\r\n        (address primary, uint256[4] memory power) = _getVotingPower(msg.sender, rules[b.ruleId].majority, false, true);\r\n        if (b.votes[primary] == Vote.None) {\r\n            // Add vote\r\n            b.participant.push(primary); // add creator primary address as participant\r\n            b.votes[primary] = v;\r\n            for (uint i = 0; i \u003c 4; i++) {\r\n                if (power[i] \u003e 0) {\r\n                    b.power[primary][i] = power[i];  // store user\u0027s voting power\r\n                    b.totalVotes[i] += power[i];\r\n                    if (v == Vote.Yea)\r\n                        b.votesYea[i] += power[i];\r\n                }\r\n            }\r\n            // add CEO wallet as participant only for Absolute majority voting\r\n            if (rules[b.ruleId].majority[0] \u003e= absoluteLevel \u0026\u0026 walletsCEO.contains(msg.sender)) {\r\n                b.ceoParticipate++;\r\n            }\r\n            emit NewVote(msg.sender, primary, ballotId);\r\n        }\r\n        else if (b.votes[primary] != v) {\r\n            // Change vote\r\n            b.votes[primary] = v;\r\n            for (uint i = 0; i \u003c 4; i++) {\r\n                if (power[i] \u003e 0) {\r\n                    if (v == Vote.Yea)\r\n                        b.votesYea[i] += power[i];\r\n                    else\r\n                        b.votesYea[i] -= b.power[primary][i];   // remove previous votes\r\n                    b.totalVotes[i] = b.totalVotes[i] + power[i] - b.power[primary][i];\r\n                    b.power[primary][i] = power[i];  // store user\u0027s voting power\r\n                }\r\n            }\r\n            emit ChangeVote(msg.sender, primary, ballotId);\r\n        }\r\n\r\n        if (_checkMajority(rules[b.ruleId].majority, b.votesYea, b.totalVotes, false) != Vote.None) { // check Instant execution\r\n            // Server-side may watch for PosableMajority event.\r\n            // If it emitted the server-side may call verify function to apply changes without waiting voting close.\r\n            emit PosableMajority(ballotId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Verify voting. Can be called many times if there are too many participants which cause Out of Gas error.\r\n     * @param ballotId The ballot index\r\n     * @param part The number of participant to verify. Uses to avoid Out of Gas.\r\n     */\r\n    function verify(uint256 ballotId, uint part) external {\r\n        _verify(ballotId, part);\r\n    }\r\n\r\n    /**\r\n     * @dev Verify next unverified voting. Can be called many times if there are too many participants which cause Out of Gas error.\r\n     * @param part The number of participant to verify. Uses to avoid Out of Gas.\r\n     */\r\n    function verifyNext(uint part) external {\r\n        uint len = ballots.length;\r\n        for (uint i = unprocessedBallot; i \u003c len; i++) {\r\n            if (ballots[i].status == Status.New) {\r\n                _verify(i, part);\r\n                return; // exit after verification to avoid Out of Gas error\r\n            }\r\n            else if (ballots[i].status != Status.Pending \u0026\u0026 unprocessedBallot == i)\r\n                unprocessedBallot++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate Circulation Supply = Total supply - sum(excluded addresses balance)\r\n     */\r\n    function getCirculation() external {\r\n        uint8[4] memory m;\r\n        for (uint i = 0; i \u003c 4; i++) {\r\n            if (tokenContract[i] != IERC20Token(0))\r\n                m[i] = 50;\r\n        }\r\n        _getCirculation(m);\r\n    }\r\n\r\n    /**\r\n     * @dev Apply changes from ballot.\r\n     * @param ballotId The ballot index\r\n     */\r\n    function _executeBallot(uint256 ballotId) internal {\r\n        require(ballots[ballotId].status == Status.Approved,\"Ballot is not Approved\");\r\n        Ballot storage b = ballots[ballotId];\r\n        Rule storage r = rules[b.ruleId];\r\n        bytes memory command;\r\n        command = abi.encodePacked(bytes4(keccak256(bytes(r.funcAbi))), b.args);\r\n        governanceProxy.trigger(r.contr, command);\r\n        b.closeVote = block.timestamp;\r\n        if (unprocessedBallot == ballotId) unprocessedBallot++;\r\n        emit ApplyBallot(b.ruleId, ballotId);\r\n    }\r\n\r\n    /**\r\n     * @dev Verify voting. Can be called many times if there are too many participants which cause Out of Gas error.\r\n     * @param ballotId The ballot index\r\n     * @param part The number of participant to verify. Uses to avoid Out of Gas.\r\n     */\r\n    function _verify(uint256 ballotId, uint part) internal {\r\n        require(ballotId \u003c ballots.length,\"Wrong ballot ID\");\r\n        Ballot storage b = ballots[ballotId];\r\n        Rule storage r = rules[b.ruleId];\r\n        require(b.status == Status.New, \"Can not be verified\");\r\n        uint256[4] memory totalVotes;\r\n        uint256[4] memory totalYea;\r\n        if (b.processedParticipants \u003e 0) {  // continue verification\r\n            totalVotes = b.totalVotes;\r\n            totalYea = b.votesYea;\r\n        }\r\n        uint256 len = b.processedParticipants + part;\r\n        if (len \u003e b.participant.length || b.closeVote \u003e block.timestamp) // if voting is not closed only etire number of participants should be count\r\n            len = b.participant.length;\r\n        bool acceptEscrowed = true;\r\n        if (r.majority[0] \u003e= absoluteLevel \u0026\u0026 b.ceoParticipate \u003c requiredCEO)  // only for Absolute majority voting\r\n            acceptEscrowed = false; // reject escrowed wallets if CED did not vote with required number of wallets\r\n        for (uint i = b.processedParticipants; i \u003c len; i++) {\r\n            (address primary, uint256[4] memory power) = _getVotingPower(b.participant[i], r.majority, true, acceptEscrowed);\r\n            for (uint j = 0; j \u003c 4; j++) {\r\n                if (power[j] \u003e 0) {\r\n                    totalVotes[j] += power[j];\r\n                    if (b.votes[primary] == Vote.Yea){\r\n                        totalYea[j] += power[j];\r\n                    }\r\n                }\r\n                b.power[primary][j] = power[j]; // store user\u0027s voting power\r\n            }\r\n        }\r\n        b.processedParticipants = len;\r\n        b.votesYea = totalYea;\r\n        b.totalVotes = totalVotes;\r\n        Vote result;\r\n        if (len == b.participant.length) {\r\n            // Check Absolute majority at first\r\n            _getCirculation(r.majority);\r\n            if (b.closeVote \u003c block.timestamp) // if vote closed\r\n            {\r\n                result = _checkMajority(r.majority, totalYea, totalVotes, true);\r\n                if (result == Vote.None) result = Vote.Nay; // if no required majority then reject proposal\r\n            }\r\n            else\r\n                result = _checkMajority(r.majority, totalYea, totalVotes, false);  // Check majority for instant execution\r\n            if (result == Vote.Yea) {\r\n                b.status = Status.Approved;\r\n                _executeBallot(ballotId);\r\n            }\r\n            else if (result == Vote.Nay) {\r\n                b.status = Status.Rejected;\r\n                b.closeVote = block.timestamp;\r\n                if (unprocessedBallot == ballotId) unprocessedBallot++;\r\n            }\r\n            else\r\n                b.processedParticipants = 0; //continue voting and reset counter to be able recount votes\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate Circulation Supply = Total supply - sum(excluded addresses balance).\r\n     * @param tokensApply if element of array = 0 then exclude that token (index: 0 = MainToken, 1 = ETN, 2 = STOCK)\r\n     * @param votesYea The total voting power said Yea.\r\n     * @param totalVotes The total voting power of all participants.\r\n     * @param isClosed the voting is closed\r\n     * @return result the majority Yea (1), Nay (2) in case absolute majority, or None (0) if no majority.\r\n    */\r\n    function _checkMajority(\r\n        uint8[4] memory tokensApply,\r\n        uint256[4] memory votesYea,\r\n        uint256[4] memory totalVotes,\r\n        bool isClosed)\r\n        internal view returns(Vote result)\r\n    {\r\n        uint256 majorityYea;\r\n        uint256 majorityNay;\r\n        uint256 requireMajority;\r\n        for (uint i = 0; i \u003c 4; i++) {\r\n            if (tokensApply[i] != 0) {\r\n                requireMajority++;\r\n                // check majority of circulation supply at first\r\n                if (votesYea[i] * 2 \u003e circulationSupply[i])\r\n                    majorityYea++;   // the voting power is more then 50% of circulation supply\r\n                else if ((totalVotes[i]-votesYea[i]) * 2 \u003e circulationSupply[i])\r\n                    majorityNay++;   // the voting power is more then 50% of circulation supply\r\n                else if (isClosed \u0026\u0026 votesYea[i] \u003e totalVotes[i] * tokensApply[i] / 100)\r\n                    majorityYea++;   // the voting power is more then require of all participants total votes power\r\n            }\r\n        }\r\n        if (majorityYea == requireMajority) result = Vote.Yea;\r\n        else if (majorityNay == requireMajority) result = Vote.Nay;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate Circulation Supply = Total supply - sum(excluded addresses balance)\r\n     * @param tokensApply if element of array = 0 then exclude that token (index: 0 = MainToken, 1 = ETN, 2 = STOCK)\r\n     */\r\n    function _getCirculation(uint8[4] memory tokensApply) internal {\r\n        uint256[4] memory total;\r\n        for (uint i = 0; i \u003c 4; i++) {\r\n            if (tokensApply[i] != 0 \u0026\u0026 circulationSupplyUpdated[i] != block.timestamp) {\r\n                uint len = excluded[i].length;\r\n                for (uint j = 0; j \u003c len; j++) {\r\n                    total[i] += tokenContract[i].balanceOf(excluded[i][j]);\r\n                    if (escrowContract[i] != IERC20Token(0) \u0026\u0026 isInEscrow[i][excluded[i][j]]) {\r\n                        total[i] += escrowContract[i].balanceOf(excluded[i][j]);\r\n                    }\r\n                }\r\n                uint256 t = IERC20Token(tokenContract[i]).totalSupply();\r\n                require(t \u003e= total[i], \"Total Supply less then accounts balance\");\r\n                circulationSupply[i] = t - total[i];\r\n                circulationSupplyUpdated[i] = block.timestamp;  // timestamp when circulationSupply updates\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate Voting Power of voter in provided communities (tokens)\r\n     * @param voter The wallet address of voter.\r\n     * @param tokensApply if element of array = 0 then exclude that token (index: 0 = MainToken, 1 = ETN, 2 = STOCK)\r\n     * @param isPrimary is true when voter address is primary address. Uses in verify function.\r\n     * @return primary - The primary address the wallet belong.\r\n     * @return votingPower - the voting power according communities.\r\n     */\r\n    function _getVotingPower(address voter, uint8[4] memory tokensApply, bool isPrimary, bool acceptEscrowed) internal view\r\n        returns(address primary, uint256[4] memory votingPower)\r\n    {\r\n        if (isPrimary)\r\n            primary = voter;\r\n        else\r\n            primary = whitelist.address_belongs(voter);\r\n        require (!blockedWallets[primary], \"Wallet is blocked for voting\");\r\n        address[] memory userWallets;\r\n        if (primary != address(0)) {\r\n            userWallets = whitelist.getUserWallets(primary);\r\n        }\r\n        else {\r\n            primary = voter;\r\n            userWallets = new address[](0);\r\n        }\r\n        bool hasPower = false;\r\n    \r\n        for (uint i = 0; i \u003c 4; i++) {\r\n            if (tokensApply[i] != 0) {\r\n                votingPower[i] += tokenContract[i].balanceOf(primary);\r\n                if (acceptEscrowed \u0026\u0026 escrowContract[i] != IERC20Token(0) \u0026\u0026 isInEscrow[i][primary]) {\r\n                    votingPower[i] += escrowContract[i].balanceOf(primary);\r\n                }\r\n                for(uint j = 0; j \u003c userWallets.length; j++) {\r\n                    votingPower[i] += tokenContract[i].balanceOf(userWallets[j]);\r\n                    if (acceptEscrowed \u0026\u0026 escrowContract[i] != IERC20Token(0) \u0026\u0026 isInEscrow[i][userWallets[j]]) {\r\n                        votingPower[i] += escrowContract[i].balanceOf(userWallets[j]);\r\n                    }\r\n                }\r\n                if (votingPower[i] \u003e 0) hasPower = true;\r\n            }\r\n        }\r\n        require(isPrimary || hasPower, \"No voting power\");\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate number of days from 1/1/1970 to selected date.\r\n     * @param year The year number\r\n     * @param month The month number\r\n     * @param day The day number\r\n     * @return _days number of day.\r\n     */\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year \u003e= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - 2440588;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate timestamp (UNIX time) of selected date and time.\r\n     * @param year The year number\r\n     * @param month The month number\r\n     * @param day The day number\r\n     * @param hour number of hours\r\n     * @param minute number of minutes\r\n     * @param second number of seconds\r\n     * @return timestamp UNIX time\r\n     */\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\r\n    }\r\n\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + 2440588;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate date from timestamp (UNIX time) .\r\n     * @param timestamp UNIX time\r\n     * @return year The year number\r\n     * @return month The month number\r\n     * @return day The day number\r\n     */\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / 86400);\r\n    }\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.9;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n *\r\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/ownership/Ownable.sol\r\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\r\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\r\n * build/artifacts folder) as well as the vanilla Ownable implementation from an openzeppelin version.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(),\"Not Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0),\"Zero address not allowed\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}"}}