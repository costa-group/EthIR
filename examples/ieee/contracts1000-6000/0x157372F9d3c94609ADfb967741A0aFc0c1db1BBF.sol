{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "src/BaseWithStorage/ERC20Group.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./ERC20SubToken.sol\";\nimport \"../common/Libraries/SafeMath.sol\";\nimport \"../common/Libraries/AddressUtils.sol\";\nimport \"../common/Libraries/ObjectLib32.sol\";\nimport \"../common/Libraries/BytesUtil.sol\";\n\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\n\ncontract ERC20Group is SuperOperators, MetaTransactionReceiver {\n    uint256 internal constant MAX_UINT256 = ~uint256(0);\n\n    /// @notice emitted when a new Token is added to the group.\n    /// @param subToken the token added, its id will be its index in the array.\n    event SubToken(ERC20SubToken subToken);\n\n    /// @notice emitted when `owner` is allowing or disallowing `operator` to transfer tokens on its behalf.\n    /// @param owner the address approving.\n    /// @param operator the address being granted (or revoked) permission to transfer.\n    /// @param approved whether the operator is granted transfer right or not.\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event Minter(address minter, bool enabled);\n\n    /// @notice Enable or disable the ability of `minter` to mint tokens\n    /// @param minter address that will be given/removed minter right.\n    /// @param enabled set whether the minter is enabled or disabled.\n    function setMinter(address minter, bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setMinter(minter, enabled);\n    }\n\n    /// @notice check whether address `who` is given minter rights.\n    /// @param who The address to query.\n    /// @return whether the address has minter rights.\n    function isMinter(address who) public view returns (bool) {\n        return _minters[who];\n    }\n\n    /// @dev mint more tokens of a specific subToken .\n    /// @param to address receiving the tokens.\n    /// @param id subToken id (also the index at which it was added).\n    /// @param amount of token minted.\n    function mint(\n        address to,\n        uint256 id,\n        uint256 amount\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        toPack[bin] = toPack[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _packedSupplies[bin] = _packedSupplies[bin].updateTokenBalance(index, amount, ObjectLib32.Operations.ADD);\n        _erc20s[id].emitTransferEvent(address(0), to, amount);\n    }\n\n    /// @dev mint more tokens of a several subToken .\n    /// @param to address receiving the tokens.\n    /// @param ids subToken ids (also the index at which it was added).\n    /// @param amounts for each token minted.\n    function batchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(_minters[msg.sender], \"NOT_AUTHORIZED_MINTER\");\n        require(ids.length == amounts.length, \"INVALID_INCONSISTENT_LENGTH\");\n        _batchMint(to, ids, amounts);\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 lastBin = MAX_UINT256;\n        uint256 bal = 0;\n        uint256 supply = 0;\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    bal = toPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        toPack[lastBin] = bal;\n                        bal = toPack[bin];\n                        _packedSupplies[lastBin] = supply;\n                        supply = _packedSupplies[bin];\n                        lastBin = bin;\n                    }\n                    bal = bal.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.ADD);\n                }\n                _erc20s[ids[i]].emitTransferEvent(address(0), to, amounts[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            toPack[lastBin] = bal;\n            _packedSupplies[lastBin] = supply;\n        }\n    }\n\n    /// @notice return the current total supply of a specific subToken.\n    /// @param id subToken id.\n    /// @return supply current total number of tokens.\n    function supplyOf(uint256 id) external view returns (uint256 supply) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedSupplies[bin].getValueInBin(index);\n    }\n\n    /// @notice return the balance of a particular owner for a particular subToken.\n    /// @param owner whose balance it is of.\n    /// @param id subToken id.\n    /// @return balance of the owner\n    function balanceOf(address owner, uint256 id) public view returns (uint256 balance) {\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        return _packedTokenBalance[owner][bin].getValueInBin(index);\n    }\n\n    /// @notice return the balances of a list of owners / subTokens.\n    /// @param owners list of addresses to which we want to know the balance.\n    /// @param ids list of subTokens's addresses.\n    /// @return balances list of balances for each request.\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids) external view returns (uint256[] memory balances) {\n        require(owners.length == ids.length, \"INVALID_INCONSISTENT_LENGTH\");\n        balances = new uint256[](ids.length);\n        for (uint256 i = 0; i < ids.length; i++) {\n            balances[i] = balanceOf(owners[i], ids[i]);\n        }\n    }\n\n    /// @notice transfer a number of subToken from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param id subToken id.\n    /// @param value amount of tokens to transfer.\n    function singleTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        ERC20SubToken erc20 = _erc20s[id];\n        require(\n            from == msg.sender ||\n                msg.sender == address(erc20) ||\n                _metaTransactionContracts[msg.sender] ||\n                _superOperators[msg.sender] ||\n                _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        fromPack[bin] = fromPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.SUB);\n        toPack[bin] = toPack[bin].updateTokenBalance(index, value, ObjectLib32.Operations.ADD);\n        erc20.emitTransferEvent(from, to, value);\n    }\n\n    /// @notice transfer a number of different subTokens from one address to another.\n    /// @param from owner to transfer from.\n    /// @param to destination address that will receive the tokens.\n    /// @param ids list of subToken ids to transfer.\n    /// @param values list of amount for eacg subTokens to transfer.\n    function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) external {\n        require(ids.length == values.length, \"INVALID_INCONSISTENT_LENGTH\");\n        require(to != address(0), \"INVALID_TO_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _batchTransferFrom(from, to, ids, values);\n    }\n\n    function _batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) internal {\n        uint256 lastBin = MAX_UINT256;\n        uint256 balFrom;\n        uint256 balTo;\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        mapping(uint256 => uint256) storage toPack = _packedTokenBalance[to];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (values[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    balFrom = ObjectLib32.updateTokenBalance(fromPack[bin], index, values[i], ObjectLib32.Operations.SUB);\n                    balTo = ObjectLib32.updateTokenBalance(toPack[bin], index, values[i], ObjectLib32.Operations.ADD);\n                } else {\n                    if (bin != lastBin) {\n                        fromPack[lastBin] = balFrom;\n                        toPack[lastBin] = balTo;\n                        balFrom = fromPack[bin];\n                        balTo = toPack[bin];\n                        lastBin = bin;\n                    }\n                    balFrom = balFrom.updateTokenBalance(index, values[i], ObjectLib32.Operations.SUB);\n                    balTo = balTo.updateTokenBalance(index, values[i], ObjectLib32.Operations.ADD);\n                }\n                ERC20SubToken erc20 = _erc20s[ids[i]];\n                erc20.emitTransferEvent(from, to, values[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            fromPack[lastBin] = balFrom;\n            toPack[lastBin] = balTo;\n        }\n    }\n\n    /// @notice grant or revoke the ability for an address to transfer token on behalf of another address.\n    /// @param sender address granting/revoking the approval.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    function setApprovalForAllFor(\n        address sender,\n        address operator,\n        bool approved\n    ) external {\n        require(msg.sender == sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender], \"NOT_AUTHORIZED\");\n        _setApprovalForAll(sender, operator, approved);\n    }\n\n    /// @notice grant or revoke the ability for an address to transfer token on your behalf.\n    /// @param operator address being granted/revoked ability to transfer.\n    /// @param approved whether the operator is revoked or approved.\n    function setApprovalForAll(address operator, bool approved) external {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /// @notice return whether an oeprator has the ability to transfer on behalf of another address.\n    /// @param owner address who would have granted the rights.\n    /// @param operator address being given the ability to transfer.\n    /// @return isOperator whether the operator has approval rigths or not.\n    function isApprovedForAll(address owner, address operator) external view returns (bool isOperator) {\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\n    }\n\n    function isAuthorizedToTransfer(address owner, address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender] || _operatorsForAll[owner][sender];\n    }\n\n    function isAuthorizedToApprove(address sender) external view returns (bool) {\n        return _metaTransactionContracts[sender] || _superOperators[sender];\n    }\n\n    function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata amounts\n    ) external {\n        require(from != address(0), \"INVALID_FROM_ZERO_ADDRESS\");\n        require(\n            from == msg.sender || _metaTransactionContracts[msg.sender] || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        _batchBurnFrom(from, ids, amounts);\n    }\n\n    /// @notice burn token for a specific owner and subToken.\n    /// @param from fron which address the token are burned from.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    function burnFrom(\n        address from,\n        uint256 id,\n        uint256 value\n    ) external {\n        require(\n            from == msg.sender || _superOperators[msg.sender] || _operatorsForAll[from][msg.sender] || _metaTransactionContracts[msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n        _burn(from, id, value);\n    }\n\n    /// @notice burn token for a specific subToken.\n    /// @param id subToken id.\n    /// @param value amount of tokens to burn.\n    function burn(uint256 id, uint256 value) external {\n        _burn(msg.sender, id, value);\n    }\n\n    // ///////////////// INTERNAL //////////////////////////\n\n    function _batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal {\n        uint256 balFrom = 0;\n        uint256 supply = 0;\n        uint256 lastBin = MAX_UINT256;\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (amounts[i] != 0) {\n                (uint256 bin, uint256 index) = ids[i].getTokenBinIndex();\n                if (lastBin == MAX_UINT256) {\n                    lastBin = bin;\n                    balFrom = fromPack[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                    supply = _packedSupplies[bin].updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                } else {\n                    if (bin != lastBin) {\n                        fromPack[lastBin] = balFrom;\n                        balFrom = fromPack[bin];\n                        _packedSupplies[lastBin] = supply;\n                        supply = _packedSupplies[bin];\n                        lastBin = bin;\n                    }\n\n                    balFrom = balFrom.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                    supply = supply.updateTokenBalance(index, amounts[i], ObjectLib32.Operations.SUB);\n                }\n                _erc20s[ids[i]].emitTransferEvent(from, address(0), amounts[i]);\n            }\n        }\n        if (lastBin != MAX_UINT256) {\n            fromPack[lastBin] = balFrom;\n            _packedSupplies[lastBin] = supply;\n        }\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 value\n    ) internal {\n        ERC20SubToken erc20 = _erc20s[id];\n        (uint256 bin, uint256 index) = id.getTokenBinIndex();\n        mapping(uint256 => uint256) storage fromPack = _packedTokenBalance[from];\n        fromPack[bin] = ObjectLib32.updateTokenBalance(fromPack[bin], index, value, ObjectLib32.Operations.SUB);\n        _packedSupplies[bin] = ObjectLib32.updateTokenBalance(_packedSupplies[bin], index, value, ObjectLib32.Operations.SUB);\n        erc20.emitTransferEvent(from, address(0), value);\n    }\n\n    function _addSubToken(ERC20SubToken subToken) internal returns (uint256 id) {\n        id = _erc20s.length;\n        require(subToken.groupAddress() == address(this), \"INVALID_GROUP\");\n        require(subToken.groupTokenId() == id, \"INVALID_ID\");\n        _erc20s.push(subToken);\n        emit SubToken(subToken);\n    }\n\n    function _setApprovalForAll(\n        address sender,\n        address operator,\n        bool approved\n    ) internal {\n        require(!_superOperators[operator], \"INVALID_SUPER_OPERATOR\");\n        _operatorsForAll[sender][operator] = approved;\n        emit ApprovalForAll(sender, operator, approved);\n    }\n\n    function _setMinter(address minter, bool enabled) internal {\n        _minters[minter] = enabled;\n        emit Minter(minter, enabled);\n    }\n\n    // ///////////////// UTILITIES /////////////////////////\n    using AddressUtils for address;\n    using ObjectLib32 for ObjectLib32.Operations;\n    using ObjectLib32 for uint256;\n    using SafeMath for uint256;\n\n    // ////////////////// DATA ///////////////////////////////\n    mapping(uint256 => uint256) internal _packedSupplies;\n    mapping(address => mapping(uint256 => uint256)) internal _packedTokenBalance;\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\n    ERC20SubToken[] internal _erc20s;\n    mapping(address => bool) internal _minters;\n\n    // ////////////// CONSTRUCTOR ////////////////////////////\n\n    struct SubTokenData {\n        string name;\n        string symbol;\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) internal {\n        _admin = admin;\n        _setMetaTransactionProcessor(metaTransactionContract, true);\n        _setMinter(initialMinter, true);\n    }\n}\n",
      "keccak256": "0x3d7f5e87a6b374bf194ffcfcb5ea4fabc93ab3acf15177c9a787fba274c5870f"
    },
    "src/BaseWithStorage/ERC20SubToken.sol": {
      "content": "pragma solidity 0.6.5;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/BaseWithStorage/SuperOperators.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\n\nimport \"./ERC20Group.sol\";\n\n\ncontract ERC20SubToken {\n    // TODO add natspec, currently blocked by solidity compiler issue\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // TODO add natspec, currently blocked by solidity compiler issue\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice A descriptive name for the tokens\n    /// @return name of the tokens\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /// @notice An abbreviated name for the tokens\n    /// @return symbol of the tokens\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice the tokenId in ERC20Group\n    /// @return the tokenId in ERC20Group\n    function groupTokenId() external view returns (uint256) {\n        return _index;\n    }\n\n    /// @notice the ERC20Group address\n    /// @return the address of the group\n    function groupAddress() external view returns (address) {\n        return address(_group);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _group.supplyOf(_index);\n    }\n\n    function balanceOf(address who) external view returns (uint256) {\n        return _group.balanceOf(who, _index);\n    }\n\n    function decimals() external pure returns (uint8) {\n        return uint8(0);\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool success) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool success) {\n        if (msg.sender != from && !_group.isAuthorizedToTransfer(from, msg.sender)) {\n            uint256 allowance = _mAllowed[from][msg.sender];\n            if (allowance != ~uint256(0)) {\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\n                require(allowance >= amount, \"NOT_AUTHOIZED_ALLOWANCE\");\n                _mAllowed[from][msg.sender] = allowance - amount;\n            }\n        }\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool success) {\n        _approveFor(msg.sender, spender, amount);\n        return true;\n    }\n\n    function approveFor(\n        address from,\n        address spender,\n        uint256 amount\n    ) external returns (bool success) {\n        require(msg.sender == from || _group.isAuthorizedToApprove(msg.sender), \"NOT_AUTHORIZED\");\n        _approveFor(from, spender, amount);\n        return true;\n    }\n\n    function emitTransferEvent(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        require(msg.sender == address(_group), \"NOT_AUTHORIZED_GROUP_ONLY\");\n        emit Transfer(from, to, amount);\n    }\n\n    // /////////////////// INTERNAL ////////////////////////\n\n    function _approveFor(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0) && spender != address(0), \"INVALID_FROM_OR_SPENDER\");\n        _mAllowed[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256 remaining) {\n        return _mAllowed[owner][spender];\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        _group.singleTransferFrom(from, to, _index, amount);\n    }\n\n    // ///////////////////// UTILITIES ///////////////////////\n    using SafeMathWithRequire for uint256;\n\n    // //////////////////// CONSTRUCTOR /////////////////////\n    constructor(\n        ERC20Group group,\n        uint256 index,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        _group = group;\n        _index = index;\n        _name = tokenName;\n        _symbol = tokenSymbol;\n    }\n\n    // ////////////////////// DATA ///////////////////////////\n    ERC20Group internal immutable _group;\n    uint256 internal immutable _index;\n    mapping(address => mapping(address => uint256)) internal _mAllowed;\n    string internal _name;\n    string internal _symbol;\n}\n",
      "keccak256": "0x41d76191a6491e9ec7ed2a77fcf8ff13ce6751d682cfa9822eb0dac09a25d87b"
    },
    "src/Catalyst/CatalystDataBase.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"./CatalystValue.sol\";\n\n\ncontract CatalystDataBase is CatalystValue {\n    event CatalystConfiguration(uint256 indexed id, uint16 minQuantity, uint16 maxQuantity, uint256 sandMintingFee, uint256 sandUpdateFee);\n\n    function _setMintData(uint256 id, MintData memory data) internal {\n        _data[id] = data;\n        _emitConfiguration(id, data.minQuantity, data.maxQuantity, data.sandMintingFee, data.sandUpdateFee);\n    }\n\n    function _setValueOverride(uint256 id, CatalystValue valueOverride) internal {\n        _valueOverrides[id] = valueOverride;\n    }\n\n    function _setConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) internal {\n        _data[id].minQuantity = minQuantity;\n        _data[id].maxQuantity = maxQuantity;\n        _data[id].sandMintingFee = uint88(sandMintingFee);\n        _data[id].sandUpdateFee = uint88(sandUpdateFee);\n        _emitConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }\n\n    function _emitConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) internal {\n        emit CatalystConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }\n\n    ///@dev compute a random value between min to 25.\n    //. example: 1-25, 6-25, 11-25, 16-25\n    function _computeValue(\n        uint256 seed,\n        uint256 gemId,\n        bytes32 blockHash,\n        uint256 slotIndex,\n        uint32 min\n    ) internal pure returns (uint32) {\n        return min + uint16(uint256(keccak256(abi.encodePacked(gemId, seed, blockHash, slotIndex))) % (26 - min));\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external override view returns (uint32[] memory values) {\n        CatalystValue valueOverride = _valueOverrides[catalystId];\n        if (address(valueOverride) != address(0)) {\n            return valueOverride.getValues(catalystId, seed, events, totalNumberOfGemTypes);\n        }\n        values = new uint32[](totalNumberOfGemTypes);\n\n        uint32 numGems;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGems += uint32(events[i].gemIds.length);\n        }\n        require(numGems <= MAX_UINT32, \"TOO_MANY_GEMS\");\n        uint32 minValue = (numGems - 1) * 5 + 1;\n\n        uint256 numGemsSoFar = 0;\n        for (uint256 i = 0; i < events.length; i++) {\n            numGemsSoFar += events[i].gemIds.length;\n            for (uint256 j = 0; j < events[i].gemIds.length; j++) {\n                uint256 gemId = events[i].gemIds[j];\n                uint256 slotIndex = numGemsSoFar - events[i].gemIds.length + j;\n                if (values[gemId] == 0) {\n                    // first gem : value = roll between ((numGemsSoFar-1)*5+1) and 25\n                    values[gemId] = _computeValue(seed, gemId, events[i].blockHash, slotIndex, (uint32(numGemsSoFar) - 1) * 5 + 1);\n                    // bump previous values:\n                    if (values[gemId] < minValue) {\n                        values[gemId] = minValue;\n                    }\n                } else {\n                    // further gem, previous roll are overriden with 25 and new roll between 1 and 25\n                    uint32 newRoll = _computeValue(seed, gemId, events[i].blockHash, slotIndex, 1);\n                    values[gemId] = (((values[gemId] - 1) / 25) + 1) * 25 + newRoll;\n                }\n            }\n        }\n    }\n\n    function getMintData(uint256 catalystId)\n        external\n        view\n        returns (\n            uint16 maxGems,\n            uint16 minQuantity,\n            uint16 maxQuantity,\n            uint256 sandMintingFee,\n            uint256 sandUpdateFee\n        )\n    {\n        maxGems = _data[catalystId].maxGems;\n        minQuantity = _data[catalystId].minQuantity;\n        maxQuantity = _data[catalystId].maxQuantity;\n        sandMintingFee = _data[catalystId].sandMintingFee;\n        sandUpdateFee = _data[catalystId].sandUpdateFee;\n    }\n\n    struct MintData {\n        uint88 sandMintingFee;\n        uint88 sandUpdateFee;\n        uint16 minQuantity;\n        uint16 maxQuantity;\n        uint16 maxGems;\n    }\n\n    uint32 internal constant MAX_UINT32 = 2**32 - 1;\n\n    mapping(uint256 => MintData) internal _data;\n    mapping(uint256 => CatalystValue) internal _valueOverrides;\n}\n",
      "keccak256": "0x8938c512354cde621487bc8ecc9753f76a5223edd4743357b03acd0412201230"
    },
    "src/Catalyst/CatalystValue.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\n\ninterface CatalystValue {\n    struct GemEvent {\n        uint256[] gemIds;\n        bytes32 blockHash;\n    }\n\n    function getValues(\n        uint256 catalystId,\n        uint256 seed,\n        GemEvent[] calldata events,\n        uint32 totalNumberOfGemTypes\n    ) external view returns (uint32[] memory values);\n}\n",
      "keccak256": "0x3983ba567af891e8d4c6a983bd0857d930754fd36d72b330925a3df33289ae0f"
    },
    "src/Catalyst/ERC20GroupCatalyst.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseWithStorage/ERC20Group.sol\";\nimport \"./CatalystDataBase.sol\";\nimport \"../BaseWithStorage/ERC20SubToken.sol\";\nimport \"./CatalystValue.sol\";\n\n\ncontract ERC20GroupCatalyst is CatalystDataBase, ERC20Group {\n    /// @dev add Catalyst, if one of the catalyst to be added in the batch need to have a value override, all catalyst added in that batch need to have override\n    /// if this is not desired, they can be added in a separated batch\n    /// if no override are needed, the valueOverrides can be left emopty\n    function addCatalysts(\n        ERC20SubToken[] memory catalysts,\n        MintData[] memory mintData,\n        CatalystValue[] memory valueOverrides\n    ) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        require(catalysts.length == mintData.length, \"INVALID_INCONSISTENT_LENGTH\");\n        for (uint256 i = 0; i < mintData.length; i++) {\n            uint256 id = _addSubToken(catalysts[i]);\n            _setMintData(id, mintData[i]);\n            if (valueOverrides.length > i) {\n                _setValueOverride(id, valueOverrides[i]);\n            }\n        }\n    }\n\n    function addCatalyst(\n        ERC20SubToken catalyst,\n        MintData memory mintData,\n        CatalystValue valueOverride\n    ) public {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        uint256 id = _addSubToken(catalyst);\n        _setMintData(id, mintData);\n        _setValueOverride(id, valueOverride);\n    }\n\n    function setConfiguration(\n        uint256 id,\n        uint16 minQuantity,\n        uint16 maxQuantity,\n        uint256 sandMintingFee,\n        uint256 sandUpdateFee\n    ) external {\n        // CatalystMinter hardcode the value for efficiency purpose, so a change here would require a new deployment of CatalystMinter\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        _setConfiguration(id, minQuantity, maxQuantity, sandMintingFee, sandUpdateFee);\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) public ERC20Group(metaTransactionContract, admin, initialMinter) {}\n}\n",
      "keccak256": "0x29aa3b239950a27dff1a9f0298af006e1d104f092c6295b6255177286294d023"
    },
    "src/Catalyst/ERC20GroupGem.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../BaseWithStorage/ERC20Group.sol\";\n\n\ncontract ERC20GroupGem is ERC20Group {\n    function addGems(ERC20SubToken[] calldata catalysts) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED_ADMIN\");\n        for (uint256 i = 0; i < catalysts.length; i++) {\n            _addSubToken(catalysts[i]);\n        }\n    }\n\n    constructor(\n        address metaTransactionContract,\n        address admin,\n        address initialMinter\n    ) public ERC20Group(metaTransactionContract, admin, initialMinter) {}\n}\n",
      "keccak256": "0xe79b10720d9371b4da49155e99788f46bf5407b14879bca13b69655952da9f92"
    },
    "src/StarterPack/PurchaseValidator.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../common/Libraries/SigUtil.sol\";\nimport \"../common/BaseWithStorage/Admin.sol\";\n\n\ncontract PurchaseValidator is Admin {\n    address private _signingWallet;\n\n    // A parallel-queue mapping to nonces.\n    mapping(address => mapping(uint128 => uint128)) public queuedNonces;\n\n    /// @notice Function to get the nonce for a given address and queue ID\n    /// @param _buyer The address of the starterPack purchaser\n    /// @param _queueId The ID of the nonce queue for the given address.\n    /// The default is queueID=0, and the max is queueID=2**128-1\n    /// @return uint128 representing the requestied nonce\n    function getNonceByBuyer(address _buyer, uint128 _queueId) external view returns (uint128) {\n        return queuedNonces[_buyer][_queueId];\n    }\n\n    /// @notice Check if a purchase message is valid\n    /// @param buyer The address paying for the purchase & receiving tokens\n    /// @param catalystIds The catalyst IDs to be purchased\n    /// @param catalystQuantities The quantities of the catalysts to be purchased\n    /// @param gemIds The gem IDs to be purchased\n    /// @param gemQuantities The quantities of the gems to be purchased\n    /// @param nonce The current nonce for the user. This is represented as a\n    /// uint256 value, but is actually 2 packed uint128's (queueId + nonce)\n    /// @param signature A signed message specifying tx details\n    /// @return True if the purchase is valid\n    function isPurchaseValid(\n        address buyer,\n        uint256[] memory catalystIds,\n        uint256[] memory catalystQuantities,\n        uint256[] memory gemIds,\n        uint256[] memory gemQuantities,\n        uint256 nonce,\n        bytes memory signature\n    ) public returns (bool) {\n        require(_checkAndUpdateNonce(buyer, nonce), \"INVALID_NONCE\");\n        bytes32 hashedData = keccak256(abi.encodePacked(catalystIds, catalystQuantities, gemIds, gemQuantities, buyer, nonce));\n\n        address signer = SigUtil.recover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashedData)), signature);\n        return signer == _signingWallet;\n    }\n\n    /// @notice Get the wallet authorized for signing purchase-messages.\n    /// @return the address of the signing wallet\n    function getSigningWallet() external view returns (address) {\n        return _signingWallet;\n    }\n\n    /// @notice Update the signing wallet address\n    /// @param newSigningWallet The new address of the signing wallet\n    function updateSigningWallet(address newSigningWallet) external {\n        require(_admin == msg.sender, \"SENDER_NOT_ADMIN\");\n        _signingWallet = newSigningWallet;\n    }\n\n    /// @dev Function for validating the nonce for a user.\n    /// @param _buyer The address for which we want to check the nonce\n    /// @param _packedValue The queueId + nonce, packed together.\n    /// EG: for queueId=42 nonce=7, pass: \"0x0000000000000000000000000000002A00000000000000000000000000000007\"\n    function _checkAndUpdateNonce(address _buyer, uint256 _packedValue) private returns (bool) {\n        uint128 queueId = uint128(_packedValue / 2**128);\n        uint128 nonce = uint128(_packedValue % 2**128);\n        uint128 currentNonce = queuedNonces[_buyer][queueId];\n        if (nonce == currentNonce) {\n            queuedNonces[_buyer][queueId] = currentNonce + 1;\n            return true;\n        }\n        return false;\n    }\n\n    constructor(address initialSigningWallet) public {\n        _signingWallet = initialSigningWallet;\n    }\n}\n",
      "keccak256": "0x9a9d210a90a0066ab6cf46773931721f9f1b3a25647e13b3361d5487b1b082ba"
    },
    "src/StarterPack/StarterPackV1.sol": {
      "content": "pragma solidity 0.6.5;\npragma experimental ABIEncoderV2;\n\nimport \"../common/Libraries/SafeMathWithRequire.sol\";\nimport \"../common/Interfaces/ERC20.sol\";\nimport \"../common/BaseWithStorage/MetaTransactionReceiver.sol\";\nimport \"../common/Interfaces/Medianizer.sol\";\nimport \"../common/BaseWithStorage/Admin.sol\";\nimport \"../Catalyst/ERC20GroupCatalyst.sol\";\nimport \"../Catalyst/ERC20GroupGem.sol\";\nimport \"./PurchaseValidator.sol\";\n\n\n/// @title StarterPack contract that supports SAND, DAI and ETH as payment\n/// @notice This contract manages the purchase and distribution of StarterPacks (bundles of Catalysts and Gems)\ncontract StarterPackV1 is Admin, MetaTransactionReceiver, PurchaseValidator {\n    using SafeMathWithRequire for uint256;\n    uint256 internal constant DAI_PRICE = 55000000000000000;\n\n    ERC20 internal immutable _sand;\n    Medianizer private immutable _medianizer;\n    ERC20 private immutable _dai;\n    ERC20Group internal immutable _erc20GroupCatalyst;\n    ERC20Group internal immutable _erc20GroupGem;\n\n    bool _sandEnabled;\n    bool _etherEnabled;\n    bool _daiEnabled;\n\n    uint256[] private _starterPackPrices;\n    uint256[] private _previousStarterPackPrices;\n    uint256 private _gemPrice;\n    uint256 private _previousGemPrice;\n\n    // The timestamp of the last pricechange\n    uint256 private _priceChangeTimestamp;\n\n    address payable internal _wallet;\n\n    // The delay between calling setPrices() and when the new prices come into effect.\n    // Minimizes the effect of price changes on pending TXs\n    uint256 private _priceChangeDelay = 1 hours;\n\n    event Purchase(address indexed buyer, Message message, uint256 price, address token, uint256 amountPaid);\n\n    event SetPrices(uint256[] prices, uint256 gemPrice);\n\n    struct Message {\n        uint256[] catalystIds;\n        uint256[] catalystQuantities;\n        uint256[] gemIds;\n        uint256[] gemQuantities;\n        uint256 nonce;\n    }\n\n    // ////////////////////////// Functions ////////////////////////\n\n    /// @notice Set the wallet receiving the proceeds\n    /// @param newWallet Address of the new receiving wallet\n    function setReceivingWallet(address payable newWallet) external {\n        require(newWallet != address(0), \"WALLET_ZERO_ADDRESS\");\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _wallet = newWallet;\n    }\n\n    /// @notice Enable / disable DAI payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    function setDAIEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _daiEnabled = enabled;\n    }\n\n    /// @notice Return whether DAI payments are enabled\n    /// @return Whether DAI payments are enabled\n    function isDAIEnabled() external view returns (bool) {\n        return _daiEnabled;\n    }\n\n    /// @notice Enable / disable ETH payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    function setETHEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _etherEnabled = enabled;\n    }\n\n    /// @notice Return whether ETH payments are enabled\n    /// @return Whether ETH payments are enabled\n    function isETHEnabled() external view returns (bool) {\n        return _etherEnabled;\n    }\n\n    /// @dev Enable / disable the specific SAND payment for StarterPacks\n    /// @param enabled Whether to enable or disable\n    function setSANDEnabled(bool enabled) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _sandEnabled = enabled;\n    }\n\n    /// @notice Return whether SAND payments are enabled\n    /// @return Whether SAND payments are enabled\n    function isSANDEnabled() external view returns (bool) {\n        return _sandEnabled;\n    }\n\n    /// @notice Purchase StarterPacks with SAND\n    /// @param buyer The destination address for the purchased Catalysts and Gems and the address that will pay for the purchase; if not metaTx then buyer must be equal to msg.sender\n    /// @param message A message containing information about the Catalysts and Gems to be purchased\n    /// @param signature A signed message specifying tx details\n\n    function purchaseWithSand(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_sandEnabled, \"SAND_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        _handlePurchaseWithERC20(buyer, _wallet, address(_sand), amountInSand);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(_sand), amountInSand);\n    }\n\n    /// @notice Purchase StarterPacks with Ether\n    /// @param buyer The destination address for the purchased Catalysts and Gems and the address that will pay for the purchase; if not metaTx then buyer must be equal to msg.sender\n    /// @param message A message containing information about the Catalysts and Gems to be purchased\n    /// @param signature A signed message specifying tx details\n    function purchaseWithETH(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external payable {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_etherEnabled, \"ETHER_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(buyer != address(this), \"DESTINATION_STARTERPACKV1_CONTRACT\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        uint256 ETHRequired = getEtherAmountWithSAND(amountInSand);\n        require(msg.value >= ETHRequired, \"NOT_ENOUGH_ETHER_SENT\");\n\n        _wallet.transfer(ETHRequired);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(0), ETHRequired);\n\n        if (msg.value - ETHRequired > 0) {\n            msg.sender.transfer(msg.value - ETHRequired); // refund extra\n        }\n    }\n\n    /// @notice Purchase StarterPacks with DAI\n    /// @param buyer The destination address for the purchased Catalysts and Gems and the address that will pay for the purchase; if not metaTx then buyer must be equal to msg.sender\n    /// @param message A message containing information about the Catalysts and Gems to be purchased\n    /// @param signature A signed message specifying tx details\n    function purchaseWithDAI(\n        address buyer,\n        Message calldata message,\n        bytes calldata signature\n    ) external {\n        require(msg.sender == buyer || _metaTransactionContracts[msg.sender], \"INVALID_SENDER\");\n        require(_daiEnabled, \"DAI_IS_NOT_ENABLED\");\n        require(buyer != address(0), \"DESTINATION_ZERO_ADDRESS\");\n        require(buyer != address(this), \"DESTINATION_STARTERPACKV1_CONTRACT\");\n        require(\n            isPurchaseValid(buyer, message.catalystIds, message.catalystQuantities, message.gemIds, message.gemQuantities, message.nonce, signature),\n            \"INVALID_PURCHASE\"\n        );\n\n        uint256 amountInSand = _calculateTotalPriceInSand(message.catalystIds, message.catalystQuantities, message.gemQuantities);\n        uint256 DAIRequired = amountInSand.mul(DAI_PRICE).div(1000000000000000000);\n        _handlePurchaseWithERC20(buyer, _wallet, address(_dai), DAIRequired);\n        _erc20GroupCatalyst.batchTransferFrom(address(this), buyer, message.catalystIds, message.catalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), buyer, message.gemIds, message.gemQuantities);\n        emit Purchase(buyer, message, amountInSand, address(_dai), DAIRequired);\n    }\n\n    /// @notice Enables admin to withdraw all remaining tokens\n    /// @param to The destination address for the purchased Catalysts and Gems\n    /// @param catalystIds The IDs of the catalysts to be transferred\n    /// @param gemIds The IDs of the gems to be transferred\n    function withdrawAll(\n        address to,\n        uint256[] calldata catalystIds,\n        uint256[] calldata gemIds\n    ) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n\n        address[] memory catalystAddresses = new address[](catalystIds.length);\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            catalystAddresses[i] = address(this);\n        }\n        address[] memory gemAddresses = new address[](gemIds.length);\n        for (uint256 i = 0; i < gemIds.length; i++) {\n            gemAddresses[i] = address(this);\n        }\n        uint256[] memory unsoldCatalystQuantities = _erc20GroupCatalyst.balanceOfBatch(catalystAddresses, catalystIds);\n        uint256[] memory unsoldGemQuantities = _erc20GroupGem.balanceOfBatch(gemAddresses, gemIds);\n\n        _erc20GroupCatalyst.batchTransferFrom(address(this), to, catalystIds, unsoldCatalystQuantities);\n        _erc20GroupGem.batchTransferFrom(address(this), to, gemIds, unsoldGemQuantities);\n    }\n\n    /// @notice Enables admin to change the prices of the StarterPack bundles\n    /// @param prices Array of new prices that will take effect after a delay period\n    /// @param gemPrice New price for gems that will take effect after a delay period\n\n    function setPrices(uint256[] calldata prices, uint256 gemPrice) external {\n        require(msg.sender == _admin, \"NOT_AUTHORIZED\");\n        _previousStarterPackPrices = _starterPackPrices;\n        _starterPackPrices = prices;\n        _previousGemPrice = _gemPrice;\n        _gemPrice = gemPrice;\n        _priceChangeTimestamp = now;\n        emit SetPrices(prices, gemPrice);\n    }\n\n    /// @notice Get current StarterPack prices\n    /// @return pricesBeforeSwitch Array of prices before price change\n    /// @return pricesAfterSwitch Array of prices after price change\n    /// @return gemPriceBeforeSwitch Gem price before price change\n    /// @return gemPriceAfterSwitch Gem price after price change\n    /// @return switchTime The time the latest price change will take effect, being the time of the price change plus the price change delay\n\n    function getPrices()\n        external\n        view\n        returns (\n            uint256[] memory pricesBeforeSwitch,\n            uint256[] memory pricesAfterSwitch,\n            uint256 gemPriceBeforeSwitch,\n            uint256 gemPriceAfterSwitch,\n            uint256 switchTime\n        )\n    {\n        switchTime = 0;\n        if (_priceChangeTimestamp != 0) {\n            switchTime = _priceChangeTimestamp + _priceChangeDelay;\n        }\n        return (_previousStarterPackPrices, _starterPackPrices, _previousGemPrice, _gemPrice, switchTime);\n    }\n\n    /// @notice Returns the amount of ETH for a specific amount of SAND\n    /// @param sandAmount An amount of SAND\n    /// @return The amount of ETH\n    function getEtherAmountWithSAND(uint256 sandAmount) public view returns (uint256) {\n        uint256 ethUsdPair = _getEthUsdPair();\n        return sandAmount.mul(DAI_PRICE).div(ethUsdPair);\n    }\n\n    // ////////////////////////// Internal ////////////////////////\n\n    /// @dev Gets the ETHUSD pair from the Medianizer contract\n    /// @return The pair as an uint256\n    function _getEthUsdPair() internal view returns (uint256) {\n        bytes32 pair = _medianizer.read();\n        return uint256(pair);\n    }\n\n    /// @dev Function to calculate the total price in SAND of the StarterPacks to be purchased\n    /// @dev The price of each StarterPack relates to the catalystId\n    /// @param catalystIds Array of catalystIds to be purchase\n    /// @param catalystQuantities Array of quantities of those catalystIds to be purchased\n    /// @return Total price in SAND\n\n    function _calculateTotalPriceInSand(\n        uint256[] memory catalystIds,\n        uint256[] memory catalystQuantities,\n        uint256[] memory gemQuantities\n    ) internal returns (uint256) {\n        (uint256[] memory prices, uint256 gemPrice) = _priceSelector();\n        uint256 totalPrice;\n        for (uint256 i = 0; i < catalystIds.length; i++) {\n            uint256 id = catalystIds[i];\n            uint256 quantity = catalystQuantities[i];\n            totalPrice += prices[id].mul(quantity);\n        }\n        for (uint256 i = 0; i < gemQuantities.length; i++) {\n            uint256 quantity = gemQuantities[i];\n            totalPrice += gemPrice.mul(quantity);\n        }\n        return totalPrice;\n    }\n\n    /// @dev Function to determine whether to use old or new prices\n    /// @return Array of prices\n\n    function _priceSelector() internal returns (uint256[] memory, uint256) {\n        uint256[] memory prices;\n        uint256 gemPrice;\n        // No price change:\n        if (_priceChangeTimestamp == 0) {\n            prices = _starterPackPrices;\n            gemPrice = _gemPrice;\n        } else {\n            // Price change delay has expired.\n            if (now > _priceChangeTimestamp + 1 hours) {\n                _priceChangeTimestamp = 0;\n                prices = _starterPackPrices;\n                gemPrice = _gemPrice;\n            } else {\n                // Price change has occured:\n                prices = _previousStarterPackPrices;\n                gemPrice = _previousGemPrice;\n            }\n        }\n        return (prices, gemPrice);\n    }\n\n    /// @dev Function to handle purchase with SAND or DAI\n    function _handlePurchaseWithERC20(\n        address buyer,\n        address payable paymentRecipient,\n        address tokenAddress,\n        uint256 amount\n    ) internal {\n        ERC20 token = ERC20(tokenAddress);\n        uint256 amountForDestination = amount;\n        require(token.transferFrom(buyer, paymentRecipient, amountForDestination), \"PAYMENT_TRANSFER_FAILED\");\n    }\n\n    // /////////////////// CONSTRUCTOR ////////////////////\n\n    constructor(\n        address starterPackAdmin,\n        address sandContractAddress,\n        address initialMetaTx,\n        address payable initialWalletAddress,\n        address medianizerContractAddress,\n        address daiTokenContractAddress,\n        address erc20GroupCatalystAddress,\n        address erc20GroupGemAddress,\n        address initialSigningWallet,\n        uint256[] memory initialStarterPackPrices,\n        uint256 initialGemPrice\n    ) public PurchaseValidator(initialSigningWallet) {\n        _setMetaTransactionProcessor(initialMetaTx, true);\n        _wallet = initialWalletAddress;\n        _admin = starterPackAdmin;\n        _sand = ERC20(sandContractAddress);\n        _medianizer = Medianizer(medianizerContractAddress);\n        _dai = ERC20(daiTokenContractAddress);\n        _erc20GroupCatalyst = ERC20Group(erc20GroupCatalystAddress);\n        _erc20GroupGem = ERC20Group(erc20GroupGemAddress);\n        _starterPackPrices = initialStarterPackPrices;\n        _previousStarterPackPrices = initialStarterPackPrices;\n        _gemPrice = initialGemPrice;\n        _previousGemPrice = initialGemPrice;\n        _sandEnabled = true; // Sand is enabled by default\n        _etherEnabled = true; // Ether is enabled by default\n    }\n}\n",
      "keccak256": "0x928121fda145eced1980e810efa1f84b266c9902f0161273b40043f344de899d"
    },
    "src/common/BaseWithStorage/Admin.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract Admin {\n    address internal _admin;\n\n    /// @dev emitted when the contract administrator is changed.\n    /// @param oldAdmin address of the previous administrator.\n    /// @param newAdmin address of the new administrator.\n    event AdminChanged(address oldAdmin, address newAdmin);\n\n    /// @dev gives the current administrator of this contract.\n    /// @return the current administrator of this contract.\n    function getAdmin() external view returns (address) {\n        return _admin;\n    }\n\n    /// @dev change the administrator to be `newAdmin`.\n    /// @param newAdmin address of the new administrator.\n    function changeAdmin(address newAdmin) external {\n        require(msg.sender == _admin, \"only admin can change admin\");\n        emit AdminChanged(_admin, newAdmin);\n        _admin = newAdmin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == _admin, \"only admin allowed\");\n        _;\n    }\n}\n",
      "keccak256": "0xe5606264fdcdb48191f172743be4fac889f183ce97e907dba4cc5b3fe41b7f9a"
    },
    "src/common/BaseWithStorage/MetaTransactionReceiver.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./Admin.sol\";\n\n\ncontract MetaTransactionReceiver is Admin {\n    mapping(address => bool) internal _metaTransactionContracts;\n\n    /// @dev emiited when a meta transaction processor is enabled/disabled\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\n\n    /// @dev Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\n        require(msg.sender == _admin, \"only admin can setup metaTransactionProcessors\");\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\n    }\n\n    /// @dev check whether address `who` is given meta-transaction execution rights.\n    /// @param who The address to query.\n    /// @return whether the address has meta-transaction execution rights.\n    function isMetaTransactionProcessor(address who) external view returns (bool) {\n        return _metaTransactionContracts[who];\n    }\n}\n",
      "keccak256": "0x3103cbc4f6bf91e2866014622a693c9562f8341b22f1bd2891210b4d4cec468f"
    },
    "src/common/BaseWithStorage/SuperOperators.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./Admin.sol\";\n\n\ncontract SuperOperators is Admin {\n    mapping(address => bool) internal _superOperators;\n\n    event SuperOperator(address superOperator, bool enabled);\n\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\n    /// @param superOperator address that will be given/removed superOperator right.\n    /// @param enabled set whether the superOperator is enabled or disabled.\n    function setSuperOperator(address superOperator, bool enabled) external {\n        require(msg.sender == _admin, \"only admin is allowed to add super operators\");\n        _superOperators[superOperator] = enabled;\n        emit SuperOperator(superOperator, enabled);\n    }\n\n    /// @notice check whether address `who` is given superOperator rights.\n    /// @param who The address to query.\n    /// @return whether the address has superOperator rights.\n    function isSuperOperator(address who) public view returns (bool) {\n        return _superOperators[who];\n    }\n}\n",
      "keccak256": "0x226c0f78303ffa5d40f3517fbaff34775519e499ab1365bfc4997a86707ff2af"
    },
    "src/common/Interfaces/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/// @dev see https://eips.ethereum.org/EIPS/eip-20\ninterface ERC20 {\n    /// @notice emitted when tokens are transfered from one address to another.\n    /// @param from address from which the token are transfered from (zero means tokens are minted).\n    /// @param to destination address which the token are transfered to (zero means tokens are burnt).\n    /// @param value amount of tokens transferred.\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice emitted when owner grant transfer rights to another address\n    /// @param owner address allowing its token to be transferred.\n    /// @param spender address allowed to spend on behalf of `owner`\n    /// @param value amount of tokens allowed.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice return the current total amount of tokens owned by all holders.\n    /// @return supply total number of tokens held.\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @notice return the number of tokens held by a particular address.\n    /// @param who address being queried.\n    /// @return balance number of token held by that address.\n    function balanceOf(address who) external view returns (uint256 balance);\n\n    /// @notice transfer tokens to a specific address.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transfer(address to, uint256 value) external returns (bool success);\n\n    /// @notice transfer tokens from one address to another.\n    /// @param from address tokens will be sent from.\n    /// @param to destination address receiving the tokens.\n    /// @param value number of tokens to transfer.\n    /// @return success whether the transfer succeeded.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    /// @notice approve an address to spend on your behalf.\n    /// @param spender address entitled to transfer on your behalf.\n    /// @param value amount allowed to be transfered.\n    /// @param success whether the approval succeeded.\n    function approve(address spender, uint256 value) external returns (bool success);\n\n    /// @notice return the current allowance for a particular owner/spender pair.\n    /// @param owner address allowing spender.\n    /// @param spender address allowed to spend.\n    /// @return amount number of tokens `spender` can spend on behalf of `owner`.\n    function allowance(address owner, address spender) external view returns (uint256 amount);\n}\n",
      "keccak256": "0x263a2705ead1d04cec64624ff8a8aa7cc108fb97e3a48516de33dbe290a7122e"
    },
    "src/common/Interfaces/Medianizer.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @title Medianizer contract\n * @dev From MakerDAO (https://etherscan.io/address/0x729D19f657BD0614b4985Cf1D82531c67569197B#code)\n */\ninterface Medianizer {\n    function read() external view returns (bytes32);\n}\n",
      "keccak256": "0xa261ed3d7b7fd22d176bb93dff2dfd786c1898354ef29c289c92cbff5596053e"
    },
    "src/common/Libraries/AddressUtils.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nlibrary AddressUtils {\n    function toPayable(address _address) internal pure returns (address payable _payable) {\n        return address(uint160(_address));\n    }\n\n    function isContract(address addr) internal view returns (bool) {\n        // for accounts without code, i.e. `keccak256('')`:\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        bytes32 codehash;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return (codehash != 0x0 && codehash != accountHash);\n    }\n}\n",
      "keccak256": "0x52ed5ebe95a057d4f41b5f44711588816059c18c7f7e48aa0b6f4078812e80de"
    },
    "src/common/Libraries/BytesUtil.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nlibrary BytesUtil {\n    function memcpy(\n        uint256 dest,\n        uint256 src,\n        uint256 len\n    ) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    function pointerToBytes(uint256 src, uint256 len) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(len);\n        uint256 retptr;\n        assembly {\n            retptr := add(ret, 32)\n        }\n\n        memcpy(retptr, src, len);\n        return ret;\n    }\n\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\n            mstore(0x40, add(m, 52))\n            b := m\n        }\n    }\n\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 32), a)\n            mstore(0x40, add(m, 64))\n            b := m\n        }\n    }\n\n    function doFirstParamEqualsAddress(bytes memory data, address _address) internal pure returns (bool) {\n        if (data.length < (36 + 32)) {\n            return false;\n        }\n        uint256 value;\n        assembly {\n            value := mload(add(data, 36))\n        }\n        return value == uint256(_address);\n    }\n\n    function doParamEqualsUInt256(\n        bytes memory data,\n        uint256 i,\n        uint256 value\n    ) internal pure returns (bool) {\n        if (data.length < (36 + (i + 1) * 32)) {\n            return false;\n        }\n        uint256 offset = 36 + i * 32;\n        uint256 valuePresent;\n        assembly {\n            valuePresent := mload(add(data, offset))\n        }\n        return valuePresent == value;\n    }\n\n    function overrideFirst32BytesWithAddress(bytes memory data, address _address) internal pure returns (bytes memory) {\n        uint256 dest;\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n\n        bytes memory addressBytes = addressToBytes(_address);\n        uint256 src;\n        assembly {\n            src := add(addressBytes, 32)\n        }\n\n        memcpy(dest, src, 20);\n        return data;\n    }\n\n    function overrideFirstTwo32BytesWithAddressAndInt(\n        bytes memory data,\n        address _address,\n        uint256 _value\n    ) internal pure returns (bytes memory) {\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(data, 48)\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\n        bytes memory bbytes = addressToBytes(_address);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 20);\n\n        assembly {\n            dest := add(data, 68)\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\n        bbytes = uint256ToBytes(_value);\n        assembly {\n            src := add(bbytes, 32)\n        }\n        memcpy(dest, src, 32);\n\n        return data;\n    }\n}\n",
      "keccak256": "0xe6deec26a5bb00520a8025fb2b7b0155e3cad78349934bbd24e8d524c54114db"
    },
    "src/common/Libraries/ObjectLib32.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./SafeMathWithRequire.sol\";\n\n\nlibrary ObjectLib32 {\n    using SafeMathWithRequire for uint256;\n    enum Operations {ADD, SUB, REPLACE}\n    // Constants regarding bin or chunk sizes for balance packing\n    uint256 constant TYPES_BITS_SIZE = 32; // Max size of each object\n    uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n\n    //\n    // Objects and Tokens Functions\n    //\n\n    /**\n     * @dev Return the bin number and index within that bin where ID is\n     * @param tokenId Object type\n     * @return bin Bin number\n     * @return index ID's index within that bin\n     */\n    function getTokenBinIndex(uint256 tokenId) internal pure returns (uint256 bin, uint256 index) {\n        bin = (tokenId * TYPES_BITS_SIZE) / 256;\n        index = tokenId % TYPES_PER_UINT256;\n        return (bin, index);\n    }\n\n    /**\n     * @dev update the balance of a type provided in binBalances\n     * @param binBalances Uint256 containing the balances of objects\n     * @param index Index of the object in the provided bin\n     * @param amount Value to update the type balance\n     * @param operation Which operation to conduct :\n     *     Operations.REPLACE : Replace type balance with amount\n     *     Operations.ADD     : ADD amount to type balance\n     *     Operations.SUB     : Substract amount from type balance\n     */\n    function updateTokenBalance(\n        uint256 binBalances,\n        uint256 index,\n        uint256 amount,\n        Operations operation\n    ) internal pure returns (uint256 newBinBalance) {\n        uint256 objectBalance = 0;\n        if (operation == Operations.ADD) {\n            objectBalance = getValueInBin(binBalances, index);\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.add(amount));\n        } else if (operation == Operations.SUB) {\n            objectBalance = getValueInBin(binBalances, index);\n            require(objectBalance >= amount, \"can't substract more than there is\");\n            newBinBalance = writeValueInBin(binBalances, index, objectBalance.sub(amount));\n        } else if (operation == Operations.REPLACE) {\n            newBinBalance = writeValueInBin(binBalances, index, amount);\n        } else {\n            revert(\"Invalid operation\"); // Bad operation\n        }\n\n        return newBinBalance;\n    }\n\n    /*\n     * @dev return value in binValue at position index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index index at which to retrieve value\n     * @return Value at given index in bin\n     */\n    function getValueInBin(uint256 binValue, uint256 index) internal pure returns (uint256) {\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 rightShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue >> rightShift) & mask;\n    }\n\n    /**\n     * @dev return the updated binValue after writing amount at index\n     * @param binValue uint256 containing the balances of TYPES_PER_UINT256 types\n     * @param index Index at which to retrieve value\n     * @param amount Value to store at index in bin\n     * @return Value at given index in bin\n     */\n    function writeValueInBin(\n        uint256 binValue,\n        uint256 index,\n        uint256 amount\n    ) internal pure returns (uint256) {\n        require(amount < 2**TYPES_BITS_SIZE, \"Amount to write in bin is too large\");\n\n        // Mask to retrieve data for a given binData\n        uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n\n        // Shift amount\n        uint256 leftShift = 256 - TYPES_BITS_SIZE * (index + 1);\n        return (binValue & ~(mask << leftShift)) | (amount << leftShift);\n    }\n}\n",
      "keccak256": "0xc2b73b8a4e836615ee9cb570406c532233a293024dad944ddb87f8957fce8b25"
    },
    "src/common/Libraries/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n",
      "keccak256": "0xdd13b563f215fd558bab94e03eb5a96e0cb30e7e156198bf448514876d1fa1bd"
    },
    "src/common/Libraries/SafeMathWithRequire.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert\n */\nlibrary SafeMathWithRequire {\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        require(c / a == b, \"overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"divbyzero\");\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"undeflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        require(c >= a, \"overflow\");\n        return c;\n    }\n}\n",
      "keccak256": "0x3ed5e25131dfcd07b3b11cb45b33dc24d0721acc0a034c85c2f17914fcea2dcd"
    },
    "src/common/Libraries/SigUtil.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nlibrary SigUtil {\n    function recover(bytes32 hash, bytes memory sig) internal pure returns (address recovered) {\n        require(sig.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n        require(v == 27 || v == 28);\n\n        recovered = ecrecover(hash, v, r, s);\n        require(recovered != address(0));\n    }\n\n    function recoverWithZeroOnFailure(bytes32 hash, bytes memory sig) internal pure returns (address) {\n        if (sig.length != 65) {\n            return (address(0));\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes memory) {\n        return abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash);\n    }\n}\n",
      "keccak256": "0x7767f4189ed6af1488e44a4e6854d8e980da15b3f39c8ddf2a5f3d420cca4812"
    }
  }
}}