{"MemoryMap.sol":{"content":"pragma solidity ^0.5.2;\n\ncontract MemoryMap {\n    /*\n      We store the state of the verifer in a contiguous chunk of memory.\n      The offsets of the different fields are listed below.\n      E.g. The offset of the i\u0027th hash is [mm_hashes + i].\n    */\n    uint256 constant internal CHANNEL_STATE_SIZE = 3;\n    uint256 constant internal MAX_N_QUERIES =  48;\n    uint256 constant internal FRI_QUEUE_SIZE = MAX_N_QUERIES;\n\n    uint256 constant internal MAX_SUPPORTED_MAX_FRI_STEP = 4;\n\n    uint256 constant internal MM_EVAL_DOMAIN_SIZE =                          0x0;\n    uint256 constant internal MM_BLOW_UP_FACTOR =                            0x1;\n    uint256 constant internal MM_LOG_EVAL_DOMAIN_SIZE =                      0x2;\n    uint256 constant internal MM_PROOF_OF_WORK_BITS =                        0x3;\n    uint256 constant internal MM_EVAL_DOMAIN_GENERATOR =                     0x4;\n    uint256 constant internal MM_PUBLIC_INPUT_PTR =                          0x5;\n    uint256 constant internal MM_TRACE_COMMITMENT =                          0x6;\n    uint256 constant internal MM_OODS_COMMITMENT =                           0x7;\n    uint256 constant internal MM_N_UNIQUE_QUERIES =                          0x8;\n    uint256 constant internal MM_CHANNEL =                                   0x9; // uint256[3]\n    uint256 constant internal MM_MERKLE_QUEUE =                              0xc; // uint256[96]\n    uint256 constant internal MM_FRI_QUEUE =                                0x6c; // uint256[144]\n    uint256 constant internal MM_FRI_QUERIES_DELIMITER =                    0xfc;\n    uint256 constant internal MM_FRI_CTX =                                  0xfd; // uint256[40]\n    uint256 constant internal MM_FRI_STEPS_PTR =                           0x125;\n    uint256 constant internal MM_FRI_EVAL_POINTS =                         0x126; // uint256[10]\n    uint256 constant internal MM_FRI_COMMITMENTS =                         0x130; // uint256[10]\n    uint256 constant internal MM_FRI_LAST_LAYER_DEG_BOUND =                0x13a;\n    uint256 constant internal MM_FRI_LAST_LAYER_PTR =                      0x13b;\n    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_START =              0x13c;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS0_A =              0x13c;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS1_A =              0x13d;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS2_A =              0x13e;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS3_A =              0x13f;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS4_A =              0x140;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS5_A =              0x141;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS6_A =              0x142;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS7_A =              0x143;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS8_A =              0x144;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS9_A =              0x145;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS0_B =              0x146;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS1_B =              0x147;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS2_B =              0x148;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS3_B =              0x149;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS4_B =              0x14a;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS5_B =              0x14b;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS6_B =              0x14c;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS7_B =              0x14d;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS8_B =              0x14e;\n    uint256 constant internal MM_PERIODIC_COLUMN__CONSTS9_B =              0x14f;\n    uint256 constant internal MM_MAT00 =                                   0x150;\n    uint256 constant internal MM_MAT01 =                                   0x151;\n    uint256 constant internal MM_TRACE_LENGTH =                            0x152;\n    uint256 constant internal MM_MAT10 =                                   0x153;\n    uint256 constant internal MM_MAT11 =                                   0x154;\n    uint256 constant internal MM_INPUT_VALUE_A =                           0x155;\n    uint256 constant internal MM_OUTPUT_VALUE_A =                          0x156;\n    uint256 constant internal MM_INPUT_VALUE_B =                           0x157;\n    uint256 constant internal MM_OUTPUT_VALUE_B =                          0x158;\n    uint256 constant internal MM_TRACE_GENERATOR =                         0x159;\n    uint256 constant internal MM_OODS_POINT =                              0x15a;\n    uint256 constant internal MM_COEFFICIENTS =                            0x15b; // uint256[48]\n    uint256 constant internal MM_OODS_VALUES =                             0x18b; // uint256[22]\n    uint256 constant internal MM_CONSTRAINT_POLY_ARGS_END =                0x1a1;\n    uint256 constant internal MM_COMPOSITION_OODS_VALUES =                 0x1a1; // uint256[2]\n    uint256 constant internal MM_OODS_EVAL_POINTS =                        0x1a3; // uint256[48]\n    uint256 constant internal MM_OODS_COEFFICIENTS =                       0x1d3; // uint256[24]\n    uint256 constant internal MM_TRACE_QUERY_RESPONSES =                   0x1eb; // uint256[960]\n    uint256 constant internal MM_COMPOSITION_QUERY_RESPONSES =             0x5ab; // uint256[96]\n    uint256 constant internal MM_CONTEXT_SIZE =                            0x60b;\n}\n"},"MimcOods.sol":{"content":"// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\npragma solidity ^0.5.2;\n\nimport \"./MemoryMap.sol\";\nimport \"./StarkParameters.sol\";\n\ncontract MimcOods is MemoryMap, StarkParameters {\n    // For each query point we want to invert (2 + N_ROWS_IN_MASK) items:\n    //  The query point itself (x).\n    //  The denominator for the constraint polynomial (x-z^constraintDegree)\n    //  [(x-(g^rowNumber)z) for rowNumber in mask].\n    uint256 constant internal BATCH_INVERSE_CHUNK = (2 + N_ROWS_IN_MASK);\n    uint256 constant internal BATCH_INVERSE_SIZE = MAX_N_QUERIES * BATCH_INVERSE_CHUNK;\n\n    /*\n      Builds and sums boundary constraints that check that the prover provided the proper evaluations\n      out of domain evaluations for the trace and composition columns.\n\n      The inputs to this function are:\n          The verifier context.\n\n      The boundary constraints for the trace enforce claims of the form f(g^k*z) = c by\n      requiring the quotient (f(x) - c)/(x-g^k*z) to be a low degree polynomial.\n\n      The boundary constraints for the composition enforce claims of the form h(z^d) = c by\n      requiring the quotient (h(x) - c)/(x-z^d) to be a low degree polynomial.\n      Where:\n            f is a trace column.\n            h is a composition column.\n            z is the out of domain sampling point.\n            g is the trace generator\n            k is the offset in the mask.\n            d is the degree of the composition polynomial.\n            c is the evaluation sent by the prover.\n    */\n    function() external {\n        // This funciton assumes that the calldata contains the context as defined in MemoryMap.sol.\n        // Note that ctx is a variable size array so the first uint256 cell contrains it\u0027s length.\n        uint256[] memory ctx;\n        assembly {\n            let ctxSize := mul(add(calldataload(0), 1), 0x20)\n            ctx := mload(0x40)\n            mstore(0x40, add(ctx, ctxSize))\n            calldatacopy(ctx, 0, ctxSize)\n        }\n        uint256[] memory batchInverseArray = new uint256[](2 * BATCH_INVERSE_SIZE);\n\n        oodsPrepareInverses(ctx, batchInverseArray);\n\n        uint256 kMontgomeryRInv_ = PrimeFieldElement6.K_MONTGOMERY_R_INV;\n\n        assembly {\n            let PRIME := 0x30000003000000010000000000000001\n            let kMontgomeryRInv := kMontgomeryRInv_\n            let context := ctx\n            let friQueue := /*friQueue*/ add(context, 0xda0)\n            let friQueueEnd := add(friQueue,  mul(/*n_unique_queries*/ mload(add(context, 0x120)), 0x60))\n            let traceQueryResponses := /*traceQueryQesponses*/ add(context, 0x3d80)\n\n            let compositionQueryResponses := /*composition_query_responses*/ add(context, 0xb580)\n\n            // Set denominatorsPtr to point to the batchInverseOut array.\n            // The content of batchInverseOut is described in oodsPrepareInverses.\n            let denominatorsPtr := add(batchInverseArray, 0x20)\n\n            for {} lt(friQueue, friQueueEnd) {friQueue := add(friQueue, 0x60)} {\n                // res accumulates numbers modulo PRIME. Since 1814839283484201961915354863390654471405*PRIME \u003c 2**256, we may add up to\n                // 1814839283484201961915354863390654471405 numbers without fear of overflow, and use addmod modulo PRIME only every\n                // 1814839283484201961915354863390654471405 iterations, and once more at the very end.\n                let res := 0\n\n                // Trace constraints.\n\n                // Mask items for column #0.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(traceQueryResponses), kMontgomeryRInv, PRIME)\n\n                // res += c_0*(f_0(x) - f_0(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[0]*/ mload(add(context, 0x3a80)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[0]*/ mload(add(context, 0x3180)))),\n                           PRIME))\n\n                // res += c_1*(f_0(x) - f_0(g * z)) / (x - g * z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - g * z)^(-1)*/ mload(add(denominatorsPtr, 0x20)),\n                                  /*oods_coefficients[1]*/ mload(add(context, 0x3aa0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[1]*/ mload(add(context, 0x31a0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #1.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x20)), kMontgomeryRInv, PRIME)\n\n                // res += c_2*(f_1(x) - f_1(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[2]*/ mload(add(context, 0x3ac0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[2]*/ mload(add(context, 0x31c0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #2.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x40)), kMontgomeryRInv, PRIME)\n\n                // res += c_3*(f_2(x) - f_2(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[3]*/ mload(add(context, 0x3ae0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[3]*/ mload(add(context, 0x31e0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #3.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x60)), kMontgomeryRInv, PRIME)\n\n                // res += c_4*(f_3(x) - f_3(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[4]*/ mload(add(context, 0x3b00)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[4]*/ mload(add(context, 0x3200)))),\n                           PRIME))\n                }\n\n                // Mask items for column #4.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x80)), kMontgomeryRInv, PRIME)\n\n                // res += c_5*(f_4(x) - f_4(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[5]*/ mload(add(context, 0x3b20)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[5]*/ mload(add(context, 0x3220)))),\n                           PRIME))\n                }\n\n                // Mask items for column #5.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0xa0)), kMontgomeryRInv, PRIME)\n\n                // res += c_6*(f_5(x) - f_5(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[6]*/ mload(add(context, 0x3b40)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[6]*/ mload(add(context, 0x3240)))),\n                           PRIME))\n                }\n\n                // Mask items for column #6.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0xc0)), kMontgomeryRInv, PRIME)\n\n                // res += c_7*(f_6(x) - f_6(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[7]*/ mload(add(context, 0x3b60)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[7]*/ mload(add(context, 0x3260)))),\n                           PRIME))\n                }\n\n                // Mask items for column #7.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0xe0)), kMontgomeryRInv, PRIME)\n\n                // res += c_8*(f_7(x) - f_7(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[8]*/ mload(add(context, 0x3b80)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[8]*/ mload(add(context, 0x3280)))),\n                           PRIME))\n                }\n\n                // Mask items for column #8.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x100)), kMontgomeryRInv, PRIME)\n\n                // res += c_9*(f_8(x) - f_8(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[9]*/ mload(add(context, 0x3ba0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[9]*/ mload(add(context, 0x32a0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #9.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x120)), kMontgomeryRInv, PRIME)\n\n                // res += c_10*(f_9(x) - f_9(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[10]*/ mload(add(context, 0x3bc0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[10]*/ mload(add(context, 0x32c0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #10.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x140)), kMontgomeryRInv, PRIME)\n\n                // res += c_11*(f_10(x) - f_10(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[11]*/ mload(add(context, 0x3be0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[11]*/ mload(add(context, 0x32e0)))),\n                           PRIME))\n\n                // res += c_12*(f_10(x) - f_10(g * z)) / (x - g * z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - g * z)^(-1)*/ mload(add(denominatorsPtr, 0x20)),\n                                  /*oods_coefficients[12]*/ mload(add(context, 0x3c00)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[12]*/ mload(add(context, 0x3300)))),\n                           PRIME))\n                }\n\n                // Mask items for column #11.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x160)), kMontgomeryRInv, PRIME)\n\n                // res += c_13*(f_11(x) - f_11(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[13]*/ mload(add(context, 0x3c20)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[13]*/ mload(add(context, 0x3320)))),\n                           PRIME))\n                }\n\n                // Mask items for column #12.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x180)), kMontgomeryRInv, PRIME)\n\n                // res += c_14*(f_12(x) - f_12(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[14]*/ mload(add(context, 0x3c40)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[14]*/ mload(add(context, 0x3340)))),\n                           PRIME))\n                }\n\n                // Mask items for column #13.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x1a0)), kMontgomeryRInv, PRIME)\n\n                // res += c_15*(f_13(x) - f_13(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[15]*/ mload(add(context, 0x3c60)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[15]*/ mload(add(context, 0x3360)))),\n                           PRIME))\n                }\n\n                // Mask items for column #14.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x1c0)), kMontgomeryRInv, PRIME)\n\n                // res += c_16*(f_14(x) - f_14(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[16]*/ mload(add(context, 0x3c80)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[16]*/ mload(add(context, 0x3380)))),\n                           PRIME))\n                }\n\n                // Mask items for column #15.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x1e0)), kMontgomeryRInv, PRIME)\n\n                // res += c_17*(f_15(x) - f_15(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[17]*/ mload(add(context, 0x3ca0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[17]*/ mload(add(context, 0x33a0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #16.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x200)), kMontgomeryRInv, PRIME)\n\n                // res += c_18*(f_16(x) - f_16(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[18]*/ mload(add(context, 0x3cc0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[18]*/ mload(add(context, 0x33c0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #17.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x220)), kMontgomeryRInv, PRIME)\n\n                // res += c_19*(f_17(x) - f_17(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[19]*/ mload(add(context, 0x3ce0)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[19]*/ mload(add(context, 0x33e0)))),\n                           PRIME))\n                }\n\n                // Mask items for column #18.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x240)), kMontgomeryRInv, PRIME)\n\n                // res += c_20*(f_18(x) - f_18(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[20]*/ mload(add(context, 0x3d00)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[20]*/ mload(add(context, 0x3400)))),\n                           PRIME))\n                }\n\n                // Mask items for column #19.\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(traceQueryResponses, 0x260)), kMontgomeryRInv, PRIME)\n\n                // res += c_21*(f_19(x) - f_19(z)) / (x - z).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z)^(-1)*/ mload(denominatorsPtr),\n                                  /*oods_coefficients[21]*/ mload(add(context, 0x3d20)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*oods_values[21]*/ mload(add(context, 0x3420)))),\n                           PRIME))\n                }\n\n                // Advance traceQueryResponses by amount read (0x20 * nTraceColumns).\n                traceQueryResponses := add(traceQueryResponses, 0x280)\n\n                // Composition constraints.\n\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(compositionQueryResponses), kMontgomeryRInv, PRIME)\n                // res += c_22*(h_0(x) - C_0(z^2)) / (x - z^2).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z^2)^(-1)*/ mload(add(denominatorsPtr, 0x40)),\n                                  /*oods_coefficients[22]*/ mload(add(context, 0x3d40)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*composition_oods_values[0]*/ mload(add(context, 0x3440)))),\n                           PRIME))\n                }\n\n                {\n                // Read the next element.\n                let columnValue := mulmod(mload(add(compositionQueryResponses, 0x20)), kMontgomeryRInv, PRIME)\n                // res += c_23*(h_1(x) - C_1(z^2)) / (x - z^2).\n                res := add(\n                    res,\n                    mulmod(mulmod(/*(x - z^2)^(-1)*/ mload(add(denominatorsPtr, 0x40)),\n                                  /*oods_coefficients[23]*/ mload(add(context, 0x3d60)),\n                                  PRIME),\n                           add(columnValue, sub(PRIME, /*composition_oods_values[1]*/ mload(add(context, 0x3460)))),\n                           PRIME))\n                }\n\n                // Advance compositionQueryResponses by amount read (0x20 * constraintDegree).\n                compositionQueryResponses := add(compositionQueryResponses, 0x40)\n\n                // Append the friValue, which is the sum of the out-of-domain-sampling boundary\n                // constraints for the trace and composition polynomials, to the friQueue array.\n                mstore(add(friQueue, 0x20), mod(res, PRIME))\n\n                // Append the friInvPoint of the current query to the friQueue array.\n                mstore(add(friQueue, 0x40), /*friInvPoint*/ mload(add(denominatorsPtr,0x60)))\n\n                // Advance denominatorsPtr by chunk size (0x20 * (2+N_ROWS_IN_MASK)).\n                denominatorsPtr := add(denominatorsPtr, 0x80)\n            }\n            return(/*friQueue*/ add(context, 0xda0), 0x1200)\n        }\n    }\n\n    /*\n      Computes and performs batch inverse on all the denominators required for the out of domain\n      sampling boundary constraints.\n\n      Since the friEvalPoints are calculated during the computation of the denominators\n      this function also adds those to the batch inverse in prepartion for the fri that follows.\n\n      After this function returns, the batch_inverse_out array holds #queries\n      chunks of size (2 + N_ROWS_IN_MASK) with the following structure:\n      0..(N_ROWS_IN_MASK-1):   [(x - g^i * z)^(-1) for i in rowsInMask]\n      N_ROWS_IN_MASK:          (x - z^constraintDegree)^-1\n      N_ROWS_IN_MASK+1:        friEvalPointInv.\n    */\n    function oodsPrepareInverses(\n        uint256[] memory context, uint256[] memory batchInverseArray)\n        internal view {\n        uint256 evalCosetOffset_ = PrimeFieldElement6.GENERATOR_VAL;\n        // The array expmodsAndPoints stores subexpressions that are needed\n        // for the denominators computation.\n        // The array is segmented as follows:\n        //    expmodsAndPoints[0:0] (.expmods) expmods used during calculations of the points below.\n        //    expmodsAndPoints[0:2] (.points) points used during the denominators calculation.\n        uint256[2] memory expmodsAndPoints;\n        assembly {\n            function expmod(base, exponent, modulus) -\u003e res {\n              let p := mload(0x40)\n              mstore(p, 0x20)                 // Length of Base.\n              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\n              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\n              mstore(add(p, 0x60), base)      // Base.\n              mstore(add(p, 0x80), exponent)  // Exponent.\n              mstore(add(p, 0xa0), modulus)   // Modulus.\n              // Call modexp precompile.\n              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n              }\n              res := mload(p)\n            }\n\n            let traceGenerator := /*trace_generator*/ mload(add(context, 0x2b40))\n            let PRIME := 0x30000003000000010000000000000001\n\n            // Prepare expmods for computations of trace generator powers.\n\n            let oodsPoint := /*oods_point*/ mload(add(context, 0x2b60))\n            {\n              // point = -z.\n              let point := sub(PRIME, oodsPoint)\n              // Compute denominators for rows with nonconst mask expression.\n              // We compute those first because for the const rows we modify the point variable.\n\n              // Compute denominators for rows with const mask expression.\n\n              // expmods_and_points.points[0] = -z.\n              mstore(add(expmodsAndPoints, 0x0), point)\n\n              // point *= g.\n              point := mulmod(point, traceGenerator, PRIME)\n              // expmods_and_points.points[1] = -(g * z).\n              mstore(add(expmodsAndPoints, 0x20), point)\n            }\n\n\n            let evalPointsPtr := /*oodsEvalPoints*/ add(context, 0x3480)\n            let evalPointsEndPtr := add(evalPointsPtr,\n                                           mul(/*n_unique_queries*/ mload(add(context, 0x120)), 0x20))\n            let productsPtr := add(batchInverseArray, 0x20)\n            let valuesPtr := add(add(batchInverseArray, 0x20), 0x1800)\n            let partialProduct := 1\n            let minusPointPow := sub(PRIME, mulmod(oodsPoint, oodsPoint, PRIME))\n            for {} lt(evalPointsPtr, evalPointsEndPtr)\n                     {evalPointsPtr := add(evalPointsPtr, 0x20)} {\n                let evalPoint := mload(evalPointsPtr)\n\n                // Shift evalPoint to evaluation domain coset.\n                let shiftedEvalPoint := mulmod(evalPoint, evalCosetOffset_, PRIME)\n\n                {\n                // Calculate denominator for row 0: x - z.\n                let denominator := add(shiftedEvalPoint, mload(add(expmodsAndPoints, 0x0)))\n                mstore(productsPtr, partialProduct)\n                mstore(valuesPtr, denominator)\n                partialProduct := mulmod(partialProduct, denominator, PRIME)\n                }\n\n                {\n                // Calculate denominator for row 1: x - g * z.\n                let denominator := add(shiftedEvalPoint, mload(add(expmodsAndPoints, 0x20)))\n                mstore(add(productsPtr, 0x20), partialProduct)\n                mstore(add(valuesPtr, 0x20), denominator)\n                partialProduct := mulmod(partialProduct, denominator, PRIME)\n                }\n\n                {\n                // Calculate the denominator for the composition polynomial columns: x - z^2.\n                let denominator := add(shiftedEvalPoint, minusPointPow)\n                mstore(add(productsPtr, 0x40), partialProduct)\n                mstore(add(valuesPtr, 0x40), denominator)\n                partialProduct := mulmod(partialProduct, denominator, PRIME)\n                }\n\n                // Add evalPoint to batch inverse inputs.\n                // inverse(evalPoint) is going to be used by FRI.\n                mstore(add(productsPtr, 0x60), partialProduct)\n                mstore(add(valuesPtr, 0x60), evalPoint)\n                partialProduct := mulmod(partialProduct, evalPoint, PRIME)\n\n                // Advance pointers.\n                productsPtr := add(productsPtr, 0x80)\n                valuesPtr := add(valuesPtr, 0x80)\n            }\n\n            let productsToValuesOffset := 0x1800\n            let firstPartialProductPtr := add(batchInverseArray, 0x20)\n            // Compute the inverse of the product.\n            let prodInv := expmod(partialProduct, sub(PRIME, 2), PRIME)\n\n            if eq(prodInv, 0) {\n                // Solidity generates reverts with reason that look as follows:\n                // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b\u0027Error(string)\u0027)[:4]).\n                // 2. 32 bytes offset bytes (always 0x20 as far as i can tell).\n                // 3. 32 bytes with the length of the revert reason.\n                // 4. Revert reason string.\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                mstore(0x4, 0x20)\n                mstore(0x24, 0x1e)\n                mstore(0x44, \"Batch inverse product is zero.\")\n                revert(0, 0x62)\n            }\n\n            // Compute the inverses.\n            // Loop over denominator_invs in reverse order.\n            // currentPartialProductPtr is initialized to one past the end.\n            let currentPartialProductPtr := productsPtr\n            // Loop in blocks of size 8 as much as possible: we can loop over a full block as long as\n            // currentPartialProductPtr \u003e= firstPartialProductPtr + 8*0x20, or equivalently,\n            // currentPartialProductPtr \u003e firstPartialProductPtr + 7*0x20.\n            // We use the latter comparison since there is no \u003e= evm opcode.\n            let midPartialProductPtr := add(firstPartialProductPtr, 0xe0)\n            for { } gt(currentPartialProductPtr, midPartialProductPtr) { } {\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n            }\n\n            // Loop over the remainder.\n            for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {\n                currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\n                // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\n                mstore(currentPartialProductPtr,\n                       mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\n                // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\n                prodInv := mulmod(prodInv,\n                                   mload(add(currentPartialProductPtr, productsToValuesOffset)),\n                                   PRIME)\n            }\n        }\n    }\n}\n// ---------- End of auto-generated code. ----------\n"},"PrimeFieldElement6.sol":{"content":"pragma solidity ^0.5.2;\n\n\ncontract PrimeFieldElement6 {\n    uint256 internal constant K_MODULUS = 0x30000003000000010000000000000001;\n    uint256 internal constant K_MODULUS_MASK = 0x3fffffffffffffffffffffffffffffff;\n    uint256 internal constant K_MONTGOMERY_R = 0xffffff0fffffffafffffffffffffffb;\n    uint256 internal constant K_MONTGOMERY_R_INV = 0x9000001200000096000000600000001;\n    uint256 internal constant GENERATOR_VAL = 3;\n    uint256 internal constant ONE_VAL = 1;\n    uint256 internal constant GEN1024_VAL = 0x2361be682e1cc2d366e86e194024739f;\n\n    function fromMontgomery(uint256 val) internal pure returns (uint256 res) {\n        // uint256 res = fmul(val, kMontgomeryRInv);\n        assembly {\n            res := mulmod(\n                val,\n                0x9000001200000096000000600000001,\n                0x30000003000000010000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fromMontgomeryBytes(bytes32 bs) internal pure returns (uint256) {\n        // Assuming bs is a 256bit bytes object, in Montgomery form, it is read into a field\n        // element.\n        uint256 res = uint256(bs);\n        return fromMontgomery(res);\n    }\n\n    function toMontgomeryInt(uint256 val) internal pure returns (uint256 res) {\n        //uint256 res = fmul(val, kMontgomeryR);\n        assembly {\n            res := mulmod(\n                val,\n                0xffffff0fffffffafffffffffffffffb,\n                0x30000003000000010000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fmul(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        //uint256 res = mulmod(a, b, kModulus);\n        assembly {\n            res := mulmod(a, b, 0x30000003000000010000000000000001)\n        }\n        return res;\n    }\n\n    function fadd(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, b, kModulus);\n        assembly {\n            res := addmod(a, b, 0x30000003000000010000000000000001)\n        }\n        return res;\n    }\n\n    function fsub(uint256 a, uint256 b) internal pure returns (uint256 res) {\n        // uint256 res = addmod(a, kModulus - b, kModulus);\n        assembly {\n            res := addmod(\n                a,\n                sub(0x30000003000000010000000000000001, b),\n                0x30000003000000010000000000000001\n            )\n        }\n        return res;\n    }\n\n    function fpow(uint256 val, uint256 exp) internal returns (uint256) {\n        return expmod(val, exp, K_MODULUS);\n    }\n\n    function expmod(uint256 base, uint256 exponent, uint256 modulus)\n        internal\n        returns (uint256 res)\n    {\n        assembly {\n            let p := mload(0x40)\n            mstore(p, 0x20) // Length of Base.\n            mstore(add(p, 0x20), 0x20) // Length of Exponent.\n            mstore(add(p, 0x40), 0x20) // Length of Modulus.\n            mstore(add(p, 0x60), base) // Base.\n            mstore(add(p, 0x80), exponent) // Exponent.\n            mstore(add(p, 0xa0), modulus) // Modulus.\n            // Call modexp precompile.\n            if iszero(call(not(0), 0x05, 0, p, 0xc0, p, 0x20)) {\n                revert(0, 0)\n            }\n            res := mload(p)\n        }\n    }\n\n    function inverse(uint256 val) internal returns (uint256) {\n        return expmod(val, K_MODULUS - 2, K_MODULUS);\n    }\n}\n"},"StarkParameters.sol":{"content":"// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\npragma solidity ^0.5.2;\n\nimport \"./PrimeFieldElement6.sol\";\n\ncontract StarkParameters is PrimeFieldElement6 {\n    uint256 constant internal N_COEFFICIENTS = 48;\n    uint256 constant internal MASK_SIZE = 22;\n    uint256 constant internal N_ROWS_IN_MASK = 2;\n    uint256 constant internal N_COLUMNS_IN_MASK = 20;\n    uint256 constant internal CONSTRAINTS_DEGREE_BOUND = 2;\n    uint256 constant internal N_OODS_VALUES = MASK_SIZE + CONSTRAINTS_DEGREE_BOUND;\n    uint256 constant internal N_OODS_COEFFICIENTS = N_OODS_VALUES;\n    uint256 constant internal MAX_FRI_STEP = 3;\n}\n// ---------- End of auto-generated code. ----------\n"}}