{{
  "language": "Solidity",
  "sources": {
    "/home/julian/betx/betx-contracts/contracts/impl/AffiliateRegistry.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IAffiliateRegistry.sol\";\nimport \"../interfaces/permissions/IWhitelist.sol\";\n\n\ncontract AffiliateRegistry is IAffiliateRegistry {\n    uint256 public constant MAX_AFFILIATE_FEE = 3*(10**19);\n\n    IWhitelist private systemParamsWhitelist;\n\n    address private defaultAffiliate;\n    mapping (address => address) private addressToAffiliate;\n    mapping (address => uint256) private affiliateFeeFrac;\n\n    event AffiliateSet(\n        address member,\n        address affiliate\n    );\n\n    event AffiliateFeeFracSet(\n        address affiliate,\n        uint256 feeFrac\n    );\n\n    constructor(IWhitelist _systemParamsWhitelist) public {\n        systemParamsWhitelist = _systemParamsWhitelist;\n    }\n\n    /// @notice Throws if the caller is not a system params admin.\n    modifier onlySystemParamsAdmin() {\n        require(\n            systemParamsWhitelist.getWhitelisted(msg.sender),\n            \"NOT_SYSTEM_PARAM_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Sets the affiliate for an address.\n    /// @param member The address to attach to the affiliate.\n    /// @param affiliate The affiliate address to attach.\n    function setAffiliate(address member, address affiliate)\n        public\n        onlySystemParamsAdmin\n    {\n        require(\n            affiliate != address(0),\n            \"AFFILIATE_ZERO_ADDRESS\"\n        );\n\n        addressToAffiliate[member] = affiliate;\n    }\n\n    /// @notice Sets the affiliate fee fraction for an address.\n    /// @param affiliate The affiliate whose fee fraction should be changed.\n    /// @param feeFrac The new fee fraction for this affiliate.\n    function setAffiliateFeeFrac(address affiliate, uint256 feeFrac)\n        public\n        onlySystemParamsAdmin\n    {\n        require(\n            feeFrac < MAX_AFFILIATE_FEE,\n            \"AFFILIATE_FEE_TOO_HIGH\"\n        );\n\n        affiliateFeeFrac[affiliate] = feeFrac;\n    }\n\n    /// @notice Sets the default affiliate if no affiliate is set for an address.\n    /// @param affiliate The new default affiliate.\n    function setDefaultAffiliate(address affiliate)\n        public\n        onlySystemParamsAdmin\n    {\n        require(\n            affiliate != address(0),\n            \"AFFILIATE_ZERO_ADDRESS\"\n        );\n\n        defaultAffiliate = affiliate;\n    }\n\n    /// @notice Gets the affiliate for an address. If no affiliate is set, it returns the\n    ///         default affiliate.\n    /// @param member The address to query.\n    /// @return The affiliate for this address.\n    function getAffiliate(address member)\n        public\n        view\n        returns (address)\n    {\n        address affiliate = addressToAffiliate[member];\n        if (affiliate == address(0)) {\n            return defaultAffiliate;\n        } else {\n            return affiliate;\n        }\n    }\n\n    function getAffiliateFeeFrac(address affiliate)\n        public\n        view\n        returns (uint256)\n    {\n        return affiliateFeeFrac[affiliate];\n    }\n\n    function getDefaultAffiliate()\n        public\n        view\n        returns (address)\n    {\n        return defaultAffiliate;\n    }\n\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/Escrow.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/LibOutcome.sol\";\nimport \"../libraries/LibOrder.sol\";\nimport \"../interfaces/trading/IFillOrder.sol\";\nimport \"../interfaces/trading/IFeeSchedule.sol\";\nimport \"../interfaces/ISystemParameters.sol\";\nimport \"../interfaces/IOutcomeReporter.sol\";\nimport \"../interfaces/IAffiliateRegistry.sol\";\nimport \"../interfaces/IEscrow.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Escrow\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Central location that stores all escrow when\n///         swaps are traded.\ncontract Escrow is IEscrow {\n    using SafeMath for uint256;\n\n    ISystemParameters private systemParameters;\n    IFillOrder private fillOrder;\n    IOutcomeReporter private outcomeReporter;\n    IFeeSchedule private feeSchedule;\n    IAffiliateRegistry private affiliateRegistry;\n\n    // marketHash => baseToken => owner => side => amount\n    mapping(bytes32 => mapping(address => mapping(address => mapping(uint8 => uint256)))) returnAmounts;\n    mapping(bytes32 => mapping(address => mapping(address => mapping(uint8 => uint256)))) stakedAmounts;\n\n    struct BetFee {\n        uint256 oracleFee;\n        uint256 affiliateFee;\n    }\n\n    event BetSettled(\n        address indexed owner,\n        bytes32 indexed marketHash,\n        address indexed baseToken,\n        LibOutcome.Outcome outcome,\n        uint256 settledAmount,\n        uint256 oracleFeeAmount,\n        uint256 affiliateFeeAmount\n    );\n\n    constructor(\n        ISystemParameters _systemParameters,\n        IFillOrder _fillOrder,\n        IOutcomeReporter _outcomeReporter,\n        IFeeSchedule _feeSchedule,\n        IAffiliateRegistry _affiliateRegistry\n    ) public {\n        systemParameters = _systemParameters;\n        fillOrder = _fillOrder;\n        outcomeReporter = _outcomeReporter;\n        feeSchedule = _feeSchedule;\n        affiliateRegistry = _affiliateRegistry;\n    }\n\n    /// @notice Throws if the caller is not the FillOrder contract.\n    modifier onlyFillOrder() {\n        require(msg.sender == address(fillOrder), \"ONLY_FILL_ORDER\");\n        _;\n    }\n\n    /// @notice Throws if the market's tokens are not redeemable.\n    /// @param marketHash The market to check.\n    modifier marketTokensRedeemable(bytes32 marketHash) {\n        require(isMarketRedeemable(marketHash), \"INVALID_REDEMPTION_TIME\");\n        _;\n    }\n\n    /// @notice Redeems outcome one or outcome two return amounts after a market\n    ///         has been resolved.\n    /// @param owner The user to redeem for.\n    /// @param marketHash The market that is resolved.\n    /// @param baseTokenAddress The token to resolve.\n    function settleBet(\n        address owner,\n        bytes32 marketHash,\n        address baseTokenAddress\n    ) public marketTokensRedeemable(marketHash) {\n        IERC20 baseToken = IERC20(baseTokenAddress);\n        LibOutcome.Outcome marketResult = outcomeReporter.getReportedOutcome(\n            marketHash\n        );\n        uint256 outcomeOneEligibility = returnAmounts[marketHash][baseTokenAddress][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_ONE\n        )];\n        uint256 outcomeTwoEligibility = returnAmounts[marketHash][baseTokenAddress][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_TWO\n        )];\n        uint256 outcomeOneStake = stakedAmounts[marketHash][baseTokenAddress][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_ONE\n        )];\n        uint256 outcomeTwoStake = stakedAmounts[marketHash][baseTokenAddress][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_TWO\n        )];\n        BetFee memory betFees;\n        uint256 payout;\n\n        if (\n            marketResult == LibOutcome.Outcome.OUTCOME_ONE &&\n            outcomeOneEligibility > 0\n        ) {\n            uint256 profits = outcomeOneEligibility.sub(outcomeOneStake);\n            betFees = settleFees(baseTokenAddress, owner, profits);\n            payout = outcomeOneEligibility.sub(betFees.oracleFee).sub(\n                betFees.affiliateFee\n            );\n            returnAmounts[marketHash][baseTokenAddress][owner][uint8(\n                LibOutcome.Outcome.OUTCOME_ONE\n            )] = 0;\n        } else if (\n            marketResult == LibOutcome.Outcome.OUTCOME_TWO &&\n            outcomeTwoEligibility > 0\n        ) {\n            uint256 profits = outcomeTwoEligibility.sub(outcomeTwoStake);\n            betFees = settleFees(baseTokenAddress, owner, profits);\n            payout = outcomeTwoEligibility.sub(betFees.oracleFee).sub(\n                betFees.affiliateFee\n            );\n            returnAmounts[marketHash][baseTokenAddress][owner][uint8(\n                LibOutcome.Outcome.OUTCOME_TWO\n            )] = 0;\n        } else if (\n            marketResult == LibOutcome.Outcome.VOID &&\n            (outcomeOneStake > 0 || outcomeTwoStake > 0)\n        ) {\n            if (outcomeOneStake > 0) {\n                payout = outcomeOneStake;\n                stakedAmounts[marketHash][baseTokenAddress][owner][uint8(\n                    LibOutcome.Outcome.OUTCOME_ONE\n                )] = 0;\n            }\n            if (outcomeTwoStake > 0) {\n                payout = payout.add(outcomeTwoStake);\n                stakedAmounts[marketHash][baseTokenAddress][owner][uint8(\n                    LibOutcome.Outcome.OUTCOME_TWO\n                )] = 0;\n            }\n        } else {\n            revert(\"MARKET_WRONG_RESOLUTION\");\n        }\n\n        require(baseToken.transfer(owner, payout), \"CANNOT_TRANSFER_ESCROW\");\n\n        emit BetSettled(\n            owner,\n            marketHash,\n            baseTokenAddress,\n            marketResult,\n            payout,\n            betFees.oracleFee,\n            betFees.affiliateFee\n        );\n    }\n\n    /// @notice Updates the user's escrowed amount they have in the market.\n    /// @param marketHash The market to redeem.\n    /// @param baseToken The token with which they are betting.\n    /// @param user The user to update.\n    /// @param outcome The side to update.\n    /// @param amount The amount to add.\n    function updateStakedAmount(\n        bytes32 marketHash,\n        address baseToken,\n        address user,\n        LibOutcome.Outcome outcome,\n        uint256 amount\n    ) public onlyFillOrder {\n        stakedAmounts[marketHash][baseToken][user][uint8(\n            outcome\n        )] = stakedAmounts[marketHash][baseToken][user][uint8(outcome)].add(\n            amount\n        );\n    }\n\n    /// @notice Updates the user's return amount\n    /// @param marketHash The market for which they are betting on outcome one.\n    /// @param baseToken The token with which they are betting.\n    /// @param user The user to update.\n    /// @param outcome The outcome to increase\n    /// @param amount The amount to add.\n    function increaseReturnAmount(\n        bytes32 marketHash,\n        address baseToken,\n        address user,\n        LibOutcome.Outcome outcome,\n        uint256 amount\n    ) public onlyFillOrder {\n        returnAmounts[marketHash][baseToken][user][uint8(\n            outcome\n        )] = returnAmounts[marketHash][baseToken][user][uint8(outcome)].add(\n            amount\n        );\n    }\n\n    /// @notice Checks if the market's tokens are redeemable.\n    /// @param marketHash The market to check.\n    /// @return true if the market's tokens are redeemable, false otherwise.\n    function isMarketRedeemable(bytes32 marketHash) public view returns (bool) {\n        uint256 reportTime = outcomeReporter.getReportTime(marketHash);\n        if (reportTime > 0) {\n            return now > reportTime;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Checks if the owner has a valid redeemable bet.\n    /// @param owner The owner of the bet.\n    /// @param marketHash The market to check.\n    /// @param baseToken The base token to check.\n    /// @return true if the owner has a valid redeemable bet for this market, false otherwise.\n    function getEligibility(\n        address owner,\n        bytes32 marketHash,\n        address baseToken\n    ) public view returns (Eligibility memory eligibility) {\n        if (!isMarketRedeemable(marketHash)) {\n            return\n                Eligibility({\n                    hasEligibility: false,\n                    outcome: LibOutcome.Outcome.VOID,\n                    amount: 0\n                });\n        }\n        LibOutcome.Outcome marketResult = outcomeReporter.getReportedOutcome(\n            marketHash\n        );\n\n        uint256 outcomeOneEligibility = returnAmounts[marketHash][baseToken][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_ONE\n        )];\n        uint256 outcomeTwoEligibility = returnAmounts[marketHash][baseToken][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_TWO\n        )];\n        uint256 outcomeOneStake = stakedAmounts[marketHash][baseToken][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_ONE\n        )];\n        uint256 outcomeTwoStake = stakedAmounts[marketHash][baseToken][owner][uint8(\n            LibOutcome.Outcome.OUTCOME_TWO\n        )];\n\n        if (\n            marketResult == LibOutcome.Outcome.OUTCOME_ONE &&\n            outcomeOneEligibility > 0\n        ) {\n            return\n                Eligibility({\n                    hasEligibility: true,\n                    outcome: LibOutcome.Outcome.OUTCOME_ONE,\n                    amount: outcomeOneEligibility\n                });\n        } else if (\n            marketResult == LibOutcome.Outcome.OUTCOME_TWO &&\n            outcomeTwoEligibility > 0\n        ) {\n            return\n                Eligibility({\n                    hasEligibility: true,\n                    outcome: LibOutcome.Outcome.OUTCOME_TWO,\n                    amount: outcomeTwoEligibility\n                });\n        } else if (\n            marketResult == LibOutcome.Outcome.VOID &&\n            (outcomeOneStake > 0 || outcomeTwoStake > 0)\n        ) {\n            return\n                Eligibility({\n                    hasEligibility: true,\n                    outcome: LibOutcome.Outcome.VOID,\n                    amount: outcomeOneStake.add(outcomeTwoStake)\n                });\n        } else {\n            return\n                Eligibility({\n                    hasEligibility: false,\n                    outcome: LibOutcome.Outcome.VOID,\n                    amount: 0\n                });\n        }\n    }\n\n    function getReturnAmount(\n        bytes32 marketHash,\n        address baseToken,\n        address owner,\n        LibOutcome.Outcome outcome\n    ) public view returns (uint256) {\n        return returnAmounts[marketHash][baseToken][owner][uint8(outcome)];\n    }\n\n    function getStakedAmount(\n        bytes32 marketHash,\n        address baseToken,\n        address owner,\n        LibOutcome.Outcome outcome\n    ) public view returns (uint256) {\n        return stakedAmounts[marketHash][baseToken][owner][uint8(outcome)];\n    }\n\n    /// @notice Settles fees for an owner and for a market.\n    /// @param baseToken The token to settle.\n    /// @param owner The owner.\n    /// @param profits How much profit the owner made off this bet.\n    /// @return The fees that were settled.\n    function settleFees(address baseToken, address owner, uint256 profits)\n        private\n        returns (BetFee memory)\n    {\n        address affiliate = affiliateRegistry.getAffiliate(owner);\n        uint256 affiliateFeeFrac = affiliateRegistry.getAffiliateFeeFrac(\n            affiliate\n        );\n\n        uint256 oracleFee = settleOracleFee(baseToken, profits);\n        uint256 affiliateFee = settleAffiliateFee(\n            baseToken,\n            profits,\n            affiliate,\n            affiliateFeeFrac\n        );\n\n        return BetFee({oracleFee: oracleFee, affiliateFee: affiliateFee});\n    }\n\n    /// @notice Settles the affiliate fee for a market.\n    /// @param baseToken The token to settle.\n    /// @param profits The profits made on the bet.\n    /// @param affiliate The affiliate set for the winner of the bet.\n    /// @param affiliateFeeFrac The fee assigned to this affiliate.\n    /// @return The affiliate fee paid.\n    function settleAffiliateFee(\n        address baseToken,\n        uint256 profits,\n        address affiliate,\n        uint256 affiliateFeeFrac\n    ) private returns (uint256) {\n        IERC20 token = IERC20(baseToken);\n        uint256 affiliateFeeAmount = profits.mul(affiliateFeeFrac).div(\n            LibOrder.getOddsPrecision()\n        );\n        if (affiliateFeeAmount > 0) {\n            require(\n                token.transfer(affiliate, affiliateFeeAmount),\n                \"CANNOT_TRANSFER_AFFILIATE_FEE\"\n            );\n        }\n        return affiliateFeeAmount;\n    }\n\n    /// @notice Calculates oracle fee to be paid based on the market profits\n    /// @param baseToken The base token to settle.\n    /// @param profits Profit of user's outcome eligibility.\n    /// @return The amount oracle fee to be paid.\n    function settleOracleFee(address baseToken, uint256 profits)\n        private\n        returns (uint256)\n    {\n        IERC20 token = IERC20(baseToken);\n        uint256 oracleFee = feeSchedule.getOracleFees(baseToken);\n        uint256 oracleFeeAmount = profits.mul(oracleFee).div(\n            LibOrder.getOddsPrecision()\n        );\n        address oracleFeeRecipient = systemParameters.getOracleFeeRecipient();\n\n        if (oracleFeeAmount > 0) {\n            require(\n                token.transfer(oracleFeeRecipient, oracleFeeAmount),\n                \"CANNOT_TRANSFER_FEE\"\n            );\n        }\n        return oracleFeeAmount;\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/Initializable.sol": {
      "content": "pragma solidity 0.5.16;\n\n\ncontract Initializable {\n    bool public initialized;\n\n    /// @notice Throws if this contract has already been initialized.\n    modifier notInitialized() {\n        require(!initialized, \"ALREADY_INITIALIZED\");\n        _;\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/Migrations.sol": {
      "content": "//solhint-disable\n\npragma solidity 0.5.16;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/OutcomeReporter.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/LibOutcome.sol\";\nimport \"../interfaces/IOutcomeReporter.sol\";\nimport \"../interfaces/permissions/IWhitelist.sol\";\nimport \"./Initializable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/// @title OutcomeReporter\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Allows OutcomeReporter admins to report an initial outcome on an event.\ncontract OutcomeReporter is IOutcomeReporter {\n    using SafeMath for uint256;\n\n    IWhitelist private outcomeReporterWhitelist;\n\n    mapping(bytes32 => LibOutcome.Outcome) private reportedOutcomes;\n    mapping(bytes32 => uint256) private reportTime;\n\n    event OutcomeReported(bytes32 marketHash, LibOutcome.Outcome outcome);\n\n    constructor(\n        IWhitelist _outcomeReporterWhitelist\n    ) public {\n        outcomeReporterWhitelist = _outcomeReporterWhitelist;\n    }\n\n    /// @notice Throws if the caller is not an Outcome Reporter admin.\n    modifier onlyOutcomeReporterAdmin() {\n        require(\n            outcomeReporterWhitelist.getWhitelisted(msg.sender),\n            \"NOT_OUTCOME_REPORTER_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Throws if the market is already reported\n    /// @param marketHash The market to check.\n    modifier notAlreadyReported(bytes32 marketHash) {\n        require(\n            reportTime[marketHash] == 0,\n            \"MARKET_ALREADY_REPORTED\"\n        );\n        _;\n    }\n\n    /// @notice Reports the initial outcome of the market.\n    ///         Only callable by OutcomeReporter admins.\n    ///         Can only be reported once.\n    /// @param marketHash The market to report.\n    /// @param reportedOutcome The outcome to report.\n    function reportOutcome(bytes32 marketHash, LibOutcome.Outcome reportedOutcome)\n        public\n        onlyOutcomeReporterAdmin\n        notAlreadyReported(marketHash)\n    {\n        reportedOutcomes[marketHash] = reportedOutcome;\n        reportTime[marketHash] = now;\n\n        emit OutcomeReported(marketHash, reportedOutcome);\n    }\n\n    /// @notice Reports the outcome for several markets.\n    /// @param marketHashes The market hashes to report.\n    /// @param outcomes The outcomes to report.\n    function reportOutcomes(\n        bytes32[] memory marketHashes,\n        LibOutcome.Outcome[] memory outcomes\n    ) public {\n        uint256 marketHashesLength = marketHashes.length;\n        for (uint256 i = 0; i < marketHashesLength; i++) {\n            reportOutcome(marketHashes[i], outcomes[i]);\n        }\n    }\n\n    function getReportedOutcome(bytes32 marketHash)\n        public\n        view\n        returns (LibOutcome.Outcome)\n    {\n        return reportedOutcomes[marketHash];\n    }\n\n    function getReportTime(bytes32 marketHash) public view returns (uint256) {\n        return reportTime[marketHash];\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/SystemParameters.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/permissions/IWhitelist.sol\";\nimport \"../interfaces/ISystemParameters.sol\";\n\n\n/// @title SystemParameters\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Stores system parameters.\ncontract SystemParameters is ISystemParameters {\n    address private oracleFeeRecipient;\n\n    IWhitelist private systemParamsWhitelist;\n\n    constructor(IWhitelist _systemParamsWhitelist) public {\n        systemParamsWhitelist = _systemParamsWhitelist;\n    }\n\n    /// @notice Throws if the caller is not a system params admin.\n    modifier onlySystemParamsAdmin() {\n        require(\n            systemParamsWhitelist.getWhitelisted(msg.sender),\n            \"NOT_SYSTEM_PARAM_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Sets the oracle fee recipient. Only callable by SystemParams admins.\n    /// @param newOracleFeeRecipient The new oracle fee recipient address\n    function setNewOracleFeeRecipient(address newOracleFeeRecipient)\n        public\n        onlySystemParamsAdmin\n    {\n        oracleFeeRecipient = newOracleFeeRecipient;\n    }\n\n    function getOracleFeeRecipient() public view returns (address) {\n        return oracleFeeRecipient;\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/extensions/OrderValidator.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\nimport \"../../libraries/LibOrderAmounts.sol\";\nimport \"../../libraries/LibString.sol\";\nimport \"../../libraries/LibOrder.sol\";\nimport \"../../interfaces/trading/IFeeSchedule.sol\";\nimport \"../../interfaces/trading/IFills.sol\";\nimport \"../../interfaces/trading/ITokenTransferProxy.sol\";\nimport \"../../interfaces/trading/IReadOnlyValidator.sol\";\nimport \"../../interfaces/IOutcomeReporter.sol\";\nimport \"../../interfaces/trading/IEIP712FillHasher.sol\";\nimport \"../../interfaces/extensions/IOrderValidator.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\n\n/// @title OrderValidator\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Functions to validate orders off-chain and\n///         return a user-friendly string.\n///         None of these are used in the actual protocol to determine\n///         any state changes.\ncontract OrderValidator is IOrderValidator {\n    using LibOrder for LibOrder.Order;\n    using LibString for string;\n    using SafeMath for uint256;\n\n    ITokenTransferProxy private proxy;\n    IFills private fills;\n    IFeeSchedule private feeSchedule;\n    IEIP712FillHasher private eip712FillHasher;\n    IOutcomeReporter private outcomeReporter;\n\n    constructor(\n        ITokenTransferProxy _proxy,\n        IFills _fills,\n        IFeeSchedule _feeSchedule,\n        IEIP712FillHasher _eip712FillHasher,\n        IOutcomeReporter _outcomeReporter\n    ) public {\n        proxy = _proxy;\n        fills = _fills;\n        feeSchedule = _feeSchedule;\n        eip712FillHasher = _eip712FillHasher;\n        outcomeReporter = _outcomeReporter;\n    }\n\n    /// @notice Gets the current status of an order without considering\n    ///         any individual taker.\n    /// @param order The order to examine.\n    /// @param makerSig The signature of maker on this order.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getOrderStatus(\n        LibOrder.Order memory order,\n        bytes memory makerSig\n    )\n        public\n        view\n        returns (string memory)\n    {\n        string memory baseMakerOrderStatus = getBaseOrderStatus(\n            order,\n            makerSig\n        );\n        if (!baseMakerOrderStatus.equals(\"OK\")) {return baseMakerOrderStatus;}\n        uint256 remainingSpace = fills.remainingSpace(order);\n        if (remainingSpace == 0) {\n            return \"FULLY_FILLED\";\n        }\n        LibOrderAmounts.OrderAmounts memory orderAmounts = LibOrderAmounts.computeOrderAmounts(\n            order,\n            remainingSpace\n        );\n        string memory allowanceBalanceValidity = getMakerAllowanceAndBalanceStatus(\n            orderAmounts,\n            order.baseToken,\n            order.maker\n        );\n        return allowanceBalanceValidity;\n    }\n\n    /// @notice Gets the current status of multiple orders without considering\n    ///         any individual taker.\n    /// @param orders The orders to examine.\n    /// @param makerSigs The signature of the makers on this order.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getMultiOrderStatus(\n        LibOrder.Order[] memory orders,\n        bytes[] memory makerSigs\n    )\n        public\n        view\n        returns (string[] memory)\n    {\n        string[] memory statuses = new string[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            statuses[i] = getOrderStatus(\n                orders[i],\n                makerSigs[i]\n            );\n        }\n\n        return statuses;\n    }\n\n    /// @notice Gets the status of a multi-order fill\n    /// @param fillDetails The fills to execute\n    /// @param executorSig The signature of the executor, if any.\n    /// @param taker The hypothetical taker.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getFillStatus(\n        LibOrder.FillDetails memory fillDetails,\n        bytes memory executorSig,\n        address taker\n    )\n        public\n        view\n        returns (string memory)\n    {\n        address executor = fillDetails.fills.orders[0].executor;\n        if (executor != address(0)) {\n            bytes32 fillHash = eip712FillHasher.getDetailsHash(fillDetails);\n\n            if (fills.getFillHashSubmitted(fillHash)) {\n                return \"FILL_ALREADY_SUBMITTED\";\n            }\n\n            if (ECDSA.recover(fillHash, executorSig) != executor) {\n                return \"EXECUTOR_SIGNATURE_MISMATCH\";\n            }\n        }\n\n        if (fillDetails.fills.orders.length > 1) {\n            for (uint256 i = 1; i < fillDetails.fills.orders.length; i++) {\n                if (fillDetails.fills.orders[i].executor != executor) {\n                    return \"INCONSISTENT_EXECUTORS\";\n                }\n            }\n        }\n\n        return _getFillStatus(\n            fillDetails.fills.orders,\n            taker,\n            fillDetails.fills.takerAmounts,\n            fillDetails.fills.makerSigs\n        );\n    }\n\n    /// @notice Gets the status of a meta multi-order fill\n    /// @param fillDetails The fills to execute, meta style.\n    /// @param taker The hypothetical taker.\n    /// @param takerSig The taker's signature for this fill.\n    /// @param executorSig The signature of the executor, if any.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getMetaFillStatus(\n        LibOrder.FillDetails memory fillDetails,\n        address taker,\n        bytes memory takerSig,\n        bytes memory executorSig\n    )\n        public\n        view\n        returns (string memory)\n    {\n        bytes32 fillHash = eip712FillHasher.getDetailsHash(fillDetails);\n\n        if (ECDSA.recover(fillHash, takerSig) != taker) {\n            return \"TAKER_SIGNATURE_MISMATCH\";\n        }\n\n        if (fills.getFillHashSubmitted(fillHash)) {\n            return \"FILL_ALREADY_SUBMITTED\";\n        }\n\n        address executor = fillDetails.fills.orders[0].executor;\n\n        if (executor != address(0) &&\n            ECDSA.recover(fillHash, executorSig) != executor) {\n            return \"EXECUTOR_SIGNATURE_MISMATCH\";\n        }\n\n        if (fillDetails.fills.orders.length > 1) {\n            for (uint256 i = 1; i < fillDetails.fills.orders.length; i++) {\n                if (fillDetails.fills.orders[i].executor != executor) {\n                    return \"INCONSISTENT_EXECUTORS\";\n                }\n            }\n        }\n\n        return _getFillStatus(\n            fillDetails.fills.orders,\n            taker,\n            fillDetails.fills.takerAmounts,\n            fillDetails.fills.makerSigs\n        );\n    }\n\n    /// @notice Gets the combined status of several orders considering\n    ///         a single taker and a taker amount for each order.\n    /// @param makerOrders The orders to fill.\n    /// @param taker The hypothetical taker.\n    /// @param takerAmounts The hypothetical amounts to fill.\n    /// @param makerSigs The signatures of the makers on these orders.\n    /// @return A string representing the status. \"OK\" for valid.\n    function _getFillStatus(\n        LibOrder.Order[] memory makerOrders,\n        address taker,\n        uint256[] memory takerAmounts,\n        bytes[] memory makerSigs\n    )\n        private\n        view\n        returns (string memory)\n    {\n        string memory baseMultiFillStatus = getBaseMultiFillStatus(\n            makerOrders,\n            taker,\n            takerAmounts,\n            makerSigs\n        );\n        if (!baseMultiFillStatus.equals(\"OK\")) {\n            return baseMultiFillStatus;\n        }\n        return getMultiAllowanceBalanceStatus(\n            makerOrders,\n            takerAmounts,\n            taker\n        );\n    }\n\n    /// @notice Gets the \"base\" status of an order without considering any token\n    ///         allowances and balances.\n    /// @param order A maker order.\n    /// @param makerSig The signature of the maker on this order.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getBaseOrderStatus(\n        LibOrder.Order memory order,\n        bytes memory makerSig\n    )\n        private\n        view\n        returns (string memory)\n    {\n        string memory paramValidity = order.getParamValidity();\n        if (paramValidity.equals(\"OK\") == false) {return paramValidity;}\n        if (outcomeReporter.getReportTime(order.marketHash) != 0) {\n            return \"MARKET_NOT_TRADEABLE\";\n        }\n        if (order.checkSignature(makerSig) == false) {\n            return \"BAD_SIGNATURE\";\n        }\n        if (fills.isOrderCancelled(order)) {\n            return \"CANCELLED\";\n        }\n        return \"OK\";\n    }\n\n    /// @notice Checks the maker's balances and allowances for given order amounts\n    /// @param orderAmounts The computed balances to transfer as a result of the fill.\n    /// @param baseTokenAddress The base token to use.\n    /// @param maker The maker's balance to check.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getMakerAllowanceAndBalanceStatus(\n        LibOrderAmounts.OrderAmounts memory orderAmounts,\n        address baseTokenAddress,\n        address maker\n    )\n        private\n        view\n        returns (string memory)\n    {\n        IERC20 baseToken = IERC20(baseTokenAddress);\n        if (baseToken.balanceOf(maker) < orderAmounts.takerAmount) {\n            return \"MAKER_INSUFFICIENT_BASE_TOKEN\";\n        }\n        if (baseToken.allowance(maker, address(proxy)) < orderAmounts.takerAmount) {\n            return \"MAKER_INSUFFICIENT_BASE_TOKEN_ALLOWANCE\";\n        }\n        return \"OK\";\n    }\n\n    /// @notice Gets the status in terms of token balances\n    ///         and allowances if several orders were to be filled by a\n    ///         single taker.\n    ///\n    ///         For this method, we can combine the orders and treat it as\n    ///         one big order for the taker, but still need to check each\n    ///         order individually for makers.\n    ///\n    ///         Assumes base token is same for every order.\n    /// @param makerOrders The hypothetical orders to fill.\n    /// @param takerAmounts The hypothetical amounts to fill for each order.\n    /// @param taker The taker filling these orders.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getMultiAllowanceBalanceStatus(\n        LibOrder.Order[] memory makerOrders,\n        uint256[] memory takerAmounts,\n        address taker\n    )\n        private\n        view\n        returns (string memory)\n    {\n        address baseToken = makerOrders[0].baseToken;\n\n        LibOrderAmounts.OrderAmounts memory totalOrderAmounts = LibOrderAmounts.computeTotalOrderAmounts(\n            makerOrders,\n            takerAmounts\n        );\n\n        for (uint256 i = 0; i < makerOrders.length; i++) {\n            LibOrderAmounts.OrderAmounts memory individualOrderAmounts = LibOrderAmounts.computeOrderAmounts(\n                makerOrders[i],\n                takerAmounts[i]\n            );\n            string memory makerAllowanceBalanceValidity = getMakerAllowanceAndBalanceStatus(\n                individualOrderAmounts,\n                baseToken,\n                makerOrders[i].maker\n            );\n            if (!makerAllowanceBalanceValidity.equals(\"OK\")) {\n                return makerAllowanceBalanceValidity;\n            }\n        }\n        return getTakerAllowanceAndBalanceStatus(\n            totalOrderAmounts,\n            baseToken,\n            taker\n        );\n    }\n\n    /// @notice Gets the combined base status of several orders considering\n    ///         a single taker and a taker amount for each order.\n    ///         Does not consider balances or allowances.\n    ///         The markets must be identical in order to combine taker amounts.\n    /// @param makerOrders The orders to fill.\n    /// @param taker The hypothetical taker.\n    /// @param takerAmounts The hypothetical amounts to fill.\n    /// @param signatures The signatures of the makers on these orders.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getBaseMultiFillStatus(\n        LibOrder.Order[] memory makerOrders,\n        address taker,\n        uint256[] memory takerAmounts,\n        bytes[] memory signatures\n    )\n        private\n        view\n        returns (string memory)\n    {\n        for (uint256 i = 0; i < makerOrders.length; i++) {\n            if (makerOrders[i].marketHash != makerOrders[0].marketHash) {return \"MARKETS_NOT_IDENTICAL\";}\n            if (makerOrders[i].baseToken != makerOrders[0].baseToken) {return \"BASE_TOKENS_NOT_IDENTICAL\";}\n            // Don't have to compare directions - all that matters is the amount end of the day\n            string memory baseMakerOrderStatus = getBaseFillStatus(\n                makerOrders[i],\n                signatures[i],\n                takerAmounts[i],\n                taker\n            );\n            if (!baseMakerOrderStatus.equals(\"OK\")) {return baseMakerOrderStatus;}\n        }\n        return \"OK\";\n    }\n\n    /// @notice Checks the fillability of an order along with the taker amount.\n    ///         Does not check balances.\n    /// @param order The order to fill.\n    /// @param makerSig The maker's signature.\n    /// @param takerAmount The hypothetical taker amount.\n    /// @param taker The taker.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getBaseFillStatus(\n        LibOrder.Order memory order,\n        bytes memory makerSig,\n        uint256 takerAmount,\n        address taker\n    )\n        private\n        view\n        returns (string memory)\n    {\n        if (takerAmount == 0) {return \"TAKER_AMOUNT_NOT_POSITIVE\";}\n        string memory baseMakerOrderStatus = getBaseOrderStatus(\n            order,\n            makerSig\n        );\n        if (!baseMakerOrderStatus.equals(\"OK\")) {return baseMakerOrderStatus;}\n        if (taker == order.maker) {return \"TAKER_NOT_MAKER\";}\n        if (!fills.orderHasSpace(order, takerAmount)) {return \"INSUFFICIENT_SPACE\";}\n        return \"OK\";\n    }\n\n    /// @notice Checks the taker's balances and allowances for a given order to be filled.\n    /// @param orderAmounts The computed balances to transfer as a result of the fill.\n    /// @param baseTokenAddress The base token address\n    /// @param taker The hypothetical taker.\n    /// @return A string representing the status. \"OK\" for valid.\n    function getTakerAllowanceAndBalanceStatus(\n        LibOrderAmounts.OrderAmounts memory orderAmounts,\n        address baseTokenAddress,\n        address taker\n    )\n        private\n        view\n        returns (string memory)\n    {\n        IERC20 baseToken = IERC20(baseTokenAddress);\n        if (baseToken.balanceOf(taker) < orderAmounts.takerEscrow) {\n            return \"TAKER_INSUFFICIENT_BASE_TOKEN\";\n        }\n        if (baseToken.allowance(taker, address(proxy)) < orderAmounts.takerEscrow) {\n            return \"TAKER_INSUFFICIENT_BASE_TOKEN_ALLOWANCE\";\n        }\n        return \"OK\";\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/permissions/OutcomeReporterWhitelist.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./Whitelist.sol\";\nimport \"../../interfaces/permissions/ISuperAdminRole.sol\";\n\n\n/// @title OutcomeReporterWhitelist\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice A whitelist that represents all members allowed to\n///         report on markets in the protocol.\ncontract OutcomeReporterWhitelist is Whitelist {\n    constructor(ISuperAdminRole _superAdminRole) public Whitelist(_superAdminRole) {}\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/permissions/SuperAdminRole.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/permissions/ISuperAdminRole.sol\";\nimport \"openzeppelin-solidity/contracts/access/Roles.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\n/// @title SuperAdminRole\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice This is copied from the openzeppelin-solidity@2.0.0 library CapperRole and just\n///         renamed to SuperAdminRole. Super admins are parents to all other admins in the system.\n///         Super admins can also promote others to super admins but not remove them.\ncontract SuperAdminRole is ISuperAdminRole {\n    using Roles for Roles.Role;\n    using SafeMath for uint256;\n\n    event SuperAdminAdded(address indexed account);\n    event SuperAdminRemoved(address indexed account);\n\n    Roles.Role private superAdmins;\n\n    uint256 private superAdminCount;\n\n    constructor() public {\n        _addSuperAdmin(msg.sender);\n    }\n\n    /// @notice Throws if the caller is not a super admin./\n    modifier onlySuperAdmin() {\n        require(isSuperAdmin(msg.sender), \"NOT_SUPER_ADMIN\");\n        _;\n    }\n\n    /// @notice Adds a super admin to the list.\n    /// @param account The account to add.\n    function addSuperAdmin(address account) public onlySuperAdmin {\n        _addSuperAdmin(account);\n    }\n\n    /// @notice Throws if the caller is last super admin left\n    modifier atLeastOneSuperAdmin() {\n        require(\n            superAdminCount > 1,\n            \"LAST_SUPER_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Removes a super admin from the list.\n    /// @param account The account to add.\n    function removeSuperAdmin(address account)\n        public\n        onlySuperAdmin\n        atLeastOneSuperAdmin\n    {\n        _removeSuperAdmin(account);\n    }\n\n    /// @notice Internal function to add an account to the super admin list.\n    /// @param account The account to add.\n    function _addSuperAdmin(address account) internal {\n        superAdmins.add(account);\n        superAdminCount = superAdminCount.add(1);\n        emit SuperAdminAdded(account);\n    }\n\n    /// @notice Internal function to remove an account from the super admin list.\n    /// @param account The account to remove.\n    function _removeSuperAdmin(address account) internal {\n        superAdmins.remove(account);\n        superAdminCount = superAdminCount.sub(1);\n        emit SuperAdminRemoved(account);\n    }\n\n        /// @notice Gets the total number of super admins.\n    /// @return The total number of super admins.\n    function getSuperAdminCount() public view returns (uint256) {\n        return superAdminCount;\n    }\n\n    /// @notice Checks if an account is a super admin.\n    /// @param account The account to add.\n    /// @return true if the account is a super admin, false otherwise.\n    function isSuperAdmin(address account) public view returns (bool) {\n        return superAdmins.has(account);\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/permissions/SystemParamsWhitelist.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/permissions/ISuperAdminRole.sol\";\nimport \"./Whitelist.sol\";\n\n\n/// @title OutcomeReporterWhitelist\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice A whitelist that represents all members allowed to\n///         change parameters in the protocol.\ncontract SystemParamsWhitelist is Whitelist {\n    constructor(ISuperAdminRole _superAdminRole) public Whitelist(_superAdminRole) {}\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/permissions/Whitelist.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/permissions/ISuperAdminRole.sol\";\nimport \"../../interfaces/permissions/IWhitelist.sol\";\n\n\n/// @title Whitelist\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n///         This simplifies the implementation of \"user permissions\".\n///         This Whitelist is special in that only super admins can add others to this whitelist.\n///         This is copied verbatim, plus the SuperAdminRole authorization, from openzeppelin.\ncontract Whitelist is IWhitelist {\n    ISuperAdminRole internal superAdminRole;\n\n    mapping (address => bool) public whitelisted;\n\n    constructor(ISuperAdminRole _superAdminRole) public {\n        superAdminRole = _superAdminRole;\n    }\n\n    /// @notice Throws if the operator is not a super admin.\n    /// @param operator The operator.\n    modifier onlySuperAdmin(address operator) {\n        require(\n            superAdminRole.isSuperAdmin(operator),\n            \"NOT_A_SUPER_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Adds an operator to the whitelist\n    ///         Only callable by the SuperAdmin role.\n    /// @param operator The operator to add.\n    function addAddressToWhitelist(address operator)\n        public\n        onlySuperAdmin(msg.sender)\n    {\n        whitelisted[operator] = true;\n    }\n\n    /// @notice Removes an address from the whitelist\n    ///         Only callable by the SuperAdmin role.\n    /// @param operator The operator to remove.\n    function removeAddressFromWhitelist(address operator)\n        public\n        onlySuperAdmin(msg.sender)\n    {\n        whitelisted[operator] = false;\n    }\n\n    /// @notice Checks if the operator is whitelisted.\n    /// @param operator The operator.\n    /// @return true if the operator is whitelisted, false otherwise\n    function getWhitelisted(address operator) public view returns (bool) {\n        return whitelisted[operator];\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/test/DAI.sol": {
      "content": "pragma solidity 0.5.16;\n\n/* solium-disable */\n\ncontract DAI {\n\n    // --- ERC20 Data ---\n    string  public constant name     = \"Dai Stablecoin\";\n    string  public constant symbol   = \"DAI\";\n    string  public constant version  = \"1\";\n    uint8   public constant decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint)                      public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint)                      public nonces;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n\n    // --- Math ---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    // bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n\n    constructor(uint256 chainId_) public {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(name)),\n            keccak256(bytes(version)),\n            chainId_,\n            address(this)\n        ));\n    }\n\n    // --- Token ---\n    function transfer(address dst, uint wad) external returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public returns (bool)\n    {\n        require(balanceOf[src] >= wad, \"Dai/insufficient-balance\");\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n            allowance[src][msg.sender] = sub(allowance[src][msg.sender], wad);\n        }\n        balanceOf[src] = sub(balanceOf[src], wad);\n        balanceOf[dst] = add(balanceOf[dst], wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    }\n\n    function burn(address usr, uint wad) external {\n        require(balanceOf[usr] >= wad, \"Dai/insufficient-balance\");\n        if (usr != msg.sender && allowance[usr][msg.sender] != uint(-1)) {\n            require(allowance[usr][msg.sender] >= wad, \"Dai/insufficient-allowance\");\n            allowance[usr][msg.sender] = sub(allowance[usr][msg.sender], wad);\n        }\n        balanceOf[usr] = sub(balanceOf[usr], wad);\n        totalSupply    = sub(totalSupply, wad);\n        emit Transfer(usr, address(0), wad);\n    }\n\n    function approve(address usr, uint wad) external returns (bool) {\n        allowance[msg.sender][usr] = wad;\n        emit Approval(msg.sender, usr, wad);\n        return true;\n    }\n\n    function setBalance(address _target, uint256 _value) external {\n        balanceOf[_target] = _value;\n    }\n\n    // --- Approve by signature ---\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry,\n                    bool allowed, uint8 v, bytes32 r, bytes32 s) external\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     holder,\n                                     spender,\n                                     nonce,\n                                     expiry,\n                                     allowed))\n        ));\n\n        require(holder != address(0), \"Dai/invalid-address-0\");\n        require(holder == ecrecover(digest, v, r, s), \"Dai/invalid-permit\");\n        require(expiry == 0 || now <= expiry, \"Dai/permit-expired\");\n        require(nonce == nonces[holder]++, \"Dai/invalid-nonce\");\n        uint wad = allowed ? uint(-1) : 0;\n        allowance[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/tokens/DetailedToken.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/// @title DetailedToken\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice A utility contract to help pull name, symbol and decimals\n///         from ERC20 tokens.\n///         Verbatim, this:\n///         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Detailed.sol\ncontract DetailedToken {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /// @notice Gets the name of the token.\n    /// @return The name of the token.\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /// @notice Gets the symbol of the token.\n    /// @return The symbol of the token.\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice Gets the decimals of the token.\n    /// @return The decimals of the token.\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/tokens/WETH.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\ncontract WETH is IERC20 {\n    using SafeMath for uint256;\n\n    string public constant name = \"SportX WETH\";\n    string public constant symbol = \"WETH\";\n    string public constant version = \"1\";\n    uint8 public constant decimals = 18;\n    bytes2 constant private EIP191_HEADER = 0x1901;\n    bytes32 public constant EIP712_UNWRAP_TYPEHASH = keccak256(\"Unwrap(address holder,uint256 amount,uint256 nonce,uint256 expiry)\");\n    bytes32 public constant EIP712_PERMIT_TYPEHASH = keccak256(\n        \"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\"\n    );\n    bytes32 public EIP712_DOMAIN_SEPARATOR;\n    uint256 private _totalSupply;\n    address public defaultOperator;\n    address public defaultOperatorController;\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowed;\n    mapping (address => uint256) public unwrapNonces;\n    mapping (address => uint256) public permitNonces;\n\n    event Deposit(address indexed dst, uint256 amount);\n    event Withdrawal(address indexed src, uint256 amount);\n\n    constructor (address _operator, uint256 _chainId, address _defaultOperatorController) public {\n        defaultOperator = _operator;\n        defaultOperatorController = _defaultOperatorController;\n        EIP712_DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                _chainId,\n                address(this)\n            )\n        );\n    }\n\n    modifier onlyDefaultOperatorController() {\n        require(\n            msg.sender == defaultOperatorController,\n            \"ONLY_DEFAULT_OPERATOR_CONTROLLER\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Alias for the deposit function to deposit ETH.\n     */\n    function() external payable {\n        _deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Sets the default operator. Only callable by the default operator controller.\n     * @param newDefaultOperator The new default operator.\n     */\n    function setDefaultOperator(address newDefaultOperator) external onlyDefaultOperatorController {\n        defaultOperator = newDefaultOperator;\n    }\n\n    /**\n     * @dev Unwraps ETH meta style. Exchanges this token, WETH, for ETH 1 to 1\n     * @param holder The holder of WETH that wishes to withdraw.\n     * @param amount The amount to withdraw.\n     * @param nonce The current nonce for this holder, to prevent replays of the withdraw.\n     * @param expiry The time after which this meta withdraw is not valid.\n     * @param v v parameter in the ECDSA signature.\n     * @param r r parameter in the ECDSA signature.\n     * @param s s parameter in the ECDSA signature.\n     */\n    function metaWithdraw(\n        address payable holder,\n        uint256 amount,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                EIP191_HEADER,\n                EIP712_DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        EIP712_UNWRAP_TYPEHASH,\n                        holder,\n                        amount,\n                        nonce,\n                        expiry\n                    )\n                )\n            )\n        );\n\n        require(holder != address(0), \"INVALID_HOLDER\");\n        require(holder == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(expiry == 0 || now <= expiry, \"META_WITHDRAW_EXPIRED\");\n        require(nonce == unwrapNonces[holder]++, \"INVALID_NONCE\");\n        require(_balances[holder] >= amount, \"INSUFFICIENT_BALANCE\");\n\n        _withdraw(holder, amount);\n    }\n\n    /**\n     * @dev Meta approval for max funds.\n     * @param holder The holder of the WETH that wishes to approve another account.\n     * @param spender The designated spender of the WETH.\n     * @param nonce The current permit nonce for this holder, to prevent replays of the increased allowance.\n     * @param expiry The time after which this meta approval is not valid.\n     * @param allowed true if this spender should be allowed to spend all funds on behalf of the holder, false otherwise.\n     * @param v v parameter in the ECDSA signature.\n     * @param r r parameter in the ECDSA signature.\n     * @param s s parameter in the ECDSA signature.\n     */\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                EIP712_DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        EIP712_PERMIT_TYPEHASH,\n                        holder,\n                        spender,\n                        nonce,\n                        expiry,\n                        allowed\n                    )\n                )\n            )\n        );\n\n        require(holder != address(0), \"INVALID_HOLDER\");\n        require(holder == ecrecover(digest, v, r, s), \"INVALID_SIGNATURE\");\n        require(expiry == 0 || now <= expiry, \"PERMIT_EXPIRED\");\n        require(nonce == permitNonces[holder]++, \"INVALID_NONCE\");\n        uint256 wad = allowed ? uint256(-1) : 0;\n        _allowed[holder][spender] = wad;\n        emit Approval(holder, spender, wad);\n    }\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0), \"SPENDER_INVALID\");\n\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n        _transfer(from, to, value);\n        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), \"SPENDER_INVALID\");\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when allowed_[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        require(spender != address(0), \"SPENDER_INVALID\");\n\n        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    /**\n     * @dev Unwraps ETH - exchanges this token, WETH, for ETH 1 to 1\n     * @param amount The amount of token to withdraw.\n     */\n    function withdraw(uint256 amount) public {\n        require(_balances[msg.sender] >= amount, \"INSUFFICIENT_BALANCE\");\n        _withdraw(msg.sender, amount);\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) private {\n        require(to != address(0), \"SPENDER_INVALID\");\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that unwraps ETH - exchanges this token, WETH, for ETH 1 to 1.\n     * @param holder The holder that wishes to withdraw to ETH.\n     * @param amount The amount of token to withdraw.\n     */\n    function _withdraw(address payable holder, uint256 amount) private {\n        _balances[holder] = _balances[holder].sub(amount);\n        holder.transfer(amount);\n        emit Withdrawal(holder, amount);\n    }\n\n    /**\n     * @dev Wraps ETH - exchanges ETH for this token, WETH, 1 to 1\n     * Additionally auto approves the defaultOperator for this token to the max amount if it is zero.\n     */\n    function _deposit(address sender, uint256 amount) private {\n        _balances[sender] = _balances[sender].add(amount);\n        uint256 senderAllowance = _allowed[sender][defaultOperator];\n        if (senderAllowance == 0) {\n            _allowed[sender][defaultOperator] = uint256(-1);\n        }\n        emit Deposit(sender, amount);\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/BaseFillOrder.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\nimport \"../../libraries/LibOrderAmounts.sol\";\nimport \"../../libraries/LibOutcome.sol\";\nimport \"../../interfaces/IEscrow.sol\";\nimport \"../../interfaces/IOutcomeReporter.sol\";\nimport \"../../interfaces/permissions/ISuperAdminRole.sol\";\nimport \"../../interfaces/trading/ITokenTransferProxy.sol\";\nimport \"../../interfaces/trading/IFills.sol\";\nimport \"../Initializable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\n/// @title BaseFillOrder\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Manages the core internal functionality to fill orders and check their validity.\ncontract BaseFillOrder is Initializable {\n    using LibOrder for LibOrder.Order;\n    using SafeMath for uint256;\n\n    ITokenTransferProxy internal proxy;\n    IFills internal fills;\n    IEscrow internal escrow;\n    ISuperAdminRole internal superAdminRole;\n    IOutcomeReporter internal outcomeReporter;\n\n    event OrderFill(\n        address indexed maker,\n        bytes32 indexed marketHash,\n        address indexed taker,\n        uint256 newFilledAmount,\n        bytes32 orderHash,\n        bytes32 fillHash,\n        LibOrder.Order order,\n        LibOrderAmounts.OrderAmounts orderAmounts\n    );\n\n    constructor(ISuperAdminRole _superAdminRole) public Initializable() {\n        superAdminRole = _superAdminRole;\n    }\n\n    /// @notice Initializes this contract with reference to other contracts.\n    /// @param _fills The Fills contract.\n    /// @param _escrow  The Escrow contract.\n    /// @param _tokenTransferProxy The TokenTransferProxy contract.\n    function initialize(\n        IFills _fills,\n        IEscrow _escrow,\n        ITokenTransferProxy _tokenTransferProxy,\n        IOutcomeReporter _outcomeReporter\n    )\n        external\n        notInitialized\n        onlySuperAdmin(msg.sender)\n    {\n        fills = _fills;\n        escrow = _escrow;\n        proxy = _tokenTransferProxy;\n        outcomeReporter = _outcomeReporter;\n        initialized = true;\n    }\n\n    /// @notice Throws if the caller is not a super admin.\n    /// @param operator The caller of the method.\n    modifier onlySuperAdmin(address operator) {\n        require(\n            superAdminRole.isSuperAdmin(operator),\n            \"NOT_A_SUPER_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Intermediate function to fill a single order\n    /// @param order The order to be filled.\n    /// @param takerAmount The amount to fill the order by.\n    /// @param taker The taker of this order.\n    /// @param fillHash The fill hash, if applicable.\n    function _fillSingleOrder(\n        LibOrder.Order memory order,\n        uint256 takerAmount,\n        address taker,\n        bytes32 fillHash\n    )\n        internal\n    {\n        LibOrderAmounts.OrderAmounts memory orderAmounts = LibOrderAmounts.computeOrderAmounts(\n            order,\n            takerAmount\n        );\n\n        updateOrderState(\n            order,\n            orderAmounts,\n            taker,\n            fillHash\n        );\n    }\n\n    /// @notice Intermediate function that settles the order for each maker and taker.\n    /// @param order The order that is being filled.\n    /// @param orderAmounts The resulting order amounts given the taker amount.\n    /// @param taker The taker of this order.\n    /// @param fillHash The fill hash, if applicable in the case of a meta fill.\n    function updateOrderState(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts,\n        address taker,\n        bytes32 fillHash\n    )\n        internal\n    {\n        uint256 newFillAmount = fills.fill(order, orderAmounts.takerAmount);\n\n        settleOrderForMaker(\n            order,\n            orderAmounts\n        );\n\n        settleOrderForTaker(\n            order,\n            orderAmounts,\n            taker\n        );\n\n        emit OrderFill(\n            order.maker,\n            order.marketHash,\n            taker,\n            newFillAmount,\n            order.getOrderHash(),\n            fillHash,\n            order,\n            orderAmounts\n        );\n    }\n\n    /// @notice Intermediate function that settles the order for the maker.\n    /// @param order The order that is being filled.\n    /// @param orderAmounts The resulting order amounts given the taker amount.\n    function settleOrderForMaker(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts\n    )\n        internal\n    {\n        updateMakerEligibility(\n            order,\n            orderAmounts\n        );\n\n        settleTransfersForMaker(\n            order,\n            orderAmounts\n        );\n    }\n\n    /// @notice Intermediate function that settles the order for the taker.\n    /// @param order The order that is being filled.\n    /// @param orderAmounts The resulting order amounts given the taker amount.\n    /// @param taker The taker for this order.\n    function settleOrderForTaker(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts,\n        address taker\n    )\n        internal\n    {\n        updateTakerEligibility(\n            order,\n            orderAmounts,\n            taker\n        );\n\n        settleTransfersForTaker(\n            order,\n            orderAmounts,\n            taker\n        );\n    }\n\n    /// @notice Checks that the order is valid given the taker and taker amount.\n    /// @param order The order to check.\n    /// @param takerAmount The amount the order will be filled by.\n    /// @param taker The taker who would fill this order.\n    /// @param makerSig The maker signature for this order.\n    function assertOrderValid(\n        LibOrder.Order memory order,\n        uint256 takerAmount,\n        address taker,\n        bytes memory makerSig\n    )\n        internal\n        view\n    {\n        require(\n            takerAmount > 0,\n            \"TAKER_AMOUNT_NOT_POSITIVE\"\n        );\n        order.assertValidAsTaker(taker, makerSig);\n        require(\n            outcomeReporter.getReportTime(order.marketHash) == 0,\n            \"MARKET_NOT_TRADEABLE\"\n        );\n        require(\n            fills.orderHasSpace(order, takerAmount),\n            \"INSUFFICIENT_SPACE\"\n        );\n    }\n\n    /// @notice Transfers a token using TokenTransferProxy transferFrom function.\n    /// @param token Address of token to transferFrom.\n    /// @param from Address transfering token.\n    /// @param to Address receiving token.\n    /// @param value Amount of token to transfer.\n    /// @return Success of token transfer.\n    function transferViaProxy(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    )\n        internal\n        returns (bool)\n    {\n        return proxy.transferFrom(token, from, to, value);\n    }\n\n    /// @notice Updates the taker's eligibility for if they win the bet or tie.\n    /// @param order The order that is being filled.\n    /// @param orderAmounts The order amounts for this order.\n    /// @param taker The taker of this order.\n    function updateTakerEligibility(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts,\n        address taker\n    )\n        private\n    {\n        if (order.isMakerBettingOutcomeOne) {\n            escrow.increaseReturnAmount(\n                order.marketHash,\n                order.baseToken,\n                taker,\n                LibOutcome.Outcome.OUTCOME_TWO,\n                orderAmounts.potSize\n            );\n            escrow.updateStakedAmount(\n                order.marketHash,\n                order.baseToken,\n                taker,\n                LibOutcome.Outcome.OUTCOME_TWO,\n                orderAmounts.takerEscrow\n            );\n        } else {\n            escrow.increaseReturnAmount(\n                order.marketHash,\n                order.baseToken,\n                taker,\n                LibOutcome.Outcome.OUTCOME_ONE,\n                orderAmounts.potSize\n            );\n            escrow.updateStakedAmount(\n                order.marketHash,\n                order.baseToken,\n                taker,\n                LibOutcome.Outcome.OUTCOME_ONE,\n                orderAmounts.takerEscrow\n            );\n        }\n    }\n\n    /// @notice Updates the maker's eligibility for if they win the bet or tie.\n    /// @param order The order that is being filled.\n    /// @param orderAmounts The order amounts for this order.\n    function updateMakerEligibility(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts\n    )\n        private\n    {\n        if (order.isMakerBettingOutcomeOne) {\n            escrow.increaseReturnAmount(\n                order.marketHash,\n                order.baseToken,\n                order.maker,\n                LibOutcome.Outcome.OUTCOME_ONE,\n                orderAmounts.potSize\n            );\n            escrow.updateStakedAmount(\n                order.marketHash,\n                order.baseToken,\n                order.maker,\n                LibOutcome.Outcome.OUTCOME_ONE,\n                orderAmounts.takerAmount\n            );\n        } else {\n            escrow.increaseReturnAmount(\n                order.marketHash,\n                order.baseToken,\n                order.maker,\n                LibOutcome.Outcome.OUTCOME_TWO,\n                orderAmounts.potSize\n            );\n            escrow.updateStakedAmount(\n                order.marketHash,\n                order.baseToken,\n                order.maker,\n                LibOutcome.Outcome.OUTCOME_TWO,\n                orderAmounts.takerAmount\n            );\n        }\n    }\n\n    /// @notice Settles base tokens (not buyer and seller tokens) for the maker.\n    /// @param order The order to settle.\n    /// @param orderAmounts The resulting order amounts given the taker amount and parameters.\n    function settleTransfersForMaker(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts\n    )\n        private\n    {\n        require(\n            transferViaProxy(\n                order.baseToken,\n                order.maker,\n                address(escrow),\n                orderAmounts.takerAmount\n            ),\n            \"CANNOT_TRANSFER_TAKER_ESCROW\"\n        );\n    }\n\n    /// @notice Settles base tokens (not buyer and seller tokens) for the taker.\n    /// @param order The order to settle.\n    /// @param orderAmounts The resulting order amounts given the taker amount and parameters.\n    /// @param taker The taker of this order.\n    function settleTransfersForTaker(\n        LibOrder.Order memory order,\n        LibOrderAmounts.OrderAmounts memory orderAmounts,\n        address taker\n    )\n        private\n    {\n        require(\n            transferViaProxy(\n                order.baseToken,\n                taker,\n                address(escrow),\n                orderAmounts.takerEscrow\n            ),\n            \"CANNOT_TRANSFER_TAKER_ESCROW\"\n        );\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/CancelOrder.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\nimport \"../../interfaces/permissions/ISuperAdminRole.sol\";\nimport \"../../interfaces/trading/IFills.sol\";\nimport \"../../interfaces/trading/ICancelOrder.sol\";\nimport \"../Initializable.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\n/// @title CancelOrder\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Manages functionality to cancel orders\ncontract CancelOrder is ICancelOrder, Initializable {\n    using LibOrder for LibOrder.Order;\n    using SafeMath for uint256;\n\n    ISuperAdminRole private superAdminRole;\n    IFills private fills;\n\n    event OrderCancel(\n        address indexed maker,\n        bytes32 orderHash,\n        LibOrder.Order order\n    );\n\n    constructor(ISuperAdminRole _superAdminRole) public Initializable() {\n        superAdminRole = _superAdminRole;\n    }\n\n    /// @notice Throws if the caller is not a super admin.\n    /// @param operator The caller of the method.\n    modifier onlySuperAdmin(address operator) {\n        require(\n            superAdminRole.isSuperAdmin(operator),\n            \"NOT_A_SUPER_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Initializes this contract with reference to other contracts\n    ///         in the protocol.\n    /// @param _fills The Fills contract.\n    function initialize(IFills _fills)\n        external\n        notInitialized\n        onlySuperAdmin(msg.sender)\n    {\n        fills = _fills;\n        initialized = true;\n    }\n\n    /// @notice Cancels an order and prevents and further filling.\n    ///         Uses the order hash to uniquely ID the order.\n    /// @param order The order to cancel.\n    function cancelOrder(LibOrder.Order memory order) public {\n        assertCancelValid(order, msg.sender);\n        fills.cancel(order);\n\n        emit OrderCancel(\n            order.maker,\n            order.getOrderHash(),\n            order\n        );\n    }\n\n    /// @notice Cancels multiple orders and prevents further filling.\n    /// @param makerOrders The orders to cancel.\n    function batchCancelOrders(LibOrder.Order[] memory makerOrders) public {\n        uint256 makerOrdersLength = makerOrders.length;\n        for (uint256 i = 0; i < makerOrdersLength; i++) {\n            cancelOrder(makerOrders[i]);\n        }\n    }\n\n    /// @notice Checks if a cancel is valid by the canceller.\n    /// @param order The order to cancel.\n    /// @param canceller The canceller that must be the maker.\n    function assertCancelValid(\n        LibOrder.Order memory order,\n        address canceller\n    )\n        private\n        view\n    {\n        require(\n            order.executor == address(0),\n            \"EXECUTOR_CANNOT_BE_SET\"\n        );\n        order.assertValidAsMaker(canceller);\n        require(\n            fills.remainingSpace(order) > 0,\n            \"INSUFFICIENT_SPACE\"\n        );\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/EIP712FillHasher.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\n\n\ncontract EIP712FillHasher {\n\n    // EIP191 header for EIP712 prefix\n    bytes2 constant private EIP191_HEADER = 0x1901;\n\n    // EIP712 Domain Name value\n    string constant private EIP712_DOMAIN_NAME = \"SportX\";\n\n    // EIP712 Domain Version value\n    string constant private EIP712_DOMAIN_VERSION = \"1.0\";\n\n    // EIP712 typeHash of EIP712Domain\n    bytes32 constant private EIP712_DOMAIN_SCHEMA_HASH = keccak256(\n        abi.encodePacked(\n            \"EIP712Domain(\",\n            \"string name,\",\n            \"string version,\",\n            \"uint256 chainId,\",\n            \"address verifyingContract\",\n            \")\"\n        )\n    );\n\n    // EIP712 encodeType of Details\n    bytes constant private EIP712_DETAILS_STRING = abi.encodePacked(\n        \"Details(\",\n        \"string action,\",\n        \"string market,\",\n        \"string betting,\",\n        \"string stake,\",\n        \"string odds,\",\n        \"string returning,\",\n        \"FillObject fills\",\n        \")\"\n    );\n\n    // EIP712 encodeType of FillObject\n    bytes constant private EIP712_FILL_OBJECT_STRING = abi.encodePacked(\n        \"FillObject(\",\n        \"Order[] orders,\",\n        \"bytes[] makerSigs,\",\n        \"uint256[] takerAmounts,\",\n        \"uint256 fillSalt\",\n        \")\"\n    );\n\n    // EIP712 encodeType of Order\n    bytes constant private EIP712_ORDER_STRING = abi.encodePacked(\n        \"Order(\",\n        \"bytes32 marketHash,\",\n        \"address baseToken,\",\n        \"uint256 totalBetSize,\",\n        \"uint256 percentageOdds,\",\n        \"uint256 expiry,\",\n        \"uint256 salt,\",\n        \"address maker,\",\n        \"address executor,\",\n        \"bool isMakerBettingOutcomeOne\",\n        \")\"\n    );\n\n    // EIP712 typeHash of Order\n    bytes32 constant private EIP712_ORDER_HASH = keccak256(\n        abi.encodePacked(\n            EIP712_ORDER_STRING\n        )\n    );\n\n    // EIP712 typeHash of FillObject\n    bytes32 constant private EIP712_FILL_OBJECT_HASH = keccak256(\n        abi.encodePacked(\n            EIP712_FILL_OBJECT_STRING,\n            EIP712_ORDER_STRING\n        )\n    );\n\n    // EIP712 typeHash of FillObjectWithMetadata\n    bytes32 constant private EIP712_DETAILS_HASH = keccak256(\n        abi.encodePacked(\n            EIP712_DETAILS_STRING,\n            EIP712_FILL_OBJECT_STRING,\n            EIP712_ORDER_STRING\n        )\n    );\n\n    // solhint-disable var-name-mixedcase\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor(uint256 chainId) public {\n        EIP712_DOMAIN_HASH = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SCHEMA_HASH,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function getOrderHash(LibOrder.Order memory order)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                EIP712_ORDER_HASH,\n                order.marketHash,\n                order.baseToken,\n                order.totalBetSize,\n                order.percentageOdds,\n                order.expiry,\n                order.salt,\n                order.maker,\n                order.executor,\n                order.isMakerBettingOutcomeOne\n            )\n        );\n    }\n\n    function getOrdersArrayHash(LibOrder.Order[] memory orders)\n        public\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory ordersBytes = new bytes32[](orders.length);\n\n        for (uint256 i = 0; i < orders.length; i++) {\n            ordersBytes[i] = getOrderHash(orders[i]);\n        }\n        return keccak256(abi.encodePacked(ordersBytes));\n    }\n\n    function getMakerSigsArrayHash(bytes[] memory sigs)\n        public\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory sigsBytes = new bytes32[](sigs.length);\n\n        for (uint256 i = 0; i < sigs.length; i++) {\n            sigsBytes[i] = keccak256(sigs[i]);\n        }\n\n        return keccak256(abi.encodePacked(sigsBytes));\n    }\n\n    function getFillObjectHash(LibOrder.FillObject memory fillObject)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                EIP712_FILL_OBJECT_HASH,\n                getOrdersArrayHash(fillObject.orders),\n                getMakerSigsArrayHash(fillObject.makerSigs),\n                keccak256(abi.encodePacked(fillObject.takerAmounts)),\n                fillObject.fillSalt\n            )\n        );\n    }\n\n    function getDetailsHash(LibOrder.FillDetails memory details)\n        public\n        view\n        returns (bytes32)\n    {\n        bytes32 structHash = keccak256(\n            abi.encode(\n                EIP712_DETAILS_HASH,\n                keccak256(bytes(details.action)),\n                keccak256(bytes(details.market)),\n                keccak256(bytes(details.betting)),\n                keccak256(bytes(details.stake)),\n                keccak256(bytes(details.odds)),\n                keccak256(bytes(details.returning)),\n                getFillObjectHash(details.fills)\n            )\n        );\n        return keccak256(\n            abi.encodePacked(\n                EIP191_HEADER,\n                EIP712_DOMAIN_HASH,\n                structHash\n            )\n        );\n    }\n\n    function getDomainHash()\n        public\n        view\n        returns (bytes32)\n    {\n        return EIP712_DOMAIN_HASH;\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/FeeSchedule.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/permissions/IWhitelist.sol\";\nimport \"../../interfaces/trading/IFeeSchedule.sol\";\nimport \"../../libraries/LibOrder.sol\";\n\n\n/// @title FeeSchedule\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Stores the oracle fee for each token (which will presumably all be the same)\ncontract FeeSchedule is IFeeSchedule {\n\n    IWhitelist private systemParamsWhitelist;\n\n    mapping(address => uint256) private oracleFees; // the convention is 10**20 = 100%\n\n    event NewOracleFee(\n        address indexed token,\n        uint256 feeFrac\n    );\n\n    constructor(IWhitelist _systemParamsWhitelist) public {\n        systemParamsWhitelist = _systemParamsWhitelist;\n    }\n\n    /// @notice Throws if the caller is not a system params admin.\n    modifier onlySystemParamsAdmin() {\n        require(\n            systemParamsWhitelist.getWhitelisted(msg.sender),\n            \"NOT_SYSTEM_PARAM_ADMIN\"\n        );\n        _;\n    }\n\n    /// @notice Throws if the fee is too high.\n    modifier underMaxOracleFee(uint256 feeFrac) {\n        require(\n            feeFrac < LibOrder.getOddsPrecision(),\n            \"ORACLE_FEE_TOO_HIGH\"\n        );\n        _;\n    }\n\n    /// @notice Gets the oracle fee for the given token.\n    /// @param token The token of interest.\n    /// @return The oracle fee for this token.\n    function getOracleFees(address token) public view returns (uint256) {\n        return oracleFees[token];\n    }\n\n    /// @notice Sets the oracle fee for the given token.\n    /// @param token The token to set.\n    /// @param feeFrac The numerator of the fee fraction\n    function setOracleFee(address token, uint256 feeFrac)\n        public\n        onlySystemParamsAdmin\n        underMaxOracleFee(feeFrac)\n    {\n        oracleFees[token] = feeFrac;\n\n        emit NewOracleFee(\n            token,\n            feeFrac\n        );\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/FillOrder.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./BaseFillOrder.sol\";\nimport \"../../interfaces/trading/IFillOrder.sol\";\nimport \"../../interfaces/trading/IEIP712FillHasher.sol\";\n\n\n/// @title MultiFillOrder\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Manages the public functionality to fill multiple orders at once\ncontract FillOrder is IFillOrder, BaseFillOrder {\n\n    IEIP712FillHasher internal eip712FillHasher;\n\n    constructor(ISuperAdminRole _superAdminRole, IEIP712FillHasher _eip712FillHasher) public BaseFillOrder(_superAdminRole) {\n        eip712FillHasher = _eip712FillHasher;\n    }\n\n    /// @notice Fills a bunch of orders simulatenously.\n    /// @param fillDetails The fills to execute.\n    /// @param executorSig The signature of the executor on this fill if the executor is set.\n    function fillOrders(\n        LibOrder.FillDetails memory fillDetails,\n        bytes memory executorSig\n    )\n        public\n    {\n        address executor = fillDetails.fills.orders[0].executor;\n        bytes32 fillHash;\n\n        require(\n            fillDetails.fills.orders.length == fillDetails.fills.takerAmounts.length &&\n            fillDetails.fills.orders.length == fillDetails.fills.makerSigs.length,\n            \"INCORRECT_ARRAY_LENGTHS\"\n        );\n\n        if (executor != address(0)) {\n            fillHash = eip712FillHasher.getDetailsHash(fillDetails);\n\n            require(\n                fills.getFillHashSubmitted(fillHash) == false,\n                \"FILL_ALREADY_SUBMITTED\"\n            );\n\n            require(\n                ECDSA.recover(\n                    fillHash,\n                    executorSig\n                ) == executor,\n                \"EXECUTOR_SIGNATURE_MISMATCH\"\n            );\n\n            if (fillDetails.fills.orders.length > 1) {\n                for (uint256 i = 1; i < fillDetails.fills.orders.length; i++) {\n                    require(\n                        fillDetails.fills.orders[i].executor == executor,\n                        \"INCONSISTENT_EXECUTORS\"\n                    );\n                }\n            }\n\n            fills.setFillHashSubmitted(fillHash);\n        }\n\n        _fillOrders(\n            fillDetails.fills.orders,\n            fillDetails.fills.takerAmounts,\n            fillDetails.fills.makerSigs,\n            msg.sender,\n            fillHash\n        );\n\n    }\n\n    /// @notice Fills a bunch of orders simulatenously in meta fashion\n    /// @param fillDetails The details of the fill\n    /// @param taker The taker for this fill.\n    /// @param takerSig The signature of the taker for this fill.\n    /// @param executorSig The signature of the executor on this order if the executor is set.\n    function metaFillOrders(\n        LibOrder.FillDetails memory fillDetails,\n        address taker,\n        bytes memory takerSig,\n        bytes memory executorSig\n    )\n        public\n    {\n        bytes32 fillHash = eip712FillHasher.getDetailsHash(fillDetails);\n\n        require(\n            ECDSA.recover(\n                fillHash,\n                takerSig\n            ) == taker,\n            \"TAKER_SIGNATURE_MISMATCH\"\n        );\n\n        require(\n            fills.getFillHashSubmitted(fillHash) == false,\n            \"FILL_ALREADY_SUBMITTED\"\n        );\n\n        address executor = fillDetails.fills.orders[0].executor;\n\n        if (executor != address(0)) {\n            require(\n                msg.sender == executor,\n                \"SENDER_MUST_BE_EXECUTOR\"\n            );\n            require(\n                ECDSA.recover(\n                    fillHash,\n                    executorSig\n                ) == executor,\n                \"EXECUTOR_SIGNATURE_MISMATCH\"\n            );\n        }\n\n        require(\n            fillDetails.fills.orders.length == fillDetails.fills.takerAmounts.length &&\n            fillDetails.fills.orders.length == fillDetails.fills.makerSigs.length,\n            \"INCORRECT_ARRAY_LENGTHS\"\n        );\n\n        if (fillDetails.fills.orders.length > 1) {\n            for (uint256 i = 1; i < fillDetails.fills.orders.length; i++) {\n                require(\n                    fillDetails.fills.orders[i].executor == executor,\n                    \"INCONSISTENT_EXECUTORS\"\n                );\n            }\n        }\n\n        _fillOrders(\n            fillDetails.fills.orders,\n            fillDetails.fills.takerAmounts,\n            fillDetails.fills.makerSigs,\n            taker,\n            fillHash\n        );\n\n        fills.setFillHashSubmitted(fillHash);\n    }\n\n    /// @notice Internal method to fill multiple orders.\n    ///         Checks if the fill can be optimized for the taker (i.e., transfers can be combined).\n    /// @param makerOrders The orders to fill.\n    /// @param takerAmounts The amount to fill for each order.\n    /// @param makerSigs The maker signatures for each order.\n    /// @param taker The taker of these orders.\n    /// @param fillHash The fill hash, if applicable in the case of a meta fill.\n    function _fillOrders(\n        LibOrder.Order[] memory makerOrders,\n        uint256[] memory takerAmounts,\n        bytes[] memory makerSigs,\n        address taker,\n        bytes32 fillHash\n    )\n        private\n    {\n        bool areOrdersSimilar = areOrdersValidAndSimilar(\n            makerOrders,\n            takerAmounts,\n            makerSigs,\n            taker\n        );\n        // If we get here they are valid so no need to check again\n\n        if (areOrdersSimilar) {\n            _fillSimilarOrders(\n                makerOrders,\n                takerAmounts,\n                taker,\n                fillHash\n            );\n        } else {\n            for (uint256 i = 0; i < makerOrders.length; i++) {\n                _fillSingleOrder(\n                    makerOrders[i],\n                    takerAmounts[i],\n                    taker,\n                    fillHash\n                );\n            }\n        }\n    }\n\n    /// @notice Internal method to fill multiple similar orders\n    ///         Here, the taker transfers are batched to save gas.\n    /// @param makerOrders The orders to fill.\n    /// @param takerAmounts The amount to fill for each order.\n    /// @param taker The taker of these orders.\n    /// @param fillHash The fill hash, if applicable in the case of a meta fill.\n    function _fillSimilarOrders(\n        LibOrder.Order[] memory makerOrders,\n        uint256[] memory takerAmounts,\n        address taker,\n        bytes32 fillHash\n    )\n        private\n    {\n        LibOrderAmounts.OrderAmounts memory totalOrderAmounts = LibOrderAmounts.computeTotalOrderAmounts(\n            makerOrders,\n            takerAmounts\n        );\n\n        settleOrderForTaker(\n            makerOrders[0],\n            totalOrderAmounts,\n            taker\n        );\n\n        settleOrdersForMaker(\n            makerOrders,\n            takerAmounts,\n            taker,\n            fillHash\n        );\n    }\n\n    /// @notice Checks if orders are valid and similar.\n    ///         If they are, then we can optimize the fill\n    /// @param makerOrders The orders to fill.\n    /// @param takerAmounts The amount to fill for each order.\n    /// @param makerSigs The maker signatures for each order.\n    /// @param taker The taker of these orders.\n    function areOrdersValidAndSimilar(\n        LibOrder.Order[] memory makerOrders,\n        uint256[] memory takerAmounts,\n        bytes[] memory makerSigs,\n        address taker\n    )\n        private\n        view\n        returns (bool)\n    {\n        bool isMakerBettingOutcomeOne = makerOrders[0].isMakerBettingOutcomeOne;\n        bytes32 marketHash = makerOrders[0].marketHash;\n        address baseToken = makerOrders[0].baseToken;\n\n        for (uint256 i = 0; i < makerOrders.length; i++) {\n            assertOrderValid(\n                makerOrders[i],\n                takerAmounts[i],\n                taker,\n                makerSigs[i]\n            );\n        }\n\n        if (makerOrders.length > 1) {\n            for (uint256 i = 1; i < makerOrders.length; i++) {\n                if (makerOrders[i].isMakerBettingOutcomeOne != isMakerBettingOutcomeOne ||\n                    makerOrders[i].marketHash != marketHash ||\n                    makerOrders[i].baseToken != baseToken\n                ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /// @notice Settles multiple orders for the maker at once.\n    /// @param makerOrders The orders to fill.\n    /// @param takerAmounts The amount to fill for each order.\n    /// @param taker The taker of these orders.\n    /// @param fillHash The fill hash, if applicable in the case of a meta fill.\n    function settleOrdersForMaker(\n        LibOrder.Order[] memory makerOrders,\n        uint256[] memory takerAmounts,\n        address taker,\n        bytes32 fillHash\n    )\n        private\n    {\n        for (uint256 i = 0; i < makerOrders.length; i++) {\n            LibOrderAmounts.OrderAmounts memory orderAmounts = LibOrderAmounts.computeOrderAmounts(\n                makerOrders[i],\n                takerAmounts[i]\n            );\n\n            uint256 newFillAmount = fills.fill(makerOrders[i], orderAmounts.takerAmount);\n\n            settleOrderForMaker(\n                makerOrders[i],\n                orderAmounts\n            );\n\n            emit OrderFill(\n                makerOrders[i].maker,\n                makerOrders[i].marketHash,\n                taker,\n                newFillAmount,\n                makerOrders[i].getOrderHash(),\n                fillHash,\n                makerOrders[i],\n                orderAmounts\n            );\n        }\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/Fills.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\nimport \"../../interfaces/trading/IFillOrder.sol\";\nimport \"../../interfaces/trading/ICancelOrder.sol\";\nimport \"../../interfaces/trading/IFills.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\n/// @title Fills\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Stores the \"fullness\" of each order, whose ID\n///         is its hash.\ncontract Fills is IFills {\n    using LibOrder for LibOrder.Order;\n    using SafeMath for uint256;\n\n    IFillOrder private fillOrder;\n    ICancelOrder private cancelOrder;\n\n    mapping(bytes32 => uint256) private filled;\n    mapping(bytes32 => bool) private cancelled;\n    mapping(bytes32 => bool) private fillHashSubmitted;\n\n    /// @notice Throws if the caller is not the FillOrder contract.\n    modifier onlyFillOrder() {\n        require(\n            msg.sender == address(fillOrder),\n            \"ONLY_FILL_ORDER\"\n        );\n        _;\n    }\n\n    /// @notice Throws if the caller is not the CancelOrder contract.\n    modifier onlyCancelOrderContract() {\n        require(\n            msg.sender == address(cancelOrder),\n            \"ONLY_CANCEL_ORDER_CONTRACT\"\n        );\n        _;\n    }\n\n    constructor(IFillOrder _fillOrder, ICancelOrder _cancelOrder) public {\n        fillOrder = _fillOrder;\n        cancelOrder = _cancelOrder;\n    }\n\n    /// @notice Fill an order by the given amount.\n    /// @param order The order to fill.\n    /// @param amount The amount to fill it by.\n    /// @return The new filled amount for this order.\n    function fill(\n        LibOrder.Order memory order,\n        uint256 amount\n    )\n        public\n        onlyFillOrder\n        returns (uint256)\n    {\n        bytes32 orderHash = order.getOrderHash();\n        filled[orderHash] = filled[orderHash].add(amount);\n        return filled[orderHash];\n    }\n\n    /// @notice Cancels an order.\n    /// @param order The order to cancel.\n    function cancel(LibOrder.Order memory order)\n        public\n        onlyCancelOrderContract\n    {\n        bytes32 orderHash = order.getOrderHash();\n        cancelled[orderHash] = true;\n    }\n\n    function setFillHashSubmitted(bytes32 fillHash)\n        public\n        onlyFillOrder\n    {\n        fillHashSubmitted[fillHash] = true;\n    }\n\n    function getFilled(bytes32 orderHash) public view returns (uint256) {\n        return filled[orderHash];\n    }\n\n    function getCancelled(bytes32 orderHash) public view returns (bool) {\n        return cancelled[orderHash];\n    }\n\n    function getFillHashSubmitted(bytes32 orderHash) public view returns (bool) {\n        return fillHashSubmitted[orderHash];\n    }\n\n    /// @notice Check if an order has sufficient space.\n    /// @param order The order to examine.\n    /// @param takerAmount The amount to fill.\n    /// @return true if there is enough space, false otherwise.\n    function orderHasSpace(\n        LibOrder.Order memory order,\n        uint256 takerAmount\n    )\n        public\n        view\n        returns (bool)\n    {\n        return takerAmount <= remainingSpace(order);\n    }\n\n    /// @notice Gets the remaining space for an order.\n    /// @param order The order to check.\n    /// @return The remaining space on the order. It returns 0 if\n    ///         the order is cancelled.\n    function remainingSpace(LibOrder.Order memory order)\n        public\n        view\n        returns (uint256)\n    {\n        bytes32 orderHash = order.getOrderHash();\n        if (cancelled[orderHash]) {\n            return 0;\n        } else {\n            return order.totalBetSize.sub(filled[orderHash]);\n        }\n    }\n\n    /// @notice Checks if the order is cancelled.\n    /// @param order The order to check.\n    /// @return true if the order is cancelled, false otherwise.\n    function isOrderCancelled(LibOrder.Order memory order)\n        public\n        view\n        returns(bool)\n    {\n        bytes32 orderHash = order.getOrderHash();\n        return cancelled[orderHash];\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/impl/trading/TokenTransferProxy.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/trading/IFillOrder.sol\";\nimport \"../../interfaces/trading/ITokenTransferProxy.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\n\n/// @title TokenTransferProxy\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Transfers tokens on behalf of the user.\ncontract TokenTransferProxy is ITokenTransferProxy {\n\n    IFillOrder private fillOrder;\n\n    constructor (IFillOrder _fillOrder) public {\n        fillOrder = _fillOrder;\n    }\n\n    /// @notice Throws if the caller is not a fill order contract derivative\n    modifier onlyFillOrder() {\n        require(\n            msg.sender == address(fillOrder),\n            \"ONLY_FILL_ORDER\"\n        );\n        _;\n    }\n\n    /// @notice Uses `transferFrom` and ERC20 approval to transfer tokens.\n    ///         Only callable by whitelisted addresses.\n    /// @param token The address of the ERC20 token to transfer on the user's behalf.\n    /// @param from The address of the user.\n    /// @param to The destination address.\n    /// @param value The amount to transfer.\n    function transferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    )\n        public\n        onlyFillOrder\n        returns (bool)\n    {\n        return IERC20(token).transferFrom(from, to, value);\n    }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/IAffiliateRegistry.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract IAffiliateRegistry {\n    function setAffiliate(address member, address affiliate) public;\n    function setAffiliateFeeFrac(address affiliate, uint256 fee) public;\n    function setDefaultAffiliate(address affiliate) public;\n    function getAffiliate(address member) public view returns (address);\n    function getAffiliateFeeFrac(address affiliate) public view returns (uint256);\n    function getDefaultAffiliate() public view returns (address);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/IEscrow.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/LibOutcome.sol\";\n\n\ncontract IEscrow {\n    struct Eligibility {\n        bool hasEligibility;\n        LibOutcome.Outcome outcome;\n        uint256 amount;\n    }\n\n    function getReturnAmount(bytes32, address, address, LibOutcome.Outcome) public view returns (uint256);\n    function getStakedAmount(bytes32, address, address, LibOutcome.Outcome) public view returns (uint256);\n    function settleBet(address, bytes32, address) public;\n    function updateStakedAmount(bytes32, address, address, LibOutcome.Outcome, uint256) public;\n    function increaseReturnAmount(bytes32, address, address, LibOutcome.Outcome, uint256) public;\n    function isMarketRedeemable(bytes32) public view returns (bool);\n    function getEligibility(address, bytes32, address) public view returns (Eligibility memory);\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/IOutcomeReporter.sol": {
      "content": "pragma solidity 0.5.16;\n\nimport \"../libraries/LibOutcome.sol\";\ncontract IOutcomeReporter {\n    function getReportedOutcome(bytes32)\n        public\n        view\n        returns (LibOutcome.Outcome);\n    function getReportTime(bytes32) public view returns (uint256);\n    function reportOutcome(bytes32, LibOutcome.Outcome) public;\n    function reportOutcomes(bytes32[] memory, LibOutcome.Outcome[] memory)\n        public;\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/ISystemParameters.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract ISystemParameters {\n    function getOracleFeeRecipient() public view returns (address);\n    function setNewOracleFeeRecipient(address) public;\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/extensions/IOrderValidator.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\ncontract IOrderValidator {\n    function getOrderStatus(LibOrder.Order memory, bytes memory)\n        public\n        view\n        returns (string memory);\n\n    function getMultiOrderStatus(LibOrder.Order[] memory, bytes[] memory)\n        public\n        view\n        returns (string[] memory);\n\n    function getFillStatus(LibOrder.FillDetails memory, bytes memory, address)\n        public\n        view\n        returns (string memory);\n\n    function getMetaFillStatus(\n        LibOrder.FillDetails memory,\n        address,\n        bytes memory,\n        bytes memory)\n        public view returns (string memory);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/permissions/ISuperAdminRole.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract ISuperAdminRole {\n    function isSuperAdmin(address account) public view returns (bool);\n    function addSuperAdmin(address account) public;\n    function removeSuperAdmin(address account) public;\n    function getSuperAdminCount() public view returns (uint256);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/permissions/IWhitelist.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract IWhitelist {\n    function addAddressToWhitelist(address) public;\n    function removeAddressFromWhitelist(address) public;\n    function getWhitelisted(address) public view returns (bool);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/tokens/IDetailedTokenDAI.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract IDetailedTokenDAI {\n    function name() public view returns (bytes32);\n    function symbol() public view returns (bytes32);\n    function decimals() public view returns (uint256);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/ICancelOrder.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\n\ncontract ICancelOrder {\n    function cancelOrder(LibOrder.Order memory order) public;\n    function batchCancelOrders(LibOrder.Order[] memory makerOrders) public;\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/IEIP712FillHasher.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\n\ncontract IEIP712FillHasher {\n    function getOrderHash(LibOrder.Order memory) public  pure returns (bytes32);\n    function getOrdersArrayHash(LibOrder.Order[] memory) public  pure returns (bytes32);\n    function getMakerSigsArrayHash(bytes[] memory) public  pure returns (bytes32);\n    function getTakerAmountsArrayHash(uint256[] memory) public  pure returns (bytes32);\n    function getFillObjectHash(LibOrder.FillObject memory) public  pure returns (bytes32);\n    function getDetailsHash(LibOrder.FillDetails memory) public  view returns (bytes32);\n    function getDomainHash() public  view returns (bytes32);\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/IFeeSchedule.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract IFeeSchedule {\n    function getOracleFees(address) public view returns (uint256);\n    function setOracleFee(address, uint256) public;\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/IFillOrder.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\n\ncontract IFillOrder {\n    function fillOrders(LibOrder.FillDetails memory, bytes memory) public;\n    function metaFillOrders(\n        LibOrder.FillDetails memory,\n        address,\n        bytes memory,\n        bytes memory)\n        public;\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/IFills.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\n\ncontract IFills {\n    function getFilled(bytes32) public view returns (uint256);\n    function getCancelled(bytes32) public view returns (bool);\n    function getFillHashSubmitted(bytes32) public view returns (bool);\n    function orderHasSpace(LibOrder.Order memory, uint256)\n        public\n        view\n        returns (bool);\n    function remainingSpace(LibOrder.Order memory)\n        public\n        view\n        returns (uint256);\n    function isOrderCancelled(LibOrder.Order memory) public view returns (bool);\n    function fill(LibOrder.Order memory, uint256) public returns (uint256);\n    function cancel(LibOrder.Order memory) public;\n    function setFillHashSubmitted(bytes32) public;\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/IReadOnlyValidator.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"../../libraries/LibOrder.sol\";\n\ncontract IReadOnlyValidator {\n    function getOrderStatus(LibOrder.Order memory, bytes memory)\n        public\n        view\n        returns (string memory);\n    function getOrderStatusForTaker(\n        LibOrder.Order memory,\n        address,\n        uint256,\n        bytes memory)\n        public view returns (string memory);\n    function getCumulativeOrderStatusForTaker(\n        LibOrder.Order[] memory,\n        address,\n        uint256[] memory,\n        bytes[] memory)\n        public view returns (string memory);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/interfaces/trading/ITokenTransferProxy.sol": {
      "content": "pragma solidity 0.5.16;\n\ncontract ITokenTransferProxy {\n    function transferFrom(address, address, address, uint256)\n        public\n        returns (bool);\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/libraries/LibOrder.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\n\n/// @title LibOrder\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Central definition for what an \"order\" is along with utilities for an order.\nlibrary LibOrder {\n    using SafeMath for uint256;\n\n    uint256 public constant ODDS_PRECISION = 10**20;\n\n    struct Order {\n        bytes32 marketHash;\n        address baseToken;\n        uint256 totalBetSize;\n        uint256 percentageOdds;\n        uint256 expiry;\n        uint256 salt;\n        address maker;\n        address executor;\n        bool isMakerBettingOutcomeOne;\n    }\n\n    struct FillObject {\n        Order[] orders;\n        bytes[] makerSigs;\n        uint256[] takerAmounts;\n        uint256 fillSalt;\n    }\n\n    struct FillDetails {\n        string action;\n        string market;\n        string betting;\n        string stake;\n        string odds;\n        string returning;\n        FillObject fills;\n    }\n\n    /// @notice Checks the parameters of the given order to see if it conforms to the protocol.\n    /// @param order The order to check.\n    /// @return A status string in UPPER_SNAKE_CASE. It will return \"OK\" if everything checks out.\n    // solhint-disable code-complexity\n    function getParamValidity(Order memory order)\n        internal\n        view\n        returns (string memory)\n    {\n        if (order.totalBetSize == 0) {return \"TOTAL_BET_SIZE_ZERO\";}\n        if (order.percentageOdds == 0 || order.percentageOdds >= ODDS_PRECISION) {return \"INVALID_PERCENTAGE_ODDS\";}\n        if (order.expiry < now) {return \"ORDER_EXPIRED\";}\n        if (order.baseToken == address(0)) {return \"BASE_TOKEN\";}\n        return \"OK\";\n    }\n\n    /// @notice Checks the signature of an order to see if\n    ///         it was an order signed by the given maker.\n    /// @param order The order to check.\n    /// @param makerSig The signature to compare.\n    /// @return true if the signature matches, false otherwise.\n    function checkSignature(Order memory order, bytes memory makerSig)\n        internal\n        pure\n        returns (bool)\n    {\n        bytes32 orderHash = getOrderHash(order);\n        return ECDSA.recover(ECDSA.toEthSignedMessageHash(orderHash), makerSig) == order.maker;\n    }\n\n    /// @notice Checks if an order's parameters conforms to the protocol's specifications.\n    /// @param order The order to check.\n    function assertValidParams(Order memory order) internal view {\n        require(\n            order.totalBetSize > 0,\n            \"TOTAL_BET_SIZE_ZERO\"\n        );\n        require(\n            order.percentageOdds > 0 && order.percentageOdds < ODDS_PRECISION,\n            \"INVALID_PERCENTAGE_ODDS\"\n        );\n        require(order.baseToken != address(0), \"INVALID_BASE_TOKEN\");\n        require(order.expiry > now, \"ORDER_EXPIRED\");\n    }\n\n    /// @notice Checks if an order has valid parameters including\n    ///         the signature and checks if the maker is not the taker.\n    /// @param order The order to check.\n    /// @param taker The hypothetical filler of this order, i.e., the taker.\n    /// @param makerSig The signature to check.\n    function assertValidAsTaker(Order memory order, address taker, bytes memory makerSig) internal view {\n        assertValidParams(order);\n        require(\n            checkSignature(order, makerSig),\n            \"SIGNATURE_MISMATCH\"\n        );\n        require(order.maker != taker, \"TAKER_NOT_MAKER\");\n    }\n\n    /// @notice Checks if the order has valid parameters\n    ///         and checks if the sender is the maker.\n    /// @param order The order to check.\n    /// @param sender The address to compare the maker to.\n    function assertValidAsMaker(Order memory order, address sender) internal view {\n        assertValidParams(order);\n        require(order.maker == sender, \"CALLER_NOT_MAKER\");\n    }\n\n    /// @notice Computes the hash of an order. Packs the arguments in order\n    ///         of the Order struct.\n    /// @param order The order to compute the hash of.\n    function getOrderHash(Order memory order) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                order.marketHash,\n                order.baseToken,\n                order.totalBetSize,\n                order.percentageOdds,\n                order.expiry,\n                order.salt,\n                order.maker,\n                order.executor,\n                order.isMakerBettingOutcomeOne\n            )\n        );\n    }\n\n    function getOddsPrecision() internal pure returns (uint256) {\n        return ODDS_PRECISION;\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/libraries/LibOrderAmounts.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./LibOrder.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\n/// @title LibOrderAmounts\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Struct definition for the resulting individual computed amounts\n///         when filling an order.\nlibrary LibOrderAmounts {\n    using SafeMath for uint256;\n\n    struct OrderAmounts {\n        uint256 takerAmount;\n        uint256 takerEscrow;\n        uint256 potSize;\n    }\n\n    /// @notice Computes the tokens that should be transferred as a result of\n    ///         the order and the specified fill amount.\n    /// @param order The reference maker order\n    /// @param takerAmount The amount to fill of this order.\n    /// @return An OrderAmounts struct.\n    function computeOrderAmounts(\n        LibOrder.Order memory order,\n        uint256 takerAmount\n    )\n        internal\n        pure\n        returns (LibOrderAmounts.OrderAmounts memory)\n    {\n        uint256 oddsPrecision = LibOrder.getOddsPrecision();\n        uint256 potSize = takerAmount.mul(oddsPrecision).div(order.percentageOdds);\n        uint256 takerEscrow = potSize.sub(takerAmount);\n\n        return LibOrderAmounts.OrderAmounts({\n            takerAmount: takerAmount,\n            takerEscrow: takerEscrow,\n            potSize: potSize\n        });\n    }\n\n    /// @notice Combines two OrderAmounts into one by adding up\n    ///         the values\n    /// @param orderAmount1 The first OrderAmount\n    /// @param orderAmount2 The second OrderAmount\n    /// @return The combined OrderAmounts struct.\n    function reduceOrderAmounts(\n        LibOrderAmounts.OrderAmounts memory orderAmount1,\n        LibOrderAmounts.OrderAmounts memory orderAmount2\n    )\n        internal\n        pure\n        returns (LibOrderAmounts.OrderAmounts memory)\n    {\n        return LibOrderAmounts.OrderAmounts({\n            takerAmount: orderAmount1.takerAmount.add(orderAmount2.takerAmount),\n            takerEscrow: orderAmount1.takerEscrow.add(orderAmount2.takerEscrow),\n            potSize: orderAmount1.potSize.add(orderAmount2.potSize)\n        });\n    }\n\n    /// @notice Takes a bunch of orders and taker amounts\n    ///         and computes the total order amounts\n    /// @param makerOrders The reference maker orders\n    /// @param takerAmounts An array of taker amounts, one for each order\n    /// @return The total OrderAmounts struct.\n    function computeTotalOrderAmounts(\n        LibOrder.Order[] memory makerOrders,\n        uint256[] memory takerAmounts\n    )\n        internal\n        pure\n        returns (LibOrderAmounts.OrderAmounts memory)\n    {\n        LibOrderAmounts.OrderAmounts memory combinedOrderAmounts;\n        uint256 makerOrdersLength = makerOrders.length;\n        for (uint256 i = 0; i < makerOrdersLength; i++) {\n            LibOrderAmounts.OrderAmounts memory orderAmounts = computeOrderAmounts(\n                makerOrders[i],\n                takerAmounts[i]\n            );\n            combinedOrderAmounts = reduceOrderAmounts(combinedOrderAmounts, orderAmounts);\n        }\n        return combinedOrderAmounts;\n    }\n}"
    },
    "/home/julian/betx/betx-contracts/contracts/libraries/LibOutcome.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/// @title LibOutcome\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Enumerations and utilities related to voting.\nlibrary LibOutcome {\n    enum Outcome { VOID, OUTCOME_ONE, OUTCOME_TWO }\n}\n"
    },
    "/home/julian/betx/betx-contracts/contracts/libraries/LibString.sol": {
      "content": "pragma solidity 0.5.16;\npragma experimental ABIEncoderV2;\n\n\n/// @title LibString\n/// @author Julian Wilson <julian@nextgenbt.com>\n/// @notice Utility to efficiently compare strings when necessary.\nlibrary LibString {\n\n    /// @notice Compares two strings by taking their hash.\n    /// @param a The first string.\n    /// @param b The second string.\n    /// @return true or false depending on if the strings matched.\n    function equals(string memory a, string memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n    }\n}"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n    * @dev Multiplies two unsigned integers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two unsigned integers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Roles.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title Elliptic curve signature operations\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\n * See https://github.com/ethereum/solidity/issues/864\n */\n\nlibrary ECDSA {\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n            v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n            return (address(0));\n        } else {\n            return ecrecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * toEthSignedMessageHash\n     * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\n     * and hash the result\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}