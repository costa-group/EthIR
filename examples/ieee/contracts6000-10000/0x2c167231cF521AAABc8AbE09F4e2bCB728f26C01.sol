{{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "ROOT=/home/achapman/augur/packages/augur-core/src/contracts//"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "trading/ProfitLoss.sol": {
      "content": "pragma solidity 0.5.15;\n\ncontract IAugur {\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool);\n    function isTrustedSender(address _address) public returns (bool);\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool);\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool);\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool);\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool);\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool);\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool);\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool);\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool);\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool);\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool);\n    function logParticipationTokensRedeemed(IUniverse universe, address _sender, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool);\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool);\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool);\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\n    function lookup(bytes32 _key) public view returns (address);\n    function getTimestamp() public view returns (uint256);\n    function getMaximumMarketEndDate() public returns (uint256);\n    function isKnownMarket(IMarket _market) public view returns (bool);\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 numOutcomes) public view returns (bytes32);\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool);\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool);\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool);\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256);\n}\n\ncontract IOwnable {\n    function getOwner() public view returns (address);\n    function transferOwnership(address _newOwner) public returns (bool);\n}\n\ncontract ITyped {\n    function getTypeName() public view returns (bytes32);\n}\n\ncontract Initializable {\n    bool private initialized = false;\n\n    modifier beforeInitialized {\n        require(!initialized);\n        _;\n    }\n\n    function endInitialization() internal beforeInitialized {\n        initialized = true;\n    }\n\n    function getInitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\nlibrary SafeMathInt256 {\n    // Signed ints with n bits can range from -2**(n-1) to (2**(n-1) - 1)\n    int256 private constant INT256_MIN = -2**(255);\n    int256 private constant INT256_MAX = (2**(255) - 1);\n\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n        require(a == 0 || c / a == b);\n        return c;\n    }\n\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // No need to check for dividing by 0 -- Solidity automatically throws on division by 0\n        int256 c = a / b;\n        return c;\n    }\n\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        require(((a >= 0) && (b >= a - INT256_MAX)) || ((a < 0) && (b <= a - INT256_MIN)));\n        return a - b;\n    }\n\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        require(((a >= 0) && (b <= INT256_MAX - a)) || ((a < 0) && (b >= INT256_MIN - a)));\n        return a + b;\n    }\n\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function abs(int256 a) internal pure returns (int256) {\n        if (a < 0) {\n            return -a;\n        }\n        return a;\n    }\n\n    function getInt256Min() internal pure returns (int256) {\n        return INT256_MIN;\n    }\n\n    function getInt256Max() internal pure returns (int256) {\n        return INT256_MAX;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(int256 a, int256 b, int256 base) internal pure returns (int256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(int256 a, int256 b, int256 base) internal pure returns (int256) {\n        return div(mul(a, base), b);\n    }\n}\n\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n\ninterface IERC1155 {\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    /// Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    ///Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /// @dev MUST emit when an approval is updated.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /// @dev MUST emit when the URI is updated for a token ID.\n    /// URIs are defined in RFC 3986.\n    /// The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\".\n    event URI(\n        string value,\n        uint256 indexed id\n    );\n\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\n    /// @dev MUST emit TransferSingle event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\n    /// @param from    Source address\n    /// @param to      Target address\n    /// @param id      ID of the token type\n    /// @param value   Transfer amount\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\n    /// @dev MUST emit TransferBatch event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\n    /// @param from    Source addresses\n    /// @param to      Target addresses\n    /// @param ids     IDs of each token type\n    /// @param values  Transfer amounts per token type\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param operator  Address to add to the set of authorized operators\n    /// @param approved  True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param owner     The owner of the Tokens\n    /// @param operator  Address of authorized operator\n    /// @return           True if the operator is approved, false if not\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Get the balance of an account's Tokens.\n    /// @param owner  The address of the token holder\n    /// @param id     ID of the Token\n    /// @return        The _owner's balance of the Token type requested\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @notice Get the total supply of a Token.\n    /// @param id     ID of the Token\n    /// @return        The total supply of the Token type requested\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param owners The addresses of the token holders\n    /// @param ids    ID of the Tokens\n    /// @return        The _owner's balance of the Token types requested\n    function balanceOfBatch(\n        address[] calldata owners,\n        uint256[] calldata ids\n    )\n        external\n        view\n        returns (uint256[] memory balances_);\n}\n\ncontract IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) public view returns (uint256);\n    function transfer(address to, uint256 amount) public returns (bool);\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ICash is IERC20 {\n}\n\ncontract IAffiliateValidator {\n    function validateReference(address _account, address _referrer) external view returns (bool);\n}\n\ncontract IDisputeWindow is ITyped, IERC20 {\n    function invalidMarketsTotal() external view returns (uint256);\n    function validityBondTotal() external view returns (uint256);\n\n    function incorrectDesignatedReportTotal() external view returns (uint256);\n    function initialReportBondTotal() external view returns (uint256);\n\n    function designatedReportNoShowsTotal() external view returns (uint256);\n    function designatedReporterNoShowBondTotal() external view returns (uint256);\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _disputeWindowId, bool _participationTokensEnabled, uint256 _duration, uint256 _startTime) public;\n    function trustedBuy(address _buyer, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getReputationToken() public view returns (IReputationToken);\n    function getStartTime() public view returns (uint256);\n    function getEndTime() public view returns (uint256);\n    function getWindowId() public view returns (uint256);\n    function isActive() public view returns (bool);\n    function isOver() public view returns (bool);\n    function onMarketFinalized() public;\n    function redeem(address _account) public returns (bool);\n}\n\ncontract IMarket is IOwnable {\n    enum MarketType {\n        YES_NO,\n        CATEGORICAL,\n        SCALAR\n    }\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public;\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32);\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getDisputeWindow() public view returns (IDisputeWindow);\n    function getNumberOfOutcomes() public view returns (uint256);\n    function getNumTicks() public view returns (uint256);\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n    function getForkingMarket() public view returns (IMarket _market);\n    function getEndTime() public view returns (uint256);\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningReportingParticipant() public view returns (IReportingParticipant);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getFinalizationTime() public view returns (uint256);\n    function getInitialReporter() public view returns (IInitialReporter);\n    function getDesignatedReportingEndTime() public view returns (uint256);\n    function getValidityBondAttoCash() public view returns (uint256);\n    function affiliateFeeDivisor() external view returns (uint256);\n    function getNumParticipants() public view returns (uint256);\n    function getDisputePacingOn() public view returns (bool);\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function isFinalizedAsInvalid() public view returns (bool);\n    function finalize() public returns (bool);\n    function isFinalized() public view returns (bool);\n    function getOpenInterest() public view returns (uint256);\n}\n\ncontract IReportingParticipant {\n    function getStake() public view returns (uint256);\n    function getPayoutDistributionHash() public view returns (bytes32);\n    function liquidateLosing() public;\n    function redeem(address _redeemer) public returns (bool);\n    function isDisavowed() public view returns (bool);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getMarket() public view returns (IMarket);\n    function getSize() public view returns (uint256);\n}\n\ncontract IInitialReporter is IReportingParticipant, IOwnable {\n    function initialize(IAugur _augur, IMarket _market, address _designatedReporter) public;\n    function report(address _reporter, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _initialReportStake) public;\n    function designatedReporterShowed() public view returns (bool);\n    function initialReporterWasCorrect() public view returns (bool);\n    function getDesignatedReporter() public view returns (address);\n    function getReportTimestamp() public view returns (uint256);\n    function migrateToNewUniverse(address _designatedReporter) public;\n    function returnRepFromDisavow() public;\n}\n\ncontract IReputationToken is IERC20 {\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool);\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getTotalMigrated() public view returns (uint256);\n    function getTotalTheoreticalSupply() public view returns (uint256);\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\n\ncontract IShareToken is ITyped, IERC1155 {\n    function initialize(IAugur _augur) external;\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public;\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external returns (uint256[] memory _outcomeFees);\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId);\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds);\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool);\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool);\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256);\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256);\n}\n\ncontract IUniverse {\n    function creationTime() external view returns (uint256);\n    function marketBalance(address) external view returns (uint256);\n\n    function fork() public returns (bool);\n    function updateForkValues() public returns (bool);\n    function getParentUniverse() public view returns (IUniverse);\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getForkingMarket() public view returns (IMarket);\n    function getForkEndTime() public view returns (uint256);\n    function getForkReputationGoal() public view returns (uint256);\n    function getParentPayoutDistributionHash() public view returns (bytes32);\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256);\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow);\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOpenInterestInAttoCash() public view returns (uint256);\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\n    function getOrCacheValidityBond() public returns (uint256);\n    function getOrCacheDesignatedReportStake() public returns (uint256);\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n    function getOrCacheMarketRepBond() public returns (uint256);\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\n    function getDisputeThresholdForFork() public view returns (uint256);\n    function getDisputeThresholdForDisputePacing() public view returns (uint256);\n    function getInitialReportMinValue() public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getReportingFeeDivisor() public view returns (uint256);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningChildPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function isOpenInterestCash(address) public view returns (bool);\n    function isForkingMarket() public view returns (bool);\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow);\n    function getDisputeWindowStartTimeAndDuration(uint256 _timestamp, bool _initial) public view returns (uint256, uint256);\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget) public view returns (bool);\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function migrateMarketOut(IUniverse _destinationUniverse) public returns (bool);\n    function migrateMarketIn(IMarket _market, uint256 _cashBalance, uint256 _marketOI) public returns (bool);\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\n    function decrementOpenInterestFromMarket(IMarket _market) public returns (bool);\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\n    function getWinningChildUniverse() public view returns (IUniverse);\n    function isForking() public view returns (bool);\n    function deposit(address _sender, uint256 _amount, address _market) public returns (bool);\n    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool);\n    function createScalarMarket(uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, int256[] memory _prices, uint256 _numTicks, string memory _extraInfo) public returns (IMarket _newMarket);\n}\n\ncontract IV2ReputationToken is IReputationToken {\n    function parentUniverse() external returns (IUniverse);\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool);\n}\n\ncontract IAugurTrading {\n    function lookup(bytes32 _key) public view returns (address);\n    function logProfitLossChanged(IMarket _market, address _account, uint256 _outcome, int256 _netPosition, uint256 _avgPrice, int256 _realizedProfit, int256 _frozenFunds, int256 _realizedCost) public returns (bool);\n    function logOrderCreated(IUniverse _universe, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logOrderCanceled(IUniverse _universe, IMarket _market, address _creator, uint256 _tokenRefund, uint256 _sharesRefund, bytes32 _orderId) public returns (bool);\n    function logOrderFilled(IUniverse _universe, address _creator, address _filler, uint256 _price, uint256 _fees, uint256 _amountFilled, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logMarketVolumeChanged(IUniverse _universe, address _market, uint256 _volume, uint256[] memory _outcomeVolumes, uint256 _totalTrades) public returns (bool);\n    function logZeroXOrderFilled(IUniverse _universe, IMarket _market, bytes32 _orderHash, bytes32 _tradeGroupId, uint8 _orderType, address[] memory _addressData, uint256[] memory _uint256Data) public returns (bool);\n    function logZeroXOrderCanceled(address _universe, address _market, address _account, uint256 _outcome, uint256 _price, uint256 _amount, uint8 _type, bytes32 _orderHash) public;\n}\n\ncontract IOrders {\n    function saveOrder(uint256[] calldata _uints, bytes32[] calldata _bytes32s, Order.Types _type, IMarket _market, address _sender) external returns (bytes32 _orderId);\n    function removeOrder(bytes32 _orderId) external returns (bool);\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\n    function getAmount(bytes32 _orderId) public view returns (uint256);\n    function getPrice(bytes32 _orderId) public view returns (uint256);\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderDataForCancel(bytes32 _orderId) public view returns (uint256, uint256, Order.Types, IMarket, uint256, address);\n    function getOrderDataForLogs(bytes32 _orderId) public view returns (Order.Types, address[] memory _addressData, uint256[] memory _uint256Data);\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled, uint256 _fill) external returns (bool);\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n}\n\nlibrary Order {\n    using SafeMathUint256 for uint256;\n\n    enum Types {\n        Bid, Ask\n    }\n\n    enum TradeDirections {\n        Long, Short\n    }\n\n    struct Data {\n        // Contracts\n        IMarket market;\n        IAugur augur;\n        IAugurTrading augurTrading;\n        IShareToken shareToken;\n        ICash cash;\n\n        // Order\n        bytes32 id;\n        address creator;\n        uint256 outcome;\n        Order.Types orderType;\n        uint256 amount;\n        uint256 price;\n        uint256 sharesEscrowed;\n        uint256 moneyEscrowed;\n        bytes32 betterOrderId;\n        bytes32 worseOrderId;\n    }\n\n    function create(IAugur _augur, IAugurTrading _augurTrading, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data memory) {\n        require(_outcome < _market.getNumberOfOutcomes(), \"Order.create: Outcome is not within market range\");\n        require(_price != 0, \"Order.create: Price may not be 0\");\n        require(_price < _market.getNumTicks(), \"Order.create: Price is outside of market range\");\n        require(_attoshares > 0, \"Order.create: Cannot use amount of 0\");\n        require(_creator != address(0), \"Order.create: Creator is 0x0\");\n\n        IShareToken _shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n\n        return Data({\n            market: _market,\n            augur: _augur,\n            augurTrading: _augurTrading,\n            shareToken: _shareToken,\n            cash: ICash(_augur.lookup(\"Cash\")),\n            id: 0,\n            creator: _creator,\n            outcome: _outcome,\n            orderType: _type,\n            amount: _attoshares,\n            price: _price,\n            sharesEscrowed: 0,\n            moneyEscrowed: 0,\n            betterOrderId: _betterOrderId,\n            worseOrderId: _worseOrderId\n        });\n    }\n\n    //\n    // \"public\" functions\n    //\n\n    function getOrderId(Order.Data memory _orderData, IOrders _orders) internal view returns (bytes32) {\n        if (_orderData.id == bytes32(0)) {\n            bytes32 _orderId = calculateOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n            require(_orders.getAmount(_orderId) == 0, \"Order.getOrderId: New order had amount. This should not be possible\");\n            _orderData.id = _orderId;\n        }\n        return _orderData.id;\n    }\n\n    function calculateOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(_type, _market, _amount, _price, _sender, _blockNumber, _outcome, _moneyEscrowed, _sharesEscrowed));\n    }\n\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n    }\n\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n    }\n\n    function saveOrder(Order.Data memory _orderData, bytes32 _tradeGroupId, IOrders _orders) internal returns (bytes32) {\n        getOrderId(_orderData, _orders);\n        uint256[] memory _uints = new uint256[](5);\n        _uints[0] = _orderData.amount;\n        _uints[1] = _orderData.price;\n        _uints[2] = _orderData.outcome;\n        _uints[3] = _orderData.moneyEscrowed;\n        _uints[4] = _orderData.sharesEscrowed;\n        bytes32[] memory _bytes32s = new bytes32[](4);\n        _bytes32s[0] = _orderData.betterOrderId;\n        _bytes32s[1] = _orderData.worseOrderId;\n        _bytes32s[2] = _tradeGroupId;\n        _bytes32s[3] = _orderData.id;\n        return _orders.saveOrder(_uints, _bytes32s, _orderData.orderType, _orderData.market, _orderData.creator);\n    }\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ncontract ProfitLoss is Initializable {\n    using SafeMathUint256 for uint256;\n    using SafeMathInt256 for int256;\n\n    IAugur public augur;\n    IAugurTrading public augurTrading;\n    IOrders public orders;\n    address public shareToken;\n    address public createOrder;\n    address public cancelOrder;\n    address public fillOrder;\n\n    struct OutcomeData {\n        int256 netPosition;\n        int256 avgPrice; // Cannot actually be negative. Typed for code convenience\n        int256 realizedProfit;\n        int256 frozenFunds;\n        int256 realizedCost; // Also cannot be negative.\n    }\n\n    // User => Market => Outcome => Data\n    mapping (address => mapping(address => mapping(uint256 => OutcomeData))) private profitLossData;\n\n    function initialize(IAugur _augur, IAugurTrading _augurTrading) public beforeInitialized {\n        endInitialization();\n        shareToken = _augur.lookup(\"ShareToken\");\n        require(shareToken != address(0));\n\n        augur = _augur;\n        augurTrading = _augurTrading;\n        createOrder = _augurTrading.lookup(\"CreateOrder\");\n        cancelOrder = _augurTrading.lookup(\"CancelOrder\");\n        fillOrder = _augurTrading.lookup(\"FillOrder\");\n        orders = IOrders(_augurTrading.lookup(\"Orders\"));\n        require(createOrder != address(0));\n        require(fillOrder != address(0));\n        require(cancelOrder != address(0));\n        require(orders != IOrders(0));\n    }\n\n    function recordFrozenFundChange(IUniverse _universe, IMarket _market, address _account, uint256 _outcome, int256 _frozenFundDelta) external returns (bool) {\n        require(msg.sender == createOrder || msg.sender == cancelOrder || msg.sender == address(orders) || msg.sender == fillOrder);\n        OutcomeData storage _outcomeData = profitLossData[_account][address(_market)][_outcome];\n        _outcomeData.frozenFunds += _frozenFundDelta.mul(10**18);\n        augurTrading.logProfitLossChanged(_market, _account, _outcome, _outcomeData.netPosition, uint256(_outcomeData.avgPrice), _outcomeData.realizedProfit, _outcomeData.frozenFunds,  _outcomeData.realizedCost);\n        return true;\n    }\n\n    function adjustTraderProfitForFees(IMarket _market, address _trader, uint256 _outcome, uint256 _fees) external returns (bool) {\n        require(msg.sender == fillOrder);\n        profitLossData[_trader][address(_market)][_outcome].realizedProfit -= int256(_fees.mul(10**18));\n        return true;\n    }\n\n    function recordTrade(IUniverse _universe, IMarket _market, address _longAddress, address _shortAddress, uint256 _outcome, int256 _amount, int256 _price, uint256 _numLongTokens, uint256 _numShortTokens, uint256 _numLongShares, uint256 _numShortShares) external returns (bool) {\n        require(msg.sender == fillOrder);\n        int256 _numTicks = int256(_market.getNumTicks()).mul(10**18);\n        _price = _price.mul(10**18);\n        {\n            int256  _shortFrozenTokenDelta = int256(_numShortTokens * 10**18).sub(int256(_numShortShares).mul(_price));\n            adjustForTrader(_universe, _market, _numTicks, _shortAddress, _outcome, -_amount, _price, _shortFrozenTokenDelta);\n        }\n        int256  _longFrozenTokenDelta = int256(_numLongTokens * 10**18).sub(int256(_numLongShares).mul(_numTicks.sub(_price)));\n        adjustForTrader(_universe, _market, _numTicks, _longAddress, _outcome, _amount, _price, _longFrozenTokenDelta);\n        return true;\n    }\n\n    function adjustForTrader(IUniverse _universe, IMarket _market, int256 _adjustedNumTicks, address _address, uint256 _outcome, int256 _amount, int256 _price, int256 _frozenTokenDelta) internal returns (bool) {\n        OutcomeData storage _outcomeData = profitLossData[_address][address(_market)][_outcome];\n        OutcomeData memory _tmpOutcomeData = profitLossData[_address][address(_market)][_outcome];\n\n        bool _sold = _tmpOutcomeData.netPosition < 0 &&  _amount > 0 || _tmpOutcomeData.netPosition > 0 &&  _amount < 0;\n        if (_tmpOutcomeData.netPosition != 0 && _sold) {\n            int256 _amountSold = _tmpOutcomeData.netPosition.abs().min(_amount.abs());\n            int256 _profit = (_tmpOutcomeData.netPosition < 0 ? _tmpOutcomeData.avgPrice.sub(_price) : _price.sub(_tmpOutcomeData.avgPrice)).mul(_amountSold);\n            _tmpOutcomeData.realizedProfit += _profit;\n            _tmpOutcomeData.realizedCost += (_tmpOutcomeData.netPosition < 0 ? _adjustedNumTicks.sub(_tmpOutcomeData.avgPrice) : _tmpOutcomeData.avgPrice).mul(_amountSold);\n            _tmpOutcomeData.frozenFunds += _profit + _frozenTokenDelta;\n\n            _outcomeData.realizedProfit = _tmpOutcomeData.realizedProfit;\n            _outcomeData.realizedCost = _tmpOutcomeData.realizedCost;\n            _outcomeData.frozenFunds = _tmpOutcomeData.frozenFunds;\n        } else {\n            _tmpOutcomeData.frozenFunds += _frozenTokenDelta;\n            _outcomeData.frozenFunds = _tmpOutcomeData.frozenFunds;\n        }\n\n        int256 _newNetPosition = _tmpOutcomeData.netPosition.add(_amount);\n        bool _reversed = _tmpOutcomeData.netPosition < 0 && _newNetPosition > 0 || _tmpOutcomeData.netPosition > 0 && _newNetPosition < 0;\n        if (_newNetPosition == 0) {\n            _tmpOutcomeData.avgPrice = 0;\n            _outcomeData.avgPrice = _tmpOutcomeData.avgPrice;\n        } else if (_reversed) {\n            _tmpOutcomeData.avgPrice = _price;\n            _outcomeData.avgPrice = _tmpOutcomeData.avgPrice;\n        } else if (!_sold) {\n            _tmpOutcomeData.avgPrice = _tmpOutcomeData.netPosition.abs().mul(_tmpOutcomeData.avgPrice).add(_amount.abs().mul(_price)).div(_newNetPosition.abs());\n            _outcomeData.avgPrice = _tmpOutcomeData.avgPrice;\n        }\n\n        _outcomeData.netPosition = _newNetPosition;\n        augurTrading.logProfitLossChanged(_market, _address, _outcome, _outcomeData.netPosition, uint256(_tmpOutcomeData.avgPrice), _tmpOutcomeData.realizedProfit, _tmpOutcomeData.frozenFunds,  _tmpOutcomeData.realizedCost);\n        return true;\n    }\n\n    function recordClaim(IMarket _market, address _account, uint256[] memory _outcomeFees) public returns (bool) {\n        require(msg.sender == address(augurTrading));\n        uint256 _numOutcomes = _market.getNumberOfOutcomes();\n        IUniverse _universe = _market.getUniverse();\n        for (uint256 _outcome = 0; _outcome < _numOutcomes; _outcome++) {\n            OutcomeData storage _outcomeData = profitLossData[_account][address(_market)][_outcome];\n            if (_outcomeData.netPosition == 0) {\n                continue;\n            }\n            int256 _salePrice = int256(_market.getWinningPayoutNumerator(_outcome).mul(10**18));\n            int256 _amount = _outcomeData.netPosition.abs();\n            _outcomeData.realizedProfit += (_outcomeData.netPosition < 0 ? _outcomeData.avgPrice.sub(_salePrice) : _salePrice.sub(_outcomeData.avgPrice)).mul(_amount);\n            _outcomeData.realizedProfit -= int256(_outcomeFees[_outcome]);\n            _outcomeData.realizedCost += (_outcomeData.netPosition < 0 ? int256(_market.getNumTicks()).sub(_outcomeData.avgPrice) : _outcomeData.avgPrice).mul(_amount);\n            _outcomeData.avgPrice = 0;\n            _outcomeData.frozenFunds = 0;\n            _outcomeData.netPosition = 0;\n            augurTrading.logProfitLossChanged(_market, _account, _outcome, 0, 0, _outcomeData.realizedProfit, 0, _outcomeData.realizedCost);\n        }\n        return true;\n    }\n\n    function getNetPosition(address _market, address _account, uint256 _outcome) external view returns (int256) {\n        return profitLossData[_account][_market][_outcome].netPosition;\n    }\n\n    function getAvgPrice(address _market, address _account, uint256 _outcome) external view returns (int256) {\n        return profitLossData[_account][_market][_outcome].avgPrice;\n    }\n\n    function getRealizedProfit(address _market, address _account, uint256 _outcome) external view returns (int256) {\n        return profitLossData[_account][_market][_outcome].realizedProfit;\n    }\n\n    function getFrozenFunds(address _market, address _account, uint256 _outcome) external view returns (int256) {\n        return profitLossData[_account][_market][_outcome].frozenFunds;\n    }\n\n    function getRealizedCost(address _market, address _account, uint256 _outcome) external view returns (int256) {\n        return profitLossData[_account][_market][_outcome].realizedCost;\n    }\n}\n\n"
    }
  }
}}