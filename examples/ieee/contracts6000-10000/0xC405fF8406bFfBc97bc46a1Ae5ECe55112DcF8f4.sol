{"BeaconContract.sol":{"content":"pragma solidity ^0.5.2;\n\nimport \"./IFactRegistry.sol\";\nimport \"./PublicInputOffsets.sol\";\n\n\ncontract BeaconContract is PublicInputOffsets {\n    event LogNewRandomness(uint256 blockNumber, bytes32 randomness);\n    // Mapping: blockNumber -\u003e randomness.\n    mapping(uint256 =\u003e bytes32) private registeredRandomness;\n\n    uint256 latestBlockNumber;\n    address public owner;\n    uint256 public n_iterations;\n    IFactRegistry verifierContract;\n    uint256 internal constant PRIME = 0x30000003000000010000000000000001;\n    uint256 internal constant MAX_LOG_TRACE_LENGTH = 40;\n    uint256 internal constant PUBLIC_INPUT_SIZE = 5;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Sender is not the owner\");\n        _;\n    }\n\n    constructor(address verifierAddress, uint256 n_iters) public {\n        owner = msg.sender;\n        verifierContract = IFactRegistry(verifierAddress);\n        n_iterations = n_iters;\n    }\n\n    /*\n      Registers a new randomness if and only if:\n        1. Can verify the block hash of the given blockNumber and that it indeed equals blockHash.\n        2. The vdfInput calculted from the given blockHash matches the given proofPublicInput.\n        3. The proofPublicInput was registered as a fact in the verifier contract.\n      Updates latest randomness.\n    */\n    function registerNewRandomness(\n        uint256 blockNumber,\n        bytes32 blockHash,\n        uint256[PUBLIC_INPUT_SIZE] calldata proofPublicInput\n    ) external onlyOwner {\n        // EVM can get block hash only for latest 256 blocks.\n        require(\n            blockNumber \u003c block.number \u0026\u0026 block.number \u003c= blockNumber + 255,\n            \"Block is not within the last 256 blocks.\"\n        );\n        // In case blockNumber refers to a block which is more than 256 blocks old,\n        // blockhash(blockNumber) returns 0.\n        require(\n            blockhash(blockNumber) == blockHash \u0026\u0026 blockHash != 0,\n            \"blockHash does not match blockNumber or too old.\"\n        );\n        require(\n            proofPublicInput[OFFSET_LOG_TRACE_LENGTH] \u003c MAX_LOG_TRACE_LENGTH,\n            \"VDF reported length exceeds the integer overflow protection limit.\"\n        );\n        require(\n            n_iterations == 10 * 2**proofPublicInput[OFFSET_LOG_TRACE_LENGTH] - 1,\n            \"Public input and n_iterations are not compatible.\"\n        );\n        require(\n            proofPublicInput[OFFSET_VDF_OUTPUT_X] \u003c PRIME \u0026\u0026\n                proofPublicInput[OFFSET_VDF_OUTPUT_Y] \u003c PRIME,\n            \"Invalid vdf output.\"\n        );\n        // To calculate the input of the VDF we first hash the blockHash with the string \"veedo\",\n        // then we split the last 250 bits to two 125 bit field elements.\n        uint256 vdfInput = uint256(keccak256(abi.encodePacked(blockHash, \"veedo\")));\n        require(\n            vdfInput \u0026 ((1 \u003c\u003c 125) - 1) == proofPublicInput[OFFSET_VDF_INPUT_X],\n            \"blockHash does not match the given proofPublicInput.\"\n        );\n        require(\n            ((vdfInput \u003e\u003e 125) \u0026 ((1 \u003c\u003c 125) - 1)) == proofPublicInput[OFFSET_VDF_INPUT_Y],\n            \"blockHash does not match the given proofPublicInput.\"\n        );\n        require(\n            verifierContract.isValid(keccak256(abi.encodePacked(proofPublicInput))),\n            \"No valid proof provided.\"\n        );\n        // The randomness is the hash of the VDF output and the string \"veedo\"\n        bytes32 randomness = keccak256(\n            abi.encodePacked(\n                proofPublicInput[OFFSET_VDF_OUTPUT_X],\n                proofPublicInput[OFFSET_VDF_OUTPUT_Y],\n                \"veedo\"\n            )\n        );\n        registeredRandomness[blockNumber] = randomness;\n        emit LogNewRandomness(blockNumber, randomness);\n        // Update latestBlockNumber if blockNumber is greater than latestBlockNumber.\n        if (blockNumber \u003e latestBlockNumber) {\n            latestBlockNumber = blockNumber;\n        }\n    }\n\n    /*\n      If there is a randomness for blockNumber, returns it.\n      Otherwise, returns 0.\n    */\n    function getRandomness(uint256 blockNumber)\n        external\n        view\n        returns (bytes32)\n    {\n        return registeredRandomness[blockNumber];\n    }\n\n    /*\n      Returns the latest registered (blockNumber, randomness).\n    */\n    function getLatestRandomness() external view returns (uint256, bytes32) {\n        return (latestBlockNumber, registeredRandomness[latestBlockNumber]);\n    }\n}\n"},"IFactRegistry.sol":{"content":"pragma solidity ^0.5.2;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post \u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\u003e`_.\n*/\ncontract IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"PublicInputOffsets.sol":{"content":"pragma solidity ^0.5.2;\n\n\ncontract PublicInputOffsets {\n    // The following constants are offsets of data expected in the public input.\n    uint256 internal constant OFFSET_LOG_TRACE_LENGTH = 0;\n    uint256 internal constant OFFSET_VDF_OUTPUT_X = 1;\n    uint256 internal constant OFFSET_VDF_OUTPUT_Y = 2;\n    uint256 internal constant OFFSET_VDF_INPUT_X = 3;\n    uint256 internal constant OFFSET_VDF_INPUT_Y = 4;\n}\n"}}