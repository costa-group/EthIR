{"base.sol":{"content":"/// base.sol -- basic ERC20 implementation\n\n// Copyright (C) 2015, 2016, 2017  DappHub, LLC\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\npragma solidity \u003e=0.4.23;\n\nimport \"./erc20.sol\";\nimport \"./math.sol\";\n\ncontract DSTokenBase is ERC20, DSMath {\n    uint256                                            _supply;\n    mapping (address =\u003e uint256)                       _balances;\n    mapping (address =\u003e mapping (address =\u003e uint256))  _approvals;\n\n    constructor(uint supply) public {\n        _balances[msg.sender] = supply;\n        _supply = supply;\n    }\n\n    function totalSupply() public view returns (uint) {\n        return _supply;\n    }\n    function balanceOf(address src) public view returns (uint) {\n        return _balances[src];\n    }\n    function allowance(address src, address guy) public view returns (uint) {\n        return _approvals[src][guy];\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        if (src != msg.sender) {\n            require(_approvals[src][msg.sender] \u003e= wad, \"ds-token-insufficient-approval\");\n            _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n        }\n\n        require(_balances[src] \u003e= wad, \"ds-token-insufficient-balance\");\n        _balances[src] = sub(_balances[src], wad);\n        _balances[dst] = add(_balances[dst], wad);\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        _approvals[msg.sender][guy] = wad;\n\n        emit Approval(msg.sender, guy, wad);\n\n        return true;\n    }\n}\n"},"erc20.sol":{"content":"/// erc20.sol -- API for the ERC20 token standard\n\n// See \u003chttps://github.com/ethereum/EIPs/issues/20\u003e.\n\n// This file likely does not meet the threshold of originality\n// required for copyright to apply.  As a result, this is free and\n// unencumbered software belonging to the public domain.\n\npragma solidity \u003e0.4.20;\n\ncontract ERC20Events {\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n}\n\ncontract ERC20 is ERC20Events {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address guy) public view returns (uint);\n    function allowance(address src, address guy) public view returns (uint);\n\n    function approve(address guy, uint wad) public returns (bool);\n    function transfer(address dst, uint wad) public returns (bool);\n    function transferFrom(\n        address src, address dst, uint wad\n    ) public returns (bool);\n}\n"},"math.sol":{"content":"/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\npragma solidity \u003e0.4.13;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) \u003e= x, \"ds-math-add-overflow\");\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) \u003c= x, \"ds-math-sub-underflow\");\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x \u003c= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x \u003e= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x \u003c= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x \u003e= y ? x : y;\n    }\n\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It\u0027s O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"},"SPT_token.sol":{"content":"pragma solidity ^0.4.20;\r\n\r\nimport \"./base.sol\";\r\n\r\ncontract SPT_tokenI is ERC20 {\r\n    function mint(uint wad) public;\r\n    function burn(uint wad) public;\r\n    function mint(address guy, uint wad) public;\r\n    function burn(address guy, uint wad) public;\r\n\r\n    function setOwner(address owner_) public;\r\n    function getOwner() public view returns(address);\r\n}\r\n\r\ncontract SPT_token is DSTokenBase, SPT_tokenI {\r\n    address owner;\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public decimals = 18; // standard token precision. override to customize\r\n\r\n    constructor(address owner_, string name_, string symbol_) public DSTokenBase(0) {\r\n        if(owner_ == address(0)) owner = msg.sender;\r\n        else owner = owner_;\r\n\r\n        name = name_;\r\n        symbol = symbol_;\r\n    }\r\n\r\n    event Mint(address indexed guy, uint wad);\r\n    event Burn(address indexed guy, uint wad);\r\n\r\n    function setOwner(address owner_) public onlyOwner {owner = owner_;}\r\n\r\n    function getOwner() public view returns(address) {return owner;}\r\n\r\n    function mint(uint wad) public {\r\n        mint(msg.sender, wad);\r\n    }\r\n    function burn(uint wad) public {\r\n        burn(msg.sender, wad);\r\n    }\r\n    function mint(address guy, uint wad) public onlyOwner {\r\n        _balances[guy] = add(_balances[guy], wad);\r\n        _supply = add(_supply, wad);\r\n        emit Mint(guy, wad);\r\n    }\r\n    function burn(address guy, uint wad) public onlyOwner {\r\n        if (guy != msg.sender \u0026\u0026 _approvals[guy][msg.sender] != uint(-1)) {\r\n            require(_approvals[guy][msg.sender] \u003e= wad, \"ds-token-insufficient-approval\");\r\n            _approvals[guy][msg.sender] = sub(_approvals[guy][msg.sender], wad);\r\n        }\r\n\r\n        require(_balances[guy] \u003e= wad, \"ds-token-insufficient-balance\");\r\n        _balances[guy] = sub(_balances[guy], wad);\r\n        _supply = sub(_supply, wad);\r\n        emit Burn(guy, wad);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner,\"\");\r\n        _;\r\n    }\r\n}"}}