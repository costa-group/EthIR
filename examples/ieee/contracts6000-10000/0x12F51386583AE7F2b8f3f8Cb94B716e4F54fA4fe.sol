{{
  "language": "Solidity",
  "settings": {
    "remappings": [
      "ROOT=/home/achapman/augur/packages/augur-core/src/contracts//"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true,
        "deduplicate": true,
        "cse": true,
        "constantOptimizer": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "reporting/OICash.sol": {
      "content": "pragma solidity 0.5.15;\n\ncontract IAugur {\n    function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function isKnownUniverse(IUniverse _universe) public view returns (bool);\n    function trustedCashTransfer(address _from, address _to, uint256 _amount) public returns (bool);\n    function isTrustedSender(address _address) public returns (bool);\n    function onCategoricalMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, bytes32[] memory _outcomes) public returns (bool);\n    function onYesNoMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash) public returns (bool);\n    function onScalarMarketCreated(uint256 _endTime, string memory _extraInfo, IMarket _market, address _marketCreator, address _designatedReporter, uint256 _feePerCashInAttoCash, int256[] memory _prices, uint256 _numTicks)  public returns (bool);\n    function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, address _initialReporter, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] memory _payoutNumerators, string memory _description, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime) public returns (bool);\n    function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _size, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked, string memory description, uint256[] memory _payoutNumerators, uint256 _currentStake, uint256 _stakeRemaining, uint256 _disputeRound) public returns (bool);\n    function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] memory _payoutNumerators, uint256 _nextWindowStartTime, uint256 _nextWindowEndTime, bool _pacingOn, uint256 _totalRepStakedInPayout, uint256 _totalRepStakedInMarket, uint256 _disputeRound) public returns (bool);\n    function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256[] memory _payoutNumerators) public returns (bool);\n    function logMarketFinalized(IUniverse _universe, uint256[] memory _winningPayoutNumerators) public returns (bool);\n    function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n    function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n    function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n    function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n    function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets, uint256 _fees) public returns (bool);\n    function logMarketOIChanged(IUniverse _universe, IMarket _market) public returns (bool);\n    function logTradingProceedsClaimed(IUniverse _universe, address _sender, address _market, uint256 _outcome, uint256 _numShares, uint256 _numPayoutTokens, uint256 _fees) public returns (bool);\n    function logUniverseForked(IMarket _forkingMarket) public returns (bool);\n    function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logReputationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logReputationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logShareTokensBalanceChanged(address _account, IMarket _market, uint256 _outcome, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logDisputeWindowCreated(IDisputeWindow _disputeWindow, uint256 _id, bool _initial) public returns (bool);\n    function logParticipationTokensRedeemed(IUniverse universe, address _sender, uint256 _attoParticipationTokens, uint256 _feePayoutShare) public returns (bool);\n    function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n    function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n    function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n    function logParticipationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value, uint256 _fromBalance, uint256 _toBalance) public returns (bool);\n    function logParticipationTokensBurned(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logParticipationTokensMinted(IUniverse _universe, address _target, uint256 _amount, uint256 _totalSupply, uint256 _balance) public returns (bool);\n    function logMarketRepBondTransferred(address _universe, address _from, address _to) public returns (bool);\n    function logWarpSyncDataUpdated(address _universe, uint256 _warpSyncHash, uint256 _marketEndTime) public returns (bool);\n    function isKnownFeeSender(address _feeSender) public view returns (bool);\n    function lookup(bytes32 _key) public view returns (address);\n    function getTimestamp() public view returns (uint256);\n    function getMaximumMarketEndDate() public returns (uint256);\n    function isKnownMarket(IMarket _market) public view returns (bool);\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators, uint256 _numTicks, uint256 numOutcomes) public view returns (bytes32);\n    function logValidityBondChanged(uint256 _validityBond) public returns (bool);\n    function logDesignatedReportStakeChanged(uint256 _designatedReportStake) public returns (bool);\n    function logNoShowBondChanged(uint256 _noShowBond) public returns (bool);\n    function logReportingFeeChanged(uint256 _reportingFee) public returns (bool);\n    function getUniverseForkIndex(IUniverse _universe) public view returns (uint256);\n}\n\ncontract IOwnable {\n    function getOwner() public view returns (address);\n    function transferOwnership(address _newOwner) public returns (bool);\n}\n\ncontract ITyped {\n    function getTypeName() public view returns (bytes32);\n}\n\ncontract Initializable {\n    bool private initialized = false;\n\n    modifier beforeInitialized {\n        require(!initialized);\n        _;\n    }\n\n    function endInitialization() internal beforeInitialized {\n        initialized = true;\n    }\n\n    function getInitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\nlibrary SafeMathUint256 {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n        return c;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a >= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            uint256 x = (y + 1) / 2;\n            z = y;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function getUint256Min() internal pure returns (uint256) {\n        return 0;\n    }\n\n    function getUint256Max() internal pure returns (uint256) {\n        // 2 ** 256 - 1\n        return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    }\n\n    function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n        return a % b == 0;\n    }\n\n    // Float [fixed point] Operations\n    function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, b), base);\n    }\n\n    function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n        return div(mul(a, base), b);\n    }\n}\n\ninterface IERC1155 {\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    /// Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define a token ID with no initial balance, the contract SHOULD emit the TransferSingle event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 value\n    );\n\n    /// @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred,\n    ///      including zero value transfers as well as minting or burning.\n    ///Operator will always be msg.sender.\n    /// Either event from address `0x0` signifies a minting operation.\n    /// An event to address `0x0` signifies a burning or melting operation.\n    /// The total value transferred from address 0x0 minus the total value transferred to 0x0 may\n    /// be used by clients and exchanges to be added to the \"circulating supply\" for a given token ID.\n    /// To define multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event\n    /// from `0x0` to `0x0`, with the token creator as `_operator`.\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /// @dev MUST emit when an approval is updated.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /// @dev MUST emit when the URI is updated for a token ID.\n    /// URIs are defined in RFC 3986.\n    /// The URI MUST point a JSON file that conforms to the \"ERC-1155 Metadata JSON Schema\".\n    event URI(\n        string value,\n        uint256 indexed id\n    );\n\n    /// @notice Transfers value amount of an _id from the _from address to the _to address specified.\n    /// @dev MUST emit TransferSingle event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if balance of sender for token `_id` is lower than the `_value` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155Received` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`.\n    /// @param from    Source address\n    /// @param to      Target address\n    /// @param id      ID of the token type\n    /// @param value   Transfer amount\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Send multiple types of Tokens from a 3rd party in one transfer (with safety call).\n    /// @dev MUST emit TransferBatch event on success.\n    /// Caller must be approved to manage the _from account's tokens (see isApprovedForAll).\n    /// MUST throw if `_to` is the zero address.\n    /// MUST throw if length of `_ids` is not the same as length of `_values`.\n    ///  MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_values` sent.\n    /// MUST throw on any other error.\n    /// When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0).\n    /// If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return value\n    /// is not `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`.\n    /// @param from    Source addresses\n    /// @param to      Target addresses\n    /// @param ids     IDs of each token type\n    /// @param values  Transfer amounts per token type\n    /// @param data    Additional data with no specified format, sent in call to `_to`\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\n    /// @dev MUST emit the ApprovalForAll event on success.\n    /// @param operator  Address to add to the set of authorized operators\n    /// @param approved  True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /// @notice Queries the approval status of an operator for a given owner.\n    /// @param owner     The owner of the Tokens\n    /// @param operator  Address of authorized operator\n    /// @return           True if the operator is approved, false if not\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /// @notice Get the balance of an account's Tokens.\n    /// @param owner  The address of the token holder\n    /// @param id     ID of the Token\n    /// @return        The _owner's balance of the Token type requested\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\n\n    /// @notice Get the total supply of a Token.\n    /// @param id     ID of the Token\n    /// @return        The total supply of the Token type requested\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    /// @notice Get the balance of multiple account/token pairs\n    /// @param owners The addresses of the token holders\n    /// @param ids    ID of the Tokens\n    /// @return        The _owner's balance of the Token types requested\n    function balanceOfBatch(\n        address[] calldata owners,\n        uint256[] calldata ids\n    )\n        external\n        view\n        returns (uint256[] memory balances_);\n}\n\ncontract IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address owner) public view returns (uint256);\n    function transfer(address to, uint256 amount) public returns (bool);\n    function transferFrom(address from, address to, uint256 amount) public returns (bool);\n    function approve(address spender, uint256 amount) public returns (bool);\n    function allowance(address owner, address spender) public view returns (uint256);\n\n    // solhint-disable-next-line no-simple-event-func-name\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ICash is IERC20 {\n}\n\ncontract ERC20 is IERC20 {\n    using SafeMathUint256 for uint256;\n\n    uint8 constant public decimals = 18;\n\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balances;\n\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address _recipient, uint256 _amount) public returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address _spender, uint256 _amount) public returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) public returns (bool) {\n        _transfer(_sender, _recipient, _amount);\n        _approve(_sender, msg.sender, allowances[_sender][msg.sender].sub(_amount));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\n        require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        balances[_sender] = balances[_sender].sub(_amount);\n        balances[_recipient] = balances[_recipient].add(_amount);\n        emit Transfer(_sender, _recipient, _amount);\n        onTokenTransfer(_sender, _recipient, _amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"ERC20: mint to the zero address\");\n\n        totalSupply = totalSupply.add(_amount);\n        balances[_account] = balances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address _account, uint256 _amount) internal {\n        require(_account != address(0), \"ERC20: burn from the zero address\");\n\n        balances[_account] = balances[_account].sub(_amount);\n        totalSupply = totalSupply.sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address _account, uint256 _amount) internal {\n        _burn(_account, _amount);\n        _approve(_account, msg.sender, allowances[_account][msg.sender].sub(_amount));\n    }\n\n    // Subclasses of this token generally want to send additional logs through the centralized Augur log emitter contract\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal;\n}\n\ncontract VariableSupplyToken is ERC20 {\n    using SafeMathUint256 for uint256;\n\n    function mint(address _target, uint256 _amount) internal returns (bool) {\n        _mint(_target, _amount);\n        onMint(_target, _amount);\n        return true;\n    }\n\n    function burn(address _target, uint256 _amount) internal returns (bool) {\n        _burn(_target, _amount);\n        onBurn(_target, _amount);\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onMint(address, uint256) internal {\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onBurn(address, uint256) internal {\n    }\n}\n\ncontract IAffiliateValidator {\n    function validateReference(address _account, address _referrer) external view returns (bool);\n}\n\ncontract IDisputeWindow is ITyped, IERC20 {\n    function invalidMarketsTotal() external view returns (uint256);\n    function validityBondTotal() external view returns (uint256);\n\n    function incorrectDesignatedReportTotal() external view returns (uint256);\n    function initialReportBondTotal() external view returns (uint256);\n\n    function designatedReportNoShowsTotal() external view returns (uint256);\n    function designatedReporterNoShowBondTotal() external view returns (uint256);\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _disputeWindowId, bool _participationTokensEnabled, uint256 _duration, uint256 _startTime) public;\n    function trustedBuy(address _buyer, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getReputationToken() public view returns (IReputationToken);\n    function getStartTime() public view returns (uint256);\n    function getEndTime() public view returns (uint256);\n    function getWindowId() public view returns (uint256);\n    function isActive() public view returns (bool);\n    function isOver() public view returns (bool);\n    function onMarketFinalized() public;\n    function redeem(address _account) public returns (bool);\n}\n\ncontract IMarket is IOwnable {\n    enum MarketType {\n        YES_NO,\n        CATEGORICAL,\n        SCALAR\n    }\n\n    function initialize(IAugur _augur, IUniverse _universe, uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public;\n    function derivePayoutDistributionHash(uint256[] memory _payoutNumerators) public view returns (bytes32);\n    function doInitialReport(uint256[] memory _payoutNumerators, string memory _description, uint256 _additionalStake) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getDisputeWindow() public view returns (IDisputeWindow);\n    function getNumberOfOutcomes() public view returns (uint256);\n    function getNumTicks() public view returns (uint256);\n    function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n    function getForkingMarket() public view returns (IMarket _market);\n    function getEndTime() public view returns (uint256);\n    function getWinningPayoutDistributionHash() public view returns (bytes32);\n    function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningReportingParticipant() public view returns (IReportingParticipant);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getFinalizationTime() public view returns (uint256);\n    function getInitialReporter() public view returns (IInitialReporter);\n    function getDesignatedReportingEndTime() public view returns (uint256);\n    function getValidityBondAttoCash() public view returns (uint256);\n    function affiliateFeeDivisor() external view returns (uint256);\n    function getNumParticipants() public view returns (uint256);\n    function getDisputePacingOn() public view returns (bool);\n    function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n    function recordMarketCreatorFees(uint256 _marketCreatorFees, address _sourceAccount, bytes32 _fingerprint) public returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function isFinalizedAsInvalid() public view returns (bool);\n    function finalize() public returns (bool);\n    function isFinalized() public view returns (bool);\n    function getOpenInterest() public view returns (uint256);\n}\n\ncontract IOICash is IERC20 {\n    function initialize(IAugur _augur, IUniverse _universe) external;\n}\n\ncontract IReportingParticipant {\n    function getStake() public view returns (uint256);\n    function getPayoutDistributionHash() public view returns (bytes32);\n    function liquidateLosing() public;\n    function redeem(address _redeemer) public returns (bool);\n    function isDisavowed() public view returns (bool);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getMarket() public view returns (IMarket);\n    function getSize() public view returns (uint256);\n}\n\ncontract IInitialReporter is IReportingParticipant, IOwnable {\n    function initialize(IAugur _augur, IMarket _market, address _designatedReporter) public;\n    function report(address _reporter, bytes32 _payoutDistributionHash, uint256[] memory _payoutNumerators, uint256 _initialReportStake) public;\n    function designatedReporterShowed() public view returns (bool);\n    function initialReporterWasCorrect() public view returns (bool);\n    function getDesignatedReporter() public view returns (address);\n    function getReportTimestamp() public view returns (uint256);\n    function migrateToNewUniverse(address _designatedReporter) public;\n    function returnRepFromDisavow() public;\n}\n\ncontract IReputationToken is IERC20 {\n    function migrateOutByPayout(uint256[] memory _payoutNumerators, uint256 _attotokens) public returns (bool);\n    function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n    function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function trustedDisputeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n    function getUniverse() public view returns (IUniverse);\n    function getTotalMigrated() public view returns (uint256);\n    function getTotalTheoreticalSupply() public view returns (uint256);\n    function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\n\ncontract IShareToken is ITyped, IERC1155 {\n    function initialize(IAugur _augur) external;\n    function initializeMarket(IMarket _market, uint256 _numOutcomes, uint256 _numTicks) public;\n    function unsafeTransferFrom(address _from, address _to, uint256 _id, uint256 _value) public;\n    function unsafeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _values) public;\n    function claimTradingProceeds(IMarket _market, address _shareHolder, bytes32 _fingerprint) external returns (uint256[] memory _outcomeFees);\n    function getMarket(uint256 _tokenId) external view returns (IMarket);\n    function getOutcome(uint256 _tokenId) external view returns (uint256);\n    function getTokenId(IMarket _market, uint256 _outcome) public pure returns (uint256 _tokenId);\n    function getTokenIds(IMarket _market, uint256[] memory _outcomes) public pure returns (uint256[] memory _tokenIds);\n    function buyCompleteSets(IMarket _market, address _account, uint256 _amount) external returns (bool);\n    function buyCompleteSetsForTrade(IMarket _market, uint256 _amount, uint256 _longOutcome, address _longRecipient, address _shortRecipient) external returns (bool);\n    function sellCompleteSets(IMarket _market, address _holder, address _recipient, uint256 _amount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function sellCompleteSetsForTrade(IMarket _market, uint256 _outcome, uint256 _amount, address _shortParticipant, address _longParticipant, address _shortRecipient, address _longRecipient, uint256 _price, address _sourceAccount, bytes32 _fingerprint) external returns (uint256 _creatorFee, uint256 _reportingFee);\n    function totalSupplyForMarketOutcome(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function balanceOfMarketOutcome(IMarket _market, uint256 _outcome, address _account) public view returns (uint256);\n    function lowestBalanceOfMarketOutcomes(IMarket _market, uint256[] memory _outcomes, address _account) public view returns (uint256);\n}\n\ncontract IUniverse {\n    function creationTime() external view returns (uint256);\n    function marketBalance(address) external view returns (uint256);\n\n    function fork() public returns (bool);\n    function updateForkValues() public returns (bool);\n    function getParentUniverse() public view returns (IUniverse);\n    function createChildUniverse(uint256[] memory _parentPayoutNumerators) public returns (IUniverse);\n    function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n    function getReputationToken() public view returns (IV2ReputationToken);\n    function getForkingMarket() public view returns (IMarket);\n    function getForkEndTime() public view returns (uint256);\n    function getForkReputationGoal() public view returns (uint256);\n    function getParentPayoutDistributionHash() public view returns (bytes32);\n    function getDisputeRoundDurationInSeconds(bool _initial) public view returns (uint256);\n    function getOrCreateDisputeWindowByTimestamp(uint256 _timestamp, bool _initial) public returns (IDisputeWindow);\n    function getOrCreateCurrentDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreateNextDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOrCreatePreviousDisputeWindow(bool _initial) public returns (IDisputeWindow);\n    function getOpenInterestInAttoCash() public view returns (uint256);\n    function getTargetRepMarketCapInAttoCash() public view returns (uint256);\n    function getOrCacheValidityBond() public returns (uint256);\n    function getOrCacheDesignatedReportStake() public returns (uint256);\n    function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n    function getOrCacheMarketRepBond() public returns (uint256);\n    function getOrCacheReportingFeeDivisor() public returns (uint256);\n    function getDisputeThresholdForFork() public view returns (uint256);\n    function getDisputeThresholdForDisputePacing() public view returns (uint256);\n    function getInitialReportMinValue() public view returns (uint256);\n    function getPayoutNumerators() public view returns (uint256[] memory);\n    function getReportingFeeDivisor() public view returns (uint256);\n    function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function getWinningChildPayoutNumerator(uint256 _outcome) public view returns (uint256);\n    function isOpenInterestCash(address) public view returns (bool);\n    function isForkingMarket() public view returns (bool);\n    function getCurrentDisputeWindow(bool _initial) public view returns (IDisputeWindow);\n    function getDisputeWindowStartTimeAndDuration(uint256 _timestamp, bool _initial) public view returns (uint256, uint256);\n    function isParentOf(IUniverse _shadyChild) public view returns (bool);\n    function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n    function isContainerForDisputeWindow(IDisputeWindow _shadyTarget) public view returns (bool);\n    function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n    function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n    function migrateMarketOut(IUniverse _destinationUniverse) public returns (bool);\n    function migrateMarketIn(IMarket _market, uint256 _cashBalance, uint256 _marketOI) public returns (bool);\n    function decrementOpenInterest(uint256 _amount) public returns (bool);\n    function decrementOpenInterestFromMarket(IMarket _market) public returns (bool);\n    function incrementOpenInterest(uint256 _amount) public returns (bool);\n    function getWinningChildUniverse() public view returns (IUniverse);\n    function isForking() public view returns (bool);\n    function deposit(address _sender, uint256 _amount, address _market) public returns (bool);\n    function withdraw(address _recipient, uint256 _amount, address _market) public returns (bool);\n    function createScalarMarket(uint256 _endTime, uint256 _feePerCashInAttoCash, IAffiliateValidator _affiliateValidator, uint256 _affiliateFeeDivisor, address _designatedReporterAddress, int256[] memory _prices, uint256 _numTicks, string memory _extraInfo) public returns (IMarket _newMarket);\n}\n\ncontract IV2ReputationToken is IReputationToken {\n    function parentUniverse() external returns (IUniverse);\n    function burnForMarket(uint256 _amountToBurn) public returns (bool);\n    function mintForWarpSync(uint256 _amountToMint, address _target) public returns (bool);\n}\n\ncontract IAugurTrading {\n    function lookup(bytes32 _key) public view returns (address);\n    function logProfitLossChanged(IMarket _market, address _account, uint256 _outcome, int256 _netPosition, uint256 _avgPrice, int256 _realizedProfit, int256 _frozenFunds, int256 _realizedCost) public returns (bool);\n    function logOrderCreated(IUniverse _universe, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logOrderCanceled(IUniverse _universe, IMarket _market, address _creator, uint256 _tokenRefund, uint256 _sharesRefund, bytes32 _orderId) public returns (bool);\n    function logOrderFilled(IUniverse _universe, address _creator, address _filler, uint256 _price, uint256 _fees, uint256 _amountFilled, bytes32 _orderId, bytes32 _tradeGroupId) public returns (bool);\n    function logMarketVolumeChanged(IUniverse _universe, address _market, uint256 _volume, uint256[] memory _outcomeVolumes, uint256 _totalTrades) public returns (bool);\n    function logZeroXOrderFilled(IUniverse _universe, IMarket _market, bytes32 _orderHash, bytes32 _tradeGroupId, uint8 _orderType, address[] memory _addressData, uint256[] memory _uint256Data) public returns (bool);\n    function logZeroXOrderCanceled(address _universe, address _market, address _account, uint256 _outcome, uint256 _price, uint256 _amount, uint8 _type, bytes32 _orderHash) public;\n}\n\ncontract IOrders {\n    function saveOrder(uint256[] calldata _uints, bytes32[] calldata _bytes32s, Order.Types _type, IMarket _market, address _sender) external returns (bytes32 _orderId);\n    function removeOrder(bytes32 _orderId) external returns (bool);\n    function getMarket(bytes32 _orderId) public view returns (IMarket);\n    function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n    function getOutcome(bytes32 _orderId) public view returns (uint256);\n    function getAmount(bytes32 _orderId) public view returns (uint256);\n    function getPrice(bytes32 _orderId) public view returns (uint256);\n    function getOrderCreator(bytes32 _orderId) public view returns (address);\n    function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n    function getOrderDataForCancel(bytes32 _orderId) public view returns (uint256, uint256, Order.Types, IMarket, uint256, address);\n    function getOrderDataForLogs(bytes32 _orderId) public view returns (Order.Types, address[] memory _addressData, uint256[] memory _uint256Data);\n    function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n    function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n    function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n    function getOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n    function getTotalEscrowed(IMarket _market) public view returns (uint256);\n    function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n    function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n    function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n    function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled, uint256 _fill) external returns (bool);\n    function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n}\n\nlibrary Order {\n    using SafeMathUint256 for uint256;\n\n    enum Types {\n        Bid, Ask\n    }\n\n    enum TradeDirections {\n        Long, Short\n    }\n\n    struct Data {\n        // Contracts\n        IMarket market;\n        IAugur augur;\n        IAugurTrading augurTrading;\n        IShareToken shareToken;\n        ICash cash;\n\n        // Order\n        bytes32 id;\n        address creator;\n        uint256 outcome;\n        Order.Types orderType;\n        uint256 amount;\n        uint256 price;\n        uint256 sharesEscrowed;\n        uint256 moneyEscrowed;\n        bytes32 betterOrderId;\n        bytes32 worseOrderId;\n    }\n\n    function create(IAugur _augur, IAugurTrading _augurTrading, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data memory) {\n        require(_outcome < _market.getNumberOfOutcomes(), \"Order.create: Outcome is not within market range\");\n        require(_price != 0, \"Order.create: Price may not be 0\");\n        require(_price < _market.getNumTicks(), \"Order.create: Price is outside of market range\");\n        require(_attoshares > 0, \"Order.create: Cannot use amount of 0\");\n        require(_creator != address(0), \"Order.create: Creator is 0x0\");\n\n        IShareToken _shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n\n        return Data({\n            market: _market,\n            augur: _augur,\n            augurTrading: _augurTrading,\n            shareToken: _shareToken,\n            cash: ICash(_augur.lookup(\"Cash\")),\n            id: 0,\n            creator: _creator,\n            outcome: _outcome,\n            orderType: _type,\n            amount: _attoshares,\n            price: _price,\n            sharesEscrowed: 0,\n            moneyEscrowed: 0,\n            betterOrderId: _betterOrderId,\n            worseOrderId: _worseOrderId\n        });\n    }\n\n    //\n    // \"public\" functions\n    //\n\n    function getOrderId(Order.Data memory _orderData, IOrders _orders) internal view returns (bytes32) {\n        if (_orderData.id == bytes32(0)) {\n            bytes32 _orderId = calculateOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n            require(_orders.getAmount(_orderId) == 0, \"Order.getOrderId: New order had amount. This should not be possible\");\n            _orderData.id = _orderId;\n        }\n        return _orderData.id;\n    }\n\n    function calculateOrderId(Order.Types _type, IMarket _market, uint256 _amount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(_type, _market, _amount, _price, _sender, _blockNumber, _outcome, _moneyEscrowed, _sharesEscrowed));\n    }\n\n    function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n        return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n    }\n\n    function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n        return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n    }\n\n    function saveOrder(Order.Data memory _orderData, bytes32 _tradeGroupId, IOrders _orders) internal returns (bytes32) {\n        getOrderId(_orderData, _orders);\n        uint256[] memory _uints = new uint256[](5);\n        _uints[0] = _orderData.amount;\n        _uints[1] = _orderData.price;\n        _uints[2] = _orderData.outcome;\n        _uints[3] = _orderData.moneyEscrowed;\n        _uints[4] = _orderData.sharesEscrowed;\n        bytes32[] memory _bytes32s = new bytes32[](4);\n        _bytes32s[0] = _orderData.betterOrderId;\n        _bytes32s[1] = _orderData.worseOrderId;\n        _bytes32s[2] = _tradeGroupId;\n        _bytes32s[3] = _orderData.id;\n        return _orders.saveOrder(_uints, _bytes32s, _orderData.orderType, _orderData.market, _orderData.creator);\n    }\n}\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\ncontract OICash is VariableSupplyToken, Initializable, IOICash {\n    using SafeMathUint256 for uint256;\n\n    IAugur public augur;\n    IERC20 public cash;\n    IUniverse public universe;\n    IShareToken public shareToken;\n    uint256 public feesPaid;\n\n    uint256 private constant MAX_APPROVAL_AMOUNT = 2 ** 256 - 1;\n\n    function initialize(IAugur _augur, IUniverse _universe) external beforeInitialized {\n        endInitialization();\n        augur = _augur;\n        cash = ICash(_augur.lookup(\"Cash\"));\n        shareToken = IShareToken(_augur.lookup(\"ShareToken\"));\n        require(shareToken != IShareToken(0));\n        universe = _universe;\n\n        cash.approve(address(_augur), MAX_APPROVAL_AMOUNT);\n    }\n\n    function deposit(uint256 _amount) external returns (bool) {\n        universe.deposit(msg.sender, _amount, address(0));\n        mint(msg.sender, _amount);\n        return true;\n    }\n\n    function withdraw(uint256 _amount) external returns (bool) {\n        burn(msg.sender, _amount);\n\n        // Withdraw cash to this contract\n        universe.withdraw(address(this), _amount, address(0));\n\n        uint256 _payout = _amount;\n        uint256 _reportingFeeDivisor = universe.getOrCacheReportingFeeDivisor();\n        uint256 _feesOwed = _amount / _reportingFeeDivisor;\n\n        if (feesPaid > _feesOwed) {\n            feesPaid = feesPaid.sub(_feesOwed);\n        } else {\n            _feesOwed = _feesOwed.sub(feesPaid);\n            feesPaid = 0;\n            _payout = _payout.sub(_feesOwed);\n            require(cash.transfer(address(universe.getOrCreateNextDisputeWindow(false)), _feesOwed));\n        }\n\n        require(cash.transfer(msg.sender, _payout));\n\n        return true;\n    }\n\n    function payFees(uint256 _feeAmount) external returns (bool) {\n        burn(msg.sender, _feeAmount);\n        universe.withdraw(address(universe.getOrCreateNextDisputeWindow(false)), _feeAmount, address(0));\n        feesPaid = feesPaid.add(_feeAmount);\n        return true;\n    }\n\n    function buyCompleteSets(IMarket _market, uint256 _amount) external returns (bool) {\n        require(universe.isContainerForMarket(_market), \"Market does not belong to universe\");\n        uint256 _cost = _amount.mul(_market.getNumTicks());\n        burn(msg.sender, _cost);\n        universe.withdraw(address(this), _cost, address(0));\n        shareToken.buyCompleteSets(_market, msg.sender, _amount);\n        return true;\n    }\n\n    function onTokenTransfer(address _from, address _to, uint256 _value) internal {\n    }\n\n    function onMint(address _target, uint256 _amount) internal {\n    }\n\n    function onBurn(address _target, uint256 _amount) internal {\n    }\n}\n\n"
    }
  }
}}