{"interfaces.sol":{"content":"pragma solidity ^0.6.4;\n\ninterface DaiErc20 {\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address,address,uint256) external returns (bool);\n    function approve(address,uint256) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n    function allowance(address, address) external view returns (uint);\n}\n\n\ninterface PotLike {\n    function chi() external view returns (uint256);\n    function rho() external view returns (uint256);\n    function drip() external returns (uint256);\n    function join(uint256) external;\n    function exit(uint256) external;\n    function pie(address) external view returns (uint256);\n\n}\n\ninterface JoinLike {\n    function join(address, uint256) external;\n    function exit(address, uint256) external;\n    function vat() external returns (VatLike);\n    function dai() external returns (DaiErc20);\n\n}\n\n\ninterface VatLike {\n    function hope(address) external;\n    function dai(address) external view returns (uint256);\n\n}\n\ninterface cDaiErc20 {\n    function mint(uint256) external returns (uint256);\n    function redeem(uint) external returns (uint);\n    function balanceOf(address) external view returns (uint);\n}\n\n"},"mathlib.sol":{"content":"pragma solidity ^0.6.4;\n\nlibrary mathlib\n{\n     \n     // --- Math functions as implemented in DAI ERC20 Token---\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) \u003e= x);\n    }\n    \n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) \u003c= x);\n    }\n    \n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    \n}\n"},"owned.sol":{"content":"pragma solidity ^0.6.4;\n\ncontract owned\n{\n     /*\n        1) Allows the manager to pause the main Factory contract\n        2) [Very Important]) The new contract that is created by the Factory is NOT owned, and therefore can not in any way be modified by the manager\n        3) Only the Factory contract is owned.\n    */\n\n    address public manager;\n    \n    constructor() public \n\t{\n\t    manager = msg.sender;\n\t}\n\n    modifier onlyManager()\n    {\n        require(msg.sender == manager);\n        _;\n    }\n    \n    function setManager(address newmanager) external onlyManager\n    {\n        /*\n            Allows the current manager to set a new manager\n        */\n        \n        require(newmanager.balance \u003e 0);\n        manager = newmanager;\n    }\n    \n}\n\n\n\n\n"},"stableescrow.sol":{"content":"pragma solidity ^0.6.4;\n\nimport \"./interfaces.sol\";\nimport \"./owned.sol\";\nimport \"./mathlib.sol\";\n\nenum savings {NO, DSR, COMPOUND}\n\nenum escrowstatus {CANCELLED, NOTACTIVATED, ACTIVATED, SETTLED}\n\nenum savestatus {NOTJOINED, JOINED, EXITED}\n\ncontract EscrowFactory is owned\n{\n    /*\n        This contract will create new Escrow Contract between 2 Parties\n    */\n    \n    address constant private dai_ = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    DaiErc20 private daiToken;\n\n    //Escrow Fee in wad\n    uint public escrowfee;\n    \n    //Switch that controls whether the factory is active\n    bool public factorycontractactive;\n    \n    \n    /** Events **/\n\n    //Event for new Escrow Contract\n    event NewEscrowEvent(address escrowcontractaddress, address indexed escrowpayer, address indexed escrowpayee, uint eventtime);\n    \n    //Event Overload\n    event NewEscrowEvent(address escrowcontractaddress, address indexed escrowpayer, address indexed escrowpayee, address indexed escrowmoderator, uint eventtime);\n    \n    constructor() public \n\t{\n\t    escrowfee = 1000000000000000000; //1 DAI\n\t\tfactorycontractactive = true;\n\t\tdaiToken = DaiErc20(dai_);\n\t}\n\n\n    function setEscrowFee(uint newfee) external onlyManager\n    {\n        /*\n            If in the future new fee is set, it can never be greater than 10 DAI\n        */\n        \n        require(newfee \u003e 0 \u0026\u0026 newfee \u003c= 10000000000000000000);\n        \n        escrowfee = newfee;\n    }\n    \n\n    function setFactoryContractSwitch() external onlyManager\n    {\n        /*\n            Switch that controls whether the contract is active\n        */\n        \n        factorycontractactive = factorycontractactive == true ? false : true;\n    }\n    \n    function createNewEscrow(address escrowpayee, uint escrowamount, uint choice) external \n    {\n        \n        require(factorycontractactive, \"Factory Contract should be Active\");\n        require(choice\u003e=0 \u0026\u0026 choice\u003c3,\"enum values can be 0,1,2\");\n        require(msg.sender != escrowpayee,\"The Payer \u0026 Payee should be different\");\n        require(escrowamount \u003e 0,\"Escrow amount has to be greater than 0\");\n        \n        \n        require(daiToken.allowance(msg.sender,address(this)) \u003e= mathlib.add(escrowamount, escrowfee), \"daiToken allowance exceeded\");\n        \n        Escrow EscrowContract = (new Escrow) (msg.sender, escrowpayee, escrowamount, choice);\n        \n        //The Esrow Amount get transferred to the new escrow contract\n        daiToken.transferFrom(msg.sender, address(EscrowContract), escrowamount);\n        \n        //Transfer the escrow fee to factory manager\n        daiToken.transferFrom(msg.sender, manager, escrowfee);\n        \n        if (choice == uint(savings.DSR))\n            {\n                EscrowContract.joinDSR();\n            }\n        else if (choice == uint(savings.COMPOUND))\n            {\n                EscrowContract.joincDai();\n            }\n        \n        \n        emit NewEscrowEvent(address(EscrowContract), msg.sender , escrowpayee , now);\n        \n    }\n    \n    //Function Overload with Moderator\n    function createNewEscrow(address escrowpayee, uint escrowamount, address escrowmoderator, uint escrowmoderatorfee, uint choice) external \n    {\n        \n        require(factorycontractactive, \"Factory Contract should be Active\");\n        require(choice\u003e=0 \u0026\u0026 choice\u003c3,\"enum values can be 0,1,2\");\n        require(msg.sender != escrowpayee \u0026\u0026 msg.sender != escrowmoderator \u0026\u0026 escrowpayee != escrowmoderator,\"The Payer, payee \u0026 moderator should be different\");\n        require(escrowamount \u003e 0,\"Escrow amount has to be greater than 0\");\n    \n        uint dailockedinnewescrow = mathlib.add(escrowamount,escrowmoderatorfee);\n  \n        require(daiToken.allowance(msg.sender,address(this)) \u003e= mathlib.add(dailockedinnewescrow, escrowfee), \"daiToken allowance exceeded\");\n        \n        EscrowWithModerator EscrowContract = (new EscrowWithModerator) (msg.sender, escrowpayee, escrowamount, choice, escrowmoderator, escrowmoderatorfee);\n        \n        //The Esrow Amount and Moderator fee gets transferred to the new escrow contract\n        daiToken.transferFrom(msg.sender, address(EscrowContract), dailockedinnewescrow);\n        \n        //Transfer the escrow fee to factory manager\n        daiToken.transferFrom(msg.sender, manager, escrowfee);\n        \n        if (choice == uint(savings.DSR))\n            {\n                EscrowContract.joinDSR();\n            }\n        else if (choice == uint(savings.COMPOUND))\n            {\n                EscrowContract.joincDai();\n            }\n        \n        emit NewEscrowEvent(address(EscrowContract), msg.sender , escrowpayee, escrowmoderator, now);\n        \n    }\n    \n}\n\ncontract Escrow\n{\n    savings public savingschoice;\n    \n    savestatus internal savingsstatus;\n    \n    escrowstatus public contractstatus;\n    \n    \n    //Contract addresses\n    address constant internal join_ = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address constant internal vat_ = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address constant internal pot_ = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\n    \n    address constant internal dai_ = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    \n    address constant internal cDai_ = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n    \n    address immutable internal fact_;\n    \n    // Contract interfaces\n    PotLike  internal pot;\n    JoinLike internal daiJoin;\n    VatLike  internal vat;\n    \n    DaiErc20  internal daiToken;\n    \n    cDaiErc20 internal cDaiToken;\n    \n    uint constant internal RAY = 10 ** 27;\n    \n    address immutable public escrowpayer;\n    address immutable public escrowpayee;\n    \n    bool public moderatoravailable;\n    \n    uint immutable public escrowamount;\n    uint public escrowsettlementamount;\n    \n    \n    //Escrow Status Change Event\n    event ContractStatusEvent(escrowstatus cstatus, uint eventtime);\n\n    constructor(address epayer,address epayee, uint eamount, uint choice) public\n    {\n        require(choice\u003e=0 \u0026\u0026 choice\u003c3,\"enum values can be 0,1,2\");\n        \n        contractstatus = escrowstatus.NOTACTIVATED;\n        savingsstatus = savestatus.NOTJOINED;\n        \n        escrowpayer = epayer;\n        escrowpayee = epayee;\n        \n        moderatoravailable = false;\n        \n        fact_ = msg.sender;\n        \n        daiToken = DaiErc20(dai_);\n        \n        \n        if (choice == uint(savings.NO))\n        {\n            savingschoice = savings.NO;   \n        }\n        else if (choice == uint(savings.DSR))\n        {\n            savingschoice = savings.DSR;\n            \n            daiJoin = JoinLike(join_);\n            vat = VatLike(vat_);\n            pot = PotLike(pot_);\n            \n            vat.hope(join_);\n            vat.hope(pot_);\n            \n            /*\n                Approval for DSR. Infinite approval is not a problem in this case since this escow contract\n                will only be used once\n            */\n            \n            daiToken.approve(join_, uint(-1));\n        }\n        else if(choice == uint(savings.COMPOUND))\n        {\n            savingschoice = savings.COMPOUND;\n            cDaiToken = cDaiErc20(cDai_);\n            \n            /*\n                Approval for cDai Compound. Infinite approval is not a problem in this case since this escow contract\n                will only be used once\n            */\n            \n            daiToken.approve(cDai_, uint(-1));\n        }\n        \n        escrowamount = eamount;\n        escrowsettlementamount = eamount; //Both are same when contract is created\n        \n    }\n    \n\n    modifier onlyFactory()\n    {\n        require(msg.sender == fact_, \"Only Factory\");\n        _;\n    }\n    \n    modifier onlyPayer()\n    {\n        require(msg.sender == escrowpayer, \"Only Payer\");\n        _;\n    }\n    \n    modifier onlyPayee()\n    {\n        require(msg.sender == escrowpayee, \"Only Payee\");\n        _;\n    }\n    \n    function joinDSR() public onlyFactory\n    {\n        /*\n            Deposit the contract amount in DSR    \n        */\n        \n        require(savingsstatus == savestatus.NOTJOINED,\"Already Joined\");\n        require(savingschoice == savings.DSR,\"Savngs Choice is not DSR\");\n        uint joinbal = getContractBalance();\n        uint chi = (now \u003e pot.rho()) ? pot.drip() : pot.chi();\n        daiJoin.join(address(this),joinbal);\n        pot.join(mathlib.mul(joinbal, RAY) / chi);\n        savingsstatus = savestatus.JOINED;\n    }\n\n\n    function exitAllDSR() internal\n    {\n        /*\n            Exit the DSR. The amount locked in DSR is transferred back to the Escrow Contract\n        */\n        \n        require(savingsstatus == savestatus.JOINED, \"DSR not Joined or already exited\");\n        require(savingschoice == savings.DSR,\"Savings Choice != savings.DSR\");\n        if (now \u003e pot.rho()) pot.drip();\n        pot.exit(pot.pie(address(this)));\n        daiJoin.exit(address(this), daiJoin.vat().dai(address(this)) / RAY);\n        savingsstatus = savestatus.EXITED;\n    }\n    \n     function getBalanceDSR() public view returns (uint) \n    {\n        \n        /*\n            Returns balance in Dai with DSR interest.\n            The value of chi is updated everytime someone on the\n            network calls the drip function.\n            Drip should be called after joining the pot, to calculate new balance.\n        */\n    \n        require(savingschoice == savings.DSR,\"savingschoice != DSR\");\n        \n        uint pie = pot.pie(address(this));\n        uint chi = pot.chi();\n        return mathlib.mul(pie,chi) / RAY;\n    }\n    \n    function joincDai() public onlyFactory \n    {\n        /*\n            Deposit the contract amount in Compound Protocol.\n            The contract will get the cDai Token.\n        */\n        \n        require(savingsstatus == savestatus.NOTJOINED,\"Already Joined\");\n        require(savingschoice == savings.COMPOUND ,\"savingschoice != COMPOUND\");\n        uint joinbal = getContractBalance();\n        uint mintResult = cDaiToken.mint(joinbal);\n        require(mintResult == 0, \"Error creating cDai\");\n        savingsstatus = savestatus.JOINED;\n    }\n    \n    function exitallcDai() internal\n    {\n        /*\n            Exit the Compound Protocol.\n        */\n        \n        require(savingsstatus == savestatus.JOINED, \"COMPOUND not Joined or already exited\");\n        require(savingschoice == savings.COMPOUND ,\"savingschoice != COMPOUND\");\n        uint cdaibal = getBalancecDai();\n        uint redeemResult = cDaiToken.redeem(cdaibal);\n        require(redeemResult == 0, \"Error Redeeming cDai to Dai\");\n        savingsstatus = savestatus.EXITED;\n    }\n    \n    function getBalancecDai() public view returns(uint)\n    {\n        //Returns cDai token Balance for this escrow contract\n        \n        require(savingschoice == savings.COMPOUND,\"savingschoice != COMPOUND\");\n        \n        return cDaiToken.balanceOf(address(this));\n    }\n    \n  \n    function exitsavingsifJoined() internal returns(bool)\n    {\n        /*\n            If contract amount is locked in DSR or Compound. This will exit from either\n            and return the DAI back to the Escrow contract.\n        */\n        \n            if (savingschoice == savings.NO)\n            {\n                    return true;\n            }\n            else if (savingschoice == savings.DSR)\n            {\n                     exitAllDSR();\n                     return savingsstatus == savestatus.EXITED ? true : false;\n            }\n            else if (savingschoice == savings.COMPOUND)\n            {\n                    exitallcDai();\n                    return savingsstatus == savestatus.EXITED ? true : false;\n                    \n            }\n    }\n    \n\n    function getContractAddress() external view returns (address)\n    {\n        return address(this);\n    }\n    \n    function getContractBalance() public view returns(uint)\n    {\n        //Gets contract balance in DAI\n        \n        return daiToken.balanceOf(address(this));\n    }\n    \n    \n    function setPayeeActivatedEscrow() external onlyPayee\n    {\n        /*\n            The Payee has to activate the Escrow contract for it to be valid.\n        */\n        \n        require(contractstatus == escrowstatus.NOTACTIVATED,\"Escrow should be NOT Activated\");\n        \n        contractstatus = escrowstatus.ACTIVATED;\n        emit ContractStatusEvent(contractstatus,now);\n    }\n    \n\n    function setCancelEscrow() external onlyPayer\n    {\n        /*\n            Allows the escrow payer to cancel the escrow if the\n            Escrow Payee has not activated it.\n        */\n        \n        require(contractstatus == escrowstatus.NOTACTIVATED,\"Escrow Should be Not Activated\");\n        \n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        \n        uint fullbalance = getContractBalance();\n        \n        require(fullbalance \u003e 0 ,\"fullbalance should be \u003e 0\");\n        \n        daiToken.transfer(escrowpayer,fullbalance);\n        \n        contractstatus = escrowstatus.CANCELLED;\n        emit ContractStatusEvent(contractstatus,now);\n        \n    }\n    \n    function setEscrowSettlementAmount(uint esettlementamount) virtual external onlyPayee\n    {\n        /*\n         Very Important: Only the escrow Payee can change this amount to less than the agreed escrowamount\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED,\"Escrow should be Activated\");\n        require(esettlementamount \u003e 0 \u0026\u0026 esettlementamount \u003c escrowamount, \"New settlement Amount not correct\");\n        escrowsettlementamount = esettlementamount;\n        \n    }\n    \n    function withdrawFundsFromSavings() virtual external onlyPayer\n    {\n        /*\n            This function will withdraw all funds from either DSR or COMPOUND\n            back into the Escrow Contract.\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED || contractstatus == escrowstatus.NOTACTIVATED, \"Escrow Cancelled or Settled\");\n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        savingschoice = savings.NO;\n    }\n    \n    function releaseFundsToPayee() virtual external onlyPayer\n    {\n        /*\n            1) The payee gets paid\n            2) Any remaining amount including interest is transferred to the Payer\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED, \"Escrow Should be activated, but not settled\");\n        \n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        \n        uint fullbalance = getContractBalance();\n        \n        //The contract balance has to be \u003e= escrowsettlementamount\n        require(fullbalance \u003e= escrowsettlementamount);\n        \n        uint payeramt =  mathlib.sub(fullbalance,escrowsettlementamount);\n        \n        //Payee gets paid\n        daiToken.transfer(escrowpayee,escrowsettlementamount);\n         \n        //Payer gets paid any remaining balance including interest \n        if (payeramt \u003e 0)\n        {\n            daiToken.transfer(escrowpayer,payeramt);\n        }\n  \n        contractstatus = escrowstatus.SETTLED;\n        emit ContractStatusEvent(contractstatus,now);\n        \n    }\n    \n    function refundFullFundsToPayer() virtual external onlyPayee\n    {\n        /*\n         1) The Payee refunds the entire amount to the payer.\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED, \"Escrow Should be activated, but not settled\");\n        \n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        \n        uint fullbalance = getContractBalance();\n        \n        require(fullbalance \u003e 0 ,\"fullbalance \u003c= 0\");\n        \n        //Payer gets refunded the full balance\n        daiToken.transfer(escrowpayer,fullbalance);\n         \n        contractstatus = escrowstatus.SETTLED; \n        emit ContractStatusEvent(contractstatus,now);\n        \n    }\n    \n}\n\ncontract EscrowWithModerator is Escrow\n{\n    \n    address immutable public escrowmoderator;\n    uint immutable public escrowmoderatorfee;\n    \n    constructor(address epayer,address epayee, uint eamount, uint choice, address emoderator, uint emoderatorfee) Escrow(epayer, epayee, eamount, choice) public\n    {\n\n        moderatoravailable = true;\n    \n        escrowmoderator = emoderator;\n        escrowmoderatorfee = emoderatorfee;\n        \n        \n    }\n    \n    modifier onlyPayerOrModerator()\n    {\n        require(msg.sender == escrowpayer || msg.sender == escrowmoderator, \"Only Payer or Moderator\");\n        _;\n    }\n    \n    modifier onlyPayeeOrModerator()\n    {\n        require(msg.sender == escrowpayee || msg.sender == escrowmoderator, \"Only Payee or Moderator\");\n        _;\n    }\n    \n\n    function setEscrowSettlementAmount(uint esettlementamount) override external onlyPayeeOrModerator\n    {\n        /*\n         Very Important: Only the escrow Payee or Moderator can change this amount to less than the agreed escrowamount\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED,\"Escrow should be Activated\");\n        require(esettlementamount \u003e 0 \u0026\u0026 esettlementamount \u003c escrowamount ,\"escrow settlementamount is incorrect\");\n        escrowsettlementamount = esettlementamount;\n    }\n    \n    function withdrawFundsFromSavings() override external onlyPayerOrModerator\n    {\n        /*\n            This function will withdraw all funds from either DSR or COMPOUND\n            back into the Escrow Contract\n        */\n       \n        require(contractstatus == escrowstatus.ACTIVATED || contractstatus == escrowstatus.NOTACTIVATED, \"Escrow Cancelled or Settled\");\n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        savingschoice = savings.NO;\n    }\n    \n    function releaseFundsToPayee() override external onlyPayerOrModerator\n    {\n        /*\n            1) The payee gets paid\n            2) The moderator gets paid the moderation fee if exists\n            3) Any remaining amount including interest is transferred to the Payer\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED, \"Escrow Should be activated, but not settled\");\n        \n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        \n        uint fullbalance = getContractBalance();\n        \n        uint minamtrequired = mathlib.add(escrowsettlementamount,escrowmoderatorfee);\n        \n        //The contract balance has to be \u003e= escrowsettlementamount and moderatorfee\n        require(fullbalance \u003e= minamtrequired);\n        \n        uint payeramt = mathlib.sub(fullbalance,minamtrequired);\n        \n        //Payee gets paid\n        daiToken.transfer(escrowpayee,escrowsettlementamount);\n        \n        //Moderator gets paid\n        if (escrowmoderatorfee \u003e 0)\n        {\n            daiToken.transfer(escrowmoderator,escrowmoderatorfee);\n        }\n        \n        //Payer gets paid any remaining balance including interest \n        if (payeramt \u003e 0)\n        {\n            daiToken.transfer(escrowpayer,payeramt);\n        }\n        \n        contractstatus = escrowstatus.SETTLED;\n        emit ContractStatusEvent(contractstatus,now);\n    \n    }\n    \n    function refundFullFundsToPayer() override external onlyPayeeOrModerator\n    {\n        /*\n             1) The payer gets refunded the full amount\n             2) The moderator gets paid the moderation fee if exists before the payer gets refunded the full amount.\n        */\n        \n        require(contractstatus == escrowstatus.ACTIVATED, \"Escrow Should be activated, but not settled\");\n        \n        require(exitsavingsifJoined() == true , \"Savings not exited\");\n        \n        uint fullbalance = getContractBalance();\n        \n        require(fullbalance \u003e 0 , \"fullbalance \u003c 0\");\n        \n        if (escrowmoderatorfee \u003e 0)\n        {\n            if (fullbalance \u003e escrowmoderatorfee)\n            {\n                uint payeramt = mathlib.sub(fullbalance,escrowmoderatorfee);\n                daiToken.transfer(escrowmoderator,escrowmoderatorfee);\n                daiToken.transfer(escrowpayer,payeramt);\n            }\n            else\n            {\n                daiToken.transfer(escrowmoderator,fullbalance);\n            }\n        }\n        else\n        {\n             daiToken.transfer(escrowpayer,fullbalance);\n        }\n        \n        contractstatus = escrowstatus.SETTLED;\n        emit ContractStatusEvent(contractstatus,now);\n\n    }\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}}