{"BimodalLib.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/**\n * This library defines the bi-modal commit-chain ledger. It provides data\n * structure definitions, accessors and mutators.\n */\nlibrary BimodalLib {\n    using SafeMathLib256 for uint256;\n\n    // ENUMS\n    enum ChallengeType {NONE, STATE_UPDATE, TRANSFER_DELIVERY, SWAP_ENACTMENT}\n\n    // DATA MODELS\n    /**\n     * Aggregate field datastructure used to sum up deposits / withdrawals for an eon.\n     */\n    struct AmountAggregate {\n        uint256 eon;\n        uint256 amount;\n    }\n\n    /**\n     * The structure for a submitted commit-chain checkpoint.\n     */\n    struct Checkpoint {\n        uint256 eonNumber;\n        bytes32 merkleRoot;\n        uint256 liveChallenges;\n    }\n\n    /**\n     * A structure representing a single commit-chain wallet.\n     */\n    struct Wallet {\n        // Deposits performed in the last three eons\n        AmountAggregate[3] depositsKept;\n        // Withdrawals requested and not yet confirmed\n        Withdrawal[] withdrawals;\n        // Recovery flag denoting whether this account has retrieved its funds\n        bool recovered;\n    }\n\n    /**\n     * A structure denoting a single withdrawal request.\n     */\n    struct Withdrawal {\n        uint256 eon;\n        uint256 amount;\n    }\n\n    /**\n     * A structure containing the information of a single challenge.\n     */\n    struct Challenge {\n        // State Update Challenges\n        ChallengeType challengeType; // 0\n        uint256 block; // 1\n        uint256 initialStateEon; // 2\n        uint256 initialStateBalance; // 3\n        uint256 deltaHighestSpendings; // 4\n        uint256 deltaHighestGains; // 5\n        uint256 finalStateBalance; // 6\n        uint256 deliveredTxNonce; // 7\n        uint64 trailIdentifier; // 8\n    }\n\n    /**\n     * The types of parent-chain operations logged into the accumulator.\n     */\n    enum Operation {DEPOSIT, WITHDRAWAL, CANCELLATION}\n\n    /* solhint-disable var-name-mixedcase */\n    /**\n     * The structure for an instance of the commit-chain ledger.\n     */\n    struct Ledger {\n        // OPERATIONAL CONSTANTS\n        uint8 EONS_KEPT;\n        uint8 DEPOSITS_KEPT;\n        uint256 MIN_CHALLENGE_GAS_COST;\n        uint256 BLOCKS_PER_EON;\n        uint256 BLOCKS_PER_EPOCH;\n        uint256 EXTENDED_BLOCKS_PER_EPOCH;\n        // STATE VARIABLES\n        uint256 genesis;\n        address operator;\n        Checkpoint[5] checkpoints;\n        bytes32[5] parentChainAccumulator; // bytes32[EONS_KEPT]\n        uint256 lastSubmissionEon;\n        mapping(address =\u003e mapping(address =\u003e mapping(address =\u003e Challenge))) challengeBook;\n        mapping(address =\u003e mapping(address =\u003e Wallet)) walletBook;\n        mapping(address =\u003e AmountAggregate[5]) deposits;\n        mapping(address =\u003e AmountAggregate[5]) pendingWithdrawals;\n        mapping(address =\u003e AmountAggregate[5]) confirmedWithdrawals;\n        mapping(address =\u003e uint64) tokenToTrail;\n        address[] trailToToken;\n    }\n\n    /* solhint-enable */\n\n    // INITIALIZATION\n    function init(\n        Ledger storage self,\n        uint256 blocksPerEon,\n        address operator\n    ) public {\n        self.BLOCKS_PER_EON = blocksPerEon;\n        self.BLOCKS_PER_EPOCH = self.BLOCKS_PER_EON.div(4);\n        self.EXTENDED_BLOCKS_PER_EPOCH = self.BLOCKS_PER_EON.div(3);\n        self.EONS_KEPT = 5; // eons kept on chain\n        self.DEPOSITS_KEPT = 3; // deposit aggregates kept on chain\n        self.MIN_CHALLENGE_GAS_COST = 0.005 szabo; // 5 gwei minimum gas reimbursement cost\n        self.operator = operator;\n        self.genesis = block.number;\n    }\n\n    // DATA ACCESS\n    /**\n     * This method calculates the current eon number using the genesis block number\n     * and eon duration.\n     */\n    function currentEon(Ledger storage self) public view returns (uint256) {\n        return block.number.sub(self.genesis).div(self.BLOCKS_PER_EON).add(1);\n    }\n\n    /**\n     * This method calculates the current era number\n     */\n    function currentEra(Ledger storage self) public view returns (uint256) {\n        return block.number.sub(self.genesis).mod(self.BLOCKS_PER_EON);\n    }\n\n    /**\n     * This method is used to embed a parent-chain operation into the accumulator\n     * through hashing its values. The on-chain accumulator is used to provide a\n     * reference with respect to which the operator can commit checkpoints.\n     */\n    function appendOperationToEonAccumulator(\n        Ledger storage self,\n        uint256 eon,\n        ERC20 token,\n        address participant,\n        Operation operation,\n        uint256 value\n    ) public {\n        self.parentChainAccumulator[eon.mod(self.EONS_KEPT)] = keccak256(\n            abi.encodePacked(\n                self.parentChainAccumulator[eon.mod(self.EONS_KEPT)],\n                eon,\n                token,\n                participant,\n                operation,\n                value\n            )\n        );\n    }\n\n    /**\n     * Retrieves the total pending withdrawal amount at a specific eon.\n     */\n    function getPendingWithdrawalsAtEon(\n        Ledger storage self,\n        ERC20 token,\n        uint256 eon\n    ) public view returns (uint256) {\n        uint256 lastAggregateEon = 0;\n        for (uint256 i = 0; i \u003c self.EONS_KEPT; i++) {\n            AmountAggregate storage currentAggregate = self\n                .pendingWithdrawals[token][eon.mod(self.EONS_KEPT)];\n            if (currentAggregate.eon == eon) {\n                return currentAggregate.amount;\n            } else if (\n                currentAggregate.eon \u003e lastAggregateEon \u0026\u0026\n                currentAggregate.eon \u003c eon\n            ) {\n                // As this is a running aggregate value, if the target eon value is not set,\n                // the most recent value is provided and assumed to have remained constant.\n                lastAggregateEon = currentAggregate.eon;\n            }\n            if (eon == 0) {\n                break;\n            }\n            eon = eon.sub(1);\n        }\n        if (lastAggregateEon == 0) {\n            return 0;\n        }\n        return\n            self.pendingWithdrawals[token][lastAggregateEon.mod(self.EONS_KEPT)]\n                .amount;\n    }\n\n    /**\n     * Increases the total pending withdrawal amount at a specific eon.\n     */\n    function addToRunningPendingWithdrawals(\n        Ledger storage self,\n        ERC20 token,\n        uint256 eon,\n        uint256 value\n    ) public {\n        AmountAggregate storage aggregate = self.pendingWithdrawals[token][eon\n            .mod(self.EONS_KEPT)];\n        // As this is a running aggregate, the target eon and all those that\n        // come after it are updated to reflect the increase.\n        if (aggregate.eon \u003c eon) {\n            // implies eon \u003e 0\n            aggregate.amount = getPendingWithdrawalsAtEon(\n                self,\n                token,\n                eon.sub(1)\n            )\n                .add(value);\n            aggregate.eon = eon;\n        } else {\n            aggregate.amount = aggregate.amount.add(value);\n        }\n    }\n\n    /**\n     * Decreases the total pending withdrawal amount at a specific eon.\n     */\n    function deductFromRunningPendingWithdrawals(\n        Ledger storage self,\n        ERC20 token,\n        uint256 eon,\n        uint256 latestEon,\n        uint256 value\n    ) public {\n        /* Initalize empty aggregates to running values */\n        for (uint256 i = 0; i \u003c self.EONS_KEPT; i++) {\n            uint256 targetEon = eon.add(i);\n            AmountAggregate storage aggregate = self\n                .pendingWithdrawals[token][targetEon.mod(self.EONS_KEPT)];\n            if (targetEon \u003e latestEon) {\n                break;\n            } else if (aggregate.eon \u003c targetEon) {\n                // implies targetEon \u003e 0\n                // Set constant running value\n                aggregate.eon = targetEon;\n                aggregate.amount = getPendingWithdrawalsAtEon(\n                    self,\n                    token,\n                    targetEon.sub(1)\n                );\n            }\n        }\n        /* Update running values */\n        for (i = 0; i \u003c self.EONS_KEPT; i++) {\n            targetEon = eon.add(i);\n            aggregate = self.pendingWithdrawals[token][targetEon.mod(\n                self.EONS_KEPT\n            )];\n            if (targetEon \u003e latestEon) {\n                break;\n            } else if (aggregate.eon \u003c targetEon) {\n                revert(\"X\"); // This is impossible.\n            } else {\n                aggregate.amount = aggregate.amount.sub(value);\n            }\n        }\n    }\n\n    /**\n     * Get the total number of live challenges for a specific eon.\n     */\n    function getLiveChallenges(Ledger storage self, uint256 eon)\n        public\n        view\n        returns (uint256)\n    {\n        Checkpoint storage checkpoint = self.checkpoints[eon.mod(\n            self.EONS_KEPT\n        )];\n        if (checkpoint.eonNumber != eon) {\n            return 0;\n        }\n        return checkpoint.liveChallenges;\n    }\n\n    /**\n     * Get checkpoint data or assume it to be empty if non-existant.\n     */\n    function getOrCreateCheckpoint(\n        Ledger storage self,\n        uint256 targetEon,\n        uint256 latestEon\n    ) public returns (Checkpoint storage checkpoint) {\n        require(\n            latestEon \u003c targetEon.add(self.EONS_KEPT) \u0026\u0026 targetEon \u003c= latestEon\n        );\n\n        uint256 index = targetEon.mod(self.EONS_KEPT);\n        checkpoint = self.checkpoints[index];\n\n        if (checkpoint.eonNumber != targetEon) {\n            checkpoint.eonNumber = targetEon;\n            checkpoint.merkleRoot = bytes32(0);\n            checkpoint.liveChallenges = 0;\n        }\n\n        return checkpoint;\n    }\n\n    /**\n     * Get the total amount pending withdrawal by a wallet at a specific eon.\n     */\n    function getWalletPendingWithdrawalAmountAtEon(\n        Ledger storage self,\n        ERC20 token,\n        address holder,\n        uint256 eon\n    ) public view returns (uint256 amount) {\n        amount = 0;\n\n        Wallet storage accountingEntry = self.walletBook[token][holder];\n        Withdrawal[] storage withdrawals = accountingEntry.withdrawals;\n        for (uint32 i = 0; i \u003c withdrawals.length; i++) {\n            Withdrawal storage withdrawal = withdrawals[i];\n            if (withdrawal.eon == eon) {\n                amount = amount.add(withdrawal.amount);\n            } else if (withdrawal.eon \u003e eon) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Get the total amounts deposited and pending withdrawal at the current eon.\n     */\n    function getCurrentEonDepositsWithdrawals(\n        Ledger storage self,\n        ERC20 token,\n        address holder\n    )\n        public\n        view\n        returns (uint256 currentEonDeposits, uint256 currentEonWithdrawals)\n    {\n        currentEonDeposits = 0;\n        currentEonWithdrawals = 0;\n\n        Wallet storage accountingEntry = self.walletBook[token][holder];\n        Challenge storage challengeEntry = self\n            .challengeBook[token][holder][holder];\n\n        AmountAggregate storage depositEntry = accountingEntry\n            .depositsKept[challengeEntry.initialStateEon.mod(\n            self.DEPOSITS_KEPT\n        )];\n\n        if (depositEntry.eon == challengeEntry.initialStateEon) {\n            currentEonDeposits = currentEonDeposits.add(depositEntry.amount);\n        }\n\n        currentEonWithdrawals = getWalletPendingWithdrawalAmountAtEon(\n            self,\n            token,\n            holder,\n            challengeEntry.initialStateEon\n        );\n\n        return (currentEonDeposits, currentEonWithdrawals);\n    }\n\n    // UTILITY\n    function addToAggregate(\n        AmountAggregate storage aggregate,\n        uint256 eon,\n        uint256 value\n    ) public {\n        if (eon \u003e aggregate.eon) {\n            aggregate.eon = eon;\n            aggregate.amount = value;\n        } else {\n            aggregate.amount = aggregate.amount.add(value);\n        }\n    }\n\n    function clearAggregate(AmountAggregate storage aggregate) public {\n        aggregate.eon = 0;\n        aggregate.amount = 0;\n    }\n\n    function signedMessageECRECOVER(\n        bytes32 message,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public pure returns (address) {\n        return\n            ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19Ethereum Signed Message:\\n32\",\n                        keccak256(\n                            abi.encodePacked(\n                                \"\\x19Liquidity.Network Authorization:\\n32\",\n                                message\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n    }\n}\n"},"BimodalProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./BimodalLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\ncontract BimodalProxy {\n    using SafeMathLib256 for uint256;\n    using BimodalLib for BimodalLib.Ledger;\n\n    // EVENTS\n    event CheckpointSubmission(uint256 indexed eon, bytes32 merkleRoot);\n\n    event Deposit(\n        address indexed token,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event WithdrawalRequest(\n        address indexed token,\n        address indexed requestor,\n        uint256 amount\n    );\n\n    event WithdrawalConfirmation(\n        address indexed token,\n        address indexed requestor,\n        uint256 amount\n    );\n\n    event ChallengeIssued(\n        address indexed token,\n        address indexed recipient,\n        address indexed sender\n    );\n\n    event StateUpdate(\n        address indexed token,\n        address indexed account,\n        uint256 indexed eon,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][3] lrDeltasPassiveMark,\n        bytes32 activeStateChecksum,\n        bytes32 passiveChecksum,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    );\n\n    // BIMODAL LEDGER DATA\n    BimodalLib.Ledger internal ledger;\n\n    // INITIALIZATION\n    constructor(uint256 blocksPerEon, address operator) public {\n        ledger.init(blocksPerEon, operator);\n    }\n\n    // SAFETY MODIFIERS\n    modifier onlyOperator() {\n        require(msg.sender == ledger.operator);\n        _;\n    }\n\n    modifier onlyWhenContractUnpunished() {\n        require(\n            !hasOutstandingChallenges() \u0026\u0026 !hasMissedCheckpointSubmission(),\n            \"p\"\n        );\n        _;\n    }\n\n    // PUBLIC DATA EXPOSURE\n    function getClientContractStateVariables(ERC20 token, address holder)\n        public\n        view\n        returns (\n            uint256 latestCheckpointEonNumber,\n            bytes32[5] latestCheckpointsMerkleRoots,\n            uint256[5] latestCheckpointsLiveChallenges,\n            uint256 currentEonDeposits,\n            uint256 previousEonDeposits,\n            uint256 secondPreviousEonDeposits,\n            uint256[2][] pendingWithdrawals,\n            uint256 holderBalance\n        )\n    {\n        latestCheckpointEonNumber = ledger.lastSubmissionEon;\n        for (\n            uint32 i = 0;\n            i \u003c ledger.EONS_KEPT \u0026\u0026 i \u003c ledger.currentEon();\n            i++\n        ) {\n            BimodalLib.Checkpoint storage checkpoint = ledger.checkpoints[ledger\n                .lastSubmissionEon\n                .sub(i)\n                .mod(ledger.EONS_KEPT)];\n            latestCheckpointsMerkleRoots[i] = checkpoint.merkleRoot;\n            latestCheckpointsLiveChallenges[i] = checkpoint.liveChallenges;\n        }\n\n        holderBalance = ledger.currentEon();\n        currentEonDeposits = getDepositsAtEon(token, holder, holderBalance);\n        if (holderBalance \u003e 1) {\n            previousEonDeposits = getDepositsAtEon(\n                token,\n                holder,\n                holderBalance - 1\n            );\n        }\n        if (holderBalance \u003e 2) {\n            secondPreviousEonDeposits = getDepositsAtEon(\n                token,\n                holder,\n                holderBalance - 2\n            );\n        }\n        BimodalLib.Wallet storage wallet = ledger.walletBook[token][holder];\n        pendingWithdrawals = new uint256[2][](wallet.withdrawals.length);\n        for (i = 0; i \u003c wallet.withdrawals.length; i++) {\n            BimodalLib.Withdrawal storage withdrawal = wallet.withdrawals[i];\n            pendingWithdrawals[i] = [withdrawal.eon, withdrawal.amount];\n        }\n        holderBalance = token != address(this)\n            ? token.balanceOf(holder)\n            : holder.balance;\n    }\n\n    function getServerContractStateVariables()\n        public\n        view\n        returns (\n            bytes32 parentChainAccumulator,\n            uint256 lastSubmissionEon,\n            bytes32 lastCheckpointRoot,\n            bool isCheckpointSubmitted,\n            bool missedCheckpointSubmission,\n            uint256 liveChallenges\n        )\n    {\n        uint256 currentEon = ledger.currentEon();\n        parentChainAccumulator = getParentChainAccumulatorAtSlot(\n            uint8(currentEon.mod(ledger.EONS_KEPT))\n        );\n\n        BimodalLib.Checkpoint storage lastCheckpoint = ledger.checkpoints[ledger\n            .lastSubmissionEon\n            .mod(ledger.EONS_KEPT)];\n        lastSubmissionEon = ledger.lastSubmissionEon;\n        lastCheckpointRoot = lastCheckpoint.merkleRoot;\n\n        isCheckpointSubmitted = lastSubmissionEon == currentEon;\n        missedCheckpointSubmission = hasMissedCheckpointSubmission();\n\n        liveChallenges = getLiveChallenges(currentEon);\n    }\n\n    function getServerContractLedgerStateVariables(\n        uint256 eonNumber,\n        ERC20 token\n    )\n        public\n        view\n        returns (\n            uint256 pendingWithdrawals,\n            uint256 confirmedWithdrawals,\n            uint256 deposits,\n            uint256 totalBalance\n        )\n    {\n        uint8 eonSlot = uint8(eonNumber.mod(ledger.EONS_KEPT));\n        uint256 targetEon = 0;\n        (targetEon, pendingWithdrawals) = getPendingWithdrawalsAtSlot(\n            token,\n            eonSlot\n        );\n        if (targetEon != eonNumber) {\n            pendingWithdrawals = 0;\n        }\n        (targetEon, confirmedWithdrawals) = getConfirmedWithdrawalsAtSlot(\n            token,\n            eonSlot\n        );\n        if (targetEon != eonNumber) {\n            confirmedWithdrawals = 0;\n        }\n        (targetEon, deposits) = getDepositsAtSlot(token, eonSlot);\n        if (targetEon != eonNumber) {\n            deposits = 0;\n        }\n        // totalBalance is for current state and not for eonNumber, which is stange\n        totalBalance = token != address(this)\n            ? token.balanceOf(this)\n            : address(this).balance;\n    }\n\n    function hasOutstandingChallenges() public view returns (bool) {\n        return\n            ledger.getLiveChallenges(ledger.currentEon().sub(1)) \u003e 0 \u0026\u0026\n            ledger.currentEra() \u003e ledger.BLOCKS_PER_EPOCH;\n    }\n\n    function hasMissedCheckpointSubmission() public view returns (bool) {\n        return ledger.currentEon().sub(ledger.lastSubmissionEon) \u003e 1;\n    }\n\n    function getCheckpointAtSlot(uint8 slot)\n        public\n        view\n        returns (\n            uint256,\n            bytes32,\n            uint256\n        )\n    {\n        BimodalLib.Checkpoint storage checkpoint = ledger.checkpoints[slot];\n        return (\n            checkpoint.eonNumber,\n            checkpoint.merkleRoot,\n            checkpoint.liveChallenges\n        );\n    }\n\n    function getParentChainAccumulatorAtSlot(uint8 slot)\n        public\n        view\n        returns (bytes32)\n    {\n        return ledger.parentChainAccumulator[slot];\n    }\n\n    function getChallenge(\n        ERC20 token,\n        address sender,\n        address recipient\n    )\n        public\n        view\n        returns (\n            BimodalLib.ChallengeType,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint64\n        )\n    {\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[token][recipient][sender];\n        return (\n            challenge.challengeType,\n            challenge.block,\n            challenge.initialStateEon,\n            challenge.initialStateBalance,\n            challenge.deltaHighestSpendings,\n            challenge.deltaHighestGains,\n            challenge.finalStateBalance,\n            challenge.deliveredTxNonce,\n            challenge.trailIdentifier\n        );\n    }\n\n    function getIsWalletRecovered(ERC20 token, address holder)\n        public\n        view\n        returns (bool)\n    {\n        BimodalLib.Wallet storage wallet = ledger.walletBook[token][holder];\n        return (wallet.recovered);\n    }\n\n    function getDepositsAtEon(\n        ERC20 token,\n        address addr,\n        uint256 eon\n    ) public view returns (uint256) {\n        (\n            uint256 aggregateEon,\n            uint256 aggregateAmount\n        ) = getWalletDepositAggregateAtSlot(\n            token,\n            addr,\n            uint8(eon.mod(ledger.DEPOSITS_KEPT))\n        );\n        return aggregateEon == eon ? aggregateAmount : 0;\n    }\n\n    function getDepositsAtSlot(ERC20 token, uint8 slot)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        BimodalLib.AmountAggregate storage aggregate = ledger\n            .deposits[token][slot];\n        return (aggregate.eon, aggregate.amount);\n    }\n\n    function getWalletDepositAggregateAtSlot(\n        ERC20 token,\n        address addr,\n        uint8 slot\n    ) public view returns (uint256, uint256) {\n        BimodalLib.AmountAggregate memory deposit = ledger\n            .walletBook[token][addr]\n            .depositsKept[slot];\n        return (deposit.eon, deposit.amount);\n    }\n\n    function getPendingWithdrawalsAtEon(ERC20 token, uint256 eon)\n        public\n        view\n        returns (uint256)\n    {\n        return ledger.getPendingWithdrawalsAtEon(token, eon);\n    }\n\n    function getPendingWithdrawalsAtSlot(ERC20 token, uint8 slot)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        BimodalLib.AmountAggregate storage aggregate = ledger\n            .pendingWithdrawals[token][slot];\n        return (aggregate.eon, aggregate.amount);\n    }\n\n    function getConfirmedWithdrawalsAtSlot(ERC20 token, uint8 slot)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        BimodalLib.AmountAggregate storage aggregate = ledger\n            .confirmedWithdrawals[token][slot];\n        return (aggregate.eon, aggregate.amount);\n    }\n\n    function getWalletPendingWithdrawalAmountAtEon(\n        ERC20 token,\n        address holder,\n        uint256 eon\n    ) public view returns (uint256) {\n        return ledger.getWalletPendingWithdrawalAmountAtEon(token, holder, eon);\n    }\n\n    function getTokenTrail(ERC20 token) public view returns (uint64) {\n        return ledger.tokenToTrail[token];\n    }\n\n    function getTokenAtTrail(uint64 trail) public view returns (address) {\n        return ledger.trailToToken[trail];\n    }\n\n    function getCurrentEonDepositsWithdrawals(ERC20 token, address holder)\n        public\n        view\n        returns (uint256 currentEonDeposits, uint256 currentEonWithdrawals)\n    {\n        return ledger.getCurrentEonDepositsWithdrawals(token, holder);\n    }\n\n    function EONS_KEPT()\n        public\n        view\n        returns (\n            // solhint-disable-line func-name-mixedcase\n            uint8\n        )\n    {\n        return ledger.EONS_KEPT;\n    }\n\n    function DEPOSITS_KEPT()\n        public\n        view\n        returns (\n            // solhint-disable-line func-name-mixedcase\n            uint8\n        )\n    {\n        return ledger.DEPOSITS_KEPT;\n    }\n\n    function MIN_CHALLENGE_GAS_COST()\n        public\n        view\n        returns (\n            // solhint-disable-line func-name-mixedcase\n            uint256\n        )\n    {\n        return ledger.MIN_CHALLENGE_GAS_COST;\n    }\n\n    function BLOCKS_PER_EON()\n        public\n        view\n        returns (\n            // solhint-disable-line func-name-mixedcase\n            uint256\n        )\n    {\n        return ledger.BLOCKS_PER_EON;\n    }\n\n    function BLOCKS_PER_EPOCH()\n        public\n        view\n        returns (\n            // solhint-disable-line func-name-mixedcase\n            uint256\n        )\n    {\n        return ledger.BLOCKS_PER_EPOCH;\n    }\n\n    function EXTENDED_BLOCKS_PER_EPOCH()\n        public\n        view\n        returns (\n            // solhint-disable-line func-name-mixedcase\n            uint256\n        )\n    {\n        return ledger.EXTENDED_BLOCKS_PER_EPOCH;\n    }\n\n    function genesis() public view returns (uint256) {\n        return ledger.genesis;\n    }\n\n    function operator() public view returns (address) {\n        return ledger.operator;\n    }\n\n    function lastSubmissionEon() public view returns (uint256) {\n        return ledger.lastSubmissionEon;\n    }\n\n    function currentEon() public view returns (uint256) {\n        return ledger.currentEon();\n    }\n\n    function currentEra() public view returns (uint256) {\n        return ledger.currentEra();\n    }\n\n    function getLiveChallenges(uint256 eon) public view returns (uint256) {\n        BimodalLib.Checkpoint storage checkpoint = ledger.checkpoints[eon.mod(\n            ledger.EONS_KEPT\n        )];\n        if (checkpoint.eonNumber != eon) {\n            return 0;\n        }\n        return checkpoint.liveChallenges;\n    }\n\n    function signedMessageECRECOVER(\n        bytes32 message,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public pure returns (address) {\n        return BimodalLib.signedMessageECRECOVER(message, r, s, v);\n    }\n}\n"},"ChallengeLib.sol":{"content":"/* solhint-disable func-order */\n\npragma solidity ^0.4.24;\n\nimport \"./BimodalLib.sol\";\nimport \"./MerkleVerifier.sol\";\nimport \"./SafeMathLib32.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/**\n * This library contains the challenge-response implementations of NOCUST.\n */\nlibrary ChallengeLib {\n    using SafeMathLib256 for uint256;\n    using SafeMathLib32 for uint32;\n    using BimodalLib for BimodalLib.Ledger;\n    // EVENTS\n    event ChallengeIssued(\n        address indexed token,\n        address indexed recipient,\n        address indexed sender\n    );\n\n    event StateUpdate(\n        address indexed token,\n        address indexed account,\n        uint256 indexed eon,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][3] lrDeltasPassiveMark,\n        bytes32 activeStateChecksum,\n        bytes32 passiveChecksum,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    );\n\n    // Validation\n    function verifyProofOfExclusiveAccountBalanceAllotment(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address holder,\n        bytes32[2] activeStateChecksum_passiveTransfersRoot, // solhint-disable func-param-name-mixedcase\n        uint64 trail,\n        uint256[3] eonPassiveMark,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2] LR // solhint-disable func-param-name-mixedcase\n    ) public view returns (bool) {\n        BimodalLib.Checkpoint memory checkpoint = ledger\n            .checkpoints[eonPassiveMark[0].mod(ledger.EONS_KEPT)];\n        require(eonPassiveMark[0] == checkpoint.eonNumber, \"r\");\n\n        // activeStateChecksum is set to the account node.\n        activeStateChecksum_passiveTransfersRoot[0] = keccak256(\n            abi.encodePacked(\n                keccak256(abi.encodePacked(address(this))),\n                keccak256(abi.encodePacked(token)),\n                keccak256(abi.encodePacked(holder)),\n                keccak256(\n                    abi.encodePacked(\n                        activeStateChecksum_passiveTransfersRoot[1], // passiveTransfersRoot\n                        eonPassiveMark[1],\n                        eonPassiveMark[2]\n                    )\n                ),\n                activeStateChecksum_passiveTransfersRoot[0] // activeStateChecksum\n            )\n        );\n        // the interval allotment is set to form the leaf\n        activeStateChecksum_passiveTransfersRoot[0] = keccak256(\n            abi.encodePacked(\n                LR[0],\n                activeStateChecksum_passiveTransfersRoot[0],\n                LR[1]\n            )\n        );\n\n        // This calls the merkle verification procedure, which returns the\n        // checkpoint allotment size\n        uint64 tokenTrail = ledger.tokenToTrail[token];\n        LR[0] = MerkleVerifier.verifyProofOfExclusiveBalanceAllotment(\n            trail,\n            tokenTrail,\n            activeStateChecksum_passiveTransfersRoot[0],\n            checkpoint.merkleRoot,\n            allotmentChain,\n            membershipChain,\n            values,\n            LR\n        );\n\n        // The previous allotment size of the target eon is reconstructed from the\n        // deposits and withdrawals performed so far and the current balance.\n        LR[1] = address(this).balance;\n\n        if (token != address(this)) {\n            require(tokenTrail != 0, \"t\");\n            LR[1] = token.balanceOf(this);\n        }\n\n        // Credit back confirmed withdrawals that were performed since target eon\n        for (tokenTrail = 0; tokenTrail \u003c ledger.EONS_KEPT; tokenTrail++) {\n            if (\n                ledger.confirmedWithdrawals[token][tokenTrail].eon \u003e=\n                eonPassiveMark[0]\n            ) {\n                LR[1] = LR[1].add(\n                    ledger.confirmedWithdrawals[token][tokenTrail].amount\n                );\n            }\n        }\n        // Debit deposits performed since target eon\n        for (tokenTrail = 0; tokenTrail \u003c ledger.EONS_KEPT; tokenTrail++) {\n            if (ledger.deposits[token][tokenTrail].eon \u003e= eonPassiveMark[0]) {\n                LR[1] = LR[1].sub(ledger.deposits[token][tokenTrail].amount);\n            }\n        }\n        // Debit withdrawals pending since prior eon\n        LR[1] = LR[1].sub(\n            ledger.getPendingWithdrawalsAtEon(token, eonPassiveMark[0].sub(1))\n        );\n        // Require that the reconstructed allotment matches the proof allotment\n        require(LR[0] \u003c= LR[1], \"b\");\n\n        return true;\n    }\n\n    function verifyProofOfActiveStateUpdateAgreement(\n        ERC20 token,\n        address holder,\n        uint64 trail,\n        uint256 eon,\n        bytes32 txSetRoot,\n        uint256[2] deltas,\n        address attester,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public view returns (bytes32 checksum) {\n        checksum = MerkleVerifier.activeStateUpdateChecksum(\n            token,\n            holder,\n            trail,\n            eon,\n            txSetRoot,\n            deltas\n        );\n        require(\n            attester == BimodalLib.signedMessageECRECOVER(checksum, r, s, v),\n            \"A\"\n        );\n    }\n\n    function verifyWithdrawalAuthorization(\n        ERC20 token,\n        address holder,\n        uint256 expiry,\n        uint256 amount,\n        address attester,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public view returns (bool) {\n        bytes32 checksum = keccak256(\n            abi.encodePacked(\n                keccak256(abi.encodePacked(address(this))),\n                keccak256(abi.encodePacked(token)),\n                keccak256(abi.encodePacked(holder)),\n                expiry,\n                amount\n            )\n        );\n        require(\n            attester == BimodalLib.signedMessageECRECOVER(checksum, r, s, v),\n            \"a\"\n        );\n        return true;\n    }\n\n    // Challenge Lifecycle Methods\n    /**\n     * This method increments the live challenge counter and emits and event\n     * containing the challenge index.\n     */\n    function markChallengeLive(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address recipient,\n        address sender\n    ) private {\n        require(ledger.currentEra() \u003e ledger.BLOCKS_PER_EPOCH);\n\n        uint256 eon = ledger.currentEon();\n        BimodalLib.Checkpoint storage checkpoint = ledger.getOrCreateCheckpoint(\n            eon,\n            eon\n        );\n        checkpoint.liveChallenges = checkpoint.liveChallenges.add(1);\n        emit ChallengeIssued(token, recipient, sender);\n    }\n\n    /**\n     * This method clears all the data in a Challenge structure and decrements the\n     * live challenge counter.\n     */\n    function clearChallenge(\n        BimodalLib.Ledger storage ledger,\n        BimodalLib.Challenge storage challenge\n    ) private {\n        BimodalLib.Checkpoint storage checkpoint = ledger.getOrCreateCheckpoint(\n            challenge.initialStateEon.add(1),\n            ledger.currentEon()\n        );\n        checkpoint.liveChallenges = checkpoint.liveChallenges.sub(1);\n\n        challenge.challengeType = BimodalLib.ChallengeType.NONE;\n        challenge.block = 0;\n        // challenge.initialStateEon = 0;\n        challenge.initialStateBalance = 0;\n        challenge.deltaHighestSpendings = 0;\n        challenge.deltaHighestGains = 0;\n        challenge.finalStateBalance = 0;\n        challenge.deliveredTxNonce = 0;\n        challenge.trailIdentifier = 0;\n    }\n\n    /**\n     * This method marks a challenge as having been successfully answered only if\n     * the response was provided in time.\n     */\n    function markChallengeAnswered(\n        BimodalLib.Ledger storage ledger,\n        BimodalLib.Challenge storage challenge\n    ) private {\n        uint256 eon = ledger.currentEon();\n\n        require(\n            challenge.challengeType != BimodalLib.ChallengeType.NONE \u0026\u0026\n                block.number.sub(challenge.block) \u003c ledger.BLOCKS_PER_EPOCH \u0026\u0026\n                (challenge.initialStateEon == eon.sub(1) ||\n                    (challenge.initialStateEon == eon.sub(2) \u0026\u0026\n                        ledger.currentEra() \u003c ledger.BLOCKS_PER_EPOCH))\n        );\n\n        clearChallenge(ledger, challenge);\n    }\n\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    // ====================================  STATE UPDATE Challenge\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    /**\n     * This method initiates the fields of the Challenge struct to hold a state\n     * update challenge.\n     */\n    function initStateUpdateChallenge(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        uint256 owed,\n        uint256[2] spentGained,\n        uint64 trail\n    ) private {\n        BimodalLib.Challenge storage challengeEntry = ledger\n            .challengeBook[token][msg.sender][msg.sender];\n        require(challengeEntry.challengeType == BimodalLib.ChallengeType.NONE);\n        require(challengeEntry.initialStateEon \u003c ledger.currentEon().sub(1));\n\n        challengeEntry.initialStateEon = ledger.currentEon().sub(1);\n        challengeEntry.initialStateBalance = owed;\n        challengeEntry.deltaHighestSpendings = spentGained[0];\n        challengeEntry.deltaHighestGains = spentGained[1];\n        challengeEntry.trailIdentifier = trail;\n\n        challengeEntry.challengeType = BimodalLib.ChallengeType.STATE_UPDATE;\n        challengeEntry.block = block.number;\n\n        markChallengeLive(ledger, token, msg.sender, msg.sender);\n    }\n\n    /**\n     * This method checks that the updated balance is at least as much as the\n     * expected balance.\n     */\n    function checkStateUpdateBalance(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address issuer,\n        BimodalLib.Challenge storage challenge,\n        uint256[2] LR, // solhint-disable func-param-name-mixedcase\n        uint256[2] spentGained,\n        uint256 passivelyReceived\n    ) private view {\n        (uint256 deposits, uint256 withdrawals) = ledger\n            .getCurrentEonDepositsWithdrawals(token, issuer);\n        uint256 incoming = spentGained[1] // actively received in commit chain\n            .add(deposits)\n            .add(passivelyReceived);\n        uint256 outgoing = spentGained[0] // actively spent in commit chain\n            .add(withdrawals);\n        // This verification is modified to permit underflow of expected balance\n        // since a client can choose to zero the `challenge.initialStateBalance`\n        require(\n            challenge.initialStateBalance.add(incoming) \u003c=\n                LR[1]\n                    .sub(LR[0]) // final balance allotment\n                    .add(outgoing),\n            \"B\"\n        );\n    }\n\n    function challengeStateUpdateWithProofOfExclusiveBalanceAllotment(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        bytes32[2] checksums,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] value,\n        uint256[2][3] lrDeltasPassiveMark,\n        bytes32[3] rsTxSetRoot,\n        uint8 v\n    ) public /* payable */\n    /* onlyWithFairReimbursement(ledger) */\n    {\n        uint256 previousEon = ledger.currentEon().sub(1);\n        address operator = ledger.operator;\n\n        // The hub must have committed to this state update\n        if (lrDeltasPassiveMark[1][0] != 0 || lrDeltasPassiveMark[1][1] != 0) {\n            verifyProofOfActiveStateUpdateAgreement(\n                token,\n                msg.sender,\n                trail,\n                previousEon,\n                rsTxSetRoot[2],\n                lrDeltasPassiveMark[1],\n                operator,\n                rsTxSetRoot[0],\n                rsTxSetRoot[1],\n                v\n            );\n        }\n\n        initStateUpdateChallenge(\n            ledger,\n            token,\n            lrDeltasPassiveMark[0][1].sub(lrDeltasPassiveMark[0][0]),\n            lrDeltasPassiveMark[1],\n            trail\n        );\n\n        // The initial state must have been ratified in the commitment\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                msg.sender,\n                checksums,\n                trail,\n                [\n                    previousEon,\n                    lrDeltasPassiveMark[2][0],\n                    lrDeltasPassiveMark[2][1]\n                ],\n                allotmentChain,\n                membershipChain,\n                value,\n                lrDeltasPassiveMark[0]\n            )\n        );\n    }\n\n    function challengeStateUpdateWithProofOfActiveStateUpdateAgreement(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        bytes32 txSetRoot,\n        uint64 trail,\n        uint256[2] deltas,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public /* payable */\n    /* TODO calculate exact addition */\n    /* onlyWithSkewedReimbursement(ledger, 25) */\n    {\n        // The hub must have committed to this transition\n        verifyProofOfActiveStateUpdateAgreement(\n            token,\n            msg.sender,\n            trail,\n            ledger.currentEon().sub(1),\n            txSetRoot,\n            deltas,\n            ledger.operator,\n            r,\n            s,\n            v\n        );\n\n        initStateUpdateChallenge(ledger, token, 0, deltas, trail);\n    }\n\n    function answerStateUpdateChallenge(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address issuer,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][3] lrDeltasPassiveMark, // [ [L, R], Deltas ]\n        bytes32[6] rSrStxSetRootChecksum,\n        uint8[2] v\n    ) public {\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[token][issuer][issuer];\n        require(\n            challenge.challengeType == BimodalLib.ChallengeType.STATE_UPDATE\n        );\n\n        // Transition must have been approved by issuer\n        if (lrDeltasPassiveMark[1][0] != 0 || lrDeltasPassiveMark[1][1] != 0) {\n            rSrStxSetRootChecksum[0] = verifyProofOfActiveStateUpdateAgreement(\n                token,\n                issuer,\n                challenge.trailIdentifier,\n                challenge.initialStateEon,\n                rSrStxSetRootChecksum[4], // txSetRoot\n                lrDeltasPassiveMark[1], // deltas\n                issuer,\n                rSrStxSetRootChecksum[0], // R[0]\n                rSrStxSetRootChecksum[1], // S[0]\n                v[0]\n            );\n            address operator = ledger.operator;\n            rSrStxSetRootChecksum[1] = verifyProofOfActiveStateUpdateAgreement(\n                token,\n                issuer,\n                challenge.trailIdentifier,\n                challenge.initialStateEon,\n                rSrStxSetRootChecksum[4], // txSetRoot\n                lrDeltasPassiveMark[1], // deltas\n                operator,\n                rSrStxSetRootChecksum[2], // R[1]\n                rSrStxSetRootChecksum[3], // S[1]\n                v[1]\n            );\n            require(rSrStxSetRootChecksum[0] == rSrStxSetRootChecksum[1], \"u\");\n        } else {\n            rSrStxSetRootChecksum[0] = bytes32(0);\n        }\n\n        // Transition has to be at least as recent as submitted one\n        require(\n            lrDeltasPassiveMark[1][0] \u003e= challenge.deltaHighestSpendings \u0026\u0026\n                lrDeltasPassiveMark[1][1] \u003e= challenge.deltaHighestGains,\n            \"x\"\n        );\n\n        // Transition has to have been properly applied\n        checkStateUpdateBalance(\n            ledger,\n            token,\n            issuer,\n            challenge,\n            lrDeltasPassiveMark[0], // LR\n            lrDeltasPassiveMark[1], // deltas\n            lrDeltasPassiveMark[2][0]\n        ); // passive amount\n\n        // Truffle crashes when trying to interpret this event in some cases.\n        emit StateUpdate(\n            token,\n            issuer,\n            challenge.initialStateEon.add(1),\n            challenge.trailIdentifier,\n            allotmentChain,\n            membershipChain,\n            values,\n            lrDeltasPassiveMark,\n            rSrStxSetRootChecksum[0], // activeStateChecksum\n            rSrStxSetRootChecksum[5], // passiveAcceptChecksum\n            rSrStxSetRootChecksum[2], // R[1]\n            rSrStxSetRootChecksum[3], // S[1]\n            v[1]\n        );\n\n        // Proof of stake must be ratified in the checkpoint\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                issuer,\n                [rSrStxSetRootChecksum[0], rSrStxSetRootChecksum[5]], // activeStateChecksum, passiveAcceptChecksum\n                challenge.trailIdentifier,\n                [\n                    challenge.initialStateEon.add(1), // eonNumber\n                    lrDeltasPassiveMark[2][0], // passiveAmount\n                    lrDeltasPassiveMark[2][1]\n                ],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrDeltasPassiveMark[0]\n            ), // LR\n            \"c\"\n        );\n\n        markChallengeAnswered(ledger, challenge);\n    }\n\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    // ====================================  ACTIVE DELIVERY Challenge\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    function initTransferDeliveryChallenge(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address sender,\n        address recipient,\n        uint256 amount,\n        uint256 txNonce,\n        uint64 trail\n    ) private {\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[token][recipient][sender];\n        require(challenge.challengeType == BimodalLib.ChallengeType.NONE);\n        require(challenge.initialStateEon \u003c ledger.currentEon().sub(1));\n\n        challenge.challengeType = BimodalLib.ChallengeType.TRANSFER_DELIVERY;\n        challenge.initialStateEon = ledger.currentEon().sub(1);\n        challenge.deliveredTxNonce = txNonce;\n        challenge.block = block.number;\n        challenge.trailIdentifier = trail;\n        challenge.finalStateBalance = amount;\n\n        markChallengeLive(ledger, token, recipient, sender);\n    }\n\n    function challengeTransferDeliveryWithProofOfActiveStateUpdateAgreement(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address[2] SR, // solhint-disable func-param-name-mixedcase\n        uint256[2] nonceAmount,\n        uint64[3] trails,\n        bytes32[] chain,\n        uint256[2] deltas,\n        bytes32[3] rsTxSetRoot,\n        uint8 v\n    ) public /* payable */\n    /* onlyWithFairReimbursement() */\n    {\n        require(msg.sender == SR[0] || msg.sender == SR[1], \"d\");\n\n        // Require hub to have committed to transition\n        verifyProofOfActiveStateUpdateAgreement(\n            token,\n            SR[0],\n            trails[0],\n            ledger.currentEon().sub(1),\n            rsTxSetRoot[2],\n            deltas,\n            ledger.operator,\n            rsTxSetRoot[0],\n            rsTxSetRoot[1],\n            v\n        );\n\n        rsTxSetRoot[0] = MerkleVerifier.transferChecksum(\n            SR[1],\n            nonceAmount[1], // amount\n            trails[2],\n            nonceAmount[0]\n        ); // nonce\n\n        // Require tx to exist in transition\n        require(\n            MerkleVerifier.verifyProofOfMembership(\n                trails[1],\n                chain,\n                rsTxSetRoot[0], // transferChecksum\n                rsTxSetRoot[2]\n            ), // txSetRoot\n            \"e\"\n        );\n\n        initTransferDeliveryChallenge(\n            ledger,\n            token,\n            SR[0], // senderAddress\n            SR[1], // recipientAddress\n            nonceAmount[1], // amount\n            nonceAmount[0], // nonce\n            trails[2]\n        ); // recipientTrail\n    }\n\n    function answerTransferDeliveryChallengeWithProofOfActiveStateUpdateAgreement(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address[2] SR, // solhint-disable func-param-name-mixedcase\n        uint64 transferMembershipTrail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][3] lrDeltasPassiveMark,\n        bytes32[2] txSetRootChecksum,\n        bytes32[] txChain\n    ) public {\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[token][SR[1]][SR[0]];\n        require(\n            challenge.challengeType ==\n                BimodalLib.ChallengeType.TRANSFER_DELIVERY\n        );\n\n        // Assert that the challenged transaction belongs to the transfer set\n        require(\n            MerkleVerifier.verifyProofOfMembership(\n                transferMembershipTrail,\n                txChain,\n                MerkleVerifier.transferChecksum(\n                    SR[0],\n                    challenge.finalStateBalance, // amount\n                    challenge.trailIdentifier, // recipient trail\n                    challenge.deliveredTxNonce\n                ),\n                txSetRootChecksum[0]\n            )\n        ); // txSetRoot\n\n        // Require committed transition to include transfer\n        txSetRootChecksum[0] = MerkleVerifier.activeStateUpdateChecksum(\n            token,\n            SR[1],\n            challenge.trailIdentifier,\n            challenge.initialStateEon,\n            txSetRootChecksum[0], // txSetRoot\n            lrDeltasPassiveMark[1]\n        ); // Deltas\n\n        // Assert that this transition was used to update the recipient\u0027s stake\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                SR[1], // recipient\n                txSetRootChecksum, // [activeStateChecksum, passiveChecksum]\n                challenge.trailIdentifier,\n                [\n                    challenge.initialStateEon.add(1), // eonNumber\n                    lrDeltasPassiveMark[2][0], // passiveAmount\n                    lrDeltasPassiveMark[2][1] // passiveMark\n                ],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrDeltasPassiveMark[0]\n            )\n        ); // LR\n\n        markChallengeAnswered(ledger, challenge);\n    }\n\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    // ====================================  PASSIVE DELIVERY Challenge\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    function challengeTransferDeliveryWithProofOfPassiveStateUpdate(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address[2] SR, // solhint-disable func-param-name-mixedcase\n        bytes32[2] txSetRootChecksum,\n        uint64[3] senderTransferRecipientTrails,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][4] lrDeltasPassiveMarkDummyAmount,\n        bytes32[] transferMembershipChain\n    ) public /* payable */\n    /* onlyWithFairReimbursement() */\n    {\n        require(msg.sender == SR[0] || msg.sender == SR[1], \"d\");\n        lrDeltasPassiveMarkDummyAmount[3][0] = ledger.currentEon().sub(1); // previousEon\n\n        // Assert that the challenged transaction ends the transfer set\n        require(\n            MerkleVerifier.verifyProofOfMembership(\n                senderTransferRecipientTrails[1], // transferMembershipTrail\n                transferMembershipChain,\n                MerkleVerifier.transferChecksum(\n                    SR[1], // recipientAddress\n                    lrDeltasPassiveMarkDummyAmount[3][1], // amount\n                    senderTransferRecipientTrails[2], // recipientTrail\n                    2**256 - 1\n                ), // nonce\n                txSetRootChecksum[0]\n            ), // txSetRoot\n            \"e\"\n        );\n\n        // Require committed transition to include transfer\n        txSetRootChecksum[0] = MerkleVerifier.activeStateUpdateChecksum(\n            token,\n            SR[0], // senderAddress\n            senderTransferRecipientTrails[0], // senderTrail\n            lrDeltasPassiveMarkDummyAmount[3][0], // previousEon\n            txSetRootChecksum[0], // txSetRoot\n            lrDeltasPassiveMarkDummyAmount[1]\n        ); // Deltas\n\n        // Assert that this transition was used to update the sender\u0027s stake\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                SR[0], // senderAddress\n                txSetRootChecksum, // [activeStateChecksum, passiveChecksum]\n                senderTransferRecipientTrails[0], // senderTrail\n                [\n                    lrDeltasPassiveMarkDummyAmount[3][0].add(1), // eonNumber\n                    lrDeltasPassiveMarkDummyAmount[2][0], // passiveAmount\n                    lrDeltasPassiveMarkDummyAmount[2][1] // passiveMark\n                ],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrDeltasPassiveMarkDummyAmount[0]\n            )\n        ); // LR\n\n        initTransferDeliveryChallenge(\n            ledger,\n            token,\n            SR[0], // sender\n            SR[1], // recipient\n            lrDeltasPassiveMarkDummyAmount[3][1], // amount\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        lrDeltasPassiveMarkDummyAmount[2][1],\n                        uint256(2**256 - 1)\n                    )\n                )\n            ), // mark (nonce)\n            senderTransferRecipientTrails[2]\n        ); // recipientTrail\n    }\n\n    function answerTransferDeliveryChallengeWithProofOfPassiveStateUpdate(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address[2] SR, // solhint-disable func-param-name-mixedcase\n        uint64 transferMembershipTrail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][3] lrPassiveMarkPositionNonce,\n        bytes32[2] checksums,\n        bytes32[] txChainValues\n    ) public {\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[token][SR[1]][SR[0]];\n        require(\n            challenge.challengeType ==\n                BimodalLib.ChallengeType.TRANSFER_DELIVERY\n        );\n        require(\n            challenge.deliveredTxNonce ==\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            lrPassiveMarkPositionNonce[2][0],\n                            lrPassiveMarkPositionNonce[2][1]\n                        )\n                    )\n                )\n        );\n\n        // Assert that the challenged transaction belongs to the passively delivered set\n        require(\n            MerkleVerifier.verifyProofOfPassiveDelivery(\n                transferMembershipTrail,\n                MerkleVerifier.transferChecksum( // node\n                    SR[0], // sender\n                    challenge.finalStateBalance, // amount\n                    challenge.trailIdentifier, // recipient trail\n                    challenge.deliveredTxNonce\n                ),\n                checksums[1], // passiveChecksum\n                txChainValues,\n                [\n                    lrPassiveMarkPositionNonce[2][0],\n                    lrPassiveMarkPositionNonce[2][0].add(\n                        challenge.finalStateBalance\n                    )\n                ]\n            ) \u003c= lrPassiveMarkPositionNonce[1][0]\n        );\n\n        // Assert that this transition was used to update the recipient\u0027s stake\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                SR[1], // recipient\n                checksums, // [activeStateChecksum, passiveChecksum]\n                challenge.trailIdentifier, // recipientTrail\n                [\n                    challenge.initialStateEon.add(1), // eonNumber\n                    lrPassiveMarkPositionNonce[1][0], // passiveAmount\n                    lrPassiveMarkPositionNonce[1][1] // passiveMark\n                ],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrPassiveMarkPositionNonce[0]\n            )\n        ); // LR\n\n        markChallengeAnswered(ledger, challenge);\n    }\n\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    // ====================================  SWAP Challenge\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    function initSwapEnactmentChallenge(\n        BimodalLib.Ledger storage ledger,\n        ERC20[2] tokens,\n        uint256[4] updatedSpentGainedPassive,\n        uint256[4] sellBuyBalanceNonce,\n        uint64 recipientTrail\n    ) private {\n        ERC20 conduit = ERC20(\n            address(keccak256(abi.encodePacked(tokens[0], tokens[1])))\n        );\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[conduit][msg.sender][msg.sender];\n        require(challenge.challengeType == BimodalLib.ChallengeType.NONE);\n        require(challenge.initialStateEon \u003c ledger.currentEon().sub(1));\n\n        challenge.initialStateEon = ledger.currentEon().sub(1);\n        challenge.deliveredTxNonce = sellBuyBalanceNonce[3];\n        challenge.challengeType = BimodalLib.ChallengeType.SWAP_ENACTMENT;\n        challenge.block = block.number;\n        challenge.trailIdentifier = recipientTrail;\n        challenge.deltaHighestSpendings = sellBuyBalanceNonce[0];\n        challenge.deltaHighestGains = sellBuyBalanceNonce[1];\n\n        (uint256 deposits, uint256 withdrawals) = ledger\n            .getCurrentEonDepositsWithdrawals(tokens[0], msg.sender);\n\n        challenge.initialStateBalance = sellBuyBalanceNonce[2] // allotment from eon e - 1\n            .add(updatedSpentGainedPassive[2]) // gained\n            .add(updatedSpentGainedPassive[3]) // passively delivered\n            .add(deposits)\n            .sub(updatedSpentGainedPassive[1]) // spent\n            .sub(withdrawals);\n        challenge.finalStateBalance = updatedSpentGainedPassive[0];\n\n        require(\n            challenge.finalStateBalance \u003e= challenge.initialStateBalance,\n            \"d\"\n        );\n\n        markChallengeLive(ledger, conduit, msg.sender, msg.sender);\n    }\n\n    function challengeSwapEnactmentWithProofOfActiveStateUpdateAgreement(\n        BimodalLib.Ledger storage ledger,\n        ERC20[2] tokens,\n        uint64[3] senderTransferRecipientTrails, // senderTransferRecipientTrails\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        bytes32[] txChain,\n        uint256[] values,\n        uint256[2][3] lrDeltasPassiveMark,\n        uint256[4] sellBuyBalanceNonce,\n        bytes32[3] txSetRootChecksumDummy\n    ) public /* payable */\n    /* onlyWithFairReimbursement() */\n    {\n        // Require swap to exist in transition\n        txSetRootChecksumDummy[2] = MerkleVerifier.swapOrderChecksum(\n            tokens,\n            senderTransferRecipientTrails[2],\n            sellBuyBalanceNonce[0], // sell\n            sellBuyBalanceNonce[1], // buy\n            sellBuyBalanceNonce[2], // balance\n            sellBuyBalanceNonce[3]\n        ); // nonce\n\n        require(\n            MerkleVerifier.verifyProofOfMembership(\n                senderTransferRecipientTrails[1],\n                txChain,\n                txSetRootChecksumDummy[2], // swapOrderChecksum\n                txSetRootChecksumDummy[0]\n            ), // txSetRoot\n            \"e\"\n        );\n\n        uint256 previousEon = ledger.currentEon().sub(1);\n\n        // Require committed transition to include swap\n        txSetRootChecksumDummy[2] = MerkleVerifier.activeStateUpdateChecksum(\n            tokens[0],\n            msg.sender,\n            senderTransferRecipientTrails[0],\n            previousEon,\n            txSetRootChecksumDummy[0],\n            lrDeltasPassiveMark[1]\n        ); // deltas\n\n        uint256 updatedBalance = lrDeltasPassiveMark[0][1].sub(\n            lrDeltasPassiveMark[0][0]\n        );\n        // The state must have been ratified in the commitment\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                tokens[0],\n                msg.sender,\n                [txSetRootChecksumDummy[2], txSetRootChecksumDummy[1]], // [activeStateChecksum, passiveChecksum]\n                senderTransferRecipientTrails[0],\n                [\n                    previousEon.add(1), // eonNumber\n                    lrDeltasPassiveMark[2][0], // passiveAmount\n                    lrDeltasPassiveMark[2][1] // passiveMark\n                ],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrDeltasPassiveMark[0]\n            )\n        ); // LR\n\n        initSwapEnactmentChallenge(\n            ledger,\n            tokens,\n            [\n                updatedBalance, // updated\n                lrDeltasPassiveMark[1][0], // spent\n                lrDeltasPassiveMark[1][1], // gained\n                lrDeltasPassiveMark[2][0]\n            ], // passiveAmount\n            sellBuyBalanceNonce,\n            senderTransferRecipientTrails[2]\n        );\n    }\n\n    /**\n     * This method just calculates the total expected balance.\n     */\n    function calculateSwapConsistencyBalance(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        uint256[2] deltas,\n        uint256 passiveAmount,\n        uint256 balance\n    ) private view returns (uint256) {\n        (uint256 deposits, uint256 withdrawals) = ledger\n            .getCurrentEonDepositsWithdrawals(token, msg.sender);\n\n        return\n            balance\n                .add(deltas[1]) // gained\n                .add(passiveAmount) // passively delivered\n                .add(deposits)\n                .sub(withdrawals)\n                .sub(deltas[0]); // spent\n    }\n\n    /**\n     * This method calculates the balance expected to be credited in return for that\n     * debited in another token according to the swapping price and is adjusted to\n     * ignore numerical errors up to 2 decimal places.\n     */\n    function verifySwapConsistency(\n        BimodalLib.Ledger storage ledger,\n        ERC20[2] tokens,\n        BimodalLib.Challenge challenge,\n        uint256[2] LR, // solhint-disable func-param-name-mixedcase\n        uint256[2] deltas,\n        uint256 passiveAmount,\n        uint256 balance\n    ) private view returns (bool) {\n        balance = calculateSwapConsistencyBalance(\n            ledger,\n            tokens[1],\n            deltas,\n            passiveAmount,\n            balance\n        );\n\n        require(LR[1].sub(LR[0]) \u003e= balance);\n\n        uint256 taken = challenge\n            .deltaHighestSpendings // sell amount\n            .sub(\n            challenge.finalStateBalance.sub(challenge.initialStateBalance)\n        ); // refund\n        uint256 given = LR[1]\n            .sub(LR[0]) // recipient allotment\n            .sub(balance); // authorized allotment\n\n        return\n            taken.mul(challenge.deltaHighestGains).div(100) \u003e=\n            challenge.deltaHighestSpendings.mul(given).div(100);\n    }\n\n    function answerSwapChallengeWithProofOfExclusiveBalanceAllotment(\n        BimodalLib.Ledger storage ledger,\n        ERC20[2] tokens,\n        address issuer,\n        uint64 transferMembershipTrail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        bytes32[] txChain,\n        uint256[] values,\n        uint256[2][3] lrDeltasPassiveMark,\n        uint256 balance,\n        bytes32[3] txSetRootChecksumDummy\n    ) public {\n        ERC20 conduit = ERC20(\n            address(keccak256(abi.encodePacked(tokens[0], tokens[1])))\n        );\n        BimodalLib.Challenge storage challenge = ledger\n            .challengeBook[conduit][issuer][issuer];\n        require(\n            challenge.challengeType == BimodalLib.ChallengeType.SWAP_ENACTMENT\n        );\n\n        // Assert that the challenged swap belongs to the transition\n        txSetRootChecksumDummy[2] = MerkleVerifier.swapOrderChecksum(\n            tokens,\n            challenge.trailIdentifier, // recipient trail\n            challenge.deltaHighestSpendings, // sell amount\n            challenge.deltaHighestGains, // buy amount\n            balance, // starting balance\n            challenge.deliveredTxNonce\n        );\n\n        require(\n            MerkleVerifier.verifyProofOfMembership(\n                transferMembershipTrail,\n                txChain,\n                txSetRootChecksumDummy[2], // order checksum\n                txSetRootChecksumDummy[0]\n            ),\n            \"M\"\n        ); // txSetRoot\n\n        // Require committed transition to include swap\n        txSetRootChecksumDummy[2] = MerkleVerifier.activeStateUpdateChecksum(\n            tokens[1],\n            issuer,\n            challenge.trailIdentifier,\n            challenge.initialStateEon,\n            txSetRootChecksumDummy[0], // txSetRoot\n            lrDeltasPassiveMark[1]\n        ); // deltas\n\n        if (balance != 2**256 - 1) {\n            require(\n                verifySwapConsistency(\n                    ledger,\n                    tokens,\n                    challenge,\n                    lrDeltasPassiveMark[0],\n                    lrDeltasPassiveMark[1],\n                    lrDeltasPassiveMark[2][0],\n                    balance\n                ),\n                \"v\"\n            );\n        }\n\n        // Assert that this transition was used to update the recipient\u0027s stake\n        require(\n            verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                tokens[1],\n                issuer,\n                [txSetRootChecksumDummy[2], txSetRootChecksumDummy[1]], // activeStateChecksum, passiveChecksum\n                challenge.trailIdentifier,\n                [\n                    challenge.initialStateEon.add(1),\n                    lrDeltasPassiveMark[2][0],\n                    lrDeltasPassiveMark[2][1]\n                ],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrDeltasPassiveMark[0]\n            ), // LR\n            \"s\"\n        );\n\n        markChallengeAnswered(ledger, challenge);\n    }\n\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    // ====================================  WITHDRAWAL Challenge\n    // ========================================================================\n    // ========================================================================\n    // ========================================================================\n    function slashWithdrawalWithProofOfMinimumAvailableBalance(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address withdrawer,\n        uint256[2] markerEonAvailable,\n        bytes32[2] rs,\n        uint8 v\n    ) public returns (uint256[2] amounts) {\n        uint256 latestEon = ledger.currentEon();\n        require(latestEon \u003c markerEonAvailable[0].add(3), \"m\");\n\n        bytes32 checksum = keccak256(\n            abi.encodePacked(\n                keccak256(abi.encodePacked(address(this))),\n                keccak256(abi.encodePacked(token)),\n                keccak256(abi.encodePacked(withdrawer)),\n                markerEonAvailable[0],\n                markerEonAvailable[1]\n            )\n        );\n\n        require(\n            withdrawer ==\n                BimodalLib.signedMessageECRECOVER(checksum, rs[0], rs[1], v)\n        );\n\n        BimodalLib.Wallet storage entry = ledger.walletBook[token][withdrawer];\n        BimodalLib.Withdrawal[] storage withdrawals = entry.withdrawals;\n\n        for (uint32 i = 1; i \u003c= withdrawals.length; i++) {\n            BimodalLib.Withdrawal storage withdrawal = withdrawals[withdrawals\n                .length\n                .sub(i)];\n\n            if (withdrawal.eon.add(1) \u003c latestEon) {\n                break;\n            } else if (withdrawal.eon == latestEon.sub(1)) {\n                amounts[0] = amounts[0].add(withdrawal.amount);\n            } else if (withdrawal.eon == latestEon) {\n                amounts[1] = amounts[1].add(withdrawal.amount);\n            }\n        }\n\n        require(amounts[0].add(amounts[1]) \u003e markerEonAvailable[1]);\n\n        withdrawals.length = withdrawals.length.sub(i.sub(1)); // i \u003e= 1\n\n        if (amounts[1] \u003e 0) {\n            ledger.deductFromRunningPendingWithdrawals(\n                token,\n                latestEon,\n                latestEon,\n                amounts[1]\n            );\n            ledger.appendOperationToEonAccumulator(\n                latestEon,\n                token,\n                withdrawer,\n                BimodalLib.Operation.CANCELLATION,\n                amounts[1]\n            );\n        }\n\n        if (amounts[0] \u003e 0) {\n            ledger.deductFromRunningPendingWithdrawals(\n                token,\n                latestEon.sub(1),\n                latestEon,\n                amounts[0]\n            );\n            ledger.appendOperationToEonAccumulator(\n                latestEon.sub(1),\n                token,\n                withdrawer,\n                BimodalLib.Operation.CANCELLATION,\n                amounts[0]\n            );\n        }\n    }\n}\n"},"ChallengeProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./BimodalProxy.sol\";\nimport \"./ERC20.sol\";\nimport \"./BimodalLib.sol\";\nimport \"./MerkleVerifier.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\ncontract ChallengeProxy is BimodalProxy {\n  using SafeMathLib256 for uint256;\n  \n  modifier onlyWithFairReimbursement() {\n    uint256 gas = gasleft();\n    _;\n    gas = gas.sub(gasleft());\n    require(\n      msg.value \u003e= gas.mul(ledger.MIN_CHALLENGE_GAS_COST) \u0026\u0026\n      msg.value \u003e= gas.mul(tx.gasprice),\n      \u0027r\u0027);\n    ledger.operator.transfer(msg.value);\n  }\n\n  modifier onlyWithSkewedReimbursement(uint256 extra) {\n    uint256 gas = gasleft();\n    _;\n    gas = gas.sub(gasleft());\n    require(\n      msg.value \u003e= gas.add(extra).mul(ledger.MIN_CHALLENGE_GAS_COST) \u0026\u0026\n      msg.value \u003e= gas.add(extra).mul(tx.gasprice),\n      \u0027r\u0027);\n    ledger.operator.transfer(msg.value);\n  }\n\n  // =========================================================================\n  function verifyProofOfExclusiveAccountBalanceAllotment(\n    ERC20 token,\n    address holder,\n    bytes32[2] activeStateChecksum_passiveTransfersRoot, // solhint-disable func-param-name-mixedcase\n    uint64 trail,\n    uint256[3] eonPassiveMark,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] values,\n    uint256[2] LR // solhint-disable-line func-param-name-mixedcase\n  )\n    public\n    view\n    returns (bool)\n  {\n    return ChallengeLib.verifyProofOfExclusiveAccountBalanceAllotment(\n      ledger,\n      token,\n      holder,\n      activeStateChecksum_passiveTransfersRoot,\n      trail,\n      eonPassiveMark,\n      allotmentChain,\n      membershipChain,\n      values,\n      LR\n    );\n  }\n\n  function verifyProofOfActiveStateUpdateAgreement(\n    ERC20 token,\n    address holder,\n    uint64 trail,\n    uint256 eon,\n    bytes32 txSetRoot,\n    uint256[2] deltas,\n    address attester, bytes32 r, bytes32 s, uint8 v\n  )\n    public\n    view\n    returns (bytes32 checksum)\n  {\n    return ChallengeLib.verifyProofOfActiveStateUpdateAgreement(\n      token,\n      holder,\n      trail,\n      eon,\n      txSetRoot,\n      deltas,\n      attester,\n      r,\n      s,\n      v\n    );\n  }\n\n  function verifyWithdrawalAuthorization(\n    ERC20 token,\n    address holder,\n    uint256 expiry,\n    uint256 amount,\n    address attester,\n    bytes32 r, bytes32 s, uint8 v\n  )\n    public\n    view\n    returns (bool)\n  {\n    return ChallengeLib.verifyWithdrawalAuthorization(\n      token,\n      holder,\n      expiry,\n      amount,\n      attester,\n      r,\n      s,\n      v\n    );\n  }\n\n  function verifyProofOfExclusiveBalanceAllotment(\n    uint64 allotmentTrail,\n    uint64 membershipTrail,\n    bytes32 node,\n    bytes32 root,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] value,\n    uint256[2] LR // solhint-disable-line func-param-name-mixedcase\n  )\n    public\n    pure\n    returns (uint256)\n  {\n    return MerkleVerifier.verifyProofOfExclusiveBalanceAllotment(\n      allotmentTrail,\n      membershipTrail,\n      node,\n      root,\n      allotmentChain,\n      membershipChain,\n      value,\n      LR\n    );\n  }\n\n  function verifyProofOfMembership(\n    uint256 trail,\n    bytes32[] chain,\n    bytes32 node,\n    bytes32 merkleRoot\n  )\n    public\n    pure\n    returns (bool)\n  {\n    return MerkleVerifier.verifyProofOfMembership(\n      trail,\n      chain,\n      node,\n      merkleRoot\n    );\n  }\n\n  function verifyProofOfPassiveDelivery(\n    uint64 allotmentTrail,\n    bytes32 node,\n    bytes32 root,\n    bytes32[] chainValues,\n    uint256[2] LR // solhint-disable-line func-param-name-mixedcase\n  )\n    public\n    pure\n    returns (uint256)\n  {\n    return MerkleVerifier.verifyProofOfPassiveDelivery(\n      allotmentTrail,\n      node,\n      root,\n      chainValues,\n      LR\n    );\n  }\n\n  // =========================================================================\n  function challengeStateUpdateWithProofOfExclusiveBalanceAllotment(\n    ERC20 token,\n    bytes32[2] checksums,\n    uint64 trail,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] value,\n    uint256[2][3] lrDeltasPassiveMark,\n    bytes32[3] rsTxSetRoot,\n    uint8 v\n  )\n    public\n    payable\n    onlyWithFairReimbursement()\n  {\n    ChallengeLib.challengeStateUpdateWithProofOfExclusiveBalanceAllotment(\n      ledger,\n      token,\n      checksums,\n      trail,\n      allotmentChain,\n      membershipChain,\n      value,\n      lrDeltasPassiveMark,\n      rsTxSetRoot,\n      v\n    );\n  }\n  \n  function challengeStateUpdateWithProofOfActiveStateUpdateAgreement(\n    ERC20 token,\n    bytes32 txSetRoot,\n    uint64 trail,\n    uint256[2] deltas,\n    bytes32 r, bytes32 s, uint8 v\n  )\n    public\n    payable\n    onlyWithSkewedReimbursement(25) /* TODO calculate exact addition */\n  {\n    ChallengeLib.challengeStateUpdateWithProofOfActiveStateUpdateAgreement(\n      ledger,\n      token,\n      txSetRoot,\n      trail,\n      deltas,\n      r,\n      s,\n      v\n    );\n  }\n\n  function answerStateUpdateChallenge(\n    ERC20 token,\n    address issuer,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] values,\n    uint256[2][3] lrDeltasPassiveMark, // [ [L, R], Deltas ]\n    bytes32[6] rSrStxSetRootChecksum,\n    uint8[2] v\n  )\n    public\n  {\n    ChallengeLib.answerStateUpdateChallenge(\n      ledger,\n      token,\n      issuer,\n      allotmentChain,\n      membershipChain,\n      values,\n      lrDeltasPassiveMark,\n      rSrStxSetRootChecksum,\n      v\n    );\n  }\n\n  // =========================================================================\n  function challengeTransferDeliveryWithProofOfActiveStateUpdateAgreement(\n    ERC20 token,\n    address[2] SR, // solhint-disable-line func-param-name-mixedcase\n    uint256[2] nonceAmount,\n    uint64[3] trails,\n    bytes32[] chain,\n    uint256[2] deltas,\n    bytes32[3] rsTxSetRoot,\n    uint8 v\n  )\n    public\n    payable\n    onlyWithFairReimbursement()\n  {\n    ChallengeLib.challengeTransferDeliveryWithProofOfActiveStateUpdateAgreement(\n      ledger,\n      token,\n      SR,\n      nonceAmount,\n      trails,\n      chain,\n      deltas,\n      rsTxSetRoot,\n      v\n    );\n  }\n\n  function answerTransferDeliveryChallengeWithProofOfActiveStateUpdateAgreement(\n    ERC20 token,\n    address[2] SR, // solhint-disable-line func-param-name-mixedcase\n    uint64 transferMembershipTrail,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] values,\n    uint256[2][3] lrDeltasPassiveMark,\n    bytes32[2] txSetRootChecksum,\n    bytes32[] txChain\n  )\n    public\n  {\n    ChallengeLib.answerTransferDeliveryChallengeWithProofOfActiveStateUpdateAgreement(\n      ledger,\n      token,\n      SR,\n      transferMembershipTrail,\n      allotmentChain,\n      membershipChain,\n      values,\n      lrDeltasPassiveMark,\n      txSetRootChecksum,\n      txChain\n    );\n  }\n\n  // =========================================================================\n  function challengeTransferDeliveryWithProofOfPassiveStateUpdate(\n    ERC20 token,\n    address[2] SR, // solhint-disable-line func-param-name-mixedcase\n    bytes32[2] txSetRootChecksum,\n    uint64[3] senderTransferRecipientTrails,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] values,\n    uint256[2][4] lrDeltasPassiveMarkDummyAmount,\n    bytes32[] transferMembershipChain\n  )\n    public\n    payable\n    onlyWithFairReimbursement()\n  {\n    ChallengeLib.challengeTransferDeliveryWithProofOfPassiveStateUpdate(\n      ledger,\n      token,\n      SR,\n      txSetRootChecksum,\n      senderTransferRecipientTrails,\n      allotmentChain,\n      membershipChain,\n      values,\n      lrDeltasPassiveMarkDummyAmount,\n      transferMembershipChain\n    );\n  }\n\n  function answerTransferDeliveryChallengeWithProofOfPassiveStateUpdate(\n    ERC20 token,\n    address[2] SR, // solhint-disable-line func-param-name-mixedcase\n    uint64 transferMembershipTrail,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] values,\n    uint256[2][3] lrPassiveMarkPositionNonce,\n    bytes32[2] checksums,\n    bytes32[] txChainValues\n  )\n    public\n  {\n    ChallengeLib.answerTransferDeliveryChallengeWithProofOfPassiveStateUpdate(\n      ledger,\n      token,\n      SR,\n      transferMembershipTrail,\n      allotmentChain,\n      membershipChain,\n      values,\n      lrPassiveMarkPositionNonce,\n      checksums,\n      txChainValues\n    );\n  }\n\n  // =========================================================================\n  function challengeSwapEnactmentWithProofOfActiveStateUpdateAgreement(\n    ERC20[2] tokens,\n    uint64[3] senderTransferRecipientTrails,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    bytes32[] txChain,\n    uint256[] values,\n    uint256[2][3] lrDeltasPassiveMark,\n    uint256[4] sellBuyBalanceNonce,\n    bytes32[3] txSetRootChecksumDummy\n  )\n    public\n    payable\n    onlyWithFairReimbursement()\n  {\n    ChallengeLib.challengeSwapEnactmentWithProofOfActiveStateUpdateAgreement(\n      ledger,\n      tokens,\n      senderTransferRecipientTrails,\n      allotmentChain,\n      membershipChain,\n      txChain,\n      values,\n      lrDeltasPassiveMark,\n      sellBuyBalanceNonce,\n      txSetRootChecksumDummy\n    );\n  }\n\n  function answerSwapChallengeWithProofOfExclusiveBalanceAllotment(\n    ERC20[2] tokens,\n    address issuer,\n    uint64 transferMembershipTrail,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    bytes32[] txChain,\n    uint256[] values,\n    uint256[2][3] lrDeltasPassiveMark,\n    uint256 balance,\n    bytes32[3] txSetRootChecksumDummy\n  )\n    public\n  {\n    ChallengeLib.answerSwapChallengeWithProofOfExclusiveBalanceAllotment(\n      ledger,\n      tokens,\n      issuer,\n      transferMembershipTrail,\n      allotmentChain,\n      membershipChain,\n      txChain,\n      values,\n      lrDeltasPassiveMark,\n      balance,\n      txSetRootChecksumDummy\n    );\n  }\n\n  // =========================================================================\n  function slashWithdrawalWithProofOfMinimumAvailableBalance(\n    ERC20 token,\n    address withdrawer,\n    uint256[2] markerEonAvailable,\n    bytes32[2] rs,\n    uint8 v\n  )\n    public\n    returns (uint256[2])\n  {\n    return ChallengeLib.slashWithdrawalWithProofOfMinimumAvailableBalance(\n      ledger,\n      token,\n      withdrawer,\n      markerEonAvailable,\n      rs,\n      v\n    );\n  }\n}\n"},"DepositLib.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./BimodalLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/**\n * This library defines the secure deposit method. The relevant data is recorded\n * on the parent chain to ascertain that a registered wallet would always be able\n * to ensure its commit chain state update consistency with the parent chain.\n */\nlibrary DepositLib {\n  using SafeMathLib256 for uint256;\n  using BimodalLib for BimodalLib.Ledger;\n  // EVENTS\n  event Deposit(address indexed token, address indexed recipient, uint256 amount);\n\n  function deposit(\n    BimodalLib.Ledger storage ledger,\n    ERC20 token,\n    address beneficiary,\n    uint256 amount\n  )\n    public\n    /* payable */\n    /* onlyWhenContractUnpunished() */\n  {\n    uint256 eon = ledger.currentEon();\n\n    uint256 value = msg.value;\n    if (token != address(this)) {\n      require(ledger.tokenToTrail[token] != 0,\n        \u0027t\u0027);\n      require(msg.value == 0,\n        \u0027m\u0027);\n      require(token.transferFrom(beneficiary, this, amount),\n        \u0027f\u0027);\n      value = amount;\n    }\n\n    BimodalLib.Wallet storage entry = ledger.walletBook[token][beneficiary];\n    BimodalLib.AmountAggregate storage depositAggregate = entry.depositsKept[eon.mod(ledger.DEPOSITS_KEPT)];\n    BimodalLib.addToAggregate(depositAggregate, eon, value);\n\n    BimodalLib.AmountAggregate storage eonDeposits = ledger.deposits[token][eon.mod(ledger.EONS_KEPT)];\n    BimodalLib.addToAggregate(eonDeposits, eon, value);\n\n    ledger.appendOperationToEonAccumulator(eon, token, beneficiary, BimodalLib.Operation.DEPOSIT, value);\n\n    emit Deposit(token, beneficiary, value);\n  }\n}\n"},"DepositProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./BimodalLib.sol\";\nimport \"./BimodalProxy.sol\";\nimport \"./DepositLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\ncontract DepositProxy is BimodalProxy {\n  using SafeMathLib256 for uint256;\n\n  function()\n    public\n    payable\n  {}\n\n  function deposit(\n    ERC20 token,\n    address beneficiary,\n    uint256 amount\n  )\n    public\n    payable\n    onlyWhenContractUnpunished()\n  {\n    DepositLib.deposit(\n      ledger,\n      token,\n      beneficiary,\n      amount);\n  }\n}\n"},"ERC20.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  \n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"},"ERC20TokenImplementation.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/* solhint-disable max-line-length */\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n * Source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/1200969eb6e0a066b1e52fb2e76a786a486706ff/contracts/token/ERC20/BasicToken.sol\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMathLib256 for uint256;\n\n  mapping(address =\u003e uint256) internal balances;\n\n  uint256 internal totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_value \u003c= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/1200969eb6e0a066b1e52fb2e76a786a486706ff/contracts/token/ERC20/StandardToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n  using SafeMathLib256 for uint256;\n\n  mapping (address =\u003e mapping (address =\u003e uint256)) internal allowed;\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_value \u003c= balances[_from]);\n    require(_value \u003c= allowed[_from][msg.sender]);\n    require(_to != address(0));\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n  )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue \u003e= oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n}\n\n/**\n * @title DetailedERC20 token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n * Source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/1200969eb6e0a066b1e52fb2e76a786a486706ff/contracts/token/ERC20/DetailedERC20.sol\n */\ncontract DetailedERC20 is ERC20 {\n  using SafeMathLib256 for uint256;\n\n  string public name;\n  string public symbol;\n  uint8 public decimals;\n\n  constructor(string _name, string _symbol, uint8 _decimals) public {\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n  }\n}\n\ninterface ApprovalSpender {\n  function receiveApproval(address from, uint256 value, address token, bytes data) external;\n}\n\n/**\n * @title Liquidity.Network Fungible Token Contract\n * Built on OpenZeppelin-Solidity Contracts https://github.com/OpenZeppelin/openzeppelin-solidity/tree/1200969eb6e0a066b1e52fb2e76a786a486706ff\n */\ncontract ERC20TokenImplementation is StandardToken, DetailedERC20 {\n  using SafeMathLib256 for uint256;\n  \n  constructor()\n    public\n    DetailedERC20(\"Liquidity.Network Token\", \"LQD\", 18)\n  {\n    totalSupply_ = 100000000 * (10 ** uint256(decimals));\n    balances[msg.sender] = totalSupply_;\n    emit Transfer(0x0, msg.sender, totalSupply_);\n  }\n\n  function approveAndCall(ApprovalSpender recipientContract, uint256 value, bytes data) public returns (bool) {\n    if (approve(recipientContract, value)) {\n      recipientContract.receiveApproval(msg.sender, value, address(this), data);\n      return true;\n    }\n  }\n}\n"},"MerkleVerifier.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./SafeMathLib32.sol\";\nimport \"./SafeMathLib64.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/*\nThis library defines a collection of different checksumming procedures for\nmembership, exclusive allotment and data.\n*/\nlibrary MerkleVerifier {\n    using SafeMathLib32 for uint32;\n    using SafeMathLib64 for uint64;\n    using SafeMathLib256 for uint256;\n\n    /**\n     * Calculate a vanilla merkle root from a chain of hashes with a fixed height\n     * starting from the leaf node.\n     */\n    function calculateMerkleRoot(\n        uint256 trail,\n        bytes32[] chain,\n        bytes32 node\n    ) public pure returns (bytes32) {\n        for (uint32 i = 0; i \u003c chain.length; i++) {\n            bool linkLeft = false;\n            if (trail \u003e 0) {\n                linkLeft = trail.mod(2) == 1;\n                trail = trail.div(2);\n            }\n            node = keccak256(\n                abi.encodePacked(\n                    i,\n                    linkLeft ? chain[i] : node,\n                    linkLeft ? node : chain[i]\n                )\n            );\n        }\n        return node;\n    }\n\n    function verifyProofOfMembership(\n        uint256 trail,\n        bytes32[] chain,\n        bytes32 node,\n        bytes32 merkleRoot\n    ) public pure returns (bool) {\n        return calculateMerkleRoot(trail, chain, node) == merkleRoot;\n    }\n\n    /**\n     * Calculate an annotated merkle tree root from a chain of hashes and sibling\n     * values with a fixed height starting from the leaf node.\n     * @return the allotment of the root node.\n     */\n    function verifyProofOfExclusiveBalanceAllotment(\n        uint64 allotmentTrail,\n        uint64 membershipTrail,\n        bytes32 node,\n        bytes32 root,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] value,\n        uint256[2] LR // solhint-disable-line func-param-name-mixedcase\n    ) public pure returns (uint256) {\n        require(value.length == allotmentChain.length, \"p\");\n\n        require(LR[1] \u003e= LR[0], \"s\");\n        for (uint32 i = 0; i \u003c value.length; i++) {\n            bool linkLeft = false; // is the current chain link on the left of this node\n            if (allotmentTrail \u003e 0) {\n                linkLeft = allotmentTrail.mod(2) == 1;\n                allotmentTrail = allotmentTrail.div(2);\n            }\n\n            node = keccak256(\n                abi.encodePacked(\n                    i,\n                    linkLeft ? value[i] : LR[0], // leftmost value\n                    keccak256(\n                        abi.encodePacked(\n                            linkLeft ? allotmentChain[i] : node, // left node\n                            linkLeft ? LR[0] : LR[1], // middle value\n                            linkLeft ? node : allotmentChain[i] // right node\n                        )\n                    ),\n                    linkLeft ? LR[1] : value[i] // rightmost value\n                )\n            );\n\n            require(linkLeft ? value[i] \u003c= LR[0] : LR[1] \u003c= value[i], \"x\");\n\n            LR[0] = linkLeft ? value[i] : LR[0];\n            LR[1] = linkLeft ? LR[1] : value[i];\n\n            require(LR[1] \u003e= LR[0], \"t\");\n        }\n        require(LR[0] == 0, \"l\");\n\n        node = keccak256(abi.encodePacked(LR[0], node, LR[1]));\n\n        require(\n            verifyProofOfMembership(\n                membershipTrail,\n                membershipChain,\n                node,\n                root\n            ),\n            \"m\"\n        );\n\n        return LR[1];\n    }\n\n    /**\n     * Calculate an annotated merkle tree root from a combined array containing\n     * the chain of hashes and sibling values with a fixed height starting from the\n     * leaf node.\n     */\n    function verifyProofOfPassiveDelivery(\n        uint64 allotmentTrail,\n        bytes32 node,\n        bytes32 root,\n        bytes32[] chainValues,\n        uint256[2] LR\n    ) public pure returns (uint256) {\n        require(chainValues.length.mod(2) == 0, \"p\");\n\n        require(LR[1] \u003e= LR[0], \"s\");\n        uint32 v = uint32(chainValues.length.div(2));\n        for (uint32 i = 0; i \u003c v; i++) {\n            bool linkLeft = false; // is the current chain link on the left of this node\n            if (allotmentTrail \u003e 0) {\n                linkLeft = allotmentTrail.mod(2) == 1;\n                allotmentTrail = allotmentTrail.div(2);\n            }\n\n            node = keccak256(\n                abi.encodePacked(\n                    i,\n                    linkLeft ? uint256(chainValues[i.add(v)]) : LR[0], // leftmost value\n                    keccak256(\n                        abi.encodePacked(\n                            linkLeft ? chainValues[i] : node, // left node\n                            linkLeft ? LR[0] : LR[1], // middle value\n                            linkLeft ? node : chainValues[i] // right node\n                        )\n                    ),\n                    linkLeft ? LR[1] : uint256(chainValues[i.add(v)]) // rightmost value\n                )\n            );\n\n            require(\n                linkLeft\n                    ? uint256(chainValues[i.add(v)]) \u003c= LR[0]\n                    : LR[1] \u003c= uint256(chainValues[i.add(v)]),\n                \"x\"\n            );\n\n            LR[0] = linkLeft ? uint256(chainValues[i.add(v)]) : LR[0];\n            LR[1] = linkLeft ? LR[1] : uint256(chainValues[i.add(v)]);\n\n            require(LR[1] \u003e= LR[0], \"t\");\n        }\n        require(LR[0] == 0, \"l\");\n\n        require(node == root, \"n\");\n\n        return LR[1];\n    }\n\n    function transferChecksum(\n        address counterparty,\n        uint256 amount,\n        uint64 recipientTrail,\n        uint256 nonce\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    keccak256(abi.encodePacked(counterparty)),\n                    amount,\n                    recipientTrail,\n                    nonce\n                )\n            );\n    }\n\n    function swapOrderChecksum(\n        ERC20[2] tokens,\n        uint64 recipientTrail,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        uint256 startBalance,\n        uint256 nonce\n    ) public pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    keccak256(abi.encodePacked(tokens[0])),\n                    keccak256(abi.encodePacked(tokens[1])),\n                    recipientTrail,\n                    sellAmount,\n                    buyAmount,\n                    startBalance,\n                    nonce\n                )\n            );\n    }\n\n    function activeStateUpdateChecksum(\n        ERC20 token,\n        address holder,\n        uint64 trail,\n        uint256 eon,\n        bytes32 txSetRoot,\n        uint256[2] deltas\n    ) public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    keccak256(abi.encodePacked(address(this))),\n                    keccak256(abi.encodePacked(token)),\n                    keccak256(abi.encodePacked(holder)),\n                    trail,\n                    eon,\n                    txSetRoot,\n                    deltas[0],\n                    deltas[1]\n                )\n            );\n    }\n}\n"},"MerkleVerifierProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./MerkleVerifier.sol\";\n\ncontract MerkleVerifierProxy {\n  function calculateMerkleRoot(\n    uint256 trail,\n    bytes32[] chain,\n    bytes32 node\n  )\n    public\n    pure\n    returns (bytes32)\n  {\n    return MerkleVerifier.calculateMerkleRoot(trail, chain, node);\n  }\n\n  function verifyProofOfExclusiveBalanceAllotment(\n    uint64 allotmentTrail,\n    uint64 membershipTrail,\n    bytes32 node,\n    bytes32 root,\n    bytes32[] allotmentChain,\n    bytes32[] membershipChain,\n    uint256[] value,\n    uint256[2] LR // solhint-disable-line func-param-name-mixedcase\n  )\n    public\n    pure\n    returns (uint256)\n  {\n    return MerkleVerifier.verifyProofOfExclusiveBalanceAllotment(\n      allotmentTrail,\n      membershipTrail,\n      node,\n      root,\n      allotmentChain,\n      membershipChain,\n      value,\n      LR\n    );\n  }\n\n  function verifyProofOfPassiveDelivery(\n    uint64 allotmentTrail,\n    bytes32 node,\n    bytes32 root,\n    bytes32[] chainValues,\n    uint256[2] LR // solhint-disable-line func-param-name-mixedcase\n  )\n    public\n    pure\n    returns (uint256)\n  {\n    MerkleVerifier.verifyProofOfPassiveDelivery(\n      allotmentTrail,\n      node,\n      root,\n      chainValues,\n      LR\n    );\n  }\n\n  function transferChecksum(\n    address counterparty,\n    uint256 amount,\n    uint64 recipientTrail,\n    uint256 nonce\n  )\n    public\n    pure\n    returns (bytes32)\n  {\n    return MerkleVerifier.transferChecksum(\n      counterparty,\n      amount,\n      recipientTrail,\n      nonce\n    );\n  }\n\n  function swapOrderChecksum(\n    ERC20[2] tokens,\n    uint64 recipientTrail,\n    uint256 sellAmount,\n    uint256 buyAmount,\n    uint256 startBalance,\n    uint256 nonce\n  )\n    public\n    pure\n    returns (bytes32)\n  {\n    return MerkleVerifier.swapOrderChecksum(\n      tokens,\n      recipientTrail,\n      sellAmount,\n      buyAmount,\n      startBalance,\n      nonce\n    );\n  }\n\n  function activeStateUpdateChecksum(\n    ERC20 token,\n    address holder,\n    uint64 trail,\n    uint256 eon,\n    bytes32 txSetRoot,\n    uint256[2] deltas\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return MerkleVerifier.activeStateUpdateChecksum(\n      token,\n      holder,\n      trail,\n      eon,\n      txSetRoot,\n      deltas\n    );\n  }\n}\n"},"Migrations.sol":{"content":"pragma solidity ^0.4.24;\n\ncontract Migrations {\n  address public owner;\n  uint256 public lastCompletedMigration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor()\n    public\n  {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint256 completed)\n    public\n    restricted\n  {\n    lastCompletedMigration = completed;\n  }\n\n  function upgrade(address newAddress)\n    public\n    restricted\n  {\n    Migrations upgraded = Migrations(newAddress);\n    upgraded.setCompleted(lastCompletedMigration);\n  }\n}\n"},"NOCUSTCommitChain.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./BimodalProxy.sol\";\nimport \"./DepositProxy.sol\";\nimport \"./WithdrawalProxy.sol\";\nimport \"./ChallengeProxy.sol\";\nimport \"./RecoveryProxy.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/**\n * This is the main Parent-chain Verifier contract. It inherits all of the proxy\n * contracts and provides a single address to interact with all the moderated\n * balance pools. Proxies define the exposed methods, events and enforce the\n * modifiers of library methods.\n */\ncontract NOCUSTCommitChain is\n    BimodalProxy,\n    DepositProxy,\n    WithdrawalProxy,\n    ChallengeProxy,\n    RecoveryProxy\n{\n    using SafeMathLib256 for uint256;\n\n    /**\n     * This is the main constructor.\n     * @param blocksPerEon - The number of blocks per eon.\n     * @param operator - The IMMUTABLE address of the operator.\n     */\n    constructor(uint256 blocksPerEon, address operator)\n        public\n        BimodalProxy(blocksPerEon, operator)\n    {\n        // Support ETH by default\n        ledger.trailToToken.push(address(this));\n        ledger.tokenToTrail[address(this)] = 0;\n    }\n\n    /**\n     * This allows the operator to register the existence of another ERC20 token\n     * @param token - ERC20 token address\n     */\n    function registerERC20(ERC20 token) public onlyOperator() {\n        require(ledger.tokenToTrail[token] == 0);\n        ledger.tokenToTrail[token] = uint64(ledger.trailToToken.length);\n        ledger.trailToToken.push(token);\n    }\n\n    /**\n     * This method allows the operator to submit one checkpoint per eon that\n     * synchronizes the commit-chain ledger with the parent chain.\n     * @param accumulator - The accumulator of the previous eon under which this checkpoint is calculated.\n     * @param merkleRoot - The checkpoint merkle root.\n     */\n    function submitCheckpoint(bytes32 accumulator, bytes32 merkleRoot)\n        public\n        onlyOperator()\n        onlyWhenContractUnpunished()\n    {\n        uint256 eon = ledger.currentEon();\n        require(\n            ledger.parentChainAccumulator[eon.sub(1).mod(ledger.EONS_KEPT)] ==\n                accumulator,\n            \"b\"\n        );\n        require(ledger.getLiveChallenges(eon.sub(1)) == 0, \"c\");\n        require(eon \u003e ledger.lastSubmissionEon, \"d\");\n\n        ledger.lastSubmissionEon = eon;\n\n        BimodalLib.Checkpoint storage checkpoint = ledger.getOrCreateCheckpoint(\n            eon,\n            eon\n        );\n        checkpoint.merkleRoot = merkleRoot;\n\n        emit CheckpointSubmission(eon, merkleRoot);\n    }\n}\n"},"RecoveryLib.sol":{"content":"/* solhint-disable func-order */\n\npragma solidity ^0.4.24;\n\nimport \"./ERC20.sol\";\nimport \"./BimodalLib.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/**\n * This library contains the implementation for the secure commit-chain recovery\n * procedure that can be used when the operator of the commit chain is halted by\n * the main verifier contract. The methods in this library are only relevant for\n * recovering the last confirmed balances of the accounts in the commit chain.\n */\nlibrary RecoveryLib {\n    using SafeMathLib256 for uint256;\n    using BimodalLib for BimodalLib.Ledger;\n\n    function reclaimUncommittedDeposits(\n        BimodalLib.Ledger storage ledger,\n        BimodalLib.Wallet storage wallet\n    ) private returns (uint256 amount) {\n        for (uint8 i = 0; i \u003c ledger.DEPOSITS_KEPT; i++) {\n            BimodalLib.AmountAggregate storage depositAggregate = wallet\n                .depositsKept[i];\n            // depositAggregate.eon \u003c ledger.lastSubmissionEon.sub(1)\n            if (depositAggregate.eon.add(1) \u003c ledger.lastSubmissionEon) {\n                continue;\n            }\n            amount = amount.add(depositAggregate.amount);\n            BimodalLib.clearAggregate(depositAggregate);\n        }\n    }\n\n    function reclaimFinalizedWithdrawal(\n        BimodalLib.Ledger storage ledger,\n        BimodalLib.Wallet storage wallet\n    ) private returns (uint256 amount) {\n        BimodalLib.Withdrawal[] storage withdrawals = wallet.withdrawals;\n        for (uint32 i = 0; i \u003c withdrawals.length; i++) {\n            BimodalLib.Withdrawal storage withdrawal = withdrawals[i];\n\n            if (withdrawal.eon.add(2) \u003e ledger.lastSubmissionEon) {\n                break;\n            }\n\n            amount = amount.add(withdrawal.amount);\n            delete withdrawals[i];\n        }\n    }\n\n    /*\n     * This method can be called without an accompanying proof of exclusive allotment\n     * to claim only the funds pending in the parent chain.\n     */\n    function recoverOnlyParentChainFunds(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address holder\n    )\n        public\n        returns (\n            /* onlyWhenContractPunished() */\n            uint256 reclaimed\n        )\n    {\n        BimodalLib.Wallet storage wallet = ledger.walletBook[token][holder];\n\n        reclaimed = reclaimUncommittedDeposits(ledger, wallet).add(\n            reclaimFinalizedWithdrawal(ledger, wallet)\n        );\n\n        if (ledger.lastSubmissionEon \u003e 0) {\n            BimodalLib.AmountAggregate storage eonWithdrawals = ledger\n                .confirmedWithdrawals[token][ledger\n                .lastSubmissionEon\n                .sub(1)\n                .mod(ledger.EONS_KEPT)];\n            BimodalLib.addToAggregate(\n                eonWithdrawals,\n                ledger.lastSubmissionEon.sub(1),\n                reclaimed\n            );\n        }\n\n        if (token != address(this)) {\n            require(ledger.tokenToTrail[token] != 0, \"t\");\n            require(token.transfer(holder, reclaimed), \"f\");\n        } else {\n            holder.transfer(reclaimed);\n        }\n    }\n\n    /**\n     * This method requires an accompanying proof of exclusive allotment to claim\n     *the funds pending in the parent chain along with those exclusively allotted\n     * in the commit chain.\n     */\n    function recoverAllFunds(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address holder,\n        bytes32[2] checksums,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2] LR, // solhint-disable func-param-name-mixedcase\n        uint256[3] dummyPassiveMark\n    )\n        public\n        returns (\n            /* onlyWhenContractPunished() */\n            uint256 recovered\n        )\n    {\n        BimodalLib.Wallet storage wallet = ledger.walletBook[token][holder];\n        require(!wallet.recovered, \"a\");\n        wallet.recovered = true;\n\n        recovered = LR[1].sub(LR[0]); // excluslive allotment\n        recovered = recovered.add(reclaimUncommittedDeposits(ledger, wallet)); // unallotted parent chain deposits\n        recovered = recovered.add(reclaimFinalizedWithdrawal(ledger, wallet)); // confirmed parent chain withdrawal\n\n        if (ledger.lastSubmissionEon \u003e 0) {\n            dummyPassiveMark[0] = ledger.lastSubmissionEon.sub(1); // confirmedEon\n        } else {\n            dummyPassiveMark[0] = 0;\n        }\n\n        require(\n            ChallengeLib.verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                holder,\n                checksums,\n                trail,\n                dummyPassiveMark, // [confirmedEon, passiveAmount, passiveMark]\n                allotmentChain,\n                membershipChain,\n                values,\n                LR\n            ),\n            \"p\"\n        );\n\n        BimodalLib.AmountAggregate storage eonWithdrawals = ledger\n            .confirmedWithdrawals[token][dummyPassiveMark[0].mod(\n            ledger.EONS_KEPT\n        )];\n        BimodalLib.addToAggregate(\n            eonWithdrawals,\n            dummyPassiveMark[0],\n            recovered\n        );\n\n        if (token != address(this)) {\n            require(ledger.tokenToTrail[token] != 0, \"t\");\n            require(token.transfer(holder, recovered), \"f\");\n        } else {\n            holder.transfer(recovered);\n        }\n    }\n}\n"},"RecoveryProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./BimodalProxy.sol\";\nimport \"./ERC20.sol\";\nimport \"./RecoveryLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\ncontract RecoveryProxy is BimodalProxy {\n    using SafeMathLib256 for uint256;\n\n    modifier onlyWhenContractPunished() {\n        require(\n            hasOutstandingChallenges() || hasMissedCheckpointSubmission(),\n            \"f\"\n        );\n        _;\n    }\n\n    // =========================================================================\n    function recoverOnlyParentChainFunds(ERC20 token, address holder)\n        public\n        onlyWhenContractPunished()\n        returns (uint256 reclaimed)\n    {\n        reclaimed = RecoveryLib.recoverOnlyParentChainFunds(\n            ledger,\n            token,\n            holder\n        );\n    }\n\n    function recoverAllFunds(\n        ERC20 token,\n        address holder,\n        bytes32[2] checksums,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2] LR, // solhint-disable-line func-param-name-mixedcase\n        uint256[3] dummyPassiveMark\n    ) public onlyWhenContractPunished() returns (uint256 recovered) {\n        recovered = RecoveryLib.recoverAllFunds(\n            ledger,\n            token,\n            holder,\n            checksums,\n            trail,\n            allotmentChain,\n            membershipChain,\n            values,\n            LR,\n            dummyPassiveMark\n        );\n    }\n}\n"},"SafeMathLib256.sol":{"content":"pragma solidity ^0.4.24;\n\n/* Overflow safety library */\nlibrary SafeMathLib256 {\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \u0027+\u0027);\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003c= a, \u0027-\u0027);\n    return a - b;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \u0027*\u0027);\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003e 0, \u0027/\u0027);\n    return a / b;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003e 0, \u0027%\u0027);\n    return a % b;\n  }\n}"},"SafeMathLib32.sol":{"content":"pragma solidity ^0.4.24;\n\nlibrary SafeMathLib32 {\n  function add(uint32 a, uint32 b) internal pure returns (uint32) {\n    uint32 c = a + b;\n    require(c \u003e= a, \u0027+\u0027);\n\n    return c;\n  }\n\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n    require(b \u003c= a, \u0027-\u0027);\n    return a - b;\n  }\n\n  function mul(uint32 a, uint32 b) internal pure returns (uint32) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint32 c = a * b;\n    require(c / a == b, \u0027*\u0027);\n\n    return c;\n  }\n\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\n    require(b \u003e 0, \u0027/\u0027);\n    return a / b;\n  }\n\n  function mod(uint32 a, uint32 b) internal pure returns (uint32) {\n    require(b \u003e 0, \u0027%\u0027);\n    return a % b;\n  }\n}"},"SafeMathLib64.sol":{"content":"pragma solidity ^0.4.24;\n\nlibrary SafeMathLib64 {\n  function add(uint64 a, uint64 b) internal pure returns (uint64) {\n    uint64 c = a + b;\n    require(c \u003e= a, \u0027+\u0027);\n\n    return c;\n  }\n  \n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n    require(b \u003c= a, \u0027-\u0027);\n    return a - b;\n  }\n  \n  function mul(uint64 a, uint64 b) internal pure returns (uint64) {\n    if (a == 0) {\n      return 0;\n    }\n\n    uint64 c = a * b;\n    require(c / a == b, \u0027*\u0027);\n\n    return c;\n  }\n  \n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\n    require(b \u003e 0, \u0027/\u0027);\n    return a / b;\n  }\n  \n  function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n    require(b \u003e 0, \u0027%\u0027);\n    return a % b;\n  }\n}"},"WithdrawalLib.sol":{"content":"/* solhint-disable func-order */\n\npragma solidity ^0.4.24;\n\nimport \"./BimodalLib.sol\";\nimport \"./ChallengeLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\n/*\nThis library contains the implementations of the first NOCUST withdrawal\nprocedures.\n*/\nlibrary WithdrawalLib {\n    using SafeMathLib256 for uint256;\n    using BimodalLib for BimodalLib.Ledger;\n    // EVENTS\n    event WithdrawalRequest(\n        address indexed token,\n        address indexed requestor,\n        uint256 amount\n    );\n\n    event WithdrawalConfirmation(\n        address indexed token,\n        address indexed requestor,\n        uint256 amount\n    );\n\n    function initWithdrawal(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address holder,\n        uint256 eon,\n        uint256 withdrawalAmount\n    ) private /* onlyWhenContractUnpunished() */\n    {\n        BimodalLib.Wallet storage entry = ledger.walletBook[token][holder];\n\n        uint256 balance = 0;\n        if (token != address(this)) {\n            require(ledger.tokenToTrail[token] != 0, \"t\");\n            balance = token.balanceOf(this);\n        } else {\n            balance = address(this).balance;\n        }\n\n        require(\n            ledger.getPendingWithdrawalsAtEon(token, eon).add(\n                withdrawalAmount\n            ) \u003c= balance,\n            \"b\"\n        );\n\n        entry.withdrawals.push(BimodalLib.Withdrawal(eon, withdrawalAmount));\n\n        ledger.addToRunningPendingWithdrawals(token, eon, withdrawalAmount);\n\n        ledger.appendOperationToEonAccumulator(\n            eon,\n            token,\n            holder,\n            BimodalLib.Operation.WITHDRAWAL,\n            withdrawalAmount\n        );\n\n        emit WithdrawalRequest(token, holder, withdrawalAmount);\n    }\n\n    /**\n     * This method can be called freely by a client to initiate a withdrawal in the\n     * parent-chain that will take 2 eons to be confirmable only if the client can\n     * provide a satisfying proof of exclusive allotment.\n     */\n    function requestWithdrawal(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        bytes32[2] checksums,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][2] lrPassiveMark, // Left, Right\n        uint256 withdrawalAmount\n    ) public /* payable */\n    /* onlyWithConstantReimbursement(100100) */\n    {\n        uint256 available = lrPassiveMark[0][1].sub(lrPassiveMark[0][0]);\n        uint256 eon = ledger.currentEon();\n\n        uint256 pending = ledger.getWalletPendingWithdrawalAmountAtEon(\n            token,\n            msg.sender,\n            eon\n        );\n        require(available \u003e= withdrawalAmount.add(pending), \"b\");\n\n        require(\n            ChallengeLib.verifyProofOfExclusiveAccountBalanceAllotment(\n                ledger,\n                token,\n                msg.sender,\n                checksums,\n                trail,\n                [eon.sub(1), lrPassiveMark[1][0], lrPassiveMark[1][1]],\n                allotmentChain,\n                membershipChain,\n                values,\n                lrPassiveMark[0]\n            ),\n            \"p\"\n        );\n\n        initWithdrawal(ledger, token, msg.sender, eon, withdrawalAmount);\n    }\n\n    /**\n     * This method can be called by a client to initiate a withdrawal in the\n     * parent-chain that will take 2 eons to be confirmable only if the client\n     * provides a signature from the operator authorizing the initialization of this\n     * withdrawal.\n     */\n    function requestAuthorizedWithdrawal(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        uint256 withdrawalAmount,\n        uint256 expiry,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public {\n        requestDelegatedWithdrawal(\n            ledger,\n            token,\n            msg.sender,\n            withdrawalAmount,\n            expiry,\n            r,\n            s,\n            v\n        );\n    }\n\n    /**\n     * This method can be called by the operator to initiate a withdrawal in the\n     * parent-chain that will take 2 eons to be confirmable only if the operator\n     * provides a signature from the client authorizing the delegation of this\n     * withdrawal initialization.\n     */\n    function requestDelegatedWithdrawal(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address holder,\n        uint256 withdrawalAmount,\n        uint256 expiry,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public /* onlyOperator() */\n    {\n        require(block.number \u003c= expiry);\n\n        uint256 eon = ledger.currentEon();\n        uint256 pending = ledger.getWalletPendingWithdrawalAmountAtEon(\n            token,\n            holder,\n            eon\n        );\n\n        require(\n            ChallengeLib.verifyWithdrawalAuthorization(\n                token,\n                holder,\n                expiry,\n                withdrawalAmount.add(pending),\n                holder,\n                r,\n                s,\n                v\n            )\n        );\n\n        initWithdrawal(ledger, token, holder, eon, withdrawalAmount);\n    }\n\n    /**\n     * This method can be called to confirm the withdrawals of a recipient that have\n     * been pending for at least two eons when the operator is not halted.\n     */\n    function confirmWithdrawal(\n        BimodalLib.Ledger storage ledger,\n        ERC20 token,\n        address recipient\n    )\n        public\n        returns (\n            /* onlyWhenContractUnpunished() */\n            uint256 amount\n        )\n    {\n        BimodalLib.Wallet storage entry = ledger.walletBook[token][recipient];\n        BimodalLib.Withdrawal[] storage withdrawals = entry.withdrawals;\n\n        uint256 eon = ledger.currentEon();\n        amount = 0;\n\n        /**\n         * after the loop, i is set to the index of the first pending withdrawals\n         * amount is the amount to be sent to the recipient\n         */\n        uint32 i = 0;\n        for (i = 0; i \u003c withdrawals.length; i++) {\n            BimodalLib.Withdrawal storage withdrawal = withdrawals[i];\n            if (withdrawal.eon.add(1) \u003e= eon) {\n                break;\n            } else if (\n                withdrawal.eon.add(2) == eon \u0026\u0026\n                ledger.currentEra() \u003c ledger.EXTENDED_BLOCKS_PER_EPOCH\n            ) {\n                break;\n            }\n\n            amount = amount.add(withdrawal.amount);\n        }\n\n        // set withdrawals to contain only pending withdrawal requests\n        for (uint32 j = 0; j \u003c i \u0026\u0026 i \u003c withdrawals.length; j++) {\n            withdrawals[j] = withdrawals[i];\n            i++;\n        }\n        withdrawals.length = withdrawals.length.sub(j);\n\n        ledger.deductFromRunningPendingWithdrawals(token, eon, eon, amount);\n\n        BimodalLib.AmountAggregate storage eonWithdrawals = ledger\n            .confirmedWithdrawals[token][eon.mod(ledger.EONS_KEPT)];\n        BimodalLib.addToAggregate(eonWithdrawals, eon, amount);\n\n        emit WithdrawalConfirmation(token, recipient, amount);\n\n        // if token is not chain native asset\n        if (token != address(this)) {\n            require(ledger.tokenToTrail[token] != 0);\n            require(token.transfer(recipient, amount));\n        } else {\n            recipient.transfer(amount);\n        }\n    }\n}\n"},"WithdrawalProxy.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./BimodalProxy.sol\";\nimport \"./ERC20.sol\";\nimport \"./WithdrawalLib.sol\";\nimport \"./SafeMathLib256.sol\";\n\ncontract WithdrawalProxy is BimodalProxy {\n    using SafeMathLib256 for uint256;\n\n    modifier onlyWithConstantReimbursement(uint256 responseGas) {\n        require(\n            msg.value \u003e= responseGas.mul(ledger.MIN_CHALLENGE_GAS_COST) \u0026\u0026\n                msg.value \u003e= responseGas.mul(tx.gasprice),\n            \"r\"\n        );\n        ledger.operator.transfer(msg.value);\n        _;\n    }\n\n    // =========================================================================\n    function requestWithdrawal(\n        ERC20 token,\n        bytes32[2] checksums,\n        uint64 trail,\n        bytes32[] allotmentChain,\n        bytes32[] membershipChain,\n        uint256[] values,\n        uint256[2][2] lrPassiveMark,\n        uint256 withdrawalAmount\n    )\n        public\n        payable\n        onlyWithConstantReimbursement(100100)\n        onlyWhenContractUnpunished()\n    {\n        WithdrawalLib.requestWithdrawal(\n            ledger,\n            token,\n            checksums,\n            trail,\n            allotmentChain,\n            membershipChain,\n            values,\n            lrPassiveMark,\n            withdrawalAmount\n        );\n    }\n\n    function requestAuthorizedWithdrawal(\n        ERC20 token,\n        uint256 withdrawalAmount,\n        uint256 expiry,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public onlyWhenContractUnpunished() {\n        WithdrawalLib.requestAuthorizedWithdrawal(\n            ledger,\n            token,\n            withdrawalAmount,\n            expiry,\n            r,\n            s,\n            v\n        );\n    }\n\n    function requestDelegatedWithdrawal(\n        ERC20 token,\n        address holder,\n        uint256 withdrawalAmount,\n        uint256 expiry,\n        bytes32 r,\n        bytes32 s,\n        uint8 v\n    ) public onlyOperator() onlyWhenContractUnpunished() {\n        WithdrawalLib.requestDelegatedWithdrawal(\n            ledger,\n            token,\n            holder,\n            withdrawalAmount,\n            expiry,\n            r,\n            s,\n            v\n        );\n    }\n\n    function confirmWithdrawal(ERC20 token, address recipient)\n        public\n        onlyWhenContractUnpunished()\n        returns (uint256)\n    {\n        return WithdrawalLib.confirmWithdrawal(ledger, token, recipient);\n    }\n}\n"}}