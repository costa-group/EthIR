{"Address.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// From: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256(\u0027\u0027)`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash \u0026\u0026 codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity\u0027s `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length \u003e 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}"},"MultiSig.sol":{"content":"/**\r\n * SPDX-License-Identifier: MIT\r\n */\r\n\r\npragma solidity \u003e=0.6;\r\n\r\nimport \"./Address.sol\";\r\nimport \"./RLPEncode.sol\";\r\n\r\ncontract MultiSig {\r\n\r\n  mapping (address =\u003e uint8) public signers; // The addresses that can co-sign transactions and the number of signatures needed\r\n  \r\n  uint16 public signerCount;\r\n\r\n  // Observation: the nonce is not increase when the transaction fails.\r\n  uint256 private sequenceNumber; // A sequence number that contains the address of this contract to make it globally unique\r\n\r\n  event SignerChange(\r\n    address indexed signer,\r\n    uint8 cosignaturesNeeded\r\n  );\r\n\r\n  event Transacted(\r\n    address indexed toAddress,  // The address the transaction was sent to\r\n    bytes4 selector, // selected operation\r\n    address[] signers // Addresses of the signers used to initiate the transaction\r\n  );\r\n\r\n  constructor (address owner) public {\r\n    // ensure that the sequence number is unique by starting at the unique address of this contract\r\n    sequenceNumber = uint256(address(this)) \u003c\u003c 64; // 64 bits should be more than enough sequence numbers\r\n    _setSigner(owner, 1); // start with the contract creator as owner\r\n  }\r\n\r\n  /**\r\n   * Checks if the provided signatures suffice to sign the transaction and if the nonce is correct.\r\n   */\r\n  function checkSignatures(address to, uint value, bytes calldata data,\r\n    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public view returns (address[] memory) {\r\n    bytes32 transactionHash = calculateTransactionHash(nextSequenceNumber(), to, value, data);\r\n    return verifySignatures(transactionHash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * Checks if the execution of a transaction would succeed if it was properly signed.\r\n   */\r\n  function checkExecution(address to, uint value, bytes calldata data) public {\r\n    Address.functionCallWithValue(to, data, value);\r\n    require(false, \"Test passed. Reverting.\");\r\n  }\r\n\r\n  function execute(address to, uint value, bytes calldata data, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public returns (bytes memory) {\r\n    sequenceNumber = nextSequenceNumber(); // ok to increment here already, will be rolled back in case of failure and saves us one local variable\r\n    bytes32 transactionHash = calculateTransactionHash(sequenceNumber, to, value, data);\r\n    address[] memory found = verifySignatures(transactionHash, v, r, s);\r\n    bytes memory returndata = Address.functionCallWithValue(to, data, value);\r\n    emit Transacted(to, extractSelector(data), found);\r\n    return returndata;\r\n  }\r\n\r\n  function extractSelector(bytes calldata data) private pure returns (bytes4){\r\n    if (data.length \u003c 4){\r\n      return bytes4(0);\r\n    } else {\r\n      return bytes4(data[0]) | (bytes4(data[1]) \u003e\u003e 8) | (bytes4(data[2]) \u003e\u003e 16) | (bytes4(data[3]) \u003e\u003e 24);\r\n    }\r\n  }\r\n\r\n  function nextSequenceNumber() public view returns (uint256){\r\n    return sequenceNumber + 1;\r\n  }\r\n\r\n  function toBytes(uint number) internal pure returns (bytes memory){\r\n    uint len = 0;\r\n    uint temp = 1;\r\n    while (number \u003e= temp){\r\n      temp = temp \u003c\u003c 8;\r\n      len++;\r\n    }\r\n    temp = number;\r\n    bytes memory data = new bytes(len);\r\n    for (uint i = len; i\u003e0; i--) {\r\n      data[i-1] = bytes1(uint8(temp));\r\n      temp = temp \u003e\u003e 8;\r\n    }\r\n    return data;\r\n  }\r\n\r\n  // Note: does not work with contract creation\r\n  function calculateTransactionHash(uint sequence, address to, uint value, bytes calldata data) private pure returns (bytes32){\r\n    bytes[] memory all = new bytes[](6);\r\n    all[0] = toBytes(sequence); // sequence number instead of nonce\r\n    all[1] = new bytes(0); // gas price\r\n    all[2] = all[1]; // gas limit\r\n    all[3] = abi.encodePacked(to);\r\n    all[4] = toBytes(value);\r\n    all[5] = data;\r\n    for (uint i = 0; i\u003c6; i++){\r\n      all[i] = RLPEncode.encodeBytes(all[i]);\r\n    }\r\n    return keccak256(RLPEncode.encodeList(all));\r\n  }\r\n\r\n  function verifySignatures(bytes32 transactionHash, uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) private view returns (address[] memory) {\r\n    address[] memory found = new address[](r.length);\r\n    for (uint i = 0; i \u003c r.length; i++) {\r\n      address signer = ecrecover(transactionHash, v[i], r[i], s[i]);\r\n      uint8 cosignaturesNeeded = signers[signer];\r\n      require(cosignaturesNeeded \u003e 0 \u0026\u0026 cosignaturesNeeded \u003c= r.length, \"cosigner error\");\r\n      found[i] = signer;\r\n    }\r\n    requireNoDuplicates(found);\r\n    return found;\r\n  }\r\n\r\n  function requireNoDuplicates(address[] memory found) private pure {\r\n    for (uint i = 0; i \u003c found.length; i++) {\r\n      for (uint j = i+1; j \u003c found.length; j++) {\r\n        require(found[i] != found[j], \"duplicate signature\");\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Call this method through execute\r\n   */\r\n  function setSigner(address signer, uint8 cosignaturesNeeded) public {\r\n    require(address(this) == msg.sender || signers[msg.sender] == 1, \"not authorized\");\r\n    _setSigner(signer, cosignaturesNeeded);\r\n  }\r\n\r\n  function _setSigner(address signer, uint8 cosignaturesNeeded) internal {\r\n    require(!Address.isContract(signer));\r\n    uint8 prevValue = signers[signer];\r\n    signers[signer] = cosignaturesNeeded;\r\n    if (prevValue \u003e 0 \u0026\u0026 cosignaturesNeeded == 0){\r\n      signerCount--;\r\n    } else if (prevValue == 0 \u0026\u0026 cosignaturesNeeded \u003e 0){\r\n      signerCount++;\r\n    }\r\n    emit SignerChange(signer, cosignaturesNeeded);\r\n  }\r\n\r\n}"},"RLPEncode.sol":{"content":"/// SPDX-License-Identifier: MIT\r\n/// @title RLP Encoding Library for Solidity\r\n/// @author Sam Mayo (sammayo888@gmail.com)\r\n/// @dev Library for rlp encoding arbitrary bytes or lists.\r\n\r\npragma solidity \u003e=0.6;\r\n\r\nlibrary RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n    /// @dev Rlp encodes a bytes\r\n    /// @param self The bytes to be encoded\r\n    /// @return The rlp encoded bytes\r\n    function encodeBytes(bytes memory self) internal pure returns (bytes memory) {\r\n        bytes memory encoded;\r\n        if(self.length == 1 \u0026\u0026 self[0] \u003c 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n        return encoded;\r\n    }\r\n    \r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal pure returns (bytes memory) {\r\n        bytes memory list = flatten(self);\r\n        bytes memory encoded = encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n        return encoded;\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private pure returns (bytes memory) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        uint len = self.length;\r\n        if(len \u003c= 55) {\r\n            bytes memory encoded = new bytes(len+1);\r\n            uint8 lenshort = uint8(len);\r\n            // length encoding byte\r\n            encoded[0] = byte(prefix1+lenshort);\r\n\r\n            // string/list contents\r\n            uint encodedPtr;\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n            return encoded;\r\n        } else {\r\n            uint8 lenLen;\r\n            uint i = 0x1;\r\n            while(len/i != 0) {\r\n                lenLen++;\r\n                i *= 0x100;\r\n            }\r\n\r\n            // 1 is the length of the length of the length\r\n           bytes memory encoded = new bytes(1+lenLen+len);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(prefix2+lenLen);\r\n\r\n            // length bytes\r\n            for(i=1; i\u003c=lenLen; i++) {\r\n                encoded[i] = byte(uint8((len/(0x100**(lenLen-i)))%0x100));\r\n            }\r\n\r\n            // string/list contents\r\n            uint encodedPtr;\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n            return encoded;\r\n        }\r\n    }\r\n    \r\n    function flatten(bytes[] memory self) private pure returns (bytes memory) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i\u003cself.length; i++) {\r\n            len += self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(uint i=0; i\u003cself.length; i++) {\r\n            bytes memory item = self[i];\r\n            \r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr += self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson\u0027s string utils library\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; len \u003e= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}"}}