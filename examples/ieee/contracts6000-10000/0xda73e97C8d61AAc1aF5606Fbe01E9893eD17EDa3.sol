{{
  "language": "Solidity",
  "sources": {
    "contracts/ActionChiMint.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {\n    GelatoActionsStandard\n} from \"@gelatonetwork/core/contracts/actions/GelatoActionsStandard.sol\";\nimport {ChiToken} from \"./ChiToken.sol\";\nimport {\n    DataFlow\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {GelatoBytes} from \"@gelatonetwork/core/contracts/libraries/GelatoBytes.sol\";\n\n/// @notice This action wraps around ChiToken.mint\n/// @dev Use in conjunction with selfProviderGasLimit Gelato Task config\ncontract ActionChiMint is GelatoActionsStandard {\n\n    ChiToken public immutable chiToken;\n    constructor(ChiToken _chiToken) public { chiToken = _chiToken; }\n\n    // ======= DEV HELPERS =========\n    /// @dev use this function to encode the data off-chain for the action data field\n    function getActionData(address _recipient, uint256 _chiAmount)\n        public\n        pure\n        virtual\n        returns(bytes memory)\n    {\n        if (_chiAmount > 140)\n            revert(\"ActionChiMint.getActionData: max 140 CHI\");\n        return abi.encodeWithSelector(this.action.selector, _recipient, _chiAmount);\n    }\n\n    // ======= ACTION IMPLEMENTATION DETAILS =========\n    /// @dev Call ChaiToken.mint via UserProxy (Delegatecall)\n    function action(address _recipient, uint256 _chiAmount)\n        public\n        virtual\n        delegatecallOnly(\"ActionChiMint.action\")\n    {\n        try chiToken.mint(_chiAmount) {\n        } catch Error(string memory error) {\n            revert(string(abi.encodePacked(\"ActionChiMint.action.mint:\", error)));\n        } catch {\n            revert(\"ActionChiMint.action.mint: unknown error\");\n        }\n\n        try chiToken.transfer(_recipient, _chiAmount) returns (bool success) {\n            require(success, \"ActionChiMint.action.transfer: unsuccessful\");\n        } catch Error(string memory error) {\n            revert(string(abi.encodePacked(\"ActionChiMint.action.transfer:\", error)));\n        } catch {\n            revert(\"ActionChiMint.action.transfer: unknown error\");\n        }\n    }\n\n    // ===== ACTION TERMS CHECK ========\n    // Make sure\n    function termsOk(\n        uint256,  // taskReceipId\n        address,  // _userProxy\n        bytes calldata _actionData,\n        DataFlow,\n        uint256,  // value\n        uint256  // cycleId\n    )\n        public\n        view\n        virtual\n        override\n        returns(string memory)\n    {\n        if (this.action.selector != GelatoBytes.calldataSliceSelector(_actionData))\n            return \"ActionChiMint: invalid action selector\";\n\n        uint256 _chiAmount = abi.decode(_actionData[36:68], (uint256));\n\n        // We want to restrict to 140 CHI minted max per TX\n        // https://medium.com/@1inch.exchange/1inch-introduces-chi-gastoken-d0bd5bb0f92b\n        if (_chiAmount > 140 || _chiAmount == 0)\n            return \"ActionChiMint: invalid chi amount\";\n\n        // STANDARD return string to signal actionConditions Ok\n        return OK;\n    }\n}\n"
    },
    "@gelatonetwork/core/contracts/actions/GelatoActionsStandard.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\n\nimport {IGelatoAction} from \"./IGelatoAction.sol\";\nimport {DataFlow} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\n/// @title GelatoActionsStandard\n/// @dev find all the NatSpecs inside IGelatoAction\nabstract contract GelatoActionsStandard is IGelatoAction {\n\n    string internal constant OK = \"OK\";\n    address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address public immutable thisActionAddress;\n\n    constructor() public { thisActionAddress = address(this); }\n\n    modifier delegatecallOnly(string memory _tracingInfo) {\n        require(\n            thisActionAddress != address(this),\n            string(abi.encodePacked(_tracingInfo, \":delegatecallOnly\"))\n        );\n        _;\n    }\n\n    function termsOk(\n        uint256,  // _taskReceiptId\n        address,  // _userProxy\n        bytes calldata,  // _actionData\n        DataFlow,\n        uint256,  // _value: for actions that send ETH around\n        uint256  // cycleId\n    )\n        external\n        view\n        virtual\n        override\n        returns(string memory)  // actionTermsOk\n    {\n        // Standard return value for actionConditions fulfilled and no erros:\n        return OK;\n    }\n}\n"
    },
    "@gelatonetwork/core/contracts/actions/IGelatoAction.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\n\nimport {DataFlow} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\n/// @title IGelatoAction - solidity interface of GelatoActionsStandard\n/// @notice all the APIs and events of GelatoActionsStandard\n/// @dev all the APIs are implemented inside GelatoActionsStandard\ninterface IGelatoAction {\n    event LogOneWay(\n        address origin,\n        address sendToken,\n        uint256 sendAmount,\n        address destination\n    );\n\n    event LogTwoWay(\n        address origin,\n        address sendToken,\n        uint256 sendAmount,\n        address destination,\n        address receiveToken,\n        uint256 receiveAmount,\n        address receiver\n    );\n\n    /// @notice Providers can use this for pre-execution sanity checks, to prevent reverts.\n    /// @dev GelatoCore checks this in canExec and passes the parameters.\n    /// @param _taskReceiptId The id of the task from which all arguments are passed.\n    /// @param _userProxy The userProxy of the task. Often address(this) for delegatecalls.\n    /// @param _actionData The encoded payload to be used in the Action.\n    /// @param _dataFlow The dataFlow of the Action.\n    /// @param _value A special param for ETH sending Actions. If the Action sends ETH\n    ///  in its Action function implementation, one should expect msg.value therein to be\n    ///  equal to _value. So Providers can check in termsOk that a valid ETH value will\n    ///  be used because they also have access to the same value when encoding the\n    ///  execPayload on their ProviderModule.\n    /// @param _cycleId For tasks that are part of a Cycle.\n    /// @return Returns OK, if Task can be executed safely according to the Provider's\n    ///  terms laid out in this function implementation.\n    function termsOk(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        bytes calldata _actionData,\n        DataFlow _dataFlow,\n        uint256 _value,\n        uint256 _cycleId\n    )\n        external\n        view\n        returns(string memory);\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {IGelatoProviderModule} from \"../../provider_modules/IGelatoProviderModule.sol\";\nimport {IGelatoCondition} from \"../../conditions/IGelatoCondition.sol\";\n\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nenum DataFlow { None, In, Out, InAndOut }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    DataFlow dataFlow;\n    uint256 value;\n    bool termsOkCheck;\n}\n\nstruct Task {\n    Condition[] conditions;  // optional\n    Action[] actions;\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\n}\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Provider provider;\n    uint256 index;\n    Task[] tasks;\n    uint256 expiryDate;\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\n    uint256 submissionsLeft;\n}\n\ninterface IGelatoCore {\n    event LogTaskSubmitted(\n        uint256 indexed taskReceiptId,\n        bytes32 indexed taskReceiptHash,\n        TaskReceipt taskReceipt\n    );\n\n    event LogExecSuccess(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorSuccessFee,\n        uint256 sysAdminSuccessFee\n    );\n    event LogCanExecFailed(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        string reason\n    );\n    event LogExecReverted(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorRefund,\n        string reason\n    );\n\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\n\n    /// @notice API to query whether Task can be submitted successfully.\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _userProxy The userProxy from which the task will be submitted.\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\n    function canSubmitTask(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external\n        view\n        returns(string memory);\n\n    /// @notice API to submit a single Task.\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task A Gelato Task object: provider, conditions, actions.\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\n    function submitTask(\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _cycles How many full cycles will be submitted\n    function submitTaskCycle(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _cycles\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\n    ///  would be submitted, but not the second\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n    ///  that should have occured once the cycle is complete:\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\n    ///  ...\n    function submitTaskChain(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _sumOfRequestedTaskSubmits\n    )\n        external;\n\n    // ================  Exec Suite =========================\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n    ///   In the latter case Executors are refunded by the Task Provider.\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function exec(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel task\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function cancelTask(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel multiple tasks at once\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n\n    /// @notice Compute hash of task receipt\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @return hash of taskReceipt\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\n\n    // ================  Getters =========================\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n    /// @return currentId currentId, last TaskReceiptId submitted\n    function currentTaskReceiptId() external view returns(uint256);\n\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n    /// @return hash of taskReceipt\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\n}\n"
    },
    "@gelatonetwork/core/contracts/provider_modules/IGelatoProviderModule.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {Action, Task} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\ninterface IGelatoProviderModule {\n\n    /// @notice Check if provider agrees to pay for inputted task receipt\n    /// @dev Enables arbitrary checks by provider\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @return \"OK\" if provider agrees\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Convert action specific payload into proxy specific payload\n    /// @dev Encoded multiple actions into a multisend\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\n    /// @return Encoded payload that will be used for low-level .call on user proxy\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n    function execPayload(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        address _provider,\n        Task calldata _task,\n        uint256 _cycleId\n    )\n        external\n        view\n        returns(bytes memory, bool checkReturndata);\n\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\n}\n"
    },
    "@gelatonetwork/core/contracts/conditions/IGelatoCondition.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\npragma experimental ABIEncoderV2;\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n    ///  \"ok\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n    ///  source of Task identification.\n    /// @param _conditionData This is the Condition.data field developers must encode their\n    ///  Condition's specific parameters in.\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\n        external\n        view\n        returns(string memory);\n}"
    },
    "contracts/ChiToken.sol": {
      "content": "// Source: https://github.com/CryptoManiacsZone/chi/blob/master/contracts/ChiToken.sol\n\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\nabstract contract ERC20WithoutTotalSupply is IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 allowed = _allowances[sender][msg.sender];\n        if ((allowed >> 255) == 0) {\n            _approve(sender, msg.sender, allowed.sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        }\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        uint256 allowed = _allowances[account][msg.sender];\n        if ((allowed >> 255) == 0) {\n            _approve(account, msg.sender, allowed.sub(amount, \"ERC20: burn amount exceeds allowance\"));\n        }\n    }\n}\n\n\ncontract ChiToken is IERC20, ERC20WithoutTotalSupply {\n    string constant public name = \"Chi Token by 1inch\";\n    string constant public symbol = \"CHI\";\n    uint8 constant public decimals = 0;\n\n    uint256 public totalMinted;\n    uint256 public totalBurned;\n\n    function totalSupply() public view override returns(uint256) {\n        return totalMinted - totalBurned;\n    }\n\n    function mint(uint256 value) public {\n        uint256 offset = totalMinted;\n        assembly {\n            mstore(0, 0x746d4946c0e9F43F4Dee607b0eF1fA1c3318585733ff6000526015600bf30000)\n\n            for {let i := div(value, 32)} i {i := sub(i, 1)} {\n                pop(create2(0, 0, 30, add(offset, 0))) pop(create2(0, 0, 30, add(offset, 1)))\n                pop(create2(0, 0, 30, add(offset, 2))) pop(create2(0, 0, 30, add(offset, 3)))\n                pop(create2(0, 0, 30, add(offset, 4))) pop(create2(0, 0, 30, add(offset, 5)))\n                pop(create2(0, 0, 30, add(offset, 6))) pop(create2(0, 0, 30, add(offset, 7)))\n                pop(create2(0, 0, 30, add(offset, 8))) pop(create2(0, 0, 30, add(offset, 9)))\n                pop(create2(0, 0, 30, add(offset, 10))) pop(create2(0, 0, 30, add(offset, 11)))\n                pop(create2(0, 0, 30, add(offset, 12))) pop(create2(0, 0, 30, add(offset, 13)))\n                pop(create2(0, 0, 30, add(offset, 14))) pop(create2(0, 0, 30, add(offset, 15)))\n                pop(create2(0, 0, 30, add(offset, 16))) pop(create2(0, 0, 30, add(offset, 17)))\n                pop(create2(0, 0, 30, add(offset, 18))) pop(create2(0, 0, 30, add(offset, 19)))\n                pop(create2(0, 0, 30, add(offset, 20))) pop(create2(0, 0, 30, add(offset, 21)))\n                pop(create2(0, 0, 30, add(offset, 22))) pop(create2(0, 0, 30, add(offset, 23)))\n                pop(create2(0, 0, 30, add(offset, 24))) pop(create2(0, 0, 30, add(offset, 25)))\n                pop(create2(0, 0, 30, add(offset, 26))) pop(create2(0, 0, 30, add(offset, 27)))\n                pop(create2(0, 0, 30, add(offset, 28))) pop(create2(0, 0, 30, add(offset, 29)))\n                pop(create2(0, 0, 30, add(offset, 30))) pop(create2(0, 0, 30, add(offset, 31)))\n                offset := add(offset, 32)\n            }\n\n            for {let i := and(value, 0x1F)} i {i := sub(i, 1)} {\n                pop(create2(0, 0, 30, offset))\n                offset := add(offset, 1)\n            }\n        }\n\n        _mint(msg.sender, value);\n        totalMinted = offset;\n    }\n\n    function computeAddress2(uint256 salt) public pure returns (address child) {\n        assembly {\n            let data := mload(0x40)\n            mstore(data, 0xff0000000000004946c0e9F43F4Dee607b0eF1fA1c0000000000000000000000)\n            mstore(add(data, 21), salt)\n            mstore(add(data, 53), 0x3c1644c68e5d6cb380c36d1bf847fdbc0c7ac28030025a2fc5e63cce23c16348)\n            child := and(keccak256(data, 85), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n    }\n\n    function _destroyChildren(uint256 value) internal {\n        assembly {\n            let i := sload(totalBurned_slot)\n            let end := add(i, value)\n            sstore(totalBurned_slot, end)\n\n            let data := mload(0x40)\n            mstore(data, 0xff0000000000004946c0e9F43F4Dee607b0eF1fA1c0000000000000000000000)\n            mstore(add(data, 53), 0x3c1644c68e5d6cb380c36d1bf847fdbc0c7ac28030025a2fc5e63cce23c16348)\n            let ptr := add(data, 21)\n            for { } lt(i, end) { i := add(i, 1) } {\n                mstore(ptr, i)\n                pop(call(gas(), keccak256(data, 85), 0, 0, 0, 0, 0))\n            }\n        }\n    }\n\n    function free(uint256 value) public returns (uint256)  {\n        if (value > 0) {\n            _burn(msg.sender, value);\n            _destroyChildren(value);\n        }\n        return value;\n    }\n\n    function freeUpTo(uint256 value) public returns (uint256) {\n        return free(Math.min(value, balanceOf(msg.sender)));\n    }\n\n    function freeFrom(address from, uint256 value) public returns (uint256) {\n        if (value > 0) {\n            _burnFrom(from, value);\n            _destroyChildren(value);\n        }\n        return value;\n    }\n\n    function freeFromUpTo(address from, uint256 value) public returns (uint256) {\n        return freeFrom(from, Math.min(Math.min(value, balanceOf(from)), allowance(from, msg.sender)));\n    }\n}"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@gelatonetwork/core/contracts/libraries/GelatoBytes.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity ^0.6.10;\n\nlibrary GelatoBytes {\n    function calldataSliceSelector(bytes calldata _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function memorySliceSelector(bytes memory _bytes)\n        internal\n        pure\n        returns (bytes4 selector)\n    {\n        selector =\n            _bytes[0] |\n            (bytes4(_bytes[1]) >> 8) |\n            (bytes4(_bytes[2]) >> 16) |\n            (bytes4(_bytes[3]) >> 24);\n    }\n\n    function revertWithErrorString(bytes memory _bytes, string memory _tracingInfo)\n        internal\n        pure\n    {\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\n        if (_bytes.length % 32 == 4) {\n            bytes4 selector;\n            assembly { selector := mload(add(0x20, _bytes)) }\n            if (selector == 0x08c379a0) {  // Function selector for Error(string)\n                assembly { _bytes := add(_bytes, 68) }\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\n            } else {\n                revert(string(abi.encodePacked(_tracingInfo, \"NoErrorSelector\")));\n            }\n        } else {\n            revert(string(abi.encodePacked(_tracingInfo, \"UnexpectedReturndata\")));\n        }\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}