{"Distribute.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity \u003e=0.4.23 \u003c0.7.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\npragma solidity \u003e=0.4.23 \u003c0.7.0;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b \u003c= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c \u003e= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}\r\n\r\npragma solidity \u003e=0.4.23 \u003c0.7.0;\r\n\r\n\r\n/*\r\n--------------------------------------------------------------------------\r\n-        Distribution Contract for the Analys-X (XYS) Token              -\r\n-                   Written by: Admirral                                 -\r\n-                     ~~~~~~~~~~~~~~~~                                   -\r\n-    This contract will track XYS stakers and distribute payments        -\r\n-    received from users who purchase Analys-X products. All payments    -\r\n-    will be received in XYS tokens.                                     -\r\n-                                                                        -\r\n-    Only 100 stakers will be allowed at any one time.                   -\r\n-    When a new user stakes, the oldest on the list is removed and       -\r\n-    they receive their stake back. The price to stake                   -\r\n-    increases by 1% after each new stake.                               -\r\n-                                                                        -\r\n-    When product fees are collected, 90% of that fee is redistributed   -\r\n-    to the 100 addresses on the list.                                   -\r\n--------------------------------------------------------------------------\r\n*/\r\n\r\ncontract Distribute is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    // EVENTS\r\n    event Stake(address indexed user);\r\n    event Purchase(address indexed user, uint256 amount);\r\n    event Withdraw(address indexed user);\r\n\r\n    //basic identifiers - ERC20 Standard\r\n    string public name = \"ANALYSX\";\r\n    string public symbol = \"XYS\";\r\n    uint256 public decimals = 6;\r\n\r\n    //total Supply - currently 40\u0027000\u0027000\r\n    uint256 private _totalSupply = 40000000 * (10 ** decimals);\r\n\r\n    // balances and allowance - ERC20 Standard\r\n    mapping (address =\u003e uint256) private _balances;\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    // Staked Token Tracking\r\n    mapping (address =\u003e uint256) public _staked;\r\n\r\n    // Users earnings from staking\r\n    mapping (address =\u003e uint256) private _earned;\r\n\r\n    // Is user on staking list? \r\n    mapping (address =\u003e bool) public _isStaked;\r\n\r\n    // Stake List\r\n    address[100] private _stakeList;\r\n\r\n    // initial staking fee\r\n    uint256 public _initialFee = 100000 * (10 ** decimals);\r\n\r\n    // Current Staking Fee\r\n    uint256 public _stakeFee;\r\n\r\n    // Total Amount Staked;\r\n    uint256 public _totalStaked;\r\n\r\n    // Time of Previous Staker\r\n    uint256 public _lastStakerTime;\r\n\r\n    // Contract owner Address\r\n    address payable _owner;\r\n\r\n\r\n    // Constructor\r\n    constructor(address payable owner) public {\r\n\r\n        // mints tokens\r\n        _mint(owner, _totalSupply);\r\n\r\n        // Sets owner of contract\r\n        _owner = owner;  \r\n\r\n        // Sets staking fee to initial amount             \r\n        _stakeFee = _initialFee;\r\n\r\n        // initiates time of most recent staker\r\n        _lastStakerTime = block.timestamp;\r\n\r\n        // fills stakeList with owner.\r\n        for (uint i = 0; i \u003c= 99; i++) {\r\n            _stakeList[i] = _owner;\r\n        }\r\n\r\n    }\r\n\r\n    // ---------------------------------\r\n    // --       ERC20 Functions       --\r\n    // --        Open Zeppelin        --\r\n    // ---------------------------------\r\n\r\n    function totalSupply() override public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) override public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) override public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) override public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n\r\n    // --------------------------------------\r\n    // --       Custom Functions           --\r\n    // --------------------------------------\r\n\r\n    // Owner modifier. Functions with this modifier can only be called by contract owner\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    } \r\n\r\n    // checks if the sending user is owner. Returns true or false\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    // change owner\r\n    function changeOwner(address payable newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n\r\n    // Returns users stake earnings\r\n    function checkReward() public view returns (uint256) {\r\n        return _earned[msg.sender];\r\n    }\r\n\r\n    // returns staker list\r\n    function showStakers() public view returns (address[100] memory) {\r\n        return _stakeList;\r\n    }\r\n\r\n    // Stake Function\r\n    function stake() public {\r\n        require(msg.sender != _owner, \"Owner cannot stake\");\r\n        require(_balances[msg.sender] \u003e= _stakeFee, \"Insufficient Tokens\");\r\n        require(_isStaked[msg.sender] == false, \"You are already staking\");\r\n        require(_staked[msg.sender] == 0, \"You have stake\"); // Maybe redundant?\r\n\r\n        // updates new stakers balances and records stake\r\n        _balances[msg.sender] = _balances[msg.sender].sub(_stakeFee);\r\n        _staked[msg.sender] = _stakeFee;\r\n        _totalStaked = _totalStaked.add(_stakeFee);\r\n\r\n        // updates staking fee\r\n        uint256 stakeIncrease = _stakeFee.div(100);\r\n        _stakeFee = _stakeFee.add(stakeIncrease);\r\n        _lastStakerTime = block.timestamp;\r\n\r\n        // updates stake list\r\n        updateStaking();\r\n\r\n        emit Stake(msg.sender);\r\n\r\n    }\r\n    \r\n    // Remove a user from staking, and replace slot with _owner address\r\n    function exitStake() public returns(bool) {\r\n        require(msg.sender != _owner, \"owner cannot exit\");\r\n        require(_isStaked[msg.sender] == true, \"You are not staking\");\r\n        require(_staked[msg.sender] != 0, \"You don\u0027t have stake\"); // Maybe redundant?\r\n        \r\n        for (uint i = 0; i \u003c 99; i++) {\r\n            if (_stakeList[i] == msg.sender) {\r\n                _balances[msg.sender] = _balances[msg.sender].add(_earned[msg.sender]).add(_staked[msg.sender]);\r\n                _staked[msg.sender] = 0;\r\n                _earned[msg.sender] = 0;\r\n                _stakeList[i] = _owner;\r\n                _isStaked[msg.sender] = false;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //Adds new user to staking list, removes oldest user, returns their stake\r\n    function updateStaking() internal {\r\n\r\n        // Refunds the user at the end of the list\r\n        address lastUser = _stakeList[99];\r\n        _balances[lastUser] = _balances[lastUser].add(_staked[lastUser]);\r\n        _staked[lastUser] = 0;\r\n        _isStaked[lastUser] = false;\r\n        \r\n        // Gives the final user their collected rewards\r\n        _balances[lastUser] = _balances[lastUser].add(_earned[lastUser]);\r\n        _earned[lastUser] = 0;\r\n\r\n        // Updates positions on list\r\n        for (uint i = 99; i \u003e 0; i--) {\r\n            uint previous = i.sub(1);\r\n            address previousUser = _stakeList[previous];\r\n            _stakeList[i] = previousUser;\r\n        }\r\n\r\n        // Inserts new staker to top of list\r\n        _stakeList[0] = msg.sender;\r\n        _isStaked[msg.sender] = true;\r\n    }\r\n\r\n    // Function to purchase service (any price is possible, product is offerred off-chain)\r\n    function purchaseService(uint256 price, address purchaser) public {\r\n        \r\n        // Check if user has required balance\r\n        require (_balances[purchaser] \u003e= price, \"Insufficient funds\");\r\n        \r\n        // token value must be \u003e 0.001 to avoid computation errors)\r\n        require (price \u003e 1000, \"Value too Small\");\r\n\r\n        // 10% goes to owner (this can be adjusted)\r\n        uint256 ownerShare = price.div(10);\r\n        uint256 toSplit = price.sub(ownerShare);\r\n        uint256 stakeShare = toSplit.div(100);\r\n        _earned[_owner] = _earned[_owner].add(ownerShare);\r\n\r\n        // distributes funds to each staker, except the last one. \r\n        for (uint i = 0; i \u003c 99; i++) {\r\n            \r\n            // adds stakeShare to each user\r\n            _earned[_stakeList[i]] = _earned[_stakeList[i]].add(stakeShare);\r\n            \r\n            // We subtract from toSplit to produce a final amount for the final staker\r\n            toSplit = toSplit.sub(stakeShare);\r\n        }\r\n        \r\n        // toSplit should be equal or slightly higher than stakeShare. This is to avoid accidental burning.\r\n        _earned[_stakeList[99]] = _earned[_stakeList[99]].add(toSplit);\r\n        \r\n        // Remove the price from sender.\r\n        _balances[purchaser] = _balances[purchaser].sub(price);\r\n\r\n        emit Purchase(purchaser, price);\r\n    }\r\n\r\n    // Stakers can call this function to claim their funds without leaving the pool. \r\n    function withdraw() public {\r\n        require(_earned[msg.sender] \u003e 0, \"Stake some more\");\r\n        _balances[msg.sender] = _balances[msg.sender].add(_earned[msg.sender]);\r\n        _earned[msg.sender] = 0;\r\n\r\n        emit Withdraw(msg.sender);\r\n    }\r\n\r\n    // Resets staking price. Can only be usable if no new staker has entered the pool in 1 month (2592000 seconds)\r\n    function stakeReset() public  onlyOwner {\r\n        require(block.timestamp.sub(_lastStakerTime) \u003e= 2592000, \"not enough time has passed\");\r\n        _stakeFee = _initialFee;\r\n    }\r\n}"},"erc20.sol":{"content":"//\"SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\nabstract contract ERC20Interface {\r\n    function totalSupply() public virtual view returns (uint);\r\n    function balanceOf(address tokenOwner) public virtual view returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public virtual view returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public virtual returns (bool success);\r\n    function approve(address spender, uint256 tokens) public virtual returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public virtual returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}"},"XYSPurchase.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.6.0;\r\n\r\nimport \"./Distribute.sol\";\r\nimport \"./erc20.sol\";\r\n\r\ncontract XYSPurchasePortal{\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    Distribute dst = Distribute(0x88277055dF2EE38dA159863dA2F56ee0A6909D62);\r\n    \r\n    struct Asset{\r\n        bool isAccepted;\r\n        uint256 rate;\r\n        string name;\r\n        string symbol;\r\n        uint256 decimal;\r\n    }\r\n    mapping(address =\u003e Asset) paymentAssets;\r\n    \r\n    address constant private ETH_ADDRESS = address(\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\n    );\r\n    \r\n    address constant private DAI_ADDRESS = address(\r\n        0x6B175474E89094C44Da98b954EedeAC495271d0F\r\n    );\r\n    \r\n    address payable constant private FUNDS_RECEIVING_WALLET = 0x794Ce138d9dECf241d0b197deCcCb02f37291DD2;\r\n    \r\n    uint256 public rateIncrementCount = 0;\r\n    uint256 public soldTokens = 0;\r\n    \r\n    event TOKENSPURCHASED(address _purchaser, uint256 _tokens);\r\n    event PAYMENTRECEIVED(address _purchaser, uint256 _amount, address _assetAddress);\r\n    \r\n    constructor() public {\r\n        paymentAssets[DAI_ADDRESS].isAccepted = true;\r\n        paymentAssets[DAI_ADDRESS].rate = 50; // per DAI part\r\n        paymentAssets[DAI_ADDRESS].name = \"DAI Stable coin\";\r\n        paymentAssets[DAI_ADDRESS].symbol = \"DAI\"; // per DAI part\r\n        paymentAssets[DAI_ADDRESS].decimal = 18; // decimals\r\n        \r\n        paymentAssets[ETH_ADDRESS].isAccepted = true;\r\n        paymentAssets[ETH_ADDRESS].rate = 11905;\r\n        paymentAssets[ETH_ADDRESS].name = \"Ethers\";\r\n        paymentAssets[ETH_ADDRESS].symbol = \"ETH\";\r\n        paymentAssets[ETH_ADDRESS].decimal = 18; // decimals\r\n    }\r\n    \r\n    function purchase(address assetAddress, uint256 amountAsset) public payable{\r\n        require(paymentAssets[assetAddress].isAccepted, \"NOT ACCEPTED: Unaccepted payment asset provided\");\r\n        require(dst.balanceOf(address(this)) \u003e= getTokenAmount(assetAddress, amountAsset), \"XYS Balance: Insufficient liquidity\");\r\n        _purchase(assetAddress, amountAsset);\r\n    }\r\n    \r\n    // receive ethers\r\n    fallback() external payable{\r\n        require(dst.balanceOf(address(this)) \u003e= getTokenAmount(ETH_ADDRESS, msg.value), \"XYS Balance: Insufficient liquidity\");\r\n        _purchase(ETH_ADDRESS, msg.value);\r\n    }\r\n    \r\n    // receive ethers\r\n    receive() external payable{\r\n        require(dst.balanceOf(address(this)) \u003e= getTokenAmount(ETH_ADDRESS, msg.value), \"XYS Balance: Insufficient liquidity\");\r\n        _purchase(ETH_ADDRESS, msg.value);\r\n    }\r\n    \r\n    function _purchase(address assetAddress, uint256 assetAmount) internal{\r\n        if(assetAddress ==  ETH_ADDRESS){\r\n            // send received ethers to the receiving wallet\r\n            FUNDS_RECEIVING_WALLET.transfer(assetAmount);\r\n            require(assetAmount \u003e= 0.5 ether, \"ETHERS: minimum purchase allowed is 0.5 ethers\");\r\n        }\r\n        else{\r\n            require(assetAmount \u003e= 120 * 10 ** (paymentAssets[assetAddress].decimal), \"DAI: minimum purchase allowed is 120 DAI\");\r\n            // send received tokens to the receiving wallet\r\n            ERC20Interface(assetAddress).transferFrom(msg.sender, FUNDS_RECEIVING_WALLET, assetAmount);\r\n        }\r\n        // send tokens to the purchaser\r\n        uint256 tokens = getTokenAmount(assetAddress, assetAmount);\r\n        dst.transfer(msg.sender, tokens);\r\n        \r\n        soldTokens += tokens;\r\n        \r\n        // update asset rate, if needed\r\n        if(soldTokens/1000000000000 \u003e 0)\r\n            rateIncrementCount = soldTokens /1000000000000 ;\r\n        \r\n        emit TOKENSPURCHASED(msg.sender, tokens);\r\n        emit PAYMENTRECEIVED(msg.sender, assetAmount, assetAddress);\r\n    }\r\n    \r\n    function getTokenAmount(address assetAddress, uint256 assetAmount) public view returns(uint256){\r\n        uint256 tokens = (paymentAssets[assetAddress].rate * assetAmount / 10 ** (paymentAssets[assetAddress].decimal - dst.decimals()));\r\n        return  tokens - onePercent(tokens) * (5 * rateIncrementCount); \r\n    }\r\n    \r\n    function onePercent(uint256 _amount) internal pure returns (uint256){\r\n        uint roundValue = _amount.ceil(100);\r\n        uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2));\r\n        return onePercentofTokens;\r\n    }\r\n}"}}