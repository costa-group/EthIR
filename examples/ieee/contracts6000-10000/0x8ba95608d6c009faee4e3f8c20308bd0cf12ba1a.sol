{"Compounder.sol":{"content":"pragma solidity \u003e=0.6.2;\n\nimport \"./IERC20.sol\";\nimport \"./ICERC20.sol\";\nimport \"./IUniswapV2Router02.sol\";\n\ncontract Compounder {\n  IUniswapV2Router02 constant router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n\n  /**\n   * @dev Swaps a token on uniswap, then mints\n   * cTokens for the purchased token.\n   * Note: Caller must already have approved Compounder\n   * to transfer at least sellAmount of sellToken\n   * @param sellToken Base token to sell\n   * @param buyToken Base token to swap sellToken for\n   * @param buyCToken cToken for buyToken\n   * @param sellAmount Number of sellToken to sell\n   * @param minBuyToken Minimum number of buyToken to receive\n   */\n  function swapTokenForCToken(\n    IERC20 sellToken,\n    IERC20 buyToken,\n    ICERC20 buyCToken,\n    uint256 sellAmount,\n    uint256 minBuyToken\n  ) public {\n    require(\n      sellToken.transferFrom(msg.sender, address(this), sellAmount),\n      \"Transfer failed\"\n    );\n    require(\n      sellToken.approve(address(router), sellAmount),\n      \"Failed to approve router.\"\n    );\n    address[] memory path = new address[](2);\n    path[0] = address(sellToken);\n    path[1] = address(buyToken);\n\n    uint[] memory amounts = router.swapExactTokensForTokens(\n      sellAmount,\n      minBuyToken,\n      path,\n      address(this),\n      block.timestamp + 1\n    );\n\n    uint256 minted = buyCToken.mint(amounts[1]);\n\n    require(\n      buyCToken.transfer(msg.sender, minted),\n      \"Failed to transfer token.\"\n    );\n  }\n\n  /**\n   * @dev Redeems a cToken for its base token, then swaps it\n   * on UniSwap for the desired output token and transfers it\n   * to the caller.\n   * Note: Caller must already have approved Compounder\n   * to transfer at least redeemAmount of sellCToken\n   * @param sellToken Base token for the cToken to sell\n   * @param sellCToken cToken for sellToken\n   * @param buyToken Desired output token\n   * @param redeemAmount Number of cTokens to redeem\n   * @param minBuyToken Minimum number of output tokens\n   */\n  function swapCTokenForToken(\n    IERC20 sellToken,\n    ICERC20 sellCToken,\n    IERC20 buyToken,\n    uint256 redeemAmount,\n    uint256 minBuyToken\n  ) public {\n    require(\n      sellCToken.transferFrom(msg.sender, address(this), redeemAmount),\n      \"Transfer failed\"\n    );\n    uint256 redeemed = sellCToken.redeem(redeemAmount);\n    address[] memory path = new address[](2);\n    path[0] = address(sellToken);\n    path[1] = address(buyToken);\n    require(\n      sellToken.approve(address(router), redeemed),\n      \"Failed to approve router.\"\n    );\n    uint[] memory amounts = router.swapExactTokensForTokens(\n      redeemed,\n      minBuyToken,\n      path,\n      address(this),\n      block.timestamp + 1\n    );\n    require(\n      buyToken.transfer(msg.sender, amounts[1]),\n      \"Failed to transfer token.\"\n    );\n  }\n\n  /**\n   * @dev Redeems a cToken for its base token, swaps it\n   * on UniSwap for the desired output token, mints cTokens\n   * for the output and returns them to the caller.\n   * Note: Caller must already have approved Compounder\n   * to transfer at least redeemAmount of sellCToken\n   * @param sellToken Base token for the cToken to sell\n   * @param sellCToken cToken for sellToken\n   * @param buyToken Base token for the cToken to buy\n   * @param buyCToken cToken for buyToken\n   * @param redeemAmount Number of cTokens to redeem\n   * @param minBuyToken Minimum number of buyTokens for the swap\n   */\n  function swapCTokenForCToken(\n    IERC20 sellToken,\n    ICERC20 sellCToken,\n    IERC20 buyToken,\n    ICERC20 buyCToken,\n    uint256 redeemAmount,\n    uint256 minBuyToken\n  ) public {\n    require(\n      sellCToken.transferFrom(msg.sender, address(this), redeemAmount),\n      \"Transfer failed\"\n    );\n    uint256 redeemed = sellCToken.redeem(redeemAmount);\n    address[] memory path = new address[](2);\n    path[0] = address(sellToken);\n    path[1] = address(buyToken);\n    require(\n      sellToken.approve(address(router), redeemed),\n      \"Failed to approve router.\"\n    );\n    uint[] memory amounts = router.swapExactTokensForTokens(\n      redeemed,\n      minBuyToken,\n      path,\n      address(this),\n      block.timestamp + 1\n    );\n    require(\n      sellToken.approve(address(buyCToken), amounts[1]),\n      \"Failed to approve compound.\"\n    );\n    uint256 minted = buyCToken.mint(amounts[1]);\n    require(\n      buyCToken.transfer(msg.sender, minted),\n      \"Failed to transfer cToken.\"\n    );\n  }\n}"},"ICERC20.sol":{"content":"pragma solidity \u003e=0.6.2;\n\nabstract contract ICERC20 {\n  function approve(address spender, uint256 value) public virtual returns (bool);\n  function balanceOf(address account) public virtual view returns (uint256);\n  function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool);\n  function transfer(address _to, uint256 _value) public virtual returns (bool);\n  function mint(uint256) external virtual returns (uint256);\n  function redeem(uint256 redeemTokens) external virtual returns (uint256);\n  function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n  function exchangeRateCurrent() external virtual view returns (uint256);\n  function borrowBalanceCurrent(address account) external virtual view returns (uint256);\n}"},"IERC20.sol":{"content":"pragma solidity \u003e=0.6.2;\n\nabstract contract IERC20 {\n  function approve(address spender, uint256 value) public virtual returns (bool);\n  function balanceOf(address account) public virtual view returns (uint256);\n  function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool);\n  function transfer(address _to, uint256 _value) public virtual returns (bool);\n}"},"IUniswapV2Router01.sol":{"content":"pragma solidity \u003e=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"IUniswapV2Router02.sol":{"content":"pragma solidity \u003e=0.6.2;\n\nimport \u0027./IUniswapV2Router01.sol\u0027;\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}"}}