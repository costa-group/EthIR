{{
  "language": "Solidity",
  "sources": {
    "contracts/aave/AaveBasicProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/GasBurner.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\n\nimport \"../utils/SafeERC20.sol\";\n\n/// @title Basic compound interactions through the DSProxy\ncontract AaveBasicProxy is GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant AAVE_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    /// @notice User deposits tokens to the Aave protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    function deposit(address _tokenAddr, uint256 _amount) public burnGas(5) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint ethValue = _amount;\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n            ethValue = 0;\n        }\n\n        ILendingPool(lendingPool).deposit{value: ethValue}(_tokenAddr, _amount, AAVE_REFERRAL_CODE);\n\n        setUserUseReserveAsCollateral(_tokenAddr);\n    }\n\n    /// @notice User withdraws tokens from the Aave protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _aTokenAddr ATokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _wholeAmount If true we will take the whole amount on chain\n    function withdraw(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeAmount) public burnGas(8) {\n        uint256 amount = _wholeAmount ? ERC20(_aTokenAddr).balanceOf(address(this)) : _amount;\n\n        IAToken(_aTokenAddr).redeem(amount);\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @notice User borrows tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _type Send 1 for variable rate and 2 for fixed rate\n    function borrow(address _tokenAddr, uint256 _amount, uint256 _type) public burnGas(8) {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        ILendingPool(lendingPool).borrow(_tokenAddr, _amount, _type, AAVE_REFERRAL_CODE);\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _aTokenAddr ATokens to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function payback(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt) public burnGas(3) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint256 amount = _amount;\n\n        if (_wholeDebt) {\n            (,amount,,,,,,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n        }\n\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, payable(address(this)));\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Aave protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _aTokenAddr ATokens to be paybacked\n    /// @param _amount Amount of tokens to be payed back\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function paybackOnBehalf(address _tokenAddr, address _aTokenAddr, uint256 _amount, bool _wholeDebt, address payable _onBehalf) public burnGas(3) payable {\n        address lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        uint256 amount = _amount;\n\n        if (_wholeDebt) {\n            (,amount,,,,,,,,) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, _onBehalf);\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), amount);\n            approveToken(_tokenAddr, lendingPoolCore);\n        }\n\n        ILendingPool(lendingPool).repay{value: msg.value}(_tokenAddr, amount, _onBehalf);\n\n        withdrawTokens(_tokenAddr);\n    }\n\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    function withdrawTokens(address _tokenAddr) public {\n        uint256 amount = _tokenAddr == ETH_ADDR ? address(this).balance : ERC20(_tokenAddr).balanceOf(address(this));\n\n        if (amount > 0) {\n            if (_tokenAddr != ETH_ADDR) {\n                ERC20(_tokenAddr).safeTransfer(msg.sender, amount);\n            } else {\n                msg.sender.transfer(amount);\n            }\n        }\n    }\n\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _caller Address which will gain the approval\n    function approveToken(address _tokenAddr, address _caller) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\n        }\n    }\n\n    function setUserUseReserveAsCollateral(address _tokenAddr) public {\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        (,,,,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_tokenAddr, address(this));\n\n        if (!collateralEnabled) {\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_tokenAddr, true);\n        }\n    }\n}\n"
    },
    "contracts/utils/GasBurner.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../interfaces/GasTokenInterface.sol\";\n\ncontract GasBurner {\n    // solhint-disable-next-line const-name-snakecase\n    GasTokenInterface public constant gasToken = GasTokenInterface(0x0000000000b3F879cb30FE243b4Dfee438691c04);\n\n    modifier burnGas(uint _amount) {\n        uint gst2Amount = _amount;\n\n        if (_amount == 0) {\n            gst2Amount = (gasleft() + 14154) / (2 * 24000 - 6870);\n            gst2Amount = gst2Amount - (gst2Amount / 3); // 33.3% less because of gaslimit != gas_used\n        }\n\n        if (gasToken.balanceOf(address(this)) >= gst2Amount) {\n            gasToken.free(gst2Amount);\n        }\n\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/GasTokenInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract GasTokenInterface is ERC20 {\n    function free(uint256 value) public virtual returns (bool success);\n\n    function freeUpTo(uint256 value) public virtual returns (uint256 freed);\n\n    function freeFrom(address from, uint256 value) public virtual returns (bool success);\n\n    function freeFromUpTo(address from, uint256 value) public virtual returns (uint256 freed);\n}\n"
    },
    "contracts/interfaces/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface ERC20 {\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        external\n        returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    function decimals() external view returns (uint256 digits);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n"
    },
    "contracts/interfaces/IAToken.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract IAToken {\n    function redeem(uint256 _amount) external virtual;\n}\n"
    },
    "contracts/interfaces/ILendingPool.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract ILendingPool {\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\n\t\n    function getReserves() external virtual view returns(address[] memory);\n\n    /// @param _reserve underlying token address\n    function getReserveData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidity,               // reserve total liquidity\n            uint256 availableLiquidity,           // reserve available liquidity for borrowing\n            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\n            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\n            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\n            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\n            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\n            uint256 averageStableBorrowRate,      // current average stable borrow rate\n            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\n            uint256 liquidityIndex,               // cumulative liquidity index\n            uint256 variableBorrowIndex,          // cumulative variable borrow index\n            address aTokenAddress,                // aTokens contract address for the specific _reserve\n            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\n        );\n\n    /// @param _user users address\n    function getUserAccountData(address _user)\n        external virtual\n        view\n        returns (\n            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\n            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\n            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\n            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\n            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\n            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\n            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\n            uint256 healthFactor                  // user current Health Factor\n    );    \n\n    /// @param _reserve underlying token address\n    /// @param _user users address\n    function getUserReserveData(address _reserve, address _user)\n        external virtual\n        view\n        returns (\n            uint256 currentATokenBalance,         // user current reserve aToken balance\n            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\n            uint256 principalBorrowBalance,       // user balance of borrowed asset\n            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\n            uint256 borrowRate,                   // user current borrow rate APY\n            uint256 liquidityRate,                // user current earn rate on _reserve\n            uint256 originationFee,               // user outstanding loan origination fee\n            uint256 variableBorrowIndex,          // user variable cumulative index\n            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\n            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\n    );\n\n    function getReserveConfigurationData(address _reserve)\n        external virtual\n        view\n        returns (\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            address rateStrategyAddress,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive\n    );\n\n    // ------------------ LendingPoolCoreData ------------------------\n    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\n    function getReserveConfiguration(address _reserve)\n        external virtual\n        view\n        returns (uint256, uint256, uint256, bool);\n    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n        public virtual\n        view\n        returns (uint256);\n\n    function getReserveCurrentLiquidityRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveCurrentVariableBorrowRate(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalLiquidity(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveAvailableLiquidity(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n    function getReserveTotalBorrowsVariable(address _reserve)\n        public virtual\n        view\n        returns (uint256);\n\n    // ---------------- LendingPoolDataProvider ---------------------\n    function calculateUserGlobalData(address _user)\n        public virtual\n        view\n        returns (\n            uint256 totalLiquidityBalanceETH,\n            uint256 totalCollateralBalanceETH,\n            uint256 totalBorrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 currentLtv,\n            uint256 currentLiquidationThreshold,\n            uint256 healthFactor,\n            bool healthFactorBelowThreshold\n        );\n}\n"
    },
    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n@title ILendingPoolAddressesProvider interface\n@notice provides the interface to fetch the LendingPoolCore address\n */\nabstract contract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public virtual view returns (address);\n    function getLendingPoolCore() public virtual view returns (address payable);\n    function getLendingPoolConfigurator() public virtual view returns (address);\n    function getLendingPoolDataProvider() public virtual view returns (address);\n    function getLendingPoolParametersProvider() public virtual view returns (address);\n    function getTokenDistributor() public virtual view returns (address);\n    function getFeeProvider() public virtual view returns (address);\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\n    function getLendingPoolManager() public virtual view returns (address);\n    function getPriceOracle() public virtual view returns (address);\n    function getLendingRateOracle() public virtual view returns (address);\n}"
    },
    "contracts/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../interfaces/ERC20.sol\";\nimport \"./Address.sol\";\nimport \"./SafeMath.sol\";\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     */\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.0;\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/utils/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/aave/AaveHelper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../DS/DSProxy.sol\";\nimport \"../mcd/Discount.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/ILendingPoolAddressesProvider.sol\";\nimport \"../interfaces/IPriceOracleGetterAave.sol\";\n\nimport \"../utils/SafeERC20.sol\";\n\ncontract AaveHelper is DSMath {\n\n    using SafeERC20 for ERC20;\n\n    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n\n\taddress public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant AAVE_LENDING_POOL_ADDRESSES = 0x24a42fD28C976A61Df5D00D0599C34c4f90748c8;\n    uint public constant NINETY_NINE_PERCENT_WEI = 999900000000000000;\n    uint16 public constant AAVE_REFERRAL_CODE = 64;\n\n    /// @param _collateralAddress underlying token address\n    /// @param _user users address\n\tfunction getMaxCollateral(address _collateralAddress, address _user) public view returns (uint256) {\n        address lendingPoolAddressDataProvider = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolDataProvider();\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        // fetch all needed data\n        // using LTV as tokenLiquidationThreshold\n        (,uint256 totalCollateralETH, uint256 totalBorrowsETH,,uint256 currentLiquidationThreshold,,,) = ILendingPool(lendingPoolAddressDataProvider).calculateUserGlobalData(_user);\n        (,uint256 tokenLiquidationThreshold,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_collateralAddress);\n        uint256 collateralPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_collateralAddress);\n        uint256 userTokenBalance = ILendingPool(lendingPoolCoreAddress).getUserUnderlyingAssetBalance(_collateralAddress, _user);\n        uint256 userTokenBalanceEth = wmul(userTokenBalance, collateralPrice);\n\n\t\t// if borrow is 0, return whole user balance\n        if (totalBorrowsETH == 0) {\n        \treturn userTokenBalance;\n        }\n\n        uint256 maxCollateralEth = div(sub(mul(currentLiquidationThreshold, totalCollateralETH), mul(totalBorrowsETH, 100)), currentLiquidationThreshold);\n\t\t/// @dev final amount can't be higher than users token balance\n        maxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\n\n        // might happen due to wmul precision\n        if (maxCollateralEth >= totalCollateralETH) {\n        \treturn totalCollateralETH;\n        }\n\n        // get sum of all other reserves multiplied with their liquidation thresholds by reversing formula\n        uint256 a = sub(wmul(currentLiquidationThreshold, totalCollateralETH), wmul(tokenLiquidationThreshold, userTokenBalanceEth));\n        // add new collateral amount multiplied by its threshold, and then divide with new total collateral\n        uint256 newLiquidationThreshold = wdiv(add(a, wmul(sub(userTokenBalanceEth, maxCollateralEth), tokenLiquidationThreshold)), sub(totalCollateralETH, maxCollateralEth));\n\n        // if new threshold is lower than first one, calculate new max collateral with newLiquidationThreshold\n        if (newLiquidationThreshold < currentLiquidationThreshold) {\n        \tmaxCollateralEth = div(sub(mul(newLiquidationThreshold, totalCollateralETH), mul(totalBorrowsETH, 100)), newLiquidationThreshold);\n        \tmaxCollateralEth = maxCollateralEth > userTokenBalanceEth ? userTokenBalanceEth : maxCollateralEth;\n        }\n\n\n\t\treturn wmul(wdiv(maxCollateralEth, collateralPrice), NINETY_NINE_PERCENT_WEI);\n\t}\n\n\t/// @param _borrowAddress underlying token address\n\t/// @param _user users address\n\tfunction getMaxBorrow(address _borrowAddress, address _user) public view returns (uint256) {\n\t\taddress lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\t\taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n\t\t(,,,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\n\n\t\tuint256 borrowPrice = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_borrowAddress);\n\n\t\treturn wmul(wdiv(availableBorrowsETH, borrowPrice), NINETY_NINE_PERCENT_WEI);\n\t}\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _tokenAddr token addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _tokenAddr) internal returns (uint feeAmount) {\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n        uint fee = SERVICE_FEE;\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddr);\n            _gasCost = wmul(_gasCost, price);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (_tokenAddr == ETH_ADDR) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(payable(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Approves token contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _caller Address which will gain the approval\n    function approveToken(address _tokenAddr, address _caller) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_caller, uint256(-1));\n        }\n    }\n\n    /// @notice Send specific amount from contract to specific user\n    /// @param _token Token we are trying to send\n    /// @param _user User that should receive funds\n    /// @param _amount Amount that should be sent\n    function sendContractBalance(address _token, address _user, uint _amount) public {\n        if (_token == ETH_ADDR) {\n            payable(_user).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(_user, _amount);\n        }\n    }\n\n    function sendFullContractBalance(address _token, address _user) public {\n        if (_token == ETH_ADDR) {\n            sendContractBalance(_token, _user, address(this).balance);\n        } else {\n            sendContractBalance(_token, _user, ERC20(_token).balanceOf(address(this)));\n        }\n    }\n}\n"
    },
    "contracts/DS/DSMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/DS/DSProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./DSAuth.sol\";\nimport \"./DSNote.sol\";\n\n\nabstract contract DSProxy is DSAuth, DSNote {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) public {\n        require(setCache(_cacheAddr));\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    // function execute(bytes memory _code, bytes memory _data)\n    //     public\n    //     payable\n    //     virtual\n    //     returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n}\n\n\ncontract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view returns (address) {\n        bytes32 hash = keccak256(_code);\n        return cache[hash];\n    }\n\n    function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }\n}\n"
    },
    "contracts/DS/DSAuth.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./DSAuthority.sol\";\n\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public auth {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_) public auth {\n        authority = authority_;\n        emit LogSetAuthority(address(authority));\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, address(this), sig);\n        }\n    }\n}\n"
    },
    "contracts/DS/DSAuthority.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract DSAuthority {\n    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n}\n"
    },
    "contracts/DS/DSNote.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract DSNote {\n    event LogNote(\n        bytes4 indexed sig,\n        address indexed guy,\n        bytes32 indexed foo,\n        bytes32 indexed bar,\n        uint256 wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n"
    },
    "contracts/mcd/Discount.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract Discount {\n    address public owner;\n    mapping(address => CustomServiceFee) public serviceFees;\n\n    uint256 constant MAX_SERVICE_FEE = 400;\n\n    struct CustomServiceFee {\n        bool active;\n        uint256 amount;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function isCustomFeeSet(address _user) public view returns (bool) {\n        return serviceFees[_user].active;\n    }\n\n    function getCustomServiceFee(address _user) public view returns (uint256) {\n        return serviceFees[_user].amount;\n    }\n\n    function setServiceFee(address _user, uint256 _fee) public {\n        require(msg.sender == owner, \"Only owner\");\n        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n\n        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n    }\n\n    function disableServiceFee(address _user) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n    }\n}\n"
    },
    "contracts/interfaces/IPriceOracleGetterAave.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/************\n@title IPriceOracleGetterAave interface\n@notice Interface for the Aave price oracle.*/\nabstract contract IPriceOracleGetterAave {\n    function getAssetPrice(address _asset) external virtual view returns (uint256);\n    function getAssetsPrices(address[] calldata _assets) external virtual view returns(uint256[] memory);\n    function getSourceOfAsset(address _asset) external virtual view returns(address);\n    function getFallbackOracle() external virtual view returns(address);\n}"
    },
    "contracts/aave/AaveLoanInfo.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AaveSafetyRatio.sol\";\n\ncontract AaveLoanInfo is AaveSafetyRatio {\n\n\tstruct LoanData {\n        address user;\n        uint128 ratio;\n        address[] collAddr;\n        address[] borrowAddr;\n        uint256[] collAmounts;\n        uint256[] borrowAmounts;\n    }\n\n    struct TokenInfo {\n        address aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 collateralFactor;\n        uint256 price;\n    }\n\n    struct TokenInfoFull {\n    \taddress aTokenAddress;\n        address underlyingTokenAddress;\n        uint256 supplyRate;\n        uint256 borrowRate;\n        uint256 totalSupply;\n        uint256 availableLiquidity;\n        uint256 totalBorrow;\n        uint256 collateralFactor;\n        uint256 price;\n        bool usageAsCollateralEnabled;\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _user Address of the user\n    function getRatio(address _user) public view returns (uint256) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }\n\n    /// @notice Fetches Aave prices for tokens\n    /// @param _tokens Arr. of tokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address[] memory _tokens) public view returns (uint256[] memory prices) {\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n        prices = new uint[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            prices[i] = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokens[i]);\n        }\n    }\n\n    /// @notice Fetches Aave collateral factors for tokens\n    /// @param _tokens Arr. of tokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address[] memory _tokens) public view returns (uint256[] memory collFactors) {\n    \taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        collFactors = new uint256[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n        \t(,collFactors[i],,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokens[i]);\n        }\n    }\n\n    function getTokenBalances(address _user, address[] memory _tokens) public view returns (uint256[] memory balances, uint256[] memory borrows, bool[] memory enabledAsCollateral) {\n    \taddress lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\n        balances = new uint256[](_tokens.length);\n        borrows = new uint256[](_tokens.length);\n        enabledAsCollateral = new bool[](_tokens.length);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address asset = _tokens[i];\n\n            (balances[i], borrows[i],,,,,,,,enabledAsCollateral[i]) = ILendingPool(lendingPoolAddress).getUserReserveData(asset, _user);\n        }\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for an aave user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address[] memory _users) public view returns (uint256[] memory ratios) {\n        ratios = new uint256[](_users.length);\n\n        for (uint256 i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }\n\n    /// @notice Information about reserves\n    /// @param _tokenAddresses Array of tokens addresses\n    /// @return tokens Array of reserves infomartion\n    function getTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfo[] memory tokens) {\n    \taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n    \taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        tokens = new TokenInfo[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n        \t(,uint256 ltv,,) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                aTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\n                underlyingTokenAddress: _tokenAddresses[i],\n                collateralFactor: ltv,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Information about reserves\n    /// @param _tokenAddresses Array of token addresses\n    /// @return tokens Array of reserves infomartion\n    function getFullTokensInfo(address[] memory _tokenAddresses) public view returns(TokenInfoFull[] memory tokens) {\n    \taddress lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n    \taddress priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        tokens = new TokenInfoFull[](_tokenAddresses.length);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; ++i) {\n        \t(,uint256 ltv,,bool usageAsCollateralEnabled) = ILendingPool(lendingPoolCoreAddress).getReserveConfiguration(_tokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n            \taTokenAddress: ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(_tokenAddresses[i]),\n                underlyingTokenAddress: _tokenAddresses[i],\n                supplyRate: ILendingPool(lendingPoolCoreAddress).getReserveCurrentLiquidityRate(_tokenAddresses[i]),\n                borrowRate: ILendingPool(lendingPoolCoreAddress).getReserveCurrentVariableBorrowRate(_tokenAddresses[i]),\n                totalSupply: ILendingPool(lendingPoolCoreAddress).getReserveTotalLiquidity(_tokenAddresses[i]),\n                availableLiquidity: ILendingPool(lendingPoolCoreAddress).getReserveAvailableLiquidity(_tokenAddresses[i]),\n                totalBorrow: ILendingPool(lendingPoolCoreAddress).getReserveTotalBorrowsVariable(_tokenAddresses[i]),\n                collateralFactor: ltv,\n                price: IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(_tokenAddresses[i]),\n                usageAsCollateralEnabled: usageAsCollateralEnabled\n            });\n        }\n    }\n\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _user) public view returns (LoanData memory data) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        address priceOracleAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getPriceOracle();\n\n        address[] memory reserves = ILendingPool(lendingPoolAddress).getReserves();\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](reserves.length),\n            borrowAddr: new address[](reserves.length),\n            collAmounts: new uint[](reserves.length),\n            borrowAmounts: new uint[](reserves.length)\n        });\n\n        uint64 collPos = 0;\n        uint64 borrowPos = 0;\n\n        for (uint64 i = 0; i < reserves.length; i++) {\n            address reserve = reserves[i];\n\n            (uint256 aTokenBalance, uint256 borrowBalance,,,,,,,,) = ILendingPool(lendingPoolAddress).getUserReserveData(reserve, _user);\n            uint256 price = IPriceOracleGetterAave(priceOracleAddress).getAssetPrice(reserves[i]);\n\n            if (aTokenBalance > 0) {\n            \tuint256 userTokenBalanceEth = wmul(aTokenBalance, price);\n            \tdata.collAddr[collPos] = reserve;\n                data.collAmounts[collPos] = userTokenBalanceEth;\n                collPos++;\n        \t}\n\n            // Sum up debt in Eth\n            if (borrowBalance > 0) {\n            \tuint256 userBorrowBalanceEth = wmul(borrowBalance, price);\n                data.borrowAddr[borrowPos] = reserve;\n                data.borrowAmounts[borrowPos] = userBorrowBalanceEth;\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }\n}"
    },
    "contracts/aave/AaveSafetyRatio.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./AaveHelper.sol\";\n\ncontract AaveSafetyRatio is AaveHelper {\n\n    function getSafetyRatio(address _user) public view returns(uint256) {\n        address lendingPoolAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        (,,uint256 totalBorrowsETH,,uint256 availableBorrowsETH,,,) = ILendingPool(lendingPoolAddress).getUserAccountData(_user);\n\n        return wdiv(add(totalBorrowsETH, availableBorrowsETH), totalBorrowsETH);\n    }\n}"
    },
    "contracts/aave/AaveSaverProxy.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./AaveHelper.sol\";\nimport \"../exchange/SaverExchangeCore.sol\";\nimport \"../interfaces/IAToken.sol\";\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../loggers/DefisaverLogger.sol\";\nimport \"../utils/GasBurner.sol\";\n\ncontract AaveSaverProxy is GasBurner, SaverExchangeCore, AaveHelper {\n\n\taddress public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    uint public constant VARIABLE_RATE = 2;\n\n\tfunction repay(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\n\n\t\taddress lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n\t\taddress lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\t\taddress payable user = payable(getUserAddress());\n\n\t\tuint256 maxCollateral = getMaxCollateral(_data.srcAddr, address(this));\n\t\t// don't swap more than maxCollateral\n\t\t_data.srcAmount = _data.srcAmount > maxCollateral ? maxCollateral : _data.srcAmount;\n\n\t\t// redeem collateral\n\t\taddress aTokenCollateral = ILendingPool(lendingPoolCore).getReserveATokenAddress(_data.srcAddr);\n\t\tIAToken(aTokenCollateral).redeem(_data.srcAmount);\n\n\t\t// swap\n\t\t(, uint256 destAmount) = _sell(_data);\n\n\t\tdestAmount -= getFee(destAmount, user, _gasCost, _data.destAddr);\n\n\t\t// payback\n\t\tif (_data.destAddr == ETH_ADDR) {\n\t\t\tILendingPool(lendingPool).repay{value: destAmount}(_data.destAddr, destAmount, payable(address(this)));\n\t\t} else {\n\t\t\tapproveToken(_data.destAddr, lendingPoolCore);\n\t\t\tILendingPool(lendingPool).repay(_data.destAddr, destAmount, payable(address(this)));\n\t\t}\n\n\t\t// first return 0x fee to msg.sender as it is the address that actually sent 0x fee\n\t\tsendContractBalance(ETH_ADDR, msg.sender, min(address(this).balance, msg.value));\n\t\t// send all leftovers from dest addr to proxy owner\n\t\tsendFullContractBalance(_data.destAddr, user);\n\n\t\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveRepay\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n\t}\n\n\tfunction boost(ExchangeData memory _data, uint _gasCost) public payable burnGas(20) {\n\t\taddress lendingPoolCore = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n\t\taddress lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n\t\t(,,,,,,,,,bool collateralEnabled) = ILendingPool(lendingPool).getUserReserveData(_data.destAddr, address(this));\n\t\taddress payable user = payable(getUserAddress());\n\n\t\tuint256 maxBorrow = getMaxBorrow(_data.srcAddr, address(this));\n\t\t_data.srcAmount = _data.srcAmount > maxBorrow ? maxBorrow : _data.srcAmount;\n\n\t\t// borrow amount\n\t\tILendingPool(lendingPool).borrow(_data.srcAddr, _data.srcAmount, VARIABLE_RATE, AAVE_REFERRAL_CODE);\n\t\t_data.srcAmount -= getFee(_data.srcAmount, user, _gasCost, _data.srcAddr);\n\n\t\t// swap\n\t\t(, uint256 destAmount) = _sell(_data);\n\n\t\tif (_data.destAddr == ETH_ADDR) {\n\t\t\tILendingPool(lendingPool).deposit{value: destAmount}(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\n\t\t} else {\n\t\t\tapproveToken(_data.destAddr, lendingPoolCore);\n\t\t\tILendingPool(lendingPool).deposit(_data.destAddr, destAmount, AAVE_REFERRAL_CODE);\n\t\t}\n\n\t\tif (!collateralEnabled) {\n            ILendingPool(lendingPool).setUserUseReserveAsCollateral(_data.destAddr, true);\n        }\n\n\t\t// returning to msg.sender as it is the address that actually sent 0x fee\n\t\tsendContractBalance(ETH_ADDR, msg.sender, min(address(this).balance, msg.value));\n\t\t// send all leftovers from dest addr to proxy owner\n\t\tsendFullContractBalance(_data.destAddr, user);\n\n\t\tDefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveBoost\", abi.encode(_data.srcAddr, _data.destAddr, _data.srcAmount, destAmount));\n\t}\n}\n"
    },
    "contracts/exchange/SaverExchangeCore.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../utils/ZrxAllowlist.sol\";\nimport \"./SaverExchangeHelper.sol\";\nimport \"./SaverExchangeRegistry.sol\";\n\ncontract SaverExchangeCore is SaverExchangeHelper, DSMath {\n\n    // first is empty to keep the legacy order in place\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ActionType { SELL, BUY }\n\n    struct ExchangeData {\n        address srcAddr;\n        address destAddr;\n        uint srcAmount;\n        uint destAmount;\n        uint minPrice;\n        address wrapper;\n        address exchangeAddr;\n        bytes callData;\n        uint256 price0x;\n    }\n\n    /// @notice Internal method that preforms a sell on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and destAmount\n    function _sell(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n        uint tokensLeft = exData.srcAmount;\n\n        // if selling eth, convert to weth\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\n            TokenInterface(WETH_ADDRESS).deposit.value(exData.srcAmount)();\n        }\n\n        // Try 0x first and then fallback on specific wrapper\n        if (exData.price0x > 0) {\n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            (success, swapedTokens, tokensLeft) = takeOrder(exData, address(this).balance, ActionType.SELL);\n\n            if (success) {\n                wrapper = exData.exchangeAddr;\n            }\n        }\n\n        // fallback to desired wrapper if 0x failed\n        if (!success) {\n            swapedTokens = saverSwap(exData, ActionType.SELL);\n            wrapper = exData.wrapper;\n        }\n\n        require(getBalance(exData.destAddr) >= wmul(exData.minPrice, exData.srcAmount), \"Final amount isn't correct\");\n\n        // if anything is left in weth, pull it to user as eth\n        if (getBalance(WETH_ADDRESS) > 0) {\n            TokenInterface(WETH_ADDRESS).withdraw(\n                TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n            );\n        }            \n\n        return (wrapper, swapedTokens);\n    }\n\n    /// @notice Internal method that preforms a buy on 0x/on-chain\n    /// @dev Usefull for other DFS contract to integrate for exchanging\n    /// @param exData Exchange data struct\n    /// @return (address, uint) Address of the wrapper used and srcAmount\n    function _buy(ExchangeData memory exData) internal returns (address, uint) {\n\n        address wrapper;\n        uint swapedTokens;\n        bool success;\n\n        require(exData.destAmount != 0, \"Dest amount must be specified\");\n\n        // if selling eth, convert to weth\n        if (exData.srcAddr == KYBER_ETH_ADDRESS) {\n            exData.srcAddr = ethToWethAddr(exData.srcAddr);\n            TokenInterface(WETH_ADDRESS).deposit.value(exData.srcAmount)();\n        }\n\n        if (exData.price0x > 0) { \n            approve0xProxy(exData.srcAddr, exData.srcAmount);\n\n            (success, swapedTokens,) = takeOrder(exData, address(this).balance, ActionType.BUY);\n\n            if (success) {\n                wrapper = exData.exchangeAddr;\n            }\n        }\n\n        // fallback to desired wrapper if 0x failed\n        if (!success) {\n            swapedTokens = saverSwap(exData, ActionType.BUY);\n            wrapper = exData.wrapper;\n        }\n\n        require(getBalance(exData.destAddr) >= exData.destAmount, \"Final amount isn't correct\");\n\n        // if anything is left in weth, pull it to user as eth\n        if (getBalance(WETH_ADDRESS) > 0) {\n            TokenInterface(WETH_ADDRESS).withdraw(\n                TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n            );\n        }\n\n        return (wrapper, getBalance(exData.destAddr));\n    }\n\n    /// @notice Takes order from 0x and returns bool indicating if it is successful\n    /// @param _exData Exchange data\n    /// @param _ethAmount Ether fee needed for 0x order\n    function takeOrder(\n        ExchangeData memory _exData,\n        uint256 _ethAmount,\n        ActionType _type\n    ) private returns (bool success, uint256, uint256) {\n\n        // write in the exact amount we are selling/buing in an order\n        if (_type == ActionType.SELL) {\n            writeUint256(_exData.callData, 36, _exData.srcAmount);\n        } else {\n            writeUint256(_exData.callData, 36, _exData.destAmount);\n        }\n\n        if (ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_exData.exchangeAddr)) {\n            (success, ) = _exData.exchangeAddr.call{value: _ethAmount}(_exData.callData);\n        } else {\n            success = false;\n        }\n\n        uint256 tokensSwaped = 0;\n        uint256 tokensLeft = _exData.srcAmount;\n\n        if (success) {\n            // check to see if any _src tokens are left over after exchange\n            tokensLeft = getBalance(_exData.srcAddr);\n\n            // convert weth -> eth if needed\n            if (_exData.destAddr == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(\n                    TokenInterface(WETH_ADDRESS).balanceOf(address(this))\n                );\n            }\n\n            // get the current balance of the swaped tokens\n            tokensSwaped = getBalance(_exData.destAddr);\n        }\n\n        return (success, tokensSwaped, tokensLeft);\n    }\n\n    /// @notice Calls wraper contract for exchage to preform an on-chain swap\n    /// @param _exData Exchange data struct\n    /// @param _type Type of action SELL|BUY\n    /// @return swapedTokens For Sell that the destAmount, for Buy thats the srcAmount\n    function saverSwap(ExchangeData memory _exData, ActionType _type) internal returns (uint swapedTokens) {\n        require(SaverExchangeRegistry(SAVER_EXCHANGE_REGISTRY).isWrapper(_exData.wrapper), \"Wrapper is not valid\");\n\n        uint ethValue = 0;\n\n        ERC20(_exData.srcAddr).safeTransfer(_exData.wrapper, _exData.srcAmount);\n        \n        if (_type == ActionType.SELL) {\n            swapedTokens = ExchangeInterfaceV2(_exData.wrapper).\n                    sell{value: ethValue}(_exData.srcAddr, _exData.destAddr, _exData.srcAmount);\n        } else {\n            swapedTokens = ExchangeInterfaceV2(_exData.wrapper).\n                    buy{value: ethValue}(_exData.srcAddr, _exData.destAddr, _exData.destAmount);\n        }\n    }\n\n    function writeUint256(bytes memory _b, uint256 _index, uint _input) internal pure {\n        if (_b.length < _index + 32) {\n            revert(\"Incorrent lengt while writting bytes32\");\n        }\n\n        bytes32 input = bytes32(_input);\n\n        _index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            mstore(add(_b, _index), input)\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external virtual payable {}\n}\n"
    },
    "contracts/interfaces/TokenInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract TokenInterface {\n    function allowance(address, address) public virtual returns (uint256);\n\n    function balanceOf(address) public virtual returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(address, address, uint256) public virtual returns (bool);\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n"
    },
    "contracts/interfaces/ExchangeInterfaceV2.sol": {
      "content": "pragma solidity ^0.6.0;\n\ninterface ExchangeInterfaceV2 {\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable returns (uint);\n\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external payable returns(uint);\n\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n\n    function getBuyRate(address _srcAddr, address _destAddr, uint _srcAmount) external view returns (uint);\n}\n"
    },
    "contracts/utils/ZrxAllowlist.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract ZrxAllowlist is AdminAuth {\n\n    mapping (address => bool) public zrxAllowlist;\n\n    function setAllowlistAddr(address _zrxAddr, bool _state) public onlyOwner {\n        zrxAllowlist[_zrxAddr] = _state;\n    }\n\n    function isZrxAddr(address _zrxAddr) public view returns (bool) {\n        return zrxAllowlist[_zrxAddr];\n    }\n}\n"
    },
    "contracts/auth/AdminAuth.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/SafeERC20.sol\";\n\ncontract AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public owner;\n    address public admin;\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /// @notice Admin is set by owner first time, after that admin is super role and has permission to change owner\n    /// @param _admin Address of multisig that becomes admin\n    function setAdminByOwner(address _admin) public {\n        require(msg.sender == owner);\n        require(admin == address(0));\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to set new admin\n    /// @param _admin Address of multisig that becomes new admin\n    function setAdminByAdmin(address _admin) public {\n        require(msg.sender == admin);\n\n        admin = _admin;\n    }\n\n    /// @notice Admin is able to change owner\n    /// @param _owner Address of new owner\n    function setOwnerByAdmin(address _owner) public {\n        require(msg.sender == admin);\n\n        owner = _owner;\n    }\n\n    /// @notice Destroy the contract\n    function kill() public onlyOwner {\n        selfdestruct(payable(owner));\n    }\n\n    /// @notice  withdraw stuck funds\n    function withdrawStuckFunds(address _token, uint _amount) public onlyOwner {\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            payable(owner).transfer(_amount);\n        } else {\n            ERC20(_token).safeTransfer(owner, _amount);\n        }\n    }\n}\n"
    },
    "contracts/exchange/SaverExchangeHelper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/SafeERC20.sol\";\nimport \"../mcd/Discount.sol\";\n\ncontract SaverExchangeHelper {\n\n    using SafeERC20 for ERC20;\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n    address public constant SAVER_EXCHANGE_REGISTRY = 0x25dd3F51e0C3c3Ff164DDC02A8E4D65Bb9cBB12D;\n\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n    address public constant ZRX_ALLOWLIST_ADDR = 0x019739e288973F92bDD3c1d87178E206E51fd911;\n\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function getBalance(address _tokenAddr) internal view returns (uint balance) {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            balance = address(this).balance;\n        } else {\n            balance = ERC20(_tokenAddr).balanceOf(address(this));\n        }\n    }\n\n    function approve0xProxy(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != KYBER_ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(address(ERC20_PROXY_0X), _amount);\n        }\n    }\n\n    function sendLeftover(address _srcAddr, address _destAddr, address payable _to) internal {\n        // send back any leftover ether or tokens\n        if (address(this).balance > 0) {\n            _to.transfer(address(this).balance);\n        }\n\n        if (getBalance(_srcAddr) > 0) {\n            ERC20(_srcAddr).safeTransfer(_to, getBalance(_srcAddr));\n        }\n\n        if (getBalance(_destAddr) > 0) {\n            ERC20(_destAddr).safeTransfer(_to, getBalance(_destAddr));\n        }\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"
    },
    "contracts/exchange/SaverExchangeRegistry.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract SaverExchangeRegistry is AdminAuth {\n\n\tmapping(address => bool) private wrappers;\n\n\tconstructor() public {\n\t\twrappers[0x880A845A85F843a5c67DB2061623c6Fc3bB4c511] = true;\n\t\twrappers[0x4c9B55f2083629A1F7aDa257ae984E03096eCD25] = true;\n\t\twrappers[0x42A9237b872368E1bec4Ca8D26A928D7d39d338C] = true;\n\t}\n\n\tfunction addWrapper(address _wrapper) public onlyOwner {\n\t\twrappers[_wrapper] = true;\n\t}\n\n\tfunction removeWrapper(address _wrapper) public onlyOwner {\n\t\twrappers[_wrapper] = false;\n\t}\n\n\tfunction isWrapper(address _wrapper) public view returns(bool) {\n\t\treturn wrappers[_wrapper];\n\t}\n}\n"
    },
    "contracts/loggers/DefisaverLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract DefisaverLogger {\n    event LogEvent(\n        address indexed contractAddress,\n        address indexed caller,\n        string indexed logName,\n        bytes data\n    );\n\n    // solhint-disable-next-line func-name-mixedcase\n    function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }\n}\n"
    },
    "contracts/aave/migration/AaveImport.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../savings/dydx/ISoloMargin.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../AaveHelper.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n// weth->eth \n// deposit eth for users proxy\n// borrow users token from proxy\n// repay on behalf of user\n// pull user supply\n// take eth amount from supply (if needed more, borrow it?)\n// return eth to sender\n\n/// @title Import Aave position from account to wallet\ncontract AaveImport is AaveHelper, AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant BASIC_PROXY = 0x9D266997bc73B27d4302E711b55FD78B5278e1De;\n    address public constant AETH_ADDRESS = 0x3a3A65aAb0dd2A17E3F1947bA16138cd37d08c04;\n\n    function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) public {\n\n        (\n            address collateralToken,\n            address borrowToken,\n            uint256 ethAmount,\n            address user,\n            address proxy\n        )\n        = abi.decode(data, (address,address,uint256,address,address));\n\n        address payable payableProxy = payable(proxy);\n\n        // withdraw eth\n        TokenInterface(WETH_ADDRESS).withdraw(ethAmount);\n\n        address lendingPoolCoreAddress = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPoolCore();\n        address lendingPool = ILendingPoolAddressesProvider(AAVE_LENDING_POOL_ADDRESSES).getLendingPool();\n        address aCollateralToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(collateralToken);\n        address aBorrowToken = ILendingPool(lendingPoolCoreAddress).getReserveATokenAddress(borrowToken);\n\n        // deposit eth on behalf of proxy\n        DSProxy(payableProxy).execute{value: ethAmount}(BASIC_PROXY, abi.encodeWithSignature(\"deposit(address,uint256)\", ETH_ADDR, ethAmount));\n        // borrow needed amount to repay users borrow\n        (,uint256 borrowAmount,,,,,,,,) = ILendingPool(lendingPool).getUserReserveData(borrowToken, user);\n        DSProxy(payableProxy).execute(BASIC_PROXY, abi.encodeWithSignature(\"borrow(address,uint256,uint256)\", borrowToken, borrowAmount, 1));\n        // payback on behalf of user\n        ERC20(borrowToken).safeApprove(proxy, borrowAmount);\n        DSProxy(payableProxy).execute(BASIC_PROXY, abi.encodeWithSignature(\"paybackOnBehalf(address,address,uint256,bool,address)\", borrowToken, aBorrowToken, 0, true, user));\n        // pull tokens from user to proxy\n        uint256 collateralAmount = ERC20(aCollateralToken).balanceOf(user);\n        ERC20(aCollateralToken).safeTransferFrom(user, proxy, collateralAmount);\n\n        // enable as collateral\n        DSProxy(payableProxy).execute(BASIC_PROXY, abi.encodeWithSignature(\"setUserUseReserveAsCollateral(address)\", collateralToken));\n\n        // withdraw deposited eth\n        DSProxy(payableProxy).execute(BASIC_PROXY, abi.encodeWithSignature(\"withdraw(address,address,uint256,bool)\", ETH_ADDR, AETH_ADDRESS, ethAmount, false));\n\n        // deposit eth, get weth and return to sender\n        TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        ERC20(WETH_ADDRESS).safeTransfer(proxy, ethAmount+2);\n    }\n\n    /// @dev if contract receive eth, convert it to WETH\n    receive() external payable {\n        // deposit eth and get weth \n        if (msg.sender == owner) {\n            TokenInterface(WETH_ADDRESS).deposit.value(address(this).balance)();\n        }\n    }\n}"
    },
    "contracts/savings/dydx/ISoloMargin.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./lib/Actions.sol\";\nimport \"./lib/Account.sol\";\nimport \"./lib/Types.sol\";\n\nabstract contract ISoloMargin {\n    struct OperatorArg {\n        address operator;\n        bool trusted;\n    }\n\n    function operate(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions\n    ) public virtual;\n\n    function getAccountBalances(\n        Account.Info memory account\n    ) public view virtual returns (\n        address[] memory,\n        Types.Par[] memory,\n        Types.Wei[] memory\n    );\n\n    function setOperators(\n        OperatorArg[] memory args\n    ) public virtual;\n\n\n   function getNumMarkets() public view virtual returns (uint256);\n\n   function getMarketTokenAddress(uint256 marketId)\n        public\n        view\n        virtual\n        returns (address);\n}\n"
    },
    "contracts/savings/dydx/lib/Actions.sol": {
      "content": "/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport { Account } from \"./Account.sol\";\nimport { Types } from \"./Types.sol\";\n\n\n/**\n * @title Actions\n * @author dYdX\n *\n * Library that defines and parses valid Actions\n */\nlibrary Actions {\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"Actions\";\n\n    // ============ Enums ============\n\n    enum ActionType {\n        Deposit,   // supply tokens\n        Withdraw,  // borrow tokens\n        Transfer,  // transfer balance between accounts\n        Buy,       // buy an amount of some token (externally)\n        Sell,      // sell an amount of some token (externally)\n        Trade,     // trade tokens against another account\n        Liquidate, // liquidate an undercollateralized or expiring account\n        Vaporize,  // use excess tokens to zero-out a completely negative account\n        Call       // send arbitrary data to an address\n    }\n\n    enum AccountLayout {\n        OnePrimary,\n        TwoPrimary,\n        PrimaryAndSecondary\n    }\n\n    enum MarketLayout {\n        ZeroMarkets,\n        OneMarket,\n        TwoMarkets\n    }\n\n    // ============ Structs ============\n\n    /*\n     * Arguments that are passed to Solo in an ordered list as part of a single operation.\n     * Each ActionArgs has an actionType which specifies which action struct that this data will be\n     * parsed into before being processed.\n     */\n    struct ActionArgs {\n        ActionType actionType;\n        uint256 accountId;\n        Types.AssetAmount amount;\n        uint256 primaryMarketId;\n        uint256 secondaryMarketId;\n        address otherAddress;\n        uint256 otherAccountId;\n        bytes data;\n    }\n\n    // ============ Action Types ============\n\n    /*\n     * Moves tokens from an address to Solo. Can either repay a borrow or provide additional supply.\n     */\n    struct DepositArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address from;\n    }\n\n    /*\n     * Moves tokens from Solo to another address. Can either borrow tokens or reduce the amount\n     * previously supplied.\n     */\n    struct WithdrawArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 market;\n        address to;\n    }\n\n    /*\n     * Transfers balance between two accounts. The msg.sender must be an operator for both accounts.\n     * The amount field applies to accountOne.\n     * This action does not require any token movement since the trade is done internally to Solo.\n     */\n    struct TransferArgs {\n        Types.AssetAmount amount;\n        Account.Info accountOne;\n        Account.Info accountTwo;\n        uint256 market;\n    }\n\n    /*\n     * Acquires a certain amount of tokens by spending other tokens. Sends takerMarket tokens to the\n     * specified exchangeWrapper contract and expects makerMarket tokens in return. The amount field\n     * applies to the makerMarket.\n     */\n    struct BuyArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 makerMarket;\n        uint256 takerMarket;\n        address exchangeWrapper;\n        bytes orderData;\n    }\n\n    /*\n     * Spends a certain amount of tokens to acquire other tokens. Sends takerMarket tokens to the\n     * specified exchangeWrapper and expects makerMarket tokens in return. The amount field applies\n     * to the takerMarket.\n     */\n    struct SellArgs {\n        Types.AssetAmount amount;\n        Account.Info account;\n        uint256 takerMarket;\n        uint256 makerMarket;\n        address exchangeWrapper;\n        bytes orderData;\n    }\n\n    /*\n     * Trades balances between two accounts using any external contract that implements the\n     * AutoTrader interface. The AutoTrader contract must be an operator for the makerAccount (for\n     * which it is trading on-behalf-of). The amount field applies to the makerAccount and the\n     * inputMarket. This proposed change to the makerAccount is passed to the AutoTrader which will\n     * quote a change for the makerAccount in the outputMarket (or will disallow the trade).\n     * This action does not require any token movement since the trade is done internally to Solo.\n     */\n    struct TradeArgs {\n        Types.AssetAmount amount;\n        Account.Info takerAccount;\n        Account.Info makerAccount;\n        uint256 inputMarket;\n        uint256 outputMarket;\n        address autoTrader;\n        bytes tradeData;\n    }\n\n    /*\n     * Each account must maintain a certain margin-ratio (specified globally). If the account falls\n     * below this margin-ratio, it can be liquidated by any other account. This allows anyone else\n     * (arbitrageurs) to repay any borrowed asset (owedMarket) of the liquidating account in\n     * exchange for any collateral asset (heldMarket) of the liquidAccount. The ratio is determined\n     * by the price ratio (given by the oracles) plus a spread (specified globally). Liquidating an\n     * account also sets a flag on the account that the account is being liquidated. This allows\n     * anyone to continue liquidating the account until there are no more borrows being taken by the\n     * liquidating account. Liquidators do not have to liquidate the entire account all at once but\n     * can liquidate as much as they choose. The liquidating flag allows liquidators to continue\n     * liquidating the account even if it becomes collateralized through partial liquidation or\n     * price movement.\n     */\n    struct LiquidateArgs {\n        Types.AssetAmount amount;\n        Account.Info solidAccount;\n        Account.Info liquidAccount;\n        uint256 owedMarket;\n        uint256 heldMarket;\n    }\n\n    /*\n     * Similar to liquidate, but vaporAccounts are accounts that have only negative balances\n     * remaining. The arbitrageur pays back the negative asset (owedMarket) of the vaporAccount in\n     * exchange for a collateral asset (heldMarket) at a favorable spread. However, since the\n     * liquidAccount has no collateral assets, the collateral must come from Solo's excess tokens.\n     */\n    struct VaporizeArgs {\n        Types.AssetAmount amount;\n        Account.Info solidAccount;\n        Account.Info vaporAccount;\n        uint256 owedMarket;\n        uint256 heldMarket;\n    }\n\n    /*\n     * Passes arbitrary bytes of data to an external contract that implements the Callee interface.\n     * Does not change any asset amounts. This function may be useful for setting certain variables\n     * on layer-two contracts for certain accounts without having to make a separate Ethereum\n     * transaction for doing so. Also, the second-layer contracts can ensure that the call is coming\n     * from an operator of the particular account.\n     */\n    struct CallArgs {\n        Account.Info account;\n        address callee;\n        bytes data;\n    }\n\n    // ============ Helper Functions ============\n\n    function getMarketLayout(\n        ActionType actionType\n    )\n        internal\n        pure\n        returns (MarketLayout)\n    {\n        if (\n            actionType == Actions.ActionType.Deposit\n            || actionType == Actions.ActionType.Withdraw\n            || actionType == Actions.ActionType.Transfer\n        ) {\n            return MarketLayout.OneMarket;\n        }\n        else if (actionType == Actions.ActionType.Call) {\n            return MarketLayout.ZeroMarkets;\n        }\n        return MarketLayout.TwoMarkets;\n    }\n\n    function getAccountLayout(\n        ActionType actionType\n    )\n        internal\n        pure\n        returns (AccountLayout)\n    {\n        if (\n            actionType == Actions.ActionType.Transfer\n            || actionType == Actions.ActionType.Trade\n        ) {\n            return AccountLayout.TwoPrimary;\n        } else if (\n            actionType == Actions.ActionType.Liquidate\n            || actionType == Actions.ActionType.Vaporize\n        ) {\n            return AccountLayout.PrimaryAndSecondary;\n        }\n        return AccountLayout.OnePrimary;\n    }\n\n    // ============ Parsing Functions ============\n\n    function parseDepositArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (DepositArgs memory)\n    {\n        assert(args.actionType == ActionType.Deposit);\n        return DepositArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            market: args.primaryMarketId,\n            from: args.otherAddress\n        });\n    }\n\n    function parseWithdrawArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (WithdrawArgs memory)\n    {\n        assert(args.actionType == ActionType.Withdraw);\n        return WithdrawArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            market: args.primaryMarketId,\n            to: args.otherAddress\n        });\n    }\n\n    function parseTransferArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (TransferArgs memory)\n    {\n        assert(args.actionType == ActionType.Transfer);\n        return TransferArgs({\n            amount: args.amount,\n            accountOne: accounts[args.accountId],\n            accountTwo: accounts[args.otherAccountId],\n            market: args.primaryMarketId\n        });\n    }\n\n    function parseBuyArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (BuyArgs memory)\n    {\n        assert(args.actionType == ActionType.Buy);\n        return BuyArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            makerMarket: args.primaryMarketId,\n            takerMarket: args.secondaryMarketId,\n            exchangeWrapper: args.otherAddress,\n            orderData: args.data\n        });\n    }\n\n    function parseSellArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (SellArgs memory)\n    {\n        assert(args.actionType == ActionType.Sell);\n        return SellArgs({\n            amount: args.amount,\n            account: accounts[args.accountId],\n            takerMarket: args.primaryMarketId,\n            makerMarket: args.secondaryMarketId,\n            exchangeWrapper: args.otherAddress,\n            orderData: args.data\n        });\n    }\n\n    function parseTradeArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (TradeArgs memory)\n    {\n        assert(args.actionType == ActionType.Trade);\n        return TradeArgs({\n            amount: args.amount,\n            takerAccount: accounts[args.accountId],\n            makerAccount: accounts[args.otherAccountId],\n            inputMarket: args.primaryMarketId,\n            outputMarket: args.secondaryMarketId,\n            autoTrader: args.otherAddress,\n            tradeData: args.data\n        });\n    }\n\n    function parseLiquidateArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (LiquidateArgs memory)\n    {\n        assert(args.actionType == ActionType.Liquidate);\n        return LiquidateArgs({\n            amount: args.amount,\n            solidAccount: accounts[args.accountId],\n            liquidAccount: accounts[args.otherAccountId],\n            owedMarket: args.primaryMarketId,\n            heldMarket: args.secondaryMarketId\n        });\n    }\n\n    function parseVaporizeArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (VaporizeArgs memory)\n    {\n        assert(args.actionType == ActionType.Vaporize);\n        return VaporizeArgs({\n            amount: args.amount,\n            solidAccount: accounts[args.accountId],\n            vaporAccount: accounts[args.otherAccountId],\n            owedMarket: args.primaryMarketId,\n            heldMarket: args.secondaryMarketId\n        });\n    }\n\n    function parseCallArgs(\n        Account.Info[] memory accounts,\n        ActionArgs memory args\n    )\n        internal\n        pure\n        returns (CallArgs memory)\n    {\n        assert(args.actionType == ActionType.Call);\n        return CallArgs({\n            account: accounts[args.accountId],\n            callee: args.otherAddress,\n            data: args.data\n        });\n    }\n}\n"
    },
    "contracts/savings/dydx/lib/Account.sol": {
      "content": "/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport { Types } from \"./Types.sol\";\n\n\n/**\n * @title Account\n * @author dYdX\n *\n * Library of structs and functions that represent an account\n */\nlibrary Account {\n    // ============ Enums ============\n\n    /*\n     * Most-recently-cached account status.\n     *\n     * Normal: Can only be liquidated if the account values are violating the global margin-ratio.\n     * Liquid: Can be liquidated no matter the account values.\n     *         Can be vaporized if there are no more positive account values.\n     * Vapor:  Has only negative (or zeroed) account values. Can be vaporized.\n     *\n     */\n    enum Status {\n        Normal,\n        Liquid,\n        Vapor\n    }\n\n    // ============ Structs ============\n\n    // Represents the unique key that specifies an account\n    struct Info {\n        address owner;  // The address that owns the account\n        uint256 number; // A nonce that allows a single address to control many accounts\n    }\n\n    // The complete storage for any account\n    struct Storage {\n        mapping (uint256 => Types.Par) balances; // Mapping from marketId to principal\n        Status status;\n    }\n\n    // ============ Library Functions ============\n\n    function equals(\n        Info memory a,\n        Info memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.owner == b.owner && a.number == b.number;\n    }\n}\n"
    },
    "contracts/savings/dydx/lib/Types.sol": {
      "content": "/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"../../../utils/SafeMath.sol\";\nimport { Math } from \"./Math.sol\";\n\n\n/**\n * @title Types\n * @author dYdX\n *\n * Library for interacting with the basic structs used in Solo\n */\nlibrary Types {\n    using Math for uint256;\n\n    // ============ AssetAmount ============\n\n    enum AssetDenomination {\n        Wei, // the amount is denominated in wei\n        Par  // the amount is denominated in par\n    }\n\n    enum AssetReference {\n        Delta, // the amount is given as a delta from the current value\n        Target // the amount is given as an exact number to end up at\n    }\n\n    struct AssetAmount {\n        bool sign; // true if positive\n        AssetDenomination denomination;\n        AssetReference ref;\n        uint256 value;\n    }\n\n    // ============ Par (Principal Amount) ============\n\n    // Total borrow and supply values for a market\n    struct TotalPar {\n        uint128 borrow;\n        uint128 supply;\n    }\n\n    // Individual principal amount for an account\n    struct Par {\n        bool sign; // true if positive\n        uint128 value;\n    }\n\n    function zeroPar()\n        internal\n        pure\n        returns (Par memory)\n    {\n        return Par({\n            sign: false,\n            value: 0\n        });\n    }\n\n    function sub(\n        Par memory a,\n        Par memory b\n    )\n        internal\n        pure\n        returns (Par memory)\n    {\n        return add(a, negative(b));\n    }\n\n    function add(\n        Par memory a,\n        Par memory b\n    )\n        internal\n        pure\n        returns (Par memory)\n    {\n        Par memory result;\n        if (a.sign == b.sign) {\n            result.sign = a.sign;\n            result.value = SafeMath.add(a.value, b.value).to128();\n        } else {\n            if (a.value >= b.value) {\n                result.sign = a.sign;\n                result.value = SafeMath.sub(a.value, b.value).to128();\n            } else {\n                result.sign = b.sign;\n                result.value = SafeMath.sub(b.value, a.value).to128();\n            }\n        }\n        return result;\n    }\n\n    function equals(\n        Par memory a,\n        Par memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.value == b.value) {\n            if (a.value == 0) {\n                return true;\n            }\n            return a.sign == b.sign;\n        }\n        return false;\n    }\n\n    function negative(\n        Par memory a\n    )\n        internal\n        pure\n        returns (Par memory)\n    {\n        return Par({\n            sign: !a.sign,\n            value: a.value\n        });\n    }\n\n    function isNegative(\n        Par memory a\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return !a.sign && a.value > 0;\n    }\n\n    function isPositive(\n        Par memory a\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.sign && a.value > 0;\n    }\n\n    function isZero(\n        Par memory a\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value == 0;\n    }\n\n    // ============ Wei (Token Amount) ============\n\n    // Individual token amount for an account\n    struct Wei {\n        bool sign; // true if positive\n        uint256 value;\n    }\n\n    function zeroWei()\n        internal\n        pure\n        returns (Wei memory)\n    {\n        return Wei({\n            sign: false,\n            value: 0\n        });\n    }\n\n    function sub(\n        Wei memory a,\n        Wei memory b\n    )\n        internal\n        pure\n        returns (Wei memory)\n    {\n        return add(a, negative(b));\n    }\n\n    function add(\n        Wei memory a,\n        Wei memory b\n    )\n        internal\n        pure\n        returns (Wei memory)\n    {\n        Wei memory result;\n        if (a.sign == b.sign) {\n            result.sign = a.sign;\n            result.value = SafeMath.add(a.value, b.value);\n        } else {\n            if (a.value >= b.value) {\n                result.sign = a.sign;\n                result.value = SafeMath.sub(a.value, b.value);\n            } else {\n                result.sign = b.sign;\n                result.value = SafeMath.sub(b.value, a.value);\n            }\n        }\n        return result;\n    }\n\n    function equals(\n        Wei memory a,\n        Wei memory b\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (a.value == b.value) {\n            if (a.value == 0) {\n                return true;\n            }\n            return a.sign == b.sign;\n        }\n        return false;\n    }\n\n    function negative(\n        Wei memory a\n    )\n        internal\n        pure\n        returns (Wei memory)\n    {\n        return Wei({\n            sign: !a.sign,\n            value: a.value\n        });\n    }\n\n    function isNegative(\n        Wei memory a\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return !a.sign && a.value > 0;\n    }\n\n    function isPositive(\n        Wei memory a\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.sign && a.value > 0;\n    }\n\n    function isZero(\n        Wei memory a\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return a.value == 0;\n    }\n}\n"
    },
    "contracts/savings/dydx/lib/Math.sol": {
      "content": "/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"../../../utils/SafeMath.sol\";\nimport { Require } from \"./Require.sol\";\n\n\n/**\n * @title Math\n * @author dYdX\n *\n * Library for non-standard Math functions\n */\nlibrary Math {\n    using SafeMath for uint256;\n\n    // ============ Constants ============\n\n    bytes32 constant FILE = \"Math\";\n\n    // ============ Library Functions ============\n\n    /*\n     * Return target * (numerator / denominator).\n     */\n    function getPartial(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return target.mul(numerator).div(denominator);\n    }\n\n    /*\n     * Return target * (numerator / denominator), but rounded up.\n     */\n    function getPartialRoundUp(\n        uint256 target,\n        uint256 numerator,\n        uint256 denominator\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (target == 0 || numerator == 0) {\n            // SafeMath will check for zero denominator\n            return SafeMath.div(0, denominator);\n        }\n        return target.mul(numerator).sub(1).div(denominator).add(1);\n    }\n\n    function to128(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint128)\n    {\n        uint128 result = uint128(number);\n        Require.that(\n            result == number,\n            FILE,\n            \"Unsafe cast to uint128\"\n        );\n        return result;\n    }\n\n    function to96(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint96)\n    {\n        uint96 result = uint96(number);\n        Require.that(\n            result == number,\n            FILE,\n            \"Unsafe cast to uint96\"\n        );\n        return result;\n    }\n\n    function to32(\n        uint256 number\n    )\n        internal\n        pure\n        returns (uint32)\n    {\n        uint32 result = uint32(number);\n        Require.that(\n            result == number,\n            FILE,\n            \"Unsafe cast to uint32\"\n        );\n        return result;\n    }\n\n    function min(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max(\n        uint256 a,\n        uint256 b\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/savings/dydx/lib/Require.sol": {
      "content": "/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title Require\n * @author dYdX\n *\n * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\n */\nlibrary Require {\n\n    // ============ Constants ============\n\n    uint256 constant ASCII_ZERO = 48; // '0'\n    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\n    uint256 constant ASCII_LOWER_EX = 120; // 'x'\n    bytes2 constant COLON = 0x3a20; // ': '\n    bytes2 constant COMMA = 0x2c20; // ', '\n    bytes2 constant LPAREN = 0x203c; // ' <'\n    byte constant RPAREN = 0x3e; // '>'\n    uint256 constant FOUR_BIT_MASK = 0xf;\n\n    // ============ Library Functions ============\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason)\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        uint256 payloadA,\n        uint256 payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        uint256 payloadB\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        address payloadA,\n        uint256 payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bytes32 payloadA\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    function that(\n        bool must,\n        bytes32 file,\n        bytes32 reason,\n        bytes32 payloadA,\n        uint256 payloadB,\n        uint256 payloadC\n    )\n        internal\n        pure\n    {\n        if (!must) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        stringifyTruncated(file),\n                        COLON,\n                        stringifyTruncated(reason),\n                        LPAREN,\n                        stringify(payloadA),\n                        COMMA,\n                        stringify(payloadB),\n                        COMMA,\n                        stringify(payloadC),\n                        RPAREN\n                    )\n                )\n            );\n        }\n    }\n\n    // ============ Private Functions ============\n\n    function stringifyTruncated(\n        bytes32 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        // put the input bytes into the result\n        bytes memory result = abi.encodePacked(input);\n\n        // determine the length of the input by finding the location of the last non-zero byte\n        for (uint256 i = 32; i > 0; ) {\n            // reverse-for-loops with unsigned integer\n            /* solium-disable-next-line security/no-modify-for-iter-var */\n            i--;\n\n            // find the last non-zero byte in order to determine the length\n            if (result[i] != 0) {\n                uint256 length = i + 1;\n\n                /* solium-disable-next-line security/no-inline-assembly */\n                assembly {\n                    mstore(result, length) // r.length = length;\n                }\n\n                return result;\n            }\n        }\n\n        // all bytes are zero\n        return new bytes(0);\n    }\n\n    function stringify(\n        uint256 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        if (input == 0) {\n            return \"0\";\n        }\n\n        // get the final string length\n        uint256 j = input;\n        uint256 length;\n        while (j != 0) {\n            length++;\n            j /= 10;\n        }\n\n        // allocate the string\n        bytes memory bstr = new bytes(length);\n\n        // populate the string starting with the least-significant character\n        j = input;\n        for (uint256 i = length; i > 0; ) {\n            // reverse-for-loops with unsigned integer\n            /* solium-disable-next-line security/no-modify-for-iter-var */\n            i--;\n\n            // take last decimal digit\n            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\n\n            // remove the last decimal digit\n            j /= 10;\n        }\n\n        return bstr;\n    }\n\n    function stringify(\n        address input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        uint256 z = uint256(input);\n\n        // addresses are \"0x\" followed by 20 bytes of data which take up 2 characters each\n        bytes memory result = new bytes(42);\n\n        // populate the result with \"0x\"\n        result[0] = byte(uint8(ASCII_ZERO));\n        result[1] = byte(uint8(ASCII_LOWER_EX));\n\n        // for each byte (starting from the lowest byte), populate the result with two characters\n        for (uint256 i = 0; i < 20; i++) {\n            // each byte takes two characters\n            uint256 shift = i * 2;\n\n            // populate the least-significant character\n            result[41 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n\n            // populate the most-significant character\n            result[40 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n        }\n\n        return result;\n    }\n\n    function stringify(\n        bytes32 input\n    )\n        private\n        pure\n        returns (bytes memory)\n    {\n        uint256 z = uint256(input);\n\n        // bytes32 are \"0x\" followed by 32 bytes of data which take up 2 characters each\n        bytes memory result = new bytes(66);\n\n        // populate the result with \"0x\"\n        result[0] = byte(uint8(ASCII_ZERO));\n        result[1] = byte(uint8(ASCII_LOWER_EX));\n\n        // for each byte (starting from the lowest byte), populate the result with two characters\n        for (uint256 i = 0; i < 32; i++) {\n            // each byte takes two characters\n            uint256 shift = i * 2;\n\n            // populate the least-significant character\n            result[65 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n\n            // populate the most-significant character\n            result[64 - shift] = char(z & FOUR_BIT_MASK);\n            z = z >> 4;\n        }\n\n        return result;\n    }\n\n    function char(\n        uint256 input\n    )\n        private\n        pure\n        returns (byte)\n    {\n        // return ASCII digit (0-9)\n        if (input < 10) {\n            return byte(uint8(input + ASCII_ZERO));\n        }\n\n        // return ASCII letter (a-f)\n        return byte(uint8(input + ASCII_RELATIVE_ZERO));\n    }\n}\n"
    },
    "contracts/aave/migration/AaveImportTaker.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../utils/DydxFlashLoanBase.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\n\n// take weth\n// send weth to AaveImport\n// approve AaveImport to manage proxy position\n// call flashloan\n// remove AaveImport\n// log\n\n/// @title Import Aave position from account to wallet\n/// @dev Contract needs to have enough wei in WETH for all transactions (2 WETH wei per transaction)\ncontract AaveImportTaker is DydxFlashLoanBase, ProxyPermission {\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant AAVE_IMPORT = 0x207754BD0044BAd0C7021ca06643C26d59d8AD8f;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must send 2 wei with this transaction\n    /// @dev User must approve AaveImport to pull _aCollateralToken\n    /// @param _collateralToken Collateral token we are moving to DSProxy\n    /// @param _borrowToken Borrow token we are moving to DSProxy\n    /// @param _ethAmount ETH amount that needs to be pulled from dydx\n    function importLoan(address _collateralToken, address _borrowToken, uint _ethAmount) public {\n        ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n        // Get marketId from token address\n        uint256 marketId = _getMarketIdFromTokenAddress(WETH_ADDR);\n\n        // Calculate repay amount (_amount + (2 wei))\n        // Approve transfer from\n        uint256 repayAmount = _getRepaymentAmountInternal(_ethAmount);\n        ERC20(WETH_ADDR).approve(SOLO_MARGIN_ADDRESS, repayAmount);\n\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n        operations[0] = _getWithdrawAction(marketId, _ethAmount, AAVE_IMPORT);\n        operations[1] = _getCallAction(\n            abi.encode(_collateralToken, _borrowToken, _ethAmount, msg.sender, address(this)),\n            AAVE_IMPORT\n        );\n        operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n        Account.Info[] memory accountInfos = new Account.Info[](1);\n        accountInfos[0] = _getAccountInfo();\n\n        givePermission(AAVE_IMPORT);\n        solo.operate(accountInfos, operations);\n        removePermission(AAVE_IMPORT);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"AaveImport\", abi.encode(_collateralToken, _borrowToken));\n    }\n}"
    },
    "contracts/auth/ProxyPermission.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSGuard.sol\";\nimport \"../DS/DSAuth.sol\";\n\ncontract ProxyPermission {\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n\n    /// @notice Called in the context of DSProxy to authorize an address\n    /// @param _contractAddr Address which will be authorized\n    function givePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n\n    /// @notice Called in the context of DSProxy to remove authority of an address\n    /// @param _contractAddr Auth address which will be removed from authority list\n    function removePermission(address _contractAddr) public {\n        address currAuthority = address(DSAuth(address(this)).authority());\n        \n        // if there is no authority, that means that contract doesn't have permission\n        if (currAuthority == address(0)) {\n            return;\n        }\n\n        DSGuard guard = DSGuard(currAuthority);\n        guard.forbid(_contractAddr, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n    }\n}\n"
    },
    "contracts/DS/DSGuard.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract DSGuard {\n    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\n\n    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n\n    function permit(address src, address dst, bytes32 sig) public virtual;\n\n    function forbid(address src, address dst, bytes32 sig) public virtual;\n}\n\n\nabstract contract DSGuardFactory {\n    function newGuard() public virtual returns (DSGuard guard);\n}\n"
    },
    "contracts/utils/DydxFlashLoanBase.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../savings/dydx/ISoloMargin.sol\";\n\ncontract DydxFlashLoanBase {\n    using SafeMath for uint256;\n\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n\n    function _getMarketIdFromTokenAddress(address token)\n        internal\n        view\n        returns (uint256)\n    {\n        return 0;\n    }\n\n    function _getRepaymentAmountInternal(uint256 amount)\n        internal\n        view\n        returns (uint256)\n    {\n        // Needs to be overcollateralize\n        // Needs to provide +2 wei to be safe\n        return amount.add(2);\n    }\n\n    function _getAccountInfo() internal view returns (Account.Info memory) {\n        return Account.Info({owner: address(this), number: 1});\n    }\n\n    function _getWithdrawAction(uint marketId, uint256 amount, address contractAddr)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Withdraw,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: contractAddr,\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n\n    function _getCallAction(bytes memory data, address contractAddr)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Call,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: false,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: 0\n                }),\n                primaryMarketId: 0,\n                secondaryMarketId: 0,\n                otherAddress: contractAddr,\n                otherAccountId: 0,\n                data: data\n            });\n    }\n\n    function _getDepositAction(uint marketId, uint256 amount, address contractAddr)\n        internal\n        view\n        returns (Actions.ActionArgs memory)\n    {\n        return\n            Actions.ActionArgs({\n                actionType: Actions.ActionType.Deposit,\n                accountId: 0,\n                amount: Types.AssetAmount({\n                    sign: true,\n                    denomination: Types.AssetDenomination.Wei,\n                    ref: Types.AssetReference.Delta,\n                    value: amount\n                }),\n                primaryMarketId: marketId,\n                secondaryMarketId: 0,\n                otherAddress: contractAddr,\n                otherAccountId: 0,\n                data: \"\"\n            });\n    }\n}"
    },
    "contracts/interfaces/ProxyRegistryInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./DSProxyInterface.sol\";\n\nabstract contract ProxyRegistryInterface {\n    function proxies(address _owner) public virtual view returns (address);\n    function build(address) public virtual returns (address);\n}\n"
    },
    "contracts/interfaces/DSProxyInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract DSProxyInterface {\n\n    /// Truffle wont compile if this isn't commented\n    // function execute(bytes memory _code, bytes memory _data)\n    //     public virtual\n    //     payable\n    //     returns (address, bytes32);\n\n    function execute(address _target, bytes memory _data) public virtual payable returns (bytes32);\n\n    function setCache(address _cacheAddr) public virtual payable returns (bool);\n\n    function owner() public virtual returns (address);\n}\n"
    },
    "contracts/auth/Auth.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./AdminAuth.sol\";\n\ncontract Auth is AdminAuth {\n\n\tbool public ALL_AUTHORIZED = false;\n\n\tmapping(address => bool) public authorized;\n\n\tmodifier onlyAuthorized() {\n        require(ALL_AUTHORIZED || authorized[msg.sender]);\n        _;\n    }\n\n\tconstructor() public {\n\t\tauthorized[msg.sender] = true;\n\t}\n\n\tfunction setAuthorized(address _user, bool _approved) public onlyOwner {\n\t\tauthorized[_user] = _approved;\n\t}\n\n\tfunction setAllAuthorized(bool _authorized) public onlyOwner {\n\t\tALL_AUTHORIZED = _authorized;\n\t}\n}"
    },
    "contracts/compound/automatic/CompoundMonitor.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"./CompoundMonitorProxy.sol\";\nimport \"./CompoundSubscriptions.sol\";\nimport \"../../interfaces/GasTokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../CompoundSafetyRatio.sol\";\n\n/// @title Contract implements logic of calling boost/repay in the automatic system\ncontract CompoundMonitor is AdminAuth, DSMath, CompoundSafetyRatio, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    enum Method { Boost, Repay }\n\n    uint public REPAY_GAS_TOKEN = 25;\n    uint public BOOST_GAS_TOKEN = 20;\n\n    uint constant public MAX_GAS_PRICE = 80000000000; // 80 gwei\n\n    uint public REPAY_GAS_COST = 2200000;\n    uint public BOOST_GAS_COST = 1700000;\n\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    CompoundMonitorProxy public compoundMonitorProxy;\n    CompoundSubscriptions public subscriptionsContract;\n    address public compoundFlashLoanTakerAddress;\n\n    DefisaverLogger public logger = DefisaverLogger(DEFISAVER_LOGGER);\n\n    /// @dev Addresses that are able to call methods for repay and boost\n    mapping(address => bool) public approvedCallers;\n\n    modifier onlyApproved() {\n        require(approvedCallers[msg.sender]);\n        _;\n    }\n\n    /// @param _compoundMonitorProxy Proxy contracts that actually is authorized to call DSProxy\n    /// @param _subscriptions Subscriptions contract for Compound positions\n    /// @param _compoundFlashLoanTaker Contract that actually performs Repay/Boost\n    constructor(address _compoundMonitorProxy, address _subscriptions, address _compoundFlashLoanTaker) public {\n        approvedCallers[msg.sender] = true;\n\n        compoundMonitorProxy = CompoundMonitorProxy(_compoundMonitorProxy);\n        subscriptionsContract = CompoundSubscriptions(_subscriptions);\n        compoundFlashLoanTakerAddress = _compoundFlashLoanTaker;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    /// @param _user The actual address that owns the Compound position\n    function repayFor(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData,\n        address _user\n    ) public payable onlyApproved burnGas(REPAY_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Repay, _user);\n        require(isAllowed); // check if conditions are met\n\n        _data[3] = calcGasCost(REPAY_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\"repayWithLoan(uint256[5],address[3],bytes)\",\n            _data, _addrData, _callData));\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Repay, _user);\n        require(isGoodRatio); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticCompoundRepay\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    /// @param _user The actual address that owns the Compound position\n    function boostFor(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData,\n        address _user\n    ) public payable onlyApproved burnGas(BOOST_GAS_TOKEN) {\n\n        (bool isAllowed, uint ratioBefore) = canCall(Method.Boost, _user);\n        require(isAllowed); // check if conditions are met\n\n        _data[3] = calcGasCost(BOOST_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\"boostWithLoan(uint256[5],address[3],bytes)\",\n            _data, _addrData, _callData));\n\n\n        (bool isGoodRatio, uint ratioAfter) = ratioGoodAfter(Method.Boost, _user);\n        require(isGoodRatio);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticCompoundBoost\", abi.encode(ratioBefore, ratioAfter));\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Compound position\n    /// @return Boolean if it can be called and the ratio\n    function canCall(Method _method, address _user) public view returns(bool, uint) {\n        bool subscribed = subscriptionsContract.isSubscribed(_user);\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    /// @param _method Type of action to be called\n    /// @param _user The actual address that owns the Compound position\n    /// @return Boolean if the recent action preformed correctly and the ratio\n    function ratioGoodAfter(Method _method, address _user) public view returns(bool, uint) {\n        CompoundSubscriptions.CompoundHolder memory holder;\n\n        holder= subscriptionsContract.getHolder(_user);\n\n        uint currRatio = getSafetyRatio(_user);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Adds a new bot address which will be able to call repay/boost\n    /// @param _caller Bot address\n    function addCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = true;\n    }\n\n    /// @notice Removes a bot address so it can't call repay/boost\n    /// @param _caller Bot address\n    function removeCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = false;\n    }\n\n    /// @notice If any tokens gets stuck in the contract owner can withdraw it\n    /// @param _tokenAddress Address of the ERC20 token\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n        ERC20(_tokenAddress).safeTransfer(_to, _amount);\n    }\n\n    /// @notice If any Eth gets stuck in the contract owner can withdraw it\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferEth(address payable _to, uint _amount) public onlyOwner {\n        _to.transfer(_amount);\n    }\n}\n"
    },
    "contracts/compound/automatic/CompoundMonitorProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Contract with the actuall DSProxy permission calls the automation operations\ncontract CompoundMonitorProxy is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    mapping(address => bool) public allowed;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n    // if someone who is allowed become malicious, owner can't be changed\n    modifier onlyAllowed() {\n        require(allowed[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 days;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _compoundSaverProxy Address of CompoundSaverProxy\n    /// @param _data Data to send to CompoundSaverProxy\n    function callExecute(address _owner, address _compoundSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }\n\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }\n\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).safeTransfer(msg.sender, balance);\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n}\n"
    },
    "contracts/compound/automatic/CompoundSubscriptions.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Stores subscription information for Compound automatization\ncontract CompoundSubscriptions is AdminAuth {\n\n    struct CompoundHolder {\n        address user;\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        bool boostEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n\n    CompoundHolder[] public subscribers;\n    mapping (address => SubPosition) public subscribersPos;\n\n    uint public changeIndex;\n\n    event Subscribed(address indexed user);\n    event Unsubscribed(address indexed user);\n    event Updated(address indexed user);\n    event ParamUpdates(address indexed user, uint128, uint128, uint128, uint128, bool);\n\n    /// @dev Called by the DSProxy contract which owns the Compound position\n    /// @notice Adds the users Compound poistion in the list of subscriptions so it can be monitored\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) external {\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(_minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[msg.sender];\n\n        CompoundHolder memory subscription = CompoundHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                user: msg.sender,\n                boostEnabled: _boostEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender);\n            emit ParamUpdates(msg.sender, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe() external {\n        _unsubscribe(msg.sender);\n    }\n\n    /// @dev Checks limit if minRatio is bigger than max\n    /// @param _minRatio Minimum ratio, bellow which repay can be triggered\n    /// @param _maxRatio Maximum ratio, over which boost can be triggered\n    /// @return Returns bool if the params are correct\n    function checkParams(uint128 _minRatio, uint128 _maxRatio) internal pure returns (bool) {\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    /// @param _user The actual address that owns the Compound position\n    function _unsubscribe(address _user) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        address lastOwner = subscribers[subscribers.length - 1].user;\n\n        SubPosition storage subInfo2 = subscribersPos[lastOwner];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop(); // remove last element and reduce arr length\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender);\n    }\n\n    /// @dev Checks if the user is subscribed\n    /// @param _user The actual address that owns the Compound position\n    /// @return If the user is subscribed\n    function isSubscribed(address _user) public view returns (bool) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subInfo.subscribed;\n    }\n\n    /// @dev Returns subscribtion information about a user\n    /// @param _user The actual address that owns the Compound position\n    /// @return Subscription information about the user if exists\n    function getHolder(address _user) public view returns (CompoundHolder memory) {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        return subscribers[subInfo.arrPos];\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    /// @return List of all subscribers\n    function getSubscribers() public view returns (CompoundHolder[] memory) {\n        return subscribers;\n    }\n\n    /// @notice Helper method for the frontend, returns all the subscribed CDPs paginated\n    /// @param _page What page of subscribers you want\n    /// @param _perPage Number of entries per page\n    /// @return List of all subscribers for that page\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (CompoundHolder[] memory) {\n        CompoundHolder[] memory holders = new CompoundHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        end = (end > holders.length) ? holders.length : end;\n\n        uint count = 0;\n        for (uint i = start; i < end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to unsubscribe a CDP\n    /// @param _user The actual address that owns the Compound position\n    function unsubscribeByAdmin(address _user) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_user];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_user);\n        }\n    }\n}\n"
    },
    "contracts/compound/CompoundSafetyRatio.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/CompoundOracleInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"./helpers/Exponential.sol\";\n\n\ncontract CompoundSafetyRatio is Exponential, DSMath {\n    // solhint-disable-next-line const-name-snakecase\n    ComptrollerInterface public constant comp = ComptrollerInterface(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n\n    // solhint-disable-next-line const-name-snakecase\n    CompoundOracleInterface public constant oracle = CompoundOracleInterface(0xDDc46a3B076aec7ab3Fc37420A8eDd2959764Ec4);\n\n\n    /// @notice Calcualted the ratio of debt / adjusted collateral\n    /// @param _user Address of the user\n    function getSafetyRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        address[] memory assets = comp.getAssetsIn(_user);\n\n        uint sumCollateral = 0;\n        uint sumBorrow = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: oracle.getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Eth\n            if (cTokenBalance != 0) {\n\n                (, uint collFactorMantissa) = comp.markets(address(asset));\n\n                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n\n                (, Exp memory tokensToEther) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\n\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToEther, cTokenBalance, sumCollateral);\n            }\n\n            // Sum up debt in Eth\n            if (borrowBalance != 0) {\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n            }\n        }\n\n        if (sumBorrow == 0) return uint(-1);\n\n        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\n        return wdiv(1e18, borrowPowerUsed);\n    }\n}\n"
    },
    "contracts/interfaces/CompoundOracleInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract CompoundOracleInterface {\n    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\n}\n"
    },
    "contracts/interfaces/ComptrollerInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract ComptrollerInterface {\n    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n\n    function exitMarket(address cToken) external virtual returns (uint256);\n\n    function getAssetsIn(address account) external virtual view returns (address[] memory);\n\n    function markets(address account) public virtual view returns (bool, uint256);\n\n    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\n\n    function claimComp(address holder) virtual public;\n}\n"
    },
    "contracts/interfaces/CTokenInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract CTokenInterface is ERC20 {\n    function mint(uint256 mintAmount) external virtual returns (uint256);\n\n    // function mint() external virtual payable;\n\n    function accrueInterest() public virtual returns (uint);\n\n    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n\n    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrow() external virtual payable;\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n\n    function repayBorrowBehalf(address borrower) external virtual payable;\n\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\n        external virtual\n        returns (uint256);\n\n    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\n\n    function exchangeRateCurrent() external virtual returns (uint256);\n\n    function supplyRatePerBlock() external virtual returns (uint256);\n\n    function borrowRatePerBlock() external virtual returns (uint256);\n\n    function totalReserves() external virtual returns (uint256);\n\n    function reserveFactorMantissa() external virtual returns (uint256);\n\n    function borrowBalanceCurrent(address account) external virtual returns (uint256);\n\n    function totalBorrowsCurrent() external virtual returns (uint256);\n\n    function getCash() external virtual returns (uint256);\n\n    function balanceOfUnderlying(address owner) external virtual returns (uint256);\n\n    function underlying() external virtual returns (address);\n\n    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n}\n"
    },
    "contracts/compound/helpers/Exponential.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./CarefulMath.sol\";\n\ncontract Exponential is CarefulMath {\n    uint constant expScale = 1e18;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n}\n"
    },
    "contracts/compound/helpers/CarefulMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n"
    },
    "contracts/compound/automatic/CompoundSubscriptionsProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../interfaces/ICompoundSubscription.sol\";\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract CompoundSubscriptionsProxy is ProxyPermission {\n\n    address public constant COMPOUND_SUBSCRIPTION_ADDRESS = 0x52015EFFD577E08f498a0CCc11905925D58D6207;\n    address public constant COMPOUND_MONITOR_PROXY = 0xB1cF8DE8e791E4Ed1Bd86c03E2fc1f14389Cb10a;\n\n    /// @notice Calls subscription contract and creates a DSGuard if non existent\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function subscribe(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        givePermission(COMPOUND_MONITOR_PROXY);\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(\n            _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls subscription contract and updated existing parameters\n    /// @dev If subscription is non existent this will create one\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalRatioBoost Ratio amount which boost should target\n    /// @param _optimalRatioRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    function update(\n        uint128 _minRatio,\n        uint128 _maxRatio,\n        uint128 _optimalRatioBoost,\n        uint128 _optimalRatioRepay,\n        bool _boostEnabled\n    ) public {\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).subscribe(_minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled);\n    }\n\n    /// @notice Calls the subscription contract to unsubscribe the caller\n    function unsubscribe() public {\n        removePermission(COMPOUND_MONITOR_PROXY);\n        ICompoundSubscription(COMPOUND_SUBSCRIPTION_ADDRESS).unsubscribe();\n    }\n}\n"
    },
    "contracts/interfaces/ICompoundSubscription.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract ICompoundSubscription {\n    function subscribe(uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled) public virtual;\n    function unsubscribe() public virtual;\n}\n"
    },
    "contracts/compound/CompoundBasicProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../utils/GasBurner.sol\";\nimport \"../utils/SafeERC20.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"../interfaces/CEtherInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\n\n/// @title Basic compound interactions through the DSProxy\ncontract CompoundBasicProxy is GasBurner {\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice User deposits tokens to the Compound protocol\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @param _tokenAddr The address of the token to be deposited\n    /// @param _cTokenAddr CTokens to be deposited\n    /// @param _amount Amount of tokens to be deposited\n    /// @param _inMarket True if the token is already in market for that address\n    function deposit(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(5) payable {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: msg.value}(); // reverts on fail\n        }\n    }\n\n    /// @notice User withdraws tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be withdrawn\n    /// @param _cTokenAddr CTokens to be withdrawn\n    /// @param _amount Amount of tokens to be withdrawn\n    /// @param _isCAmount If true _amount is cTokens if falls _amount is underlying tokens\n    function withdraw(address _tokenAddr, address _cTokenAddr, uint _amount, bool _isCAmount) public burnGas(5) {\n\n        if (_isCAmount) {\n            require(CTokenInterface(_cTokenAddr).redeem(_amount) == 0);\n        } else {\n            require(CTokenInterface(_cTokenAddr).redeemUnderlying(_amount) == 0);\n        }\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n\n    }\n\n    /// @notice User borrows tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be borrowed\n    /// @param _cTokenAddr CTokens to be borrowed\n    /// @param _amount Amount of tokens to be borrowed\n    /// @param _inMarket True if the token is already in market for that address\n    function borrow(address _tokenAddr, address _cTokenAddr, uint _amount, bool _inMarket) public burnGas(8) {\n        if (!_inMarket) {\n            enterMarket(_cTokenAddr);\n        }\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @dev User needs to approve the DSProxy to pull the _tokenAddr tokens\n    /// @notice User paybacks tokens to the Compound protocol\n    /// @param _tokenAddr The address of the token to be paybacked\n    /// @param _cTokenAddr CTokens to be paybacked\n    /// @param _amount Amount of tokens to be payedback\n    /// @param _wholeDebt If true the _amount will be set to the whole amount of the debt\n    function payback(address _tokenAddr, address _cTokenAddr, uint _amount, bool _wholeDebt) public burnGas(5) payable {\n        approveToken(_tokenAddr, _cTokenAddr);\n\n        if (_wholeDebt) {\n            _amount = CTokenInterface(_cTokenAddr).borrowBalanceCurrent(address(this));\n        }\n\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(this), _amount);\n\n            require(CTokenInterface(_cTokenAddr).repayBorrow(_amount) == 0);\n        } else {\n            CEtherInterface(_cTokenAddr).repayBorrow{value: msg.value}();\n            msg.sender.transfer(address(this).balance); // send back the extra eth\n        }\n    }\n\n    /// @notice Helper method to withdraw tokens from the DSProxy\n    /// @param _tokenAddr Address of the token to be withdrawn\n    function withdrawTokens(address _tokenAddr) public {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, ERC20(_tokenAddr).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Enters the Compound market so it can be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n    /// @notice Exits the Compound market so it can't be deposited/borrowed\n    /// @param _cTokenAddr CToken address of the token\n    function exitMarket(address _cTokenAddr) public {\n        ComptrollerInterface(COMPTROLLER_ADDR).exitMarket(_cTokenAddr);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDR) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n}\n"
    },
    "contracts/interfaces/CEtherInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract CEtherInterface {\n    function mint() external virtual payable;\n    function repayBorrow() external virtual payable;\n}\n"
    },
    "contracts/compound/CompoundLoanInfo.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./CompoundSafetyRatio.sol\";\nimport \"./helpers/CompoundSaverHelper.sol\";\n\n\n/// @title Gets data about Compound positions\ncontract CompoundLoanInfo is CompoundSafetyRatio, CompoundSaverHelper {\n\n    struct LoanData {\n        address user;\n        uint128 ratio;\n        address[] collAddr;\n        address[] borrowAddr;\n        uint[] collAmounts;\n        uint[] borrowAmounts;\n    }\n\n    struct TokenInfo {\n        address cTokenAddress;\n        address underlyingTokenAddress;\n        uint collateralFactor;\n        uint price;\n    }\n\n    struct TokenInfoFull {\n        address underlyingTokenAddress;\n        uint supplyRate;\n        uint borrowRate;\n        uint exchangeRate;\n        uint marketLiquidity;\n        uint totalSupply;\n        uint totalBorrow;\n        uint collateralFactor;\n        uint price;\n    }\n\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _user Address of the user\n    function getRatio(address _user) public view returns (uint) {\n        // For each asset the account is in\n        return getSafetyRatio(_user);\n    }\n\n    /// @notice Fetches Compound prices for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the prices\n    /// @return prices Array of prices\n    function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n        prices = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            prices[i] = oracle.getUnderlyingPrice(_cTokens[i]);\n        }\n    }\n\n    /// @notice Fetches Compound collateral factors for tokens\n    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\n    /// @return collFactors Array of coll. factors\n    function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\n        collFactors = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; ++i) {\n            (, collFactors[i]) = comp.markets(_cTokens[i]);\n        }\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _user Address of the user\n    /// @return data LoanData information\n    function getLoanData(address _user) public view returns (LoanData memory data) {\n        address[] memory assets = comp.getAssetsIn(_user);\n\n        data = LoanData({\n            user: _user,\n            ratio: 0,\n            collAddr: new address[](assets.length),\n            borrowAddr: new address[](assets.length),\n            collAmounts: new uint[](assets.length),\n            borrowAmounts: new uint[](assets.length)\n        });\n\n        uint sumCollateral = 0;\n        uint sumBorrow = 0;\n        uint collPos = 0;\n        uint borrowPos = 0;\n\n        for (uint i = 0; i < assets.length; i++) {\n            address asset = assets[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory oraclePrice;\n\n            if (cTokenBalance != 0 || borrowBalance != 0) {\n                oraclePrice = Exp({mantissa: oracle.getUnderlyingPrice(asset)});\n            }\n\n            // Sum up collateral in Eth\n            if (cTokenBalance != 0) {\n                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n                (, Exp memory tokensToEther) = mulExp(exchangeRate, oraclePrice);\n                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToEther, cTokenBalance, sumCollateral);\n\n                data.collAddr[collPos] = asset;\n                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToEther, cTokenBalance);\n                collPos++;\n            }\n\n            // Sum up debt in Eth\n            if (borrowBalance != 0) {\n                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n\n                data.borrowAddr[borrowPos] = asset;\n                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\n                borrowPos++;\n            }\n        }\n\n        data.ratio = uint128(getSafetyRatio(_user));\n\n        return data;\n    }\n\n    function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\n        balances = new uint[](_cTokens.length);\n        borrows = new uint[](_cTokens.length);\n\n        for (uint i = 0; i < _cTokens.length; i++) {\n            address asset = _cTokens[i];\n\n            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n\n            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\n\n            borrows[i] = borrowBalance;\n        }\n\n    }\n\n    /// @notice Fetches all the collateral/debt address and amounts, denominated in ether\n    /// @param _users Addresses of the user\n    /// @return loans Array of LoanData information\n    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n        loans = new LoanData[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            loans[i] = getLoanData(_users[i]);\n        }\n    }\n\n    /// @notice Calcualted the ratio of coll/debt for a compound user\n    /// @param _users Addresses of the user\n    /// @return ratios Array of ratios\n    function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\n        ratios = new uint[](_users.length);\n\n        for (uint i = 0; i < _users.length; ++i) {\n            ratios[i] = getSafetyRatio(_users[i]);\n        }\n    }\n\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\n        tokens = new TokenInfo[](_cTokenAddresses.length);\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfo({\n                cTokenAddress: _cTokenAddresses[i],\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                collateralFactor: collFactor,\n                price: oracle.getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }\n\n    /// @notice Information about cTokens\n    /// @param _cTokenAddresses Array of cTokens addresses\n    /// @return tokens Array of cTokens infomartion\n    function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\n        tokens = new TokenInfoFull[](_cTokenAddresses.length);\n\n        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\n\n            tokens[i] = TokenInfoFull({\n                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n                supplyRate: cToken.supplyRatePerBlock(),\n                borrowRate: cToken.borrowRatePerBlock(),\n                exchangeRate: cToken.exchangeRateCurrent(),\n                marketLiquidity: cToken.getCash(),\n                totalSupply: cToken.totalSupply(),\n                totalBorrow: cToken.totalBorrowsCurrent(),\n                collateralFactor: collFactor,\n                price: oracle.getUnderlyingPrice(_cTokenAddresses[i])\n            });\n        }\n    }\n}\n"
    },
    "contracts/compound/helpers/CompoundSaverHelper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/CEtherInterface.sol\";\nimport \"../../interfaces/CompoundOracleInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\n\nimport \"../../mcd/Discount.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\n\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Utlity functions for Compound contracts\ncontract CompoundSaverHelper is DSMath {\n\n    using SafeERC20 for ERC20;\n\n    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\n    address public constant COMPOUND_ORACLE = 0xDDc46a3B076aec7ab3Fc37420A8eDd2959764Ec4;\n\n    /// @notice Helper method to payback the Compound debt\n    /// @dev If amount is bigger it will repay the whole debt and send the extra to the _user\n    /// @param _amount Amount of tokens we want to repay\n    /// @param _cBorrowToken Ctoken address we are repaying\n    /// @param _borrowToken Token address we are repaying\n    /// @param _user Owner of the compound position we are paying back\n    function paybackDebt(uint _amount, address _cBorrowToken, address _borrowToken, address payable _user) internal {\n        uint wholeDebt = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(address(this));\n\n        if (_amount > wholeDebt) {\n            if (_borrowToken == ETH_ADDRESS) {\n                _user.transfer((_amount - wholeDebt));\n            } else {\n                ERC20(_borrowToken).safeTransfer(_user, (_amount - wholeDebt));\n            }\n\n            _amount = wholeDebt;\n        }\n\n        approveCToken(_borrowToken, _cBorrowToken);\n\n        if (_borrowToken == ETH_ADDRESS) {\n            CEtherInterface(_cBorrowToken).repayBorrow{value: _amount}();\n        } else {\n            require(CTokenInterface(_cBorrowToken).repayBorrow(_amount) == 0);\n        }\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Amount that is converted\n    /// @param _user Actuall user addr not DSProxy\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getFee(uint _amount, address _user, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        uint fee = SERVICE_FEE;\n\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(_user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(_user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint ethTokenPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cTokenAddr);\n            _gasCost = wdiv(_gasCost, ethTokenPrice);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Calculates the gas cost of transaction and send it to wallet\n    /// @param _amount Amount that is converted\n    /// @param _gasCost Ether amount of gas we are spending for tx\n    /// @param _cTokenAddr CToken addr. of token we are getting for the fee\n    /// @return feeAmount The amount we took for the fee\n    function getGasCost(uint _amount, uint _gasCost, address _cTokenAddr) internal returns (uint feeAmount) {\n        address tokenAddr = getUnderlyingAddr(_cTokenAddr);\n\n        if (_gasCost != 0) {\n            uint ethTokenPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cTokenAddr);\n            feeAmount = wdiv(_gasCost, ethTokenPrice);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    /// @notice Enters the market for the collatera and borrow tokens\n    /// @param _cTokenAddrColl Collateral address we are entering the market in\n    /// @param _cTokenAddrBorrow Borrow address we are entering the market in\n    function enterMarket(address _cTokenAddrColl, address _cTokenAddrBorrow) internal {\n        address[] memory markets = new address[](2);\n        markets[0] = _cTokenAddrColl;\n        markets[1] = _cTokenAddrBorrow;\n\n        ComptrollerInterface(COMPTROLLER).enterMarkets(markets);\n    }\n\n    /// @notice Approves CToken contract to pull underlying tokens from the DSProxy\n    /// @param _tokenAddr Token we are trying to approve\n    /// @param _cTokenAddr Address which will gain the approval\n    function approveCToken(address _tokenAddr, address _cTokenAddr) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeApprove(_cTokenAddr, uint(-1));\n        }\n    }\n\n    /// @notice Returns the underlying address of the cToken asset\n    /// @param _cTokenAddress cToken address\n    /// @return Token address of the cToken specified\n    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n        if (_cTokenAddress == CETH_ADDRESS) {\n            return ETH_ADDRESS;\n        } else {\n            return CTokenInterface(_cTokenAddress).underlying();\n        }\n    }\n\n    /// @notice Returns the owner of the DSProxy that called the contract\n    function getUserAddress() internal view returns (address) {\n        DSProxy proxy = DSProxy(uint160(address(this)));\n\n        return proxy.owner();\n    }\n\n    /// @notice Returns the maximum amount of collateral available to withdraw\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cCollAddress Collateral we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. collateral amount in that token\n    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n\n        if (liquidityInEth == 0) return usersBalance;\n\n        CTokenInterface(_cCollAddress).accrueInterest();\n\n        if (_cCollAddress == CETH_ADDRESS) {\n            if (liquidityInEth > usersBalance) return usersBalance;\n\n            return sub(liquidityInEth, (liquidityInEth / 100));\n        }\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cCollAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        if (liquidityInToken > usersBalance) return usersBalance;\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n\n    /// @notice Returns the maximum amount of borrow amount available\n    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n    /// @param _cBorrowAddress Borrow token we are getting the max value of\n    /// @param _account Users account\n    /// @return Returns the max. borrow amount in that token\n    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n        (, uint liquidityInEth, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n\n        CTokenInterface(_cBorrowAddress).accrueInterest();\n\n        if (_cBorrowAddress == CETH_ADDRESS) return sub(liquidityInEth, (liquidityInEth / 100));\n\n        uint ethPrice = CompoundOracleInterface(COMPOUND_ORACLE).getUnderlyingPrice(_cBorrowAddress);\n        uint liquidityInToken = wdiv(liquidityInEth, ethPrice);\n\n        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n    }\n}\n"
    },
    "contracts/compound/create/CompoundCreateReceiver.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSProxy.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../exchange/SaverExchangeCore.sol\";\nimport \"../../shifter/ShifterRegistry.sol\";\n\n/// @title Contract that receives the FL from Aave for Creating loans\ncontract CompoundCreateReceiver is FlashLoanReceiverBase, SaverExchangeCore {\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0xaD888d0Ade988EbEe74B8D4F39BF29a8d0fe8A8D);\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() public FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) {}\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (address payable proxyAddr, bytes memory proxyData, ExchangeData memory exchangeData)\n                                 = packFunctionCall(_amount, _fee, _params);\n\n        // Swap\n        (, uint sellAmount) = _sell(exchangeData);\n\n        // DFS fee\n        getFee(sellAmount, exchangeData.destAddr, proxyAddr);\n\n        // Send amount to DSProxy\n        sendToProxy(proxyAddr, exchangeData.destAddr);\n\n        address compOpenProxy = shifterRegistry.getAddr(\"COMP_SHIFTER\");\n\n        // Execute the DSProxy call\n        DSProxyInterface(proxyAddr).execute(compOpenProxy, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            // solhint-disable-next-line avoid-tx-origin\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _amount Amount of FL\n    /// @param _fee Fee of the FL\n    /// @param _params Saver proxy params\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure  returns (address payable, bytes memory proxyData, ExchangeData memory exchangeData) {\n        (\n            uint[4] memory numData, // srcAmount, destAmount, minPrice, price0x\n            address[6] memory addrData, // cCollAddr, cDebtAddr, srcAddr, destAddr, exchangeAddr, wrapper\n            bytes memory callData,\n            address proxy\n        )\n        = abi.decode(_params, (uint256[4],address[6],bytes,address));\n\n        proxyData = abi.encodeWithSignature(\n            \"open(address,address,uint256)\",\n                                addrData[0], addrData[1], (_amount + _fee));\n\n         exchangeData = SaverExchangeCore.ExchangeData({\n            srcAddr: addrData[2],\n            destAddr: addrData[3],\n            srcAmount: numData[0],\n            destAmount: numData[1],\n            minPrice: numData[2],\n            wrapper: addrData[5],\n            exchangeAddr: addrData[4],\n            callData: callData,\n            price0x: numData[3]\n        });\n\n        return (payable(proxy), proxyData, exchangeData);\n    }\n\n    /// @notice Send the FL funds received to DSProxy\n    /// @param _proxy DSProxy address\n    /// @param _reserve Token address\n    function sendToProxy(address payable _proxy, address _reserve) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, ERC20(_reserve).balanceOf(address(this)));\n        } else {\n            _proxy.transfer(address(this).balance);\n        }\n    }\n\n    function getFee(uint _amount, address _tokenAddr, address _proxy) internal returns (uint feeAmount) {\n        uint fee = 400;\n\n        DSProxy proxy = DSProxy(payable(_proxy));\n        address user = proxy.owner();\n\n        if (Discount(DISCOUNT_ADDR).isCustomFeeSet(user)) {\n            fee = Discount(DISCOUNT_ADDR).getCustomServiceFee(user);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        if (_tokenAddr == ETH_ADDRESS) {\n            WALLET_ADDR.transfer(feeAmount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(WALLET_ADDR, feeAmount);\n        }\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external override(FlashLoanReceiverBase, SaverExchangeCore) payable {}\n}\n"
    },
    "contracts/utils/FlashLoanReceiverBase.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./SafeERC20.sol\";\n\ninterface IFlashLoanReceiver {\n    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external;\n}\n\nabstract contract ILendingPoolAddressesProvider {\n\n    function getLendingPool() public view virtual returns (address);\n    function setLendingPoolImpl(address _pool) public virtual;\n\n    function getLendingPoolCore() public virtual view returns (address payable);\n    function setLendingPoolCoreImpl(address _lendingPoolCore) public virtual;\n\n    function getLendingPoolConfigurator() public virtual view returns (address);\n    function setLendingPoolConfiguratorImpl(address _configurator) public virtual;\n\n    function getLendingPoolDataProvider() public virtual view returns (address);\n    function setLendingPoolDataProviderImpl(address _provider) public virtual;\n\n    function getLendingPoolParametersProvider() public virtual view returns (address);\n    function setLendingPoolParametersProviderImpl(address _parametersProvider) public virtual;\n\n    function getTokenDistributor() public virtual view returns (address);\n    function setTokenDistributor(address _tokenDistributor) public virtual;\n\n\n    function getFeeProvider() public virtual view returns (address);\n    function setFeeProviderImpl(address _feeProvider) public virtual;\n\n    function getLendingPoolLiquidationManager() public virtual view returns (address);\n    function setLendingPoolLiquidationManager(address _manager) public virtual;\n\n    function getLendingPoolManager() public virtual view returns (address);\n    function setLendingPoolManager(address _lendingPoolManager) public virtual;\n\n    function getPriceOracle() public virtual view returns (address);\n    function setPriceOracle(address _priceOracle) public virtual;\n\n    function getLendingRateOracle() public view virtual returns (address);\n    function setLendingRateOracle(address _lendingRateOracle) public virtual;\n}\n\nlibrary EthAddressLib {\n\n    function ethAddress() internal pure returns(address) {\n        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    }\n}\n\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\n\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    ILendingPoolAddressesProvider public addressesProvider;\n\n    constructor(ILendingPoolAddressesProvider _provider) public {\n        addressesProvider = _provider;\n    }\n\n    receive () external virtual payable {}\n\n    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {\n\n        address payable core = addressesProvider.getLendingPoolCore();\n\n        transferInternal(core,_reserve, _amount);\n    }\n\n    function transferInternal(address payable _destination, address _reserve, uint256  _amount) internal {\n        if(_reserve == EthAddressLib.ethAddress()) {\n            //solium-disable-next-line\n            _destination.call{value: _amount}(\"\");\n            return;\n        }\n\n        ERC20(_reserve).safeTransfer(_destination, _amount);\n\n\n    }\n\n    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {\n        if(_reserve == EthAddressLib.ethAddress()) {\n\n            return _target.balance;\n        }\n\n        return ERC20(_reserve).balanceOf(_target);\n\n    }\n}\n"
    },
    "contracts/shifter/ShifterRegistry.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/AdminAuth.sol\";\n\ncontract ShifterRegistry is AdminAuth {\n    mapping (string => address) public contractAddresses;\n    bool public finalized;\n\n    function changeContractAddr(string memory _contractName, address _protoAddr) public onlyOwner {\n        require(!finalized);\n        contractAddresses[_contractName] = _protoAddr;\n    }\n\n    function lock() public onlyOwner {\n        finalized = true;\n    }\n\n    function getAddr(string memory _contractName) public view returns (address contractAddr) {\n        contractAddr = contractAddresses[_contractName];\n\n        require(contractAddr != address(0), \"No contract address registred\");\n    }\n\n}\n"
    },
    "contracts/compound/create/CompoundCreateTaker.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../exchange/SaverExchangeCore.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Opens compound positions with a leverage\ncontract CompoundCreateTaker is ProxyPermission {\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    struct CreateInfo {\n        address cCollAddress;\n        address cBorrowAddress;\n        uint depositAmount;\n    }\n\n    /// @notice Main function which will take a FL and open a leverage position\n    /// @dev Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy\n    /// @param _createInfo [cCollAddress, cBorrowAddress, depositAmount]\n    /// @param _exchangeData Exchange data struct\n    function openLeveragedLoan(\n        CreateInfo memory _createInfo,\n        SaverExchangeCore.ExchangeData memory _exchangeData,\n        address payable _compReceiver\n    ) public payable {\n        uint loanAmount = _exchangeData.srcAmount;\n\n        // Pull tokens from user\n        if (_exchangeData.destAddr != ETH_ADDRESS) {\n            ERC20(_exchangeData.destAddr).safeTransferFrom(msg.sender, address(this), _createInfo.depositAmount);\n        } else {\n            require(msg.value >= _createInfo.depositAmount, \"Must send correct amount of eth\");\n        }\n\n        // Send tokens to FL receiver\n        sendDeposit(_compReceiver, _exchangeData.destAddr);\n\n        // Pack the struct data\n        (uint[4] memory numData, address[6] memory addrData, bytes memory callData)\n                                            = _packData(_createInfo, _exchangeData);\n        bytes memory paramsData = abi.encode(numData, addrData, callData, address(this));\n\n        givePermission(_compReceiver);\n\n        lendingPool.flashLoan(_compReceiver, _exchangeData.srcAddr, loanAmount, paramsData);\n\n        removePermission(_compReceiver);\n\n        logger.Log(address(this), msg.sender, \"CompoundLeveragedLoan\",\n            abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _exchangeData.destAmount));\n    }\n\n    function sendDeposit(address payable _compoundReceiver, address _token) internal {\n        if (_token != ETH_ADDRESS) {\n            ERC20(_token).safeTransfer(_compoundReceiver, ERC20(_token).balanceOf(address(this)));\n        }\n\n        _compoundReceiver.transfer(address(this).balance);\n    }\n\n    function _packData(\n        CreateInfo memory _createInfo,\n        SaverExchangeCore.ExchangeData memory exchangeData\n    ) internal pure returns (uint[4] memory numData, address[6] memory addrData, bytes memory callData) {\n\n        numData = [\n            exchangeData.srcAmount,\n            exchangeData.destAmount,\n            exchangeData.minPrice,\n            exchangeData.price0x\n        ];\n\n        addrData = [\n            _createInfo.cCollAddress,\n            _createInfo.cBorrowAddress,\n            exchangeData.srcAddr,\n            exchangeData.destAddr,\n            exchangeData.exchangeAddr,\n            exchangeData.wrapper\n        ];\n\n        callData = exchangeData.callData;\n    }\n}\n"
    },
    "contracts/compound/import/CompoundBorrowProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ComptrollerInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\ncontract CompoundBorrowProxy {\n\n    using SafeERC20 for ERC20;\n\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    function borrow(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) public {\n        address[] memory markets = new address[](2);\n        markets[0] = _cCollToken;\n        markets[1] = _cBorrowToken;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n\n        require(CTokenInterface(_cBorrowToken).borrow(_amount) == 0);\n\n        // withdraw funds to msg.sender\n        if (_borrowToken != ETH_ADDR) {\n            ERC20(_borrowToken).safeTransfer(msg.sender, ERC20(_borrowToken).balanceOf(address(this)));\n        } else {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n}\n"
    },
    "contracts/compound/import/CompoundImportFlashLoan.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Receives FL from Aave and imports the position to DSProxy\ncontract CompoundImportFlashLoan is FlashLoanReceiverBase {\n\n    using SafeERC20 for ERC20;\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address public constant COMPOUND_BORROW_PROXY = 0xb7EDC39bE76107e2Cc645f0f6a3D164f5e173Ee2;\n\n    address public owner;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n    }\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        (\n            address cCollateralToken,\n            address cBorrowToken,\n            address user,\n            address proxy\n        )\n        = abi.decode(_params, (address,address,address,address));\n\n        // approve FL tokens so we can repay them\n        ERC20(_reserve).safeApprove(cBorrowToken, uint(-1));\n\n        // repay compound debt\n        require(CTokenInterface(cBorrowToken).repayBorrowBehalf(user, uint(-1)) == 0, \"Repay borrow behalf fail\");\n\n        // transfer cTokens to proxy\n        uint cTokenBalance = CTokenInterface(cCollateralToken).balanceOf(user);\n        require(CTokenInterface(cCollateralToken).transferFrom(user, proxy, cTokenBalance));\n\n        // borrow\n        bytes memory proxyData = getProxyData(cCollateralToken, cBorrowToken, _reserve, (_amount + _fee));\n        DSProxyInterface(proxy).execute(COMPOUND_BORROW_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _cCollToken CToken address of collateral\n    /// @param _cBorrowToken CToken address we will borrow\n    /// @param _borrowToken Token address we will borrow\n    /// @param _amount Amount that will be borrowed\n    /// @return proxyData Formated function call data\n    function getProxyData(address _cCollToken, address _cBorrowToken, address _borrowToken, uint _amount) internal pure returns (bytes memory proxyData) {\n        proxyData = abi.encodeWithSignature(\n            \"borrow(address,address,address,uint256)\",\n            _cCollToken, _cBorrowToken, _borrowToken, _amount);\n    }\n\n    function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(owner == msg.sender, \"Must be owner\");\n\n        if (_tokenAddr == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n            msg.sender.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).safeTransfer(owner, _amount);\n        }\n    }\n}\n"
    },
    "contracts/compound/import/CompoundImportTaker.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\nimport \"../../loggers/FlashLoanLogger.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../interfaces/ProxyRegistryInterface.sol\";\n\nimport \"../helpers/CompoundSaverHelper.sol\";\n\n/// @title Imports Compound position from the account to DSProxy\ncontract CompoundImportTaker is CompoundSaverHelper, ProxyPermission, GasBurner {\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_IMPORT_FLASH_LOAN = 0x0a9238e14d5A20CDb03811B12D1984587C3CE9a0;\n    address public constant PROXY_REGISTRY_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n\n    // solhint-disable-next-line const-name-snakecase\n    FlashLoanLogger public constant logger = FlashLoanLogger(\n        0xb9303686B0EE92F92f63973EF85f3105329D345c\n    );\n\n    /// @notice Starts the process to move users position 1 collateral and 1 borrow\n    /// @dev User must approve COMPOUND_IMPORT_FLASH_LOAN to pull _cCollateralToken\n    /// @param _cCollateralToken Collateral we are moving to DSProxy\n    /// @param _cBorrowToken Borrow token we are moving to DSProxy\n    function importLoan(address _cCollateralToken, address _cBorrowToken) external burnGas(20) {\n        address proxy = getProxy();\n\n        uint loanAmount = CTokenInterface(_cBorrowToken).borrowBalanceCurrent(msg.sender);\n        bytes memory paramsData = abi.encode(_cCollateralToken, _cBorrowToken, msg.sender, proxy);\n\n        givePermission(COMPOUND_IMPORT_FLASH_LOAN);\n\n        lendingPool.flashLoan(COMPOUND_IMPORT_FLASH_LOAN, getUnderlyingAddr(_cBorrowToken), loanAmount, paramsData);\n\n        removePermission(COMPOUND_IMPORT_FLASH_LOAN);\n\n        logger.logFlashLoan(\"CompoundImport\", loanAmount, 0, _cCollateralToken);\n    }\n\n    /// @notice Gets proxy address, if user doesn't has DSProxy build it\n    /// @return proxy DsProxy address\n    function getProxy() internal returns (address proxy) {\n        proxy = ProxyRegistryInterface(PROXY_REGISTRY_ADDRESS).proxies(msg.sender);\n\n        if (proxy == address(0)) {\n            proxy = ProxyRegistryInterface(PROXY_REGISTRY_ADDRESS).build(msg.sender);\n        }\n\n    }\n}\n"
    },
    "contracts/loggers/FlashLoanLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract FlashLoanLogger {\n    event FlashLoan(string actionType, uint256 id, uint256 loanAmount, address sender);\n\n    function logFlashLoan(\n        string calldata _actionType,\n        uint256 _id,\n        uint256 _loanAmount,\n        address _sender\n    ) external {\n        emit FlashLoan(_actionType, _loanAmount, _id, _sender);\n    }\n}\n"
    },
    "contracts/compound/saver/CompoundFlashLoanTaker.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/GasBurner.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"./CompoundSaverProxy.sol\";\nimport \"../../loggers/FlashLoanLogger.sol\";\nimport \"../../auth/ProxyPermission.sol\";\n\n/// @title Entry point for the FL Repay Boosts, called by DSProxy\ncontract CompoundFlashLoanTaker is CompoundSaverProxy, ProxyPermission, GasBurner {\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address payable public constant COMPOUND_SAVER_FLASH_LOAN = 0xb0a59B7fC1c92c76b3c6AB52097f38611A492b1C;\n\n    // solhint-disable-next-line const-name-snakecase\n    FlashLoanLogger public constant logger = FlashLoanLogger(\n        0xb9303686B0EE92F92f63973EF85f3105329D345c\n    );\n\n    /// @notice Repays the position with it's own fund or with FL if needed\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    function repayWithLoan(\n        uint[5] calldata _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] calldata _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes calldata _callData\n    ) external payable burnGas(25) {\n        uint maxColl = getMaxCollateral(_addrData[0], address(this));\n\n        if (_data[0] <= maxColl) {\n            repay(_data, _addrData, _callData);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_data[0] - maxColl);\n            bytes memory paramsData = abi.encode(_data, _addrData, _callData, true, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_addrData[0]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.logFlashLoan(\"CompoundFlashRepay\", loanAmount, _data[0], _addrData[0]);\n        }\n    }\n\n    /// @notice Boosts the position with it's own fund or with FL if needed\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    function boostWithLoan(\n        uint[5] calldata _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] calldata _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes calldata _callData\n    ) external payable burnGas(20) {\n        uint maxBorrow = getMaxBorrow(_addrData[1], address(this));\n\n        if (_data[0] <= maxBorrow) {\n            boost(_data, _addrData, _callData);\n        } else {\n            // 0x fee\n            COMPOUND_SAVER_FLASH_LOAN.transfer(msg.value);\n\n            uint loanAmount = (_data[0] - maxBorrow);\n            bytes memory paramsData = abi.encode(_data, _addrData, _callData, false, address(this));\n\n            givePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            lendingPool.flashLoan(COMPOUND_SAVER_FLASH_LOAN, getUnderlyingAddr(_addrData[1]), loanAmount, paramsData);\n\n            removePermission(COMPOUND_SAVER_FLASH_LOAN);\n\n            logger.logFlashLoan(\"CompoundFlashBoost\", loanAmount, _data[0], _addrData[1]);\n        }\n\n    }\n\n}\n"
    },
    "contracts/compound/saver/CompoundSaverProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../mcd/saver_proxy/ExchangeHelper.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\nimport \"../helpers/CompoundSaverHelper.sol\";\n\n/// @title Contract that implements repay/boost functionality\ncontract CompoundSaverProxy is CompoundSaverHelper, ExchangeHelper {\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    /// @notice Withdraws collateral, converts to borrowed token and repays debt\n    /// @dev Called through the DSProxy\n    /// @param _data Amount and exchange data for the repay [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData Coll/Debt addresses [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x calldata info\n    function repay(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData\n    ) public payable {\n        enterMarket(_addrData[0], _addrData[1]);\n\n        address payable user = address(uint160(getUserAddress()));\n\n        uint maxColl = getMaxCollateral(_addrData[0], address(this));\n\n        uint collAmount = (_data[0] > maxColl) ? maxColl : _data[0];\n\n        require(CTokenInterface(_addrData[0]).redeemUnderlying(collAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_addrData[0]);\n        address borrowToken = getUnderlyingAddr(_addrData[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            swapAmount = swap(\n                [collAmount, _data[1], _data[2], _data[4]], // collAmount, minPrice, exchangeType, 0xPrice\n                collToken,\n                borrowToken,\n                _addrData[2],\n                _callData\n            );\n\n            swapAmount -= getFee(swapAmount, user, _data[3], _addrData[1]);\n        } else {\n            swapAmount = collAmount;\n            swapAmount -= getGasCost(swapAmount, _data[3], _addrData[1]);\n        }\n\n        paybackDebt(swapAmount, _addrData[1], borrowToken, user);\n\n        // handle 0x fee\n        user.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundRepay\", abi.encode(_data[0], swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Borrows token, converts to collateral, and adds to position\n    /// @dev Called through the DSProxy\n    /// @param _data Amount and exchange data for the boost [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData Coll/Debt addresses [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x calldata info\n    function boost(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData\n    ) public payable {\n        enterMarket(_addrData[0], _addrData[1]);\n\n        address payable user = address(uint160(getUserAddress()));\n\n        uint maxBorrow = getMaxBorrow(_addrData[1], address(this));\n        uint borrowAmount = (_data[0] > maxBorrow) ? maxBorrow : _data[0];\n\n        require(CTokenInterface(_addrData[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_addrData[0]);\n        address borrowToken = getUnderlyingAddr(_addrData[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            borrowAmount -= getFee(borrowAmount, user, _data[3], _addrData[1]);\n\n            swapAmount = swap(\n                [borrowAmount, _data[1], _data[2], _data[4]], // collAmount, minPrice, exchangeType, 0xPrice\n                borrowToken,\n                collToken,\n                _addrData[2],\n                _callData\n            );\n        } else {\n            swapAmount = borrowAmount;\n            swapAmount -= getGasCost(swapAmount, _data[3], _addrData[1]);\n        }\n\n        approveCToken(collToken, _addrData[0]);\n\n        if (collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_addrData[0]).mint(swapAmount) == 0);\n        } else {\n            CEtherInterface(_addrData[0]).mint{value: swapAmount}(); // reverts on fail\n        }\n\n        // handle 0x fee\n        user.transfer(address(this).balance);\n\n        // log amount, collToken, borrowToken\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundBoost\", abi.encode(_data[0], swapAmount, collToken, borrowToken));\n    }\n\n}\n"
    },
    "contracts/mcd/saver_proxy/ExchangeHelper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ExchangeInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../interfaces/SaverExchangeInterface.sol\";\n\nimport \"../../constants/ConstantAddressesExchange.sol\";\nimport \"../../utils/ZrxAllowlist.sol\";\n\nimport \"../../utils/SafeERC20.sol\";\n\n/// @title Helper methods for integration with SaverExchange\ncontract ExchangeHelper is ConstantAddressesExchange {\n\n    using SafeERC20 for ERC20;\n\n    address public constant ZRX_ALLOWLIST_ADDR = 0x019739e288973F92bDD3c1d87178E206E51fd911;\n\n    /// @notice Swaps 2 tokens on the Saver Exchange\n    /// @dev ETH is sent with Weth address\n    /// @param _data [amount, minPrice, exchangeType, 0xPrice]\n    /// @param _src Token address of the source token\n    /// @param _dest Token address of the destination token\n    /// @param _exchangeAddress Address of 0x exchange that should be called\n    /// @param _callData data to call 0x exchange with\n    function swap(uint[4] memory _data, address _src, address _dest, address _exchangeAddress, bytes memory _callData) internal returns (uint) {\n        address wrapper;\n        uint price;\n        // [tokensReturned, tokensLeft]\n        uint[2] memory tokens;\n        bool success;\n\n        // tokensLeft is equal to amount at the beginning\n        tokens[1] = _data[0];\n\n        _src = wethToKyberEth(_src);\n        _dest = wethToKyberEth(_dest);\n\n        // use this to avoid stack too deep error\n        address[3] memory orderAddresses = [_exchangeAddress, _src, _dest];\n\n        // if _data[2] == 4 use 0x if possible\n        if (_data[2] == 4) {\n            if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n                ERC20(orderAddresses[1]).approve(address(ERC20_PROXY_0X), _data[0]);\n            }\n\n            (success, tokens[0], ) = takeOrder(orderAddresses, _callData, address(this).balance, _data[0]);\n\n            // if specifically 4, then require it to be successfull\n            require(success && tokens[0] > 0, \"0x transaction failed\");\n        }\n\n        if (tokens[0] == 0) {\n            (wrapper, price) = SaverExchangeInterface(SAVER_EXCHANGE_ADDRESS).getBestPrice(_data[0], orderAddresses[1], orderAddresses[2], _data[2]);\n\n            require(price > _data[1] || _data[3] > _data[1], \"Slippage hit\");\n\n            // handle 0x exchange, if equal price, try 0x to use less gas\n            if (_data[3] >= price) {\n                if (orderAddresses[1] != KYBER_ETH_ADDRESS) {\n                    ERC20(orderAddresses[1]).approve(address(ERC20_PROXY_0X), _data[0]);\n                }\n\n                // when selling eth its possible that some eth isn't sold and it is returned back\n                (success, tokens[0], tokens[1]) = takeOrder(orderAddresses, _callData, address(this).balance, _data[0]);\n            }\n\n            // if there are more tokens left, try to sell them on other exchanges\n            if (tokens[1] > 0) {\n                // as it stands today, this can happend only when selling ETH\n                if (tokens[1] != _data[0]) {\n                    (wrapper, price) = SaverExchangeInterface(SAVER_EXCHANGE_ADDRESS).getBestPrice(tokens[1], orderAddresses[1], orderAddresses[2], _data[2]);\n                }\n\n                require(price > _data[1], \"Slippage hit onchain price\");\n\n                if (orderAddresses[1] == KYBER_ETH_ADDRESS) {\n                    uint tRet;\n                    (tRet,) = ExchangeInterface(wrapper).swapEtherToToken{value: tokens[1]}(tokens[1], orderAddresses[2], uint(-1));\n                    tokens[0] += tRet;\n                } else {\n                    ERC20(orderAddresses[1]).safeTransfer(wrapper, tokens[1]);\n\n                    if (orderAddresses[2] == KYBER_ETH_ADDRESS) {\n                        tokens[0] += ExchangeInterface(wrapper).swapTokenToEther(orderAddresses[1], tokens[1], uint(-1));\n                    } else {\n                        tokens[0] += ExchangeInterface(wrapper).swapTokenToToken(orderAddresses[1], orderAddresses[2], tokens[1]);\n                    }\n                }\n            }\n        }\n\n        return tokens[0];\n    }\n\n    // @notice Takes order from 0x and returns bool indicating if it is successful\n    // @param _addresses [exchange, src, dst]\n    // @param _data Data to send with call\n    // @param _value Value to send with call\n    // @param _amount Amount to sell\n    function takeOrder(address[3] memory _addresses, bytes memory _data, uint _value, uint _amount) private returns(bool, uint, uint) {\n        bool success;\n\n        if (ZrxAllowlist(ZRX_ALLOWLIST_ADDR).isZrxAddr(_addresses[0])) {\n            (success, ) = _addresses[0].call{value: _value}(_data);\n        } else {\n            success = false;\n        }\n\n        uint tokensLeft = _amount;\n        uint tokensReturned = 0;\n        if (success){\n            // check how many tokens left from _src\n            if (_addresses[1] == KYBER_ETH_ADDRESS) {\n                tokensLeft = address(this).balance;\n            } else {\n                tokensLeft = ERC20(_addresses[1]).balanceOf(address(this));\n            }\n\n            // check how many tokens are returned\n            if (_addresses[2] == KYBER_ETH_ADDRESS) {\n                TokenInterface(WETH_ADDRESS).withdraw(TokenInterface(WETH_ADDRESS).balanceOf(address(this)));\n                tokensReturned = address(this).balance;\n            } else {\n                tokensReturned = ERC20(_addresses[2]).balanceOf(address(this));\n            }\n        }\n\n        return (success, tokensReturned, tokensLeft);\n    }\n\n    /// @notice Converts WETH -> Kybers Eth address\n    /// @param _src Input address\n    function wethToKyberEth(address _src) internal pure returns (address) {\n        return _src == WETH_ADDRESS ? KYBER_ETH_ADDRESS : _src;\n    }\n}\n"
    },
    "contracts/interfaces/ExchangeInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\n//TODO: currenlty only adjusted to kyber, but should be genric interfaces for more dec. exchanges\ninterface ExchangeInterface {\n    function swapEtherToToken(uint256 _ethAmount, address _tokenAddress, uint256 _maxAmount)\n        external\n        payable\n        returns (uint256, uint256);\n\n    function swapTokenToEther(address _tokenAddress, uint256 _amount, uint256 _maxAmount)\n        external\n        returns (uint256);\n\n    function swapTokenToToken(address _src, address _dest, uint256 _amount)\n        external\n        payable\n        returns (uint256);\n\n    function getExpectedRate(address src, address dest, uint256 srcQty)\n        external\n        view\n        returns (uint256 expectedRate);\n}\n"
    },
    "contracts/interfaces/SaverExchangeInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract SaverExchangeInterface {\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        uint256 _exchangeType\n    ) public view virtual returns (address, uint256);\n}\n"
    },
    "contracts/constants/ConstantAddressesExchange.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ConstantAddressesExchangeMainnet.sol\";\nimport \"./ConstantAddressesExchangeKovan.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ncontract ConstantAddressesExchange is ConstantAddressesExchangeMainnet {}\n"
    },
    "contracts/constants/ConstantAddressesExchangeMainnet.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract ConstantAddressesExchangeMainnet {\n    address public constant MAKER_DAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant MKR_ADDRESS = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant LOGGER_ADDRESS = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n    address public constant SAVER_EXCHANGE_ADDRESS = 0x50C6e7fe2139F5413e9e8128a84c81363C02666f;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public constant PROXY_ACTIONS = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\n\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant ETH_JOIN_ADDRESS = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\n    address public constant MIGRATION_ACTIONS_PROXY = 0xe4B22D484958E582098A98229A24e8A43801b674;\n\n    address public constant SAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address payable public constant SCD_MCD_MIGRATION = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n    address public constant NEW_IDAI_ADDRESS = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;\n}\n"
    },
    "contracts/constants/ConstantAddressesExchangeKovan.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract ConstantAddressesExchangeKovan {\n    address public constant MAKER_DAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant MKR_ADDRESS = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;\n    address public constant WETH_ADDRESS = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;\n    address payable public constant WALLET_ID = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;\n    address public constant LOGGER_ADDRESS = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;\n    address public constant DISCOUNT_ADDRESS = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;\n\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000170CcC93903185bE5A2094C870Df62;\n    address public constant SAVER_EXCHANGE_ADDRESS = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x1476483dD8C35F25e568113C5f70249D3976ba21;\n    address public constant VAT_ADDRESS = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;\n    address public constant SPOTTER_ADDRESS = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;\n    address public constant PROXY_ACTIONS = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;\n\n    address public constant JUG_ADDRESS = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;\n    address public constant DAI_JOIN_ADDRESS = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;\n    address public constant ETH_JOIN_ADDRESS = 0x775787933e92b709f2a3C70aa87999696e74A9F8;\n    address public constant MIGRATION_ACTIONS_PROXY = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;\n\n    address public constant SAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n    address public constant DAI_ADDRESS = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;\n\n    address payable public constant SCD_MCD_MIGRATION = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;\n\n    // Our contracts\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n    address public constant NEW_IDAI_ADDRESS = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;\n}\n"
    },
    "contracts/compound/saver/CompoundSaverFlashLoan.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/FlashLoanReceiverBase.sol\";\nimport \"../../interfaces/DSProxyInterface.sol\";\n\n/// @title Contract that receives the FL from Aave for Repays/Boost\ncontract CompoundSaverFlashLoan is FlashLoanReceiverBase {\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address payable public COMPOUND_SAVER_FLASH_PROXY = 0xe12A042b5Fc0cc2B8e598b36C4E87d8b723eB5ca;\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address public owner;\n\n    using SafeERC20 for ERC20;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n    }\n\n    /// @notice Called by Aave when sending back the FL amount\n    /// @param _reserve The address of the borrowed token\n    /// @param _amount Amount of FL tokens received\n    /// @param _fee FL Aave fee\n    /// @param _params The params that are sent from the original FL caller contract\n   function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (bytes memory proxyData, address payable proxyAddr) = packFunctionCall(_amount, _fee, _params);\n\n        // Send Flash loan amount to DSProxy\n        sendLoanToProxy(proxyAddr, _reserve, _amount);\n\n        // Execute the DSProxy call\n        DSProxyInterface(proxyAddr).execute(COMPOUND_SAVER_FLASH_PROXY, proxyData);\n\n        // Repay the loan with the money DSProxy sent back\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Formats function data call so we can call it through DSProxy\n    /// @param _amount Amount of FL\n    /// @param _fee Fee of the FL\n    /// @param _params Saver proxy params\n    /// @return proxyData Formated function call data\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params) internal pure returns (bytes memory proxyData, address payable) {\n        (\n            uint[5] memory data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n            address[3] memory addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n            bytes memory callData,\n            bool isRepay,\n            address payable proxyAddr\n        )\n        = abi.decode(_params, (uint256[5],address[3],bytes,bool,address));\n\n        uint[2] memory flashLoanData = [_amount, _fee];\n\n        if (isRepay) {\n            proxyData = abi.encodeWithSignature(\"flashRepay(uint256[5],address[3],bytes,uint256[2])\", data, addrData, callData, flashLoanData);\n        } else {\n            proxyData = abi.encodeWithSignature(\"flashBoost(uint256[5],address[3],bytes,uint256[2])\", data, addrData, callData, flashLoanData);\n        }\n\n        return (proxyData, proxyAddr);\n    }\n\n    /// @notice Send the FL funds received to DSProxy\n    /// @param _proxy DSProxy address\n    /// @param _reserve Token address\n    /// @param _amount Amount of tokens\n    function sendLoanToProxy(address payable _proxy, address _reserve, uint _amount) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\n        }\n\n        _proxy.transfer(address(this).balance);\n    }\n\n    receive() external override payable {}\n}\n"
    },
    "contracts/compound/saver/CompoundSaverFlashProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../mcd/saver_proxy/ExchangeHelper.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../mcd/Discount.sol\";\nimport \"../helpers/CompoundSaverHelper.sol\";\nimport \"../../loggers/DefisaverLogger.sol\";\n\n/// @title Implements the actual logic of Repay/Boost with FL\ncontract CompoundSaverFlashProxy is ExchangeHelper, CompoundSaverHelper  {\n\n    address public constant DEFISAVER_LOGGER = 0x5c55B921f590a89C1Ebe84dF170E655a82b62126;\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Repays the position and sends tokens back for FL\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    /// @param _flashLoanData Data about FL [amount, fee]\n    function flashRepay(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_addrData[0], _addrData[1]);\n\n        address payable user = address(uint160(getUserAddress()));\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        uint maxColl = getMaxCollateral(_addrData[0], address(this));\n\n        // draw max coll\n        require(CTokenInterface(_addrData[0]).redeemUnderlying(maxColl) == 0);\n\n        address collToken = getUnderlyingAddr(_addrData[0]);\n        address borrowToken = getUnderlyingAddr(_addrData[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // swap max coll + loanAmount\n            swapAmount = swap(\n                [(maxColl + _flashLoanData[0]), _data[1], _data[2], _data[4]], // collAmount, minPrice, exchangeType, 0xPrice\n                collToken,\n                borrowToken,\n                _addrData[2],\n                _callData\n            );\n\n            // get fee\n            swapAmount -= getFee(swapAmount, user, _data[3], _addrData[1]);\n        } else {\n            swapAmount = (maxColl + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _data[3], _addrData[1]);\n        }\n\n        // payback debt\n        paybackDebt(swapAmount, _addrData[1], borrowToken, user);\n\n        // draw collateral for loanAmount + loanFee\n        require(CTokenInterface(_addrData[0]).redeemUnderlying(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(collToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundRepay\", abi.encode(_data[0], swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Boosts the position and sends tokens back for FL\n    /// @param _data Amount and exchange data [amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _addrData cTokens addreses and exchange [cCollAddress, cBorrowAddress, exchangeAddress]\n    /// @param _callData 0x callData\n    /// @param _flashLoanData Data about FL [amount, fee]\n    function flashBoost(\n        uint[5] memory _data, // amount, minPrice, exchangeType, gasCost, 0xPrice\n        address[3] memory _addrData, // cCollAddress, cBorrowAddress, exchangeAddress\n        bytes memory _callData,\n        uint[2] memory _flashLoanData // amount, fee\n    ) public payable {\n        enterMarket(_addrData[0], _addrData[1]);\n\n        address payable user = address(uint160(getUserAddress()));\n        uint flashBorrowed = _flashLoanData[0] + _flashLoanData[1];\n\n        // borrow max amount\n        uint borrowAmount = getMaxBorrow(_addrData[1], address(this));\n        require(CTokenInterface(_addrData[1]).borrow(borrowAmount) == 0);\n\n        address collToken = getUnderlyingAddr(_addrData[0]);\n        address borrowToken = getUnderlyingAddr(_addrData[1]);\n\n        uint swapAmount = 0;\n\n        if (collToken != borrowToken) {\n            // get dfs fee\n            borrowAmount -= getFee((borrowAmount + _flashLoanData[0]), user, _data[3], _addrData[1]);\n\n            // swap borrowed amount and fl loan amount\n            swapAmount = swap(\n                [(borrowAmount + _flashLoanData[0]), _data[1], _data[2], _data[4]], // collAmount, minPrice, exchangeType, 0xPrice\n                borrowToken,\n                collToken,\n                _addrData[2],\n                _callData\n            );\n        } else {\n            swapAmount = (borrowAmount + _flashLoanData[0]);\n            swapAmount -= getGasCost(swapAmount, _data[3], _addrData[1]);\n        }\n\n        // deposit swaped collateral\n        depositCollateral(collToken, _addrData[0], swapAmount);\n\n        // borrow token to repay flash loan\n        require(CTokenInterface(_addrData[1]).borrow(flashBorrowed) == 0);\n\n        // repay flash loan\n        returnFlashLoan(borrowToken, flashBorrowed);\n\n        DefisaverLogger(DEFISAVER_LOGGER).Log(address(this), msg.sender, \"CompoundBoost\", abi.encode(_data[0], swapAmount, collToken, borrowToken));\n    }\n\n    /// @notice Helper method to deposit tokens in Compound\n    /// @param _collToken Token address of the collateral\n    /// @param _cCollToken CToken address of the collateral\n    /// @param _depositAmount Amount to deposit\n    function depositCollateral(address _collToken, address _cCollToken, uint _depositAmount) internal {\n        approveCToken(_collToken, _cCollToken);\n\n        if (_collToken != ETH_ADDRESS) {\n            require(CTokenInterface(_cCollToken).mint(_depositAmount) == 0);\n        } else {\n            CEtherInterface(_cCollToken).mint{value: _depositAmount}(); // reverts on fail\n        }\n    }\n\n    /// @notice Returns the tokens/ether to the msg.sender which is the FL contract\n    /// @param _tokenAddr Address of token which we return\n    /// @param _amount Amount to return\n    function returnFlashLoan(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr != ETH_ADDRESS) {\n            ERC20(_tokenAddr).safeTransfer(msg.sender, _amount);\n        }\n\n        msg.sender.transfer(address(this).balance);\n    }\n\n}\n"
    },
    "contracts/constants/ConstantAddresses.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ConstantAddressesMainnet.sol\";\nimport \"./ConstantAddressesKovan.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ncontract ConstantAddresses is ConstantAddressesMainnet {}\n"
    },
    "contracts/constants/ConstantAddressesMainnet.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract ConstantAddressesMainnet {\n    address public constant MAKER_DAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public constant IDAI_ADDRESS = 0x14094949152EDDBFcd073717200DA82fEd8dC960;\n    address public constant SOLO_MARGIN_ADDRESS = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n    address public constant CDAI_ADDRESS = 0xF5DCe57282A584D2746FaF1593d3121Fcac444dC;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant MKR_ADDRESS = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant VOX_ADDRESS = 0x9B0F70Df76165442ca6092939132bBAEA77f2d7A;\n    address public constant PETH_ADDRESS = 0xf53AD2c6851052A81B42133467480961B2321C09;\n    address public constant TUB_ADDRESS = 0x448a5065aeBB8E423F0896E6c5D525C040f59af3;\n    address payable public constant WALLET_ID = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n    address public constant LOGGER_ADDRESS = 0xeCf88e1ceC2D2894A0295DB3D86Fe7CE4991E6dF;\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    address public constant DISCOUNT_ADDRESS = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n\n    address public constant KYBER_WRAPPER = 0x8F337bD3b7F2b05d9A8dC8Ac518584e833424893;\n    address public constant UNISWAP_WRAPPER = 0x1e30124FDE14533231216D95F7798cD0061e5cf8;\n    address public constant ETH2DAI_WRAPPER = 0xd7BBB1777E13b6F535Dec414f575b858ed300baF;\n    address public constant OASIS_WRAPPER = 0x9aBE2715D2d99246269b8E17e9D1b620E9bf6558;\n\n    address public constant KYBER_INTERFACE = 0x818E6FECD516Ecc3849DAf6845e3EC868087B755;\n    address public constant UNISWAP_FACTORY = 0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95;\n    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n    address public constant PIP_INTERFACE_ADDRESS = 0x729D19f657BD0614b4985Cf1D82531c67569197B;\n\n    address public constant PROXY_REGISTRY_INTERFACE_ADDRESS = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4;\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\n\n    address public constant SAVINGS_LOGGER_ADDRESS = 0x89b3635BD2bAD145C6f92E82C9e83f06D5654984;\n    address public constant AUTOMATIC_LOGGER_ADDRESS = 0xAD32Ce09DE65971fFA8356d7eF0B783B82Fd1a9A;\n\n    address public constant SAVER_EXCHANGE_ADDRESS = 0x6eC6D98e2AF940436348883fAFD5646E9cdE2446;\n\n    // Kovan addresses, not used on mainnet\n    address public constant COMPOUND_DAI_ADDRESS = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;\n    address public constant STUPID_EXCHANGE = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n    address public constant VAT_ADDRESS = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B;\n    address public constant SPOTTER_ADDRESS = 0x65C79fcB50Ca1594B025960e539eD7A9a6D434A3;\n    address public constant PROXY_ACTIONS = 0x82ecD135Dce65Fbc6DbdD0e4237E0AF93FFD5038;\n\n    address public constant JUG_ADDRESS = 0x19c0976f590D67707E62397C87829d896Dc0f1F1;\n    address public constant DAI_JOIN_ADDRESS = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant ETH_JOIN_ADDRESS = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\n    address public constant MIGRATION_ACTIONS_PROXY = 0xe4B22D484958E582098A98229A24e8A43801b674;\n\n    address public constant SAI_ADDRESS = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address payable public constant SCD_MCD_MIGRATION = 0xc73e0383F3Aff3215E6f04B0331D58CeCf0Ab849;\n\n    // Our contracts\n    address public constant SUBSCRIPTION_ADDRESS = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\n    address public constant MONITOR_ADDRESS = 0x3F4339816EDEF8D3d3970DB2993e2e0Ec6010760;\n\n    address public constant NEW_CDAI_ADDRESS = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\n    address public constant NEW_IDAI_ADDRESS = 0x493C57C4763932315A328269E1ADaD09653B9081;\n\n    address public constant ERC20_PROXY_0X = 0x95E6F48254609A6ee006F7D493c8e5fB97094ceF;\n}\n"
    },
    "contracts/constants/ConstantAddressesKovan.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract ConstantAddressesKovan {\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;\n    address public constant MAKER_DAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n    address public constant MKR_ADDRESS = 0xAaF64BFCC32d0F15873a02163e7E500671a4ffcD;\n    address public constant VOX_ADDRESS = 0xBb4339c0aB5B1d9f14Bd6e3426444A1e9d86A1d9;\n    address public constant PETH_ADDRESS = 0xf4d791139cE033Ad35DB2B2201435fAd668B1b64;\n    address public constant TUB_ADDRESS = 0xa71937147b55Deb8a530C7229C442Fd3F31b7db2;\n    address public constant LOGGER_ADDRESS = 0x32d0e18f988F952Eb3524aCE762042381a2c39E5;\n    address payable public constant WALLET_ID = 0x54b44C6B18fc0b4A1010B21d524c338D1f8065F6;\n    address public constant OTC_ADDRESS = 0x4A6bC4e803c62081ffEbCc8d227B5a87a58f1F8F;\n    address public constant COMPOUND_DAI_ADDRESS = 0x25a01a05C188DaCBCf1D61Af55D4a5B4021F7eeD;\n    address public constant SOLO_MARGIN_ADDRESS = 0x4EC3570cADaAEE08Ae384779B0f3A45EF85289DE;\n    address public constant IDAI_ADDRESS = 0xA1e58F3B1927743393b25f261471E1f2D3D9f0F6;\n    address public constant CDAI_ADDRESS = 0xb6b09fBffBa6A5C4631e5F7B2e3Ee183aC259c0d;\n    address public constant STUPID_EXCHANGE = 0x863E41FE88288ebf3fcd91d8Dbb679fb83fdfE17;\n    address public constant DISCOUNT_ADDRESS = 0x1297c1105FEDf45E0CF6C102934f32C4EB780929;\n    address public constant SAI_SAVER_PROXY = 0xADB7c74bCe932fC6C27ddA3Ac2344707d2fBb0E6;\n\n    address public constant KYBER_WRAPPER = 0x68c56FF0E7BBD30AF9Ad68225479449869fC1bA0;\n    address public constant UNISWAP_WRAPPER = 0x2A4ee140F05f1Ba9A07A020b07CCFB76CecE4b43;\n    address public constant ETH2DAI_WRAPPER = 0x823cde416973a19f98Bb9C96d97F4FE6C9A7238B;\n    address public constant OASIS_WRAPPER = 0x0257Ba4876863143bbeDB7847beC583e4deb6fE6;\n\n    address public constant SAVER_EXCHANGE_ADDRESS = 0xACA7d11e3f482418C324aAC8e90AaD0431f692A6;\n\n    address public constant FACTORY_ADDRESS = 0xc72E74E474682680a414b506699bBcA44ab9a930;\n    //\n    address public constant PIP_INTERFACE_ADDRESS = 0xA944bd4b25C9F186A846fd5668941AA3d3B8425F;\n    address public constant PROXY_REGISTRY_INTERFACE_ADDRESS = 0x64A436ae831C1672AE81F674CAb8B6775df3475C;\n    address public constant GAS_TOKEN_INTERFACE_ADDRESS = 0x0000000000170CcC93903185bE5A2094C870Df62;\n    address public constant KYBER_INTERFACE = 0x692f391bCc85cefCe8C237C01e1f636BbD70EA4D;\n\n    address public constant SAVINGS_LOGGER_ADDRESS = 0x2aa889D809B29c608dA99767837D189dAe12a874;\n\n    // Rinkeby, when no Kovan\n    address public constant UNISWAP_FACTORY = 0xf5D915570BC477f9B8D6C0E980aA81757A3AaC36;\n\n    // new MCD contracts\n    address public constant MANAGER_ADDRESS = 0x1476483dD8C35F25e568113C5f70249D3976ba21;\n    address public constant VAT_ADDRESS = 0xbA987bDB501d131f766fEe8180Da5d81b34b69d9;\n    address public constant SPOTTER_ADDRESS = 0x3a042de6413eDB15F2784f2f97cC68C7E9750b2D;\n\n    address public constant JUG_ADDRESS = 0xcbB7718c9F39d05aEEDE1c472ca8Bf804b2f1EaD;\n    address public constant DAI_JOIN_ADDRESS = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;\n    address public constant ETH_JOIN_ADDRESS = 0x775787933e92b709f2a3C70aa87999696e74A9F8;\n    address public constant MIGRATION_ACTIONS_PROXY = 0x433870076aBd08865f0e038dcC4Ac6450e313Bd8;\n    address public constant PROXY_ACTIONS = 0xd1D24637b9109B7f61459176EdcfF9Be56283a7B;\n\n    address public constant SAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n    address public constant DAI_ADDRESS = 0x4F96Fe3b7A6Cf9725f59d353F723c1bDb64CA6Aa;\n\n    address payable public constant SCD_MCD_MIGRATION = 0x411B2Faa662C8e3E5cF8f01dFdae0aeE482ca7b0;\n\n    // Our contracts\n    address public constant SUBSCRIPTION_ADDRESS = 0xFC41f79776061a396635aD0b9dF7a640A05063C1;\n    address public constant MONITOR_ADDRESS = 0xfC1Fc0502e90B7A3766f93344E1eDb906F8A75DD;\n\n    // TODO: find out what the\n    address public constant NEW_CDAI_ADDRESS = 0xe7bc397DBd069fC7d0109C0636d06888bb50668c;\n    address public constant NEW_IDAI_ADDRESS = 0x6c1E2B0f67e00c06c8e2BE7Dc681Ab785163fF4D;\n}\n"
    },
    "contracts/DS/DSProxyFactoryInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./DSProxy.sol\";\n\nabstract contract DSProxyFactoryInterface {\n    function build(address owner) public virtual returns (DSProxy proxy);\n}\n"
    },
    "contracts/exchange/AllowanceProxy.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../auth/AdminAuth.sol\";\nimport \"./SaverExchange.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract AllowanceProxy is AdminAuth {\n\n    using SafeERC20 for ERC20;\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // TODO: Real saver exchange address\n    SaverExchange saverExchange = SaverExchange(0x235abFAd01eb1BDa28Ef94087FBAA63E18074926);\n\n    function callSell(SaverExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        saverExchange.sell{value: msg.value}(exData, msg.sender);\n    }\n\n    function callBuy(SaverExchangeCore.ExchangeData memory exData) public payable {\n        pullAndSendTokens(exData.srcAddr, exData.srcAmount);\n\n        saverExchange.buy{value: msg.value}(exData, msg.sender);\n    }\n\n    function pullAndSendTokens(address _tokenAddr, uint _amount) internal {\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            require(msg.value >= _amount, \"msg.value smaller than amount\");\n        } else {\n            ERC20(_tokenAddr).safeTransferFrom(msg.sender, address(saverExchange), _amount);\n        }\n    }\n\n    function ownerChangeExchange(address payable _newExchange) public onlyOwner {\n        saverExchange = SaverExchange(_newExchange);\n    }\n}\n"
    },
    "contracts/exchange/SaverExchange.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/GasTokenInterface.sol\";\nimport \"./SaverExchangeCore.sol\";\nimport \"../DS/DSMath.sol\";\nimport \"../loggers/DefisaverLogger.sol\";\nimport \"../auth/AdminAuth.sol\";\nimport \"../utils/GasBurner.sol\";\nimport \"../utils/SafeERC20.sol\";\n\ncontract SaverExchange is SaverExchangeCore, AdminAuth, GasBurner {\n\n    using SafeERC20 for ERC20;\n\n    uint256 public constant SERVICE_FEE = 800; // 0.125% Fee\n\n    // solhint-disable-next-line const-name-snakecase\n    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n\n    uint public burnAmount = 10;\n\n    /// @notice Takes a src amount of tokens and converts it into the dest token\n    /// @dev Takes fee from the _srcAmount before the exchange\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    function sell(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount) {\n\n        // take fee\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint destAmount) = _sell(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeSell\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\n    }\n\n    /// @notice Takes a dest amount of tokens and converts it from the src token\n    /// @dev Send always more than needed for the swap, extra will be returned\n    /// @param exData [srcAddr, destAddr, srcAmount, destAmount, minPrice, exchangeType, exchangeAddr, callData, price0x]\n    /// @param _user User address who called the exchange\n    function buy(ExchangeData memory exData, address payable _user) public payable burnGas(burnAmount){\n\n        uint dfsFee = getFee(exData.srcAmount, exData.srcAddr);\n        exData.srcAmount = sub(exData.srcAmount, dfsFee);\n\n        // Perform the exchange\n        (address wrapper, uint srcAmount) = _buy(exData);\n\n        // send back any leftover ether or tokens\n        sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n        // log the event\n        logger.Log(address(this), msg.sender, \"ExchangeBuy\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, srcAmount, exData.destAmount));\n\n    }\n\n    /// @notice Takes a feePercentage and sends it to wallet\n    /// @param _amount Dai amount of the whole trade\n    /// @param _token Address of the token\n    /// @return feeAmount Amount in Dai owner earned on the fee\n    function getFee(uint256 _amount, address _token) internal returns (uint256 feeAmount) {\n        uint256 fee = SERVICE_FEE;\n\n        if (Discount(DISCOUNT_ADDRESS).isCustomFeeSet(msg.sender)) {\n            fee = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(msg.sender);\n        }\n\n        if (fee == 0) {\n            feeAmount = 0;\n        } else {\n            feeAmount = _amount / fee;\n            if (_token == KYBER_ETH_ADDRESS) {\n                WALLET_ID.transfer(feeAmount);\n            } else {\n                ERC20(_token).safeTransfer(WALLET_ID, feeAmount);\n            }\n        }\n    }\n\n    /// @notice Changes the amount of gas token we burn for each call\n    /// @dev Only callable by the owner\n    /// @param _newBurnAmount New amount of gas tokens to be burned\n    function changeBurnAmount(uint _newBurnAmount) public {\n        require(owner == msg.sender);\n\n        burnAmount = _newBurnAmount;\n    }\n\n}\n"
    },
    "contracts/exchange/Prices.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../DS/DSMath.sol\";\nimport \"../interfaces/TokenInterface.sol\";\nimport \"../interfaces/ExchangeInterfaceV2.sol\";\nimport \"./SaverExchangeHelper.sol\";\n\ncontract Prices is DSMath {\n\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    address public constant KYBER_WRAPPER = 0x69f822ac6A5980aB50616A035d4246dC7c8ADF7e;\n    address public constant UNISWAP_WRAPPER = 0x880A845A85F843a5c67DB2061623c6Fc3bB4c511;\n    address public constant OASIS_WRAPPER = 0xF023bC4BD9745EDd1c5D033d2B53eB68f1897D66;\n\n    // first is empty to keep the legacy order in place\n    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n\n    enum ActionType { SELL, BUY }\n\n\n    /// @notice Returns the best estimated price from 2 exchanges\n    /// @param _amount Amount of source tokens you want to exchange\n    /// @param _srcToken Address of the source token\n    /// @param _destToken Address of the destination token\n    /// @param _exchangeType Which exchange will be used\n    /// @param _type Type of action SELL|BUY\n    /// @return (address, uint) The address of the best exchange and the exchange price\n    function getBestPrice(\n        uint256 _amount,\n        address _srcToken,\n        address _destToken,\n        ExchangeType _exchangeType,\n        ActionType _type\n    ) public returns (address, uint256) {\n\n        if (_exchangeType == ExchangeType.OASIS) {\n            return (OASIS_WRAPPER, getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        if (_exchangeType == ExchangeType.KYBER) {\n            return (KYBER_WRAPPER, getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        if (_exchangeType == ExchangeType.UNISWAP) {\n            return (UNISWAP_WRAPPER, getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount, _type));\n        }\n\n        uint expectedRateKyber = getExpectedRate(KYBER_WRAPPER, _srcToken, _destToken, _amount, _type);\n        uint expectedRateUniswap = getExpectedRate(UNISWAP_WRAPPER, _srcToken, _destToken, _amount, _type);\n        uint expectedRateOasis = getExpectedRate(OASIS_WRAPPER, _srcToken, _destToken, _amount, _type);\n\n        if (_type == ActionType.SELL) {\n            return getBiggestRate(expectedRateKyber, expectedRateUniswap, expectedRateOasis);\n        } else {\n            return getSmallestRate(expectedRateKyber, expectedRateUniswap, expectedRateOasis);\n        }\n    }\n\n    /// @notice Return the expected rate from the exchange wrapper\n    /// @dev In case of Oasis/Uniswap handles the different precision tokens\n    /// @param _wrapper Address of exchange wrapper\n    /// @param _srcToken From token\n    /// @param _destToken To token\n    /// @param _amount Amount to be exchanged\n    /// @param _type Type of action SELL|BUY\n    function getExpectedRate(\n        address _wrapper,\n        address _srcToken,\n        address _destToken,\n        uint256 _amount,\n        ActionType _type\n    ) public returns (uint256) {\n        bool success;\n        bytes memory result;\n\n        if (_type == ActionType.SELL) {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getSellRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n\n        } else {\n            (success, result) = _wrapper.call(abi.encodeWithSignature(\n                \"getBuyRate(address,address,uint256)\",\n                _srcToken,\n                _destToken,\n                _amount\n            ));\n        }\n\n        if (success) {\n            return sliceUint(result, 0);\n        }\n\n        return 0;\n    }\n\n    /// @notice Finds the biggest rate between exchanges, needed for sell rate\n    /// @param _expectedRateKyber Kyber rate\n    /// @param _expectedRateUniswap Uniswap rate\n    /// @param _expectedRateOasis Oasis rate\n    function getBiggestRate(\n        uint _expectedRateKyber,\n        uint _expectedRateUniswap,\n        uint _expectedRateOasis\n    ) internal pure returns (address, uint) {\n        if (\n            (_expectedRateUniswap >= _expectedRateKyber) && (_expectedRateUniswap >= _expectedRateOasis)\n        ) {\n            return (UNISWAP_WRAPPER, _expectedRateUniswap);\n        }\n\n        if (\n            (_expectedRateKyber >= _expectedRateUniswap) && (_expectedRateKyber >= _expectedRateOasis)\n        ) {\n            return (KYBER_WRAPPER, _expectedRateKyber);\n        }\n\n        if (\n            (_expectedRateOasis >= _expectedRateKyber) && (_expectedRateOasis >= _expectedRateUniswap)\n        ) {\n            return (OASIS_WRAPPER, _expectedRateOasis);\n        }\n    }\n\n    /// @notice Finds the smallest rate between exchanges, needed for buy rate\n    /// @param _expectedRateKyber Kyber rate\n    /// @param _expectedRateUniswap Uniswap rate\n    /// @param _expectedRateOasis Oasis rate\n    function getSmallestRate(\n        uint _expectedRateKyber,\n        uint _expectedRateUniswap,\n        uint _expectedRateOasis\n    ) internal pure returns (address, uint) {\n        if (\n            (_expectedRateUniswap <= _expectedRateKyber) && (_expectedRateUniswap <= _expectedRateOasis)\n        ) {\n            return (UNISWAP_WRAPPER, _expectedRateUniswap);\n        }\n\n        if (\n            (_expectedRateKyber <= _expectedRateUniswap) && (_expectedRateKyber <= _expectedRateOasis)\n        ) {\n            return (KYBER_WRAPPER, _expectedRateKyber);\n        }\n\n        if (\n            (_expectedRateOasis <= _expectedRateKyber) && (_expectedRateOasis <= _expectedRateUniswap)\n        ) {\n            return (OASIS_WRAPPER, _expectedRateOasis);\n        }\n    }\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n\n    function sliceUint(bytes memory bs, uint256 start) internal pure returns (uint256) {\n        require(bs.length >= start + 32, \"slicing out of range\");\n\n        uint256 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n\n        return x;\n    }\n}\n"
    },
    "contracts/exchange/wrappers/KyberWrapper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/KyberNetworkProxyInterface.sol\";\nimport \"../../interfaces/ExchangeInterface.sol\";\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../DS/DSMath.sol\";\n\ncontract KyberWrapper is DSMath, ConstantAddresses, ExchangeInterfaceV2 {\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), _srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            _srcAmount,\n            destToken,\n            msg.sender,\n            uint(-1),\n            0,\n            WALLET_ID\n        );\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Kyber\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        ERC20 srcToken = ERC20(_srcAddr);\n        ERC20 destToken = ERC20(_destAddr);\n\n        uint srcAmount = 0;\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmount = srcToken.balanceOf(address(this));\n        } else {\n            srcAmount = msg.value;\n        }\n\n        KyberNetworkProxyInterface kyberNetworkProxy = KyberNetworkProxyInterface(KYBER_INTERFACE);\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcToken.safeApprove(address(kyberNetworkProxy), srcAmount);\n        }\n\n        uint destAmount = kyberNetworkProxy.trade{value: msg.value}(\n            srcToken,\n            srcAmount,\n            destToken,\n            msg.sender,\n            _destAmount,\n            0,\n            WALLET_ID\n        );\n\n        require(destAmount == _destAmount, \"Wrong dest amount\");\n\n        uint srcAmountAfter = 0;\n\n        if (_srcAddr != KYBER_ETH_ADDRESS) {\n            srcAmountAfter = srcToken.balanceOf(address(this));\n        } else {\n            srcAmountAfter = address(this).balance;\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return (srcAmount - srcAmountAfter);\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return rate Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint rate) {\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\n            .getExpectedRate(ERC20(_srcAddr), ERC20(_destAddr), _srcAmount);\n\n        // multiply with decimal difference in src token\n        rate = rate * (10**(18 - getDecimals(_srcAddr)));\n        // divide with decimal difference in dest token\n        rate = rate / (10**(18 - getDecimals(_destAddr)));\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return rate Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint rate) {\n        uint256 srcRate = getSellRate(_srcAddr, _destAddr, _destAmount);\n        uint256 srcAmount = wmul(_destAmount, srcRate);\n\n        rate = getSellRate(_destAddr, _srcAddr, srcAmount);\n\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\n        rate = rate + (rate / 30);\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        if (_srcAddr == KYBER_ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    receive() payable external {}\n\n    function getDecimals(address _token) internal view returns (uint256) {\n        if (_token == KYBER_ETH_ADDRESS) return 18;\n\n        return ERC20(_token).decimals();\n    }\n}\n"
    },
    "contracts/interfaces/KyberNetworkProxyInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract KyberNetworkProxyInterface {\n    function maxGasPrice() external virtual view returns (uint256);\n\n    function getUserCapInWei(address user) external virtual view returns (uint256);\n\n    function getUserCapInTokenWei(address user, ERC20 token) external virtual view returns (uint256);\n\n    function enabled() external virtual view returns (bool);\n\n    function info(bytes32 id) external virtual view returns (uint256);\n\n    function getExpectedRate(ERC20 src, ERC20 dest, uint256 srcQty)\n        public virtual\n        view\n        returns (uint256 expectedRate, uint256 slippageRate);\n\n    function tradeWithHint(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address walletId,\n        bytes memory hint\n    ) public virtual payable returns (uint256);\n\n    function trade(\n        ERC20 src,\n        uint256 srcAmount,\n        ERC20 dest,\n        address destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address walletId\n    ) public virtual payable returns (uint256);\n\n    function swapEtherToToken(ERC20 token, uint256 minConversionRate)\n        external virtual\n        payable\n        returns (uint256);\n\n    function swapTokenToEther(ERC20 token, uint256 tokenQty, uint256 minRate)\n        external virtual\n        payable\n        returns (uint256);\n\n    function swapTokenToToken(ERC20 src, uint256 srcAmount, ERC20 dest, uint256 minConversionRate)\n        public virtual\n        returns (uint256);\n}\n"
    },
    "contracts/exchange/wrappers/OasisTradeWrapper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../interfaces/OasisInterface.sol\";\nimport \"../../interfaces/TokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../utils/SafeERC20.sol\";\n\ncontract OasisTradeWrapper is DSMath, ExchangeInterfaceV2 {\n\n    using SafeERC20 for ERC20;\n\n    address public constant OTC_ADDRESS = 0x794e6e91555438aFc3ccF1c5076A74F42133d08D;\n    address public constant WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant KYBER_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @notice Sells a _srcAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external override payable returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, _srcAmount);\n\n        uint destAmount = OasisInterface(OTC_ADDRESS).sellAllAmount(srcAddr, _srcAmount, destAddr, 0);\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(destAmount);\n            msg.sender.transfer(destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, destAmount);\n        }\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Oasis\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        ERC20(srcAddr).safeApprove(OTC_ADDRESS, uint(-1));\n\n        uint srcAmount = OasisInterface(OTC_ADDRESS).buyAllAmount(destAddr, _destAmount, srcAddr, uint(-1));\n\n        // convert weth -> eth and send back\n        if (destAddr == WETH_ADDRESS) {\n            TokenInterface(WETH_ADDRESS).withdraw(_destAmount);\n            msg.sender.transfer(_destAmount);\n        } else {\n            ERC20(destAddr).safeTransfer(msg.sender, _destAmount);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(srcAddr);\n\n        return srcAmount;\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(OasisInterface(OTC_ADDRESS).getBuyAmount(destAddr, srcAddr, _srcAmount), _srcAmount);\n    }\n\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        address srcAddr = ethToWethAddr(_srcAddr);\n        address destAddr = ethToWethAddr(_destAddr);\n\n        return wdiv(OasisInterface(OTC_ADDRESS).getPayAmount(srcAddr, destAddr, _destAmount), _destAmount);\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n         address srcAddr = ethToWethAddr(_srcAddr);\n\n        if (srcAddr == WETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(srcAddr).safeTransfer(msg.sender, ERC20(srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n\n    receive() payable external {}\n}\n"
    },
    "contracts/interfaces/OasisInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract OasisInterface {\n    function getBuyAmount(address tokenToBuy, address tokenToPay, uint256 amountToPay)\n        external\n        virtual\n        view\n        returns (uint256 amountBought);\n\n    function getPayAmount(address tokenToPay, address tokenToBuy, uint256 amountToBuy)\n        public virtual\n        view\n        returns (uint256 amountPaid);\n\n    function sellAllAmount(address pay_gem, uint256 pay_amt, address buy_gem, uint256 min_fill_amount)\n        public virtual\n        returns (uint256 fill_amt);\n\n    function buyAllAmount(address buy_gem, uint256 buy_amt, address pay_gem, uint256 max_fill_amount)\n        public virtual\n        returns (uint256 fill_amt);\n}\n"
    },
    "contracts/exchange/wrappers/UniswapWrapper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../utils/SafeERC20.sol\";\nimport \"../../interfaces/KyberNetworkProxyInterface.sol\";\nimport \"../../interfaces/ExchangeInterfaceV2.sol\";\nimport \"../../interfaces/UniswapExchangeInterface.sol\";\nimport \"../../interfaces/UniswapFactoryInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\n\ncontract UniswapWrapper is DSMath, ConstantAddresses, ExchangeInterfaceV2 {\n\n    using SafeERC20 for ERC20;\n\n    /// @notice Sells a _srcAmount of tokens at Uniswap\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Destination amount\n    function sell(address _srcAddr, address _destAddr, uint _srcAmount) external payable override returns (uint) {\n        address uniswapExchangeAddr;\n        uint destAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\n\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferInput(_srcAmount, 1, block.timestamp + 1, msg.sender);\n        }\n        // if we are selling token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, _srcAmount);\n\n            destAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferInput(_srcAmount, 1, 1, block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        return destAmount;\n    }\n\n    /// @notice Buys a _destAmount of tokens at Uniswap\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint srcAmount\n    function buy(address _srcAddr, address _destAddr, uint _destAmount) external override payable returns(uint) {\n        address uniswapExchangeAddr;\n        uint srcAmount;\n\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n         // if we are buying ether\n        if (_destAddr == WETH_ADDRESS) {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToEthTransferOutput(_destAmount, uint(-1), block.timestamp + 1, msg.sender);\n        }\n        // if we are buying token to token\n        else {\n            uniswapExchangeAddr = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n\n            ERC20(_srcAddr).safeApprove(uniswapExchangeAddr, uint(-1));\n\n            srcAmount = UniswapExchangeInterface(uniswapExchangeAddr).\n                tokenToTokenTransferOutput(_destAmount, uint(-1), uint(-1), block.timestamp + 1, msg.sender, _destAddr);\n        }\n\n        // Send the leftover from the source token back\n        sendLeftOver(_srcAddr);\n\n        return srcAmount;\n    }\n\n    /// @notice Return a rate for which we can sell an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _srcAmount From amount\n    /// @return uint Rate\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        if(_srcAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenInputPrice(_srcAmount), _srcAmount);\n        } else if (_destAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthInputPrice(_srcAmount), _srcAmount);\n        } else {\n            uint ethBought = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getTokenToEthInputPrice(_srcAmount);\n            return wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getEthToTokenInputPrice(ethBought), _srcAmount);\n        }\n    }\n\n    /// @notice Return a rate for which we can buy an amount of tokens\n    /// @param _srcAddr From token\n    /// @param _destAddr To token\n    /// @param _destAmount To amount\n    /// @return uint Rate\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount) public override view returns (uint) {\n        _srcAddr = ethToWethAddr(_srcAddr);\n        _destAddr = ethToWethAddr(_destAddr);\n\n        if(_srcAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getEthToTokenOutputPrice(_destAmount), _destAmount);\n        } else if (_destAddr == WETH_ADDRESS) {\n            address uniswapTokenAddress = UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr);\n            return wdiv(UniswapExchangeInterface(uniswapTokenAddress).getTokenToEthOutputPrice(_destAmount), _destAmount);\n        } else {\n            uint ethNeeded = UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_destAddr)).getTokenToEthOutputPrice(_destAmount);\n            return wdiv(UniswapExchangeInterface(UniswapFactoryInterface(UNISWAP_FACTORY).getExchange(_srcAddr)).getEthToTokenOutputPrice(ethNeeded), _destAmount);\n        }\n    }\n\n    /// @notice Send any leftover tokens, we use to clear out srcTokens after buy\n    /// @param _srcAddr Source token address\n    function sendLeftOver(address _srcAddr) internal {\n        if (_srcAddr == WETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(_srcAddr).safeTransfer(msg.sender, ERC20(_srcAddr).balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Converts Kybers Eth address -> Weth\n    /// @param _src Input address\n    function ethToWethAddr(address _src) internal pure returns (address) {\n        return _src == KYBER_ETH_ADDRESS ? WETH_ADDRESS : _src;\n    }\n\n    receive() payable external {}\n}\n"
    },
    "contracts/interfaces/UniswapExchangeInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract UniswapExchangeInterface {\n    function getEthToTokenInputPrice(uint256 eth_sold)\n        external virtual\n        view\n        returns (uint256 tokens_bought);\n\n    function getEthToTokenOutputPrice(uint256 tokens_bought)\n        external virtual\n        view\n        returns (uint256 eth_sold);\n\n    function getTokenToEthInputPrice(uint256 tokens_sold)\n        external virtual\n        view\n        returns (uint256 eth_bought);\n\n    function getTokenToEthOutputPrice(uint256 eth_bought)\n        external virtual\n        view\n        returns (uint256 tokens_sold);\n\n    function tokenToEthTransferInput(\n        uint256 tokens_sold,\n        uint256 min_eth,\n        uint256 deadline,\n        address recipient\n    ) external virtual returns (uint256 eth_bought);\n\n    function ethToTokenTransferInput(uint256 min_tokens, uint256 deadline, address recipient)\n        external virtual\n        payable\n        returns (uint256 tokens_bought);\n\n    function tokenToTokenTransferInput(\n        uint256 tokens_sold,\n        uint256 min_tokens_bought,\n        uint256 min_eth_bought,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external virtual returns (uint256 tokens_bought);\n\n    function ethToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 deadline,\n        address recipient\n    ) external virtual payable returns (uint256  eth_sold);\n\n    function tokenToEthTransferOutput(\n        uint256 eth_bought,\n        uint256 max_tokens,\n        uint256 deadline,\n        address recipient\n    ) external virtual returns (uint256  tokens_sold);\n\n    function tokenToTokenTransferOutput(\n        uint256 tokens_bought,\n        uint256 max_tokens_sold,\n        uint256 max_eth_sold,\n        uint256 deadline,\n        address recipient,\n        address token_addr\n    ) external virtual returns (uint256  tokens_sold);\n\n}\n"
    },
    "contracts/interfaces/UniswapFactoryInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract UniswapFactoryInterface {\n    function getExchange(address token) external view virtual returns (address exchange);\n}\n"
    },
    "contracts/interfaces/ILoanShifter.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract ILoanShifter {\n    function getLoanAmount(uint, address) public view virtual returns(uint);\n    function getUnderlyingAsset(address _addr) public view virtual returns (address);\n}\n"
    },
    "contracts/interfaces/ITokenInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ITokenInterface is ERC20 {\n    function assetBalanceOf(address _owner) public virtual view returns (uint256);\n\n    function mint(address receiver, uint256 depositAmount) external virtual returns (uint256 mintAmount);\n\n    function burn(address receiver, uint256 burnAmount) external virtual returns (uint256 loanAmountPaid);\n\n    function tokenPrice() public virtual view returns (uint256 price);\n}\n"
    },
    "contracts/interfaces/Osm.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract Osm {\n    mapping(address => uint256) public bud;\n\n    function peep() external view virtual returns (bytes32, bool);\n}\n"
    },
    "contracts/interfaces/OsmMom.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract OsmMom {\n    mapping (bytes32 => address) public osms;\n}\n"
    },
    "contracts/interfaces/OtcInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract OtcInterface {\n    function buyAllAmount(address, uint256, address, uint256) public virtual returns (uint256);\n\n    function getPayAmount(address, address, uint256) public virtual view returns (uint256);\n\n    function getBuyAmount(address, address, uint256) public virtual view returns (uint256);\n}\n"
    },
    "contracts/interfaces/PipInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract PipInterface {\n    function read() public virtual returns (bytes32);\n}\n"
    },
    "contracts/loggers/ActionLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\ncontract ActionLogger {\n    event Log(string indexed _type, address indexed owner, uint256 _first, uint256 _second);\n\n    function logEvent(string memory _type, address _owner, uint256 _first, uint256 _second) public {\n        emit Log(_type, _owner, _first, _second);\n    }\n}\n"
    },
    "contracts/loggers/AutomaticLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract AutomaticLogger {\n    event CdpRepay(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio, address logger);\n    event CdpBoost(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio, address logger);\n\n    function logRepay(uint cdpId, address caller, uint amount, uint beforeRatio, uint afterRatio) public {\n        emit CdpRepay(cdpId, caller, amount, beforeRatio, afterRatio, msg.sender);\n    }\n\n    function logBoost(uint cdpId, address caller, uint amount, uint beforeRatio, uint afterRatio) public {\n        emit CdpBoost(cdpId, caller, amount, beforeRatio, afterRatio, msg.sender);\n    }\n}\n"
    },
    "contracts/loggers/CompoundLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract CompoundLogger {\n    event Repay(\n        address indexed owner,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        address collAddr,\n        address borrowAddr\n    );\n\n    event Boost(\n        address indexed owner,\n        uint256 borrowAmount,\n        uint256 collateralAmount,\n        address collAddr,\n        address borrowAddr\n    );\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogRepay(address _owner, uint256 _collateralAmount, uint256 _borrowAmount, address _collAddr, address _borrowAddr)\n        public\n    {\n        emit Repay(_owner, _collateralAmount, _borrowAmount, _collAddr, _borrowAddr);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogBoost(address _owner, uint256 _borrowAmount, uint256 _collateralAmount, address _collAddr, address _borrowAddr)\n        public\n    {\n        emit Boost(_owner, _borrowAmount, _collateralAmount, _collAddr, _borrowAddr);\n    }\n}\n"
    },
    "contracts/loggers/ExchangeLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract ExchangeLogger {\n    event Swap(\n        address src,\n        address dest,\n        uint256 amountSold,\n        uint256 amountBought,\n        address wrapper\n    );\n\n    function logSwap(\n        address _src,\n        address _dest,\n        uint256 _amountSold,\n        uint256 _amountBought,\n        address _wrapper\n    ) public {\n        emit Swap(_src, _dest, _amountSold, _amountBought, _wrapper);\n    }\n}\n"
    },
    "contracts/loggers/SaverLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract SaverLogger {\n    event Repay(\n        uint256 indexed cdpId,\n        address indexed owner,\n        uint256 collateralAmount,\n        uint256 daiAmount\n    );\n    event Boost(\n        uint256 indexed cdpId,\n        address indexed owner,\n        uint256 daiAmount,\n        uint256 collateralAmount\n    );\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogRepay(uint256 _cdpId, address _owner, uint256 _collateralAmount, uint256 _daiAmount)\n        public\n    {\n        emit Repay(_cdpId, _owner, _collateralAmount, _daiAmount);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function LogBoost(uint256 _cdpId, address _owner, uint256 _daiAmount, uint256 _collateralAmount)\n        public\n    {\n        emit Boost(_cdpId, _owner, _daiAmount, _collateralAmount);\n    }\n}\n"
    },
    "contracts/mcd/automatic/ISubscriptions.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./Static.sol\";\n\nabstract contract ISubscriptions is Static {\n\n    function canCall(Method _method, uint _cdpId) external virtual view returns(bool, uint);\n    function getOwner(uint _cdpId) external virtual view returns(address);\n    function ratioGoodAfter(Method _method, uint _cdpId) external virtual view returns(bool, uint);\n    function getRatio(uint _cdpId) public view virtual returns (uint);\n    function getSubscribedInfo(uint _cdpId) public virtual view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\n    function unsubscribeIfMoved(uint _cdpId) public virtual;\n}\n"
    },
    "contracts/mcd/automatic/Static.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/// @title Implements enum Method\ncontract Static {\n\n    enum Method { Boost, Repay }\n}\n"
    },
    "contracts/mcd/automatic/MCDMonitor.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./ISubscriptions.sol\";\nimport \"./Static.sol\";\nimport \"./MCDMonitorProxy.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../interfaces/GasTokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\n\n/// @title Implements logic that allows bots to call Boost and Repay\ncontract MCDMonitor is ConstantAddresses, DSMath, Static {\n\n    uint constant public REPAY_GAS_TOKEN = 30;\n    uint constant public BOOST_GAS_TOKEN = 19;\n\n    uint constant public MAX_GAS_PRICE = 40000000000; // 40 gwei\n\n    uint public REPAY_GAS_COST = 1800000;\n    uint public BOOST_GAS_COST = 1250000;\n\n    MCDMonitorProxy public monitorProxyContract;\n    ISubscriptions public subscriptionsContract;\n    GasTokenInterface gasToken = GasTokenInterface(GAS_TOKEN_INTERFACE_ADDRESS);\n    address public owner;\n    address public mcdSaverProxyAddress;\n\n    /// @dev Addresses that are able to call methods for repay and boost\n    mapping(address => bool) public approvedCallers;\n\n    event CdpRepay(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio);\n    event CdpBoost(uint indexed cdpId, address indexed caller, uint amount, uint beforeRatio, uint afterRatio);\n\n    modifier onlyApproved() {\n        require(approvedCallers[msg.sender]);\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    constructor(address _monitorProxy, address _subscriptions, address _mcdSaverProxyAddress) public {\n        approvedCallers[msg.sender] = true;\n        owner = msg.sender;\n\n        monitorProxyContract = MCDMonitorProxy(_monitorProxy);\n        subscriptionsContract = ISubscriptions(_subscriptions);\n        mcdSaverProxyAddress = _mcdSaverProxyAddress;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _cdpId Id of the cdp\n    /// @param _amount Amount of Eth to convert to Dai\n    /// @param _exchangeType Which exchange to use, 0 is to select best one\n    /// @param _collateralJoin Address of collateral join for specific CDP\n    function repayFor(uint _cdpId, uint _amount, address _collateralJoin, uint _exchangeType) public onlyApproved {\n        if (gasToken.balanceOf(address(this)) >= BOOST_GAS_TOKEN) {\n            gasToken.free(BOOST_GAS_TOKEN);\n        }\n\n\n        uint ratioBefore;\n        bool canCall;\n        (canCall, ratioBefore) = subscriptionsContract.canCall(Method.Repay, _cdpId);\n        require(canCall);\n\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\n\n        monitorProxyContract.callExecute(subscriptionsContract.getOwner(_cdpId), mcdSaverProxyAddress, abi.encodeWithSignature(\"repay(uint256,address,uint256,uint256,uint256,uint256)\", _cdpId, _collateralJoin, _amount, 0, _exchangeType, gasCost));\n\n        uint ratioAfter;\n        bool ratioGoodAfter;\n        (ratioGoodAfter, ratioAfter) = subscriptionsContract.ratioGoodAfter(Method.Repay, _cdpId);\n        // doesn't allow user to repay too much\n        require(ratioGoodAfter);\n\n        emit CdpRepay(_cdpId, msg.sender, _amount, ratioBefore, ratioAfter);\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _cdpId Id of the cdp\n    /// @param _amount Amount of Dai to convert to Eth\n    /// @param _exchangeType Which exchange to use, 0 is to select best one\n    /// @param _collateralJoin Address of collateral join for specific CDP\n    function boostFor(uint _cdpId, uint _amount, address _collateralJoin, uint _exchangeType) public onlyApproved {\n        if (gasToken.balanceOf(address(this)) >= REPAY_GAS_TOKEN) {\n            gasToken.free(REPAY_GAS_TOKEN);\n        }\n\n        uint ratioBefore;\n        bool canCall;\n        (canCall, ratioBefore) = subscriptionsContract.canCall(Method.Boost, _cdpId);\n        require(canCall);\n\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\n\n        monitorProxyContract.callExecute(subscriptionsContract.getOwner(_cdpId), mcdSaverProxyAddress, abi.encodeWithSignature(\"boost(uint256,address,uint256,uint256,uint256,uint256)\", _cdpId, _collateralJoin, _amount, 0, _exchangeType, gasCost));\n\n        uint ratioAfter;\n        bool ratioGoodAfter;\n        (ratioGoodAfter, ratioAfter) = subscriptionsContract.ratioGoodAfter(Method.Boost, _cdpId);\n        // doesn't allow user to boost too much\n        require(ratioGoodAfter);\n\n        emit CdpBoost(_cdpId, msg.sender, _amount, ratioBefore, ratioAfter);\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) internal view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Adds a new bot address which will be able to call repay/boost\n    /// @param _caller Bot address\n    function addCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = true;\n    }\n\n    /// @notice Removes a bot address so it can't call repay/boost\n    /// @param _caller Bot address\n    function removeCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = false;\n    }\n\n    /// @notice If any tokens gets stuck in the contract owner can withdraw it\n    /// @param _tokenAddress Address of the ERC20 token\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n        ERC20(_tokenAddress).transfer(_to, _amount);\n    }\n\n    /// @notice If any Eth gets stuck in the contract owner can withdraw it\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferEth(address payable _to, uint _amount) public onlyOwner {\n        _to.transfer(_amount);\n    }\n}\n"
    },
    "contracts/mcd/automatic/MCDMonitorProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\n\n/// @title Implements logic for calling MCDSaverProxy always from same contract\ncontract MCDMonitorProxy {\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public owner;\n    address public newMonitor;\n    uint public changeRequestedTimestamp;\n\n    mapping(address => bool) public allowed;\n\n    // if someone who is allowed become malicious, owner can't be changed\n    modifier onlyAllowed() {\n        require(allowed[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        owner = msg.sender;\n        CHANGE_PERIOD = _changePeriod * 1 days;\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _saverProxy Address of MCDSaverProxy\n    /// @param _data Data to send to MCDSaverProxy\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute(_saverProxy, _data);\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyAllowed {\n        changeRequestedTimestamp = now;\n        newMonitor = _newMonitor;\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyAllowed {\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n    }\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }\n\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }\n}\n"
    },
    "contracts/mcd/automatic/Subscriptions.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../maker/Manager.sol\";\nimport \"./ISubscriptions.sol\";\nimport \"../saver_proxy/MCDSaverProxy.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../maker/Vat.sol\";\nimport \"../maker/Spotter.sol\";\n\n/// @title Handles subscriptions for automatic monitoring\ncontract Subscriptions is ISubscriptions, ConstantAddresses {\n\n    bytes32 internal constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n    bytes32 internal constant BAT_ILK = 0x4241542d41000000000000000000000000000000000000000000000000000000;\n\n    struct CdpHolder {\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        address owner;\n        uint cdpId;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n\n    CdpHolder[] public subscribers;\n    mapping (uint => SubPosition) public subscribersPos;\n\n    mapping (bytes32 => uint) public minLimits;\n\n    address public owner;\n    uint public changeIndex;\n\n    Manager public manager = Manager(MANAGER_ADDRESS);\n    Vat public vat = Vat(VAT_ADDRESS);\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\n    MCDSaverProxy public saverProxy;\n\n    event Subscribed(address indexed owner, uint cdpId);\n    event Unsubscribed(address indexed owner, uint cdpId);\n    event Updated(address indexed owner, uint cdpId);\n\n    /// @param _saverProxy Address of the MCDSaverProxy contract\n    constructor(address _saverProxy) public {\n        owner = msg.sender;\n\n        saverProxy = MCDSaverProxy(_saverProxy);\n\n        minLimits[ETH_ILK] = 1700000000000000000;\n        minLimits[BAT_ILK] = 1700000000000000000;\n    }\n\n    /// @dev Called by the DSProxy contract which owns the CDP\n    /// @notice Adds the users CDP in the list of subscriptions so it can be monitored\n    /// @param _cdpId Id of the CDP\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n        require(checkParams(manager.ilks(_cdpId), _minRatio, _maxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        CdpHolder memory subscription = CdpHolder({\n                minRatio: _minRatio,\n                maxRatio: _maxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                owner: msg.sender,\n                cdpId: _cdpId\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender, _cdpId);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender, _cdpId);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe(uint _cdpId) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        _unsubscribe(_cdpId);\n    }\n\n    /// @dev Checks if the _owner is the owner of the CDP\n    function isOwner(address _owner, uint _cdpId) internal view returns (bool) {\n        return getOwner(_cdpId) == _owner;\n    }\n\n    /// @dev Checks limit for minimum ratio and if minRatio is bigger than max\n    function checkParams(bytes32 _ilk, uint128 _minRatio, uint128 _maxRatio) internal view returns (bool) {\n        if (_minRatio < minLimits[_ilk]) {\n            return false;\n        }\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Gets CDP ratio, calls MCDSaverProxy for getting the ratio\n    function getRatio(uint _cdpId) public override view returns (uint) {\n        return saverProxy.getRatio(_cdpId, manager.ilks(_cdpId)) / (10 ** 18);\n    }\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    function canCall(Method _method, uint _cdpId) public override view returns(bool, uint) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, 0);\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        if (getOwner(_cdpId) != subscriber.owner) return (false, 0);\n\n        uint currRatio = getRatio(_cdpId);\n\n        if (_method == Method.Repay) {\n            return (currRatio < subscriber.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > subscriber.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    function _unsubscribe(uint _cdpId) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        uint lastCdpId = subscribers[subscribers.length - 1].cdpId;\n\n        SubPosition storage subInfo2 = subscribersPos[lastCdpId];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop();\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender, _cdpId);\n    }\n\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function getOwner(uint _cdpId) public override view returns(address) {\n        return manager.owns(_cdpId);\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    function ratioGoodAfter(Method _method, uint _cdpId) public override view returns(bool, uint) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        uint currRatio = getRatio(_cdpId);\n\n        if (_method == Method.Repay) {\n            return (currRatio < subscriber.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > subscriber.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Helper method for the front to get all the info about the subscribed CDP\n    function getSubscribedInfo(uint _cdpId) public override view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, 0, 0, 0, 0, address(0), 0, 0);\n\n        (coll, debt) = saverProxy.getCdpInfo(manager, _cdpId, manager.ilks(_cdpId));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (\n            true,\n            subscriber.minRatio,\n            subscriber.maxRatio,\n            subscriber.optimalRatioRepay,\n            subscriber.optimalRatioBoost,\n            subscriber.owner,\n            coll,\n            debt\n        );\n    }\n\n    /// @notice Helper method for the front to get the information about the ilk of a CDP\n    function getIlkInfo(bytes32 _ilk, uint _cdpId) public view returns(bytes32 ilk, uint art, uint rate, uint spot, uint line, uint dust, uint mat, uint par) {\n        // send either ilk or cdpId\n        if (_ilk == bytes32(0)) {\n            _ilk = manager.ilks(_cdpId);\n        }\n\n        ilk = _ilk;\n        (,mat) = spotter.ilks(_ilk);\n        par = spotter.par();\n        (art, rate, spot, line, dust) = vat.ilks(_ilk);\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    function getSubscribers() public view returns (CdpHolder[] memory) {\n        return subscribers;\n    }\n\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to change a min. limit for an asset\n    function changeMinRatios(bytes32 _ilk, uint _newRatio) public {\n        require(msg.sender == owner, \"Must be owner\");\n\n        minLimits[_ilk] = _newRatio;\n    }\n\n    /// @notice Admin function to unsubscribe a CDP if it's owner transfered to a different addr\n    function unsubscribeIfMoved(uint _cdpId) public override {\n        require(msg.sender == owner, \"Must be owner\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        if (subInfo.subscribed) {\n            if (getOwner(_cdpId) != subscribers[subInfo.arrPos].owner) {\n                _unsubscribe(_cdpId);\n            }\n        }\n\n    }\n}\n"
    },
    "contracts/mcd/maker/Manager.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Manager {\n    function last(address) virtual public returns (uint);\n    function cdpCan(address, uint, address) virtual public view returns (uint);\n    function ilks(uint) virtual public view returns (bytes32);\n    function owns(uint) virtual public view returns (address);\n    function urns(uint) virtual public view returns (address);\n    function vat() virtual public view returns (address);\n    function open(bytes32, address) virtual public returns (uint);\n    function give(uint, address) virtual public;\n    function cdpAllow(uint, address, uint) virtual public;\n    function urnAllow(address, uint) virtual public;\n    function frob(uint, int, int) virtual public;\n    function flux(uint, address, uint) virtual public;\n    function move(uint, address, uint) virtual public;\n    function exit(address, uint, address, uint) virtual public;\n    function quit(uint, address) virtual public;\n    function enter(address, uint) virtual public;\n    function shift(uint, uint) virtual public;\n}\n"
    },
    "contracts/mcd/saver_proxy/MCDSaverProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ExchangeInterface.sol\";\n\nimport \"../../loggers/SaverLogger.sol\";\nimport \"../Discount.sol\";\n\nimport \"../maker/Spotter.sol\";\nimport \"../maker/Jug.sol\";\nimport \"../maker/DaiJoin.sol\";\nimport \"../maker/Join.sol\";\n\nimport \"./ExchangeHelper.sol\";\nimport \"./SaverProxyHelper.sol\";\n\n\n/// @title Implements Boost and Repay for MCD CDPs\ncontract MCDSaverProxy is SaverProxyHelper, ExchangeHelper {\n\n    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n    bytes32 public constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n    bytes32 public constant USDC_ILK = 0x555344432d410000000000000000000000000000000000000000000000000000;\n\n    Manager public constant manager = Manager(MANAGER_ADDRESS);\n    Vat public constant vat = Vat(VAT_ADDRESS);\n    DaiJoin public constant daiJoin = DaiJoin(DAI_JOIN_ADDRESS);\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\n\n    /// @notice Checks if the collateral amount is increased after boost\n    /// @param _cdpId The Id of the CDP\n    modifier boostCheck(uint _cdpId) {\n        bytes32 ilk = manager.ilks(_cdpId);\n        address urn = manager.urns(_cdpId);\n\n        (uint collateralBefore, ) = vat.urns(ilk, urn);\n\n        _;\n\n        (uint collateralAfter, ) = vat.urns(ilk, urn);\n\n        require(collateralAfter > collateralBefore);\n    }\n\n    /// @notice Checks if ratio is increased after repay\n    /// @param _cdpId The Id of the CDP\n    modifier repayCheck(uint _cdpId) {\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        uint beforeRatio = getRatio(_cdpId, ilk);\n\n        _;\n\n        uint afterRatio = getRatio(_cdpId, ilk);\n\n        require(afterRatio > beforeRatio || afterRatio == 0);\n    }\n\n    /// @notice Repay - draws collateral, converts to Dai and repays the debt\n    /// @dev Must be called by the DSProxy contract that owns the CDP\n    /// @param _data Uint array [cdpId, amount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _joinAddr Address of the join contract for the CDP collateral\n    /// @param _exchangeAddress Address of 0x exchange that should be called\n    /// @param _callData data to call 0x exchange with\n    function repay(\n        // cdpId, amount, minPrice, exchangeType, gasCost, 0xPrice\n        uint[6] memory _data,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable repayCheck(_data[0]) {\n\n        address owner = getOwner(manager, _data[0]);\n        bytes32 ilk = manager.ilks(_data[0]);\n\n        // uint collDrawn;\n        // uint daiAmount;\n        // uint daiAfterFee;\n        uint[3] memory temp;\n\n        temp[0] = drawCollateral(_data[0], ilk, _joinAddr, _data[1]);\n\n                                // collDrawn, minPrice, exchangeType, 0xPrice\n        uint[4] memory swapData = [temp[0], _data[2], _data[3], _data[5]];\n        temp[1] = swap(swapData, getCollateralAddr(_joinAddr), DAI_ADDRESS, _exchangeAddress, _callData);\n        temp[2] = sub(temp[1], getFee(temp[1], _data[4], owner));\n\n        paybackDebt(_data[0], ilk, temp[2], owner);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        SaverLogger(LOGGER_ADDRESS).LogRepay(_data[0], owner, temp[0], temp[1]);\n    }\n\n    /// @notice Boost - draws Dai, converts to collateral and adds to CDP\n    /// @dev Must be called by the DSProxy contract that owns the CDP\n    /// @param _data Uint array [cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _joinAddr Address of the join contract for the CDP collateral\n    /// @param _exchangeAddress Address of 0x exchange that should be called\n    /// @param _callData data to call 0x exchange with\n    function boost(\n        // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        uint[6] memory _data,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable boostCheck(_data[0]) {\n        address owner = getOwner(manager, _data[0]);\n        bytes32 ilk = manager.ilks(_data[0]);\n\n        // uint daiDrawn;\n        // uint daiAfterFee;\n        // uint collateralAmount;\n        uint[3] memory temp;\n\n        temp[0] = drawDai(_data[0], ilk, _data[1]);\n        temp[1] = sub(temp[0], getFee(temp[0], _data[4], owner));\n                                // daiAfterFee, minPrice, exchangeType, 0xPrice\n        uint[4] memory swapData = [temp[1], _data[2], _data[3], _data[5]];\n        temp[2] = swap(swapData, DAI_ADDRESS, getCollateralAddr(_joinAddr), _exchangeAddress, _callData);\n\n        addCollateral(_data[0], _joinAddr, temp[2]);\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n\n        SaverLogger(LOGGER_ADDRESS).LogBoost(_data[0], owner, temp[0], temp[2]);\n    }\n\n    /// @notice Draws Dai from the CDP\n    /// @dev If _daiAmount is bigger than max available we'll draw max\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _daiAmount Amount of Dai to draw\n    function drawDai(uint _cdpId, bytes32 _ilk, uint _daiAmount) internal returns (uint) {\n        uint rate = Jug(JUG_ADDRESS).drip(_ilk);\n        uint daiVatBalance = vat.dai(manager.urns(_cdpId));\n\n        uint maxAmount = getMaxDebt(_cdpId, _ilk);\n\n        if (_daiAmount >= maxAmount) {\n            _daiAmount = sub(maxAmount, 1);\n        }\n\n        manager.frob(_cdpId, int(0), normalizeDrawAmount(_daiAmount, rate, daiVatBalance));\n        manager.move(_cdpId, address(this), toRad(_daiAmount));\n\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\n            vat.hope(DAI_JOIN_ADDRESS);\n        }\n\n        DaiJoin(DAI_JOIN_ADDRESS).exit(address(this), _daiAmount);\n\n        return _daiAmount;\n    }\n\n    /// @notice Adds collateral to the CDP\n    /// @param _cdpId Id of the CDP\n    /// @param _joinAddr Address of the join contract for the CDP collateral\n    /// @param _amount Amount of collateral to add\n    function addCollateral(uint _cdpId, address _joinAddr, uint _amount) internal {\n        int convertAmount = 0;\n\n        if (_joinAddr == ETH_JOIN_ADDRESS) {\n            Join(_joinAddr).gem().deposit{value: _amount}();\n            convertAmount = toPositiveInt(_amount);\n        } else {\n            convertAmount = toPositiveInt(convertTo18(_joinAddr, _amount));\n        }\n\n        Join(_joinAddr).gem().approve(_joinAddr, _amount);\n        Join(_joinAddr).join(address(this), _amount);\n\n        vat.frob(\n            manager.ilks(_cdpId),\n            manager.urns(_cdpId),\n            address(this),\n            address(this),\n            convertAmount,\n            0\n        );\n\n    }\n\n    /// @notice Draws collateral and returns it to DSProxy\n    /// @dev If _amount is bigger than max available we'll draw max\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _joinAddr Address of the join contract for the CDP collateral\n    /// @param _amount Amount of collateral to draw\n    function drawCollateral(uint _cdpId, bytes32 _ilk, address _joinAddr, uint _amount) internal returns (uint) {\n        uint maxCollateral = getMaxCollateral(_cdpId, _ilk, _joinAddr);\n\n        if (_amount >= maxCollateral) {\n            _amount = sub(maxCollateral, 1);\n        }\n\n        uint frobAmount = _amount;\n\n        if (Join(_joinAddr).dec() != 18) {\n            frobAmount = _amount * (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        manager.frob(_cdpId, -toPositiveInt(frobAmount), 0);\n        manager.flux(_cdpId, address(this), frobAmount);\n\n        Join(_joinAddr).exit(address(this), _amount);\n\n        if (_joinAddr == ETH_JOIN_ADDRESS) {\n            Join(_joinAddr).gem().withdraw(_amount); // Weth -> Eth\n        }\n\n        return _amount;\n    }\n\n    /// @notice Paybacks Dai debt\n    /// @dev If the _daiAmount is bigger than the whole debt, returns extra Dai\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _daiAmount Amount of Dai to payback\n    /// @param _owner Address that owns the DSProxy that owns the CDP\n    function paybackDebt(uint _cdpId, bytes32 _ilk, uint _daiAmount, address _owner) internal {\n        address urn = manager.urns(_cdpId);\n\n        uint wholeDebt = getAllDebt(VAT_ADDRESS, urn, urn, _ilk);\n\n        if (_daiAmount > wholeDebt) {\n            ERC20(DAI_ADDRESS).transfer(_owner, sub(_daiAmount, wholeDebt));\n            _daiAmount = wholeDebt;\n        }\n\n        daiJoin.dai().approve(DAI_JOIN_ADDRESS, _daiAmount);\n        daiJoin.join(urn, _daiAmount);\n\n        manager.frob(_cdpId, 0, normalizePaybackAmount(VAT_ADDRESS, urn, _ilk));\n    }\n\n    /// @notice Calculates the fee amount\n    /// @param _amount Dai amount that is converted\n    /// @param _gasCost Used for Monitor, estimated gas cost of tx\n    /// @param _owner The address that controlls the DSProxy that owns the CDP\n    function getFee(uint _amount, uint _gasCost, address _owner) internal returns (uint feeAmount) {\n        uint fee = SERVICE_FEE;\n\n        if (Discount(DISCOUNT_ADDRESS).isCustomFeeSet(_owner)) {\n            fee = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(_owner);\n        }\n\n        feeAmount = (fee == 0) ? 0 : (_amount / fee);\n\n        if (_gasCost != 0) {\n            uint ethDaiPrice = getPrice(ETH_ILK);\n            _gasCost = rmul(_gasCost, ethDaiPrice);\n\n            feeAmount = add(feeAmount, _gasCost);\n        }\n\n        // fee can't go over 20% of the whole amount\n        if (feeAmount > (_amount / 5)) {\n            feeAmount = _amount / 5;\n        }\n\n        ERC20(DAI_ADDRESS).transfer(WALLET_ID, feeAmount);\n    }\n\n    /// @notice Gets the maximum amount of collateral available to draw\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _joinAddr Joind address of collateral\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxCollateral(uint _cdpId, bytes32 _ilk, address _joinAddr) public view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        (, uint mat) = Spotter(SPOTTER_ADDRESS).ilks(_ilk);\n\n        uint maxCollateral = sub(sub(collateral, (div(mul(mat, debt), price))), 10);\n\n        uint normalizeMaxCollateral = maxCollateral;\n\n        if (Join(_joinAddr).dec() != 18) {\n            normalizeMaxCollateral = maxCollateral / (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        return normalizeMaxCollateral;\n    }\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxDebt(uint _cdpId, bytes32 _ilk) public virtual view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (, uint mat) = spotter.ilks(_ilk);\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        return sub(sub(div(mul(collateral, price), mat), debt), 10);\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getRatio(uint _cdpId, bytes32 _ilk) public view returns (uint) {\n        uint price = getPrice( _ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt);\n    }\n\n    /// @notice Gets CDP info (collateral, debt, price, ilk)\n    /// @param _cdpId Id of the CDP\n    function getCdpDetailedInfo(uint _cdpId) public view returns (uint collateral, uint debt, uint price, bytes32 ilk) {\n        address urn = manager.urns(_cdpId);\n        ilk = manager.ilks(_cdpId);\n\n        (collateral, debt) = vat.urns(ilk, urn);\n        (,uint rate,,,) = vat.ilks(ilk);\n\n        debt = rmul(debt, rate);\n        price = getPrice(ilk);\n    }\n\n}\n"
    },
    "contracts/mcd/maker/Spotter.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/PipInterface.sol\";\n\nabstract contract Spotter {\n    struct Ilk {\n        PipInterface pip;\n        uint256 mat;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    uint256 public par;\n\n}\n"
    },
    "contracts/mcd/maker/Jug.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Jug {\n    struct Ilk {\n        uint256 duty;\n        uint256  rho;\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n\n    function drip(bytes32) public virtual returns (uint);\n}\n"
    },
    "contracts/mcd/maker/DaiJoin.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./Vat.sol\";\nimport \"./Gem.sol\";\n\nabstract contract DaiJoin {\n    function vat() public virtual returns (Vat);\n    function dai() public virtual returns (Gem);\n    function join(address, uint) public virtual payable;\n    function exit(address, uint) public virtual;\n}\n"
    },
    "contracts/mcd/maker/Vat.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Vat {\n\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    struct Ilk {\n        uint256 Art;   // Total Normalised Debt     [wad]\n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n\n    function can(address, address) virtual public view returns (uint);\n    function dai(address) virtual public view returns (uint);\n    function frob(bytes32, address, address, address, int, int) virtual public;\n    function hope(address) virtual public;\n    function move(address, address, uint) virtual public;\n    function fork(bytes32, address, address, int, int) virtual public;\n}\n"
    },
    "contracts/mcd/maker/Gem.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Gem {\n    function dec() virtual public returns (uint);\n    function gem() virtual public returns (Gem);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public returns (bool);\n    function transferFrom(address, address, uint) virtual public returns (bool);\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n    function allowance(address, address) virtual public returns (uint);\n}\n"
    },
    "contracts/mcd/maker/Join.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./Gem.sol\";\n\nabstract contract Join {\n    bytes32 public ilk;\n\n    function dec() virtual public view returns (uint);\n    function gem() virtual public view returns (Gem);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n"
    },
    "contracts/mcd/saver_proxy/SaverProxyHelper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSMath.sol\";\nimport \"../../DS/DSProxy.sol\";\nimport \"../maker/Manager.sol\";\nimport \"../maker/Join.sol\";\nimport \"../maker/Vat.sol\";\n\n/// @title Helper methods for MCDSaverProxy\ncontract SaverProxyHelper is DSMath {\n\n    /// @notice Returns a normalized debt _amount based on the current rate\n    /// @param _amount Amount of dai to be normalized\n    /// @param _rate Current rate of the stability fee\n    /// @param _daiVatBalance Balance od Dai in the Vat for that CDP\n    function normalizeDrawAmount(uint _amount, uint _rate, uint _daiVatBalance) internal pure returns (int dart) {\n        if (_daiVatBalance < mul(_amount, RAY)) {\n            dart = toPositiveInt(sub(mul(_amount, RAY), _daiVatBalance) / _rate);\n            dart = mul(uint(dart), _rate) < mul(_amount, RAY) ? dart + 1 : dart;\n        }\n    }\n\n    /// @notice Converts a number to Rad percision\n    /// @param _wad The input number in wad percision\n    function toRad(uint _wad) internal pure returns (uint) {\n        return mul(_wad, 10 ** 27);\n    }\n\n    /// @notice Converts a number to 18 decimal percision\n    /// @param _joinAddr Join address of the collateral\n    /// @param _amount Number to be converted\n    function convertTo18(address _joinAddr, uint256 _amount) internal returns (uint256) {\n        return mul(_amount, 10 ** (18 - Join(_joinAddr).dec()));\n    }\n\n    /// @notice Converts a uint to int and checks if positive\n    /// @param _x Number to be converted\n    function toPositiveInt(uint _x) internal pure returns (int y) {\n        y = int(_x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    /// @notice Gets Dai amount in Vat which can be added to Cdp\n    /// @param _vat Address of Vat contract\n    /// @param _urn Urn of the Cdp\n    /// @param _ilk Ilk of the Cdp\n    function normalizePaybackAmount(address _vat, address _urn, bytes32 _ilk) internal view returns (int amount) {\n        uint dai = Vat(_vat).dai(_urn);\n\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\n\n        amount = toPositiveInt(dai / rate);\n        amount = uint(amount) <= art ? - amount : - toPositiveInt(art);\n    }\n\n    /// @notice Gets the whole debt of the CDP\n    /// @param _vat Address of Vat contract\n    /// @param _usr Address of the Dai holder\n    /// @param _urn Urn of the Cdp\n    /// @param _ilk Ilk of the Cdp\n    function getAllDebt(address _vat, address _usr, address _urn, bytes32 _ilk) internal view returns (uint daiAmount) {\n        (, uint rate,,,) = Vat(_vat).ilks(_ilk);\n        (, uint art) = Vat(_vat).urns(_ilk, _urn);\n        uint dai = Vat(_vat).dai(_usr);\n\n        uint rad = sub(mul(art, rate), dai);\n        daiAmount = rad / RAY;\n\n        daiAmount = mul(daiAmount, RAY) < rad ? daiAmount + 1 : daiAmount;\n    }\n\n    /// @notice Gets the token address from the Join contract\n    /// @param _joinAddr Address of the Join contract\n    function getCollateralAddr(address _joinAddr) internal returns (address) {\n        return address(Join(_joinAddr).gem());\n    }\n\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _manager Manager contract\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getCdpInfo(Manager _manager, uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address vat = _manager.vat();\n        address urn = _manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = Vat(vat).urns(_ilk, urn);\n        (,uint rate,,,) = Vat(vat).ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }\n\n    /// @notice Address that owns the DSProxy that owns the CDP\n    /// @param _manager Manager contract\n    /// @param _cdpId Id of the CDP\n    function getOwner(Manager _manager, uint _cdpId) public view returns (address) {\n        DSProxy proxy = DSProxy(uint160(_manager.owns(_cdpId)));\n\n        return proxy.owner();\n    }\n}\n"
    },
    "contracts/mcd/automatic/SubscriptionsProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSGuard.sol\";\nimport \"../../DS/DSAuth.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\n\ncontract SubscriptionsInterface {\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay) external {}\n    function unsubscribe(uint _cdpId) external {}\n}\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract SubscriptionsProxy is ConstantAddresses {\n\n    address public constant MONITOR_PROXY_ADDRESS = 0x93Efcf86b6a7a33aE961A7Ec6C741F49bce11DA7;\n\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, address _subscriptions) public {\n\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(MONITOR_PROXY_ADDRESS, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n\n        SubscriptionsInterface(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay);\n    }\n\n    function update(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, address _subscriptions) public {\n        SubscriptionsInterface(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay);\n    }\n\n    function unsubscribe(uint _cdpId, address _subscriptions) public {\n        SubscriptionsInterface(_subscriptions).unsubscribe(_cdpId);\n    }\n}\n"
    },
    "contracts/mcd/automaticV2/AutomaticProxyV2.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../saver_proxy/MCDSaverProxy.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../loggers/FlashLoanLogger.sol\";\n\n\nabstract contract ILendingPool {\n    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n}\n\ncontract AutomaticProxyV2 is MCDSaverProxy {\n\n    address payable public constant MCD_SAVER_FLASH_LOAN = 0xCcFb21Ced87762a1d8425F867a7F8Ec2dFfaBE92;\n    address public constant AAVE_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    FlashLoanLogger public constant logger = FlashLoanLogger(\n        0xb9303686B0EE92F92f63973EF85f3105329D345c\n    );\n\n    function automaticBoost(\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable {\n        uint256 maxDebt = getMaxDebt(_data[0], manager.ilks(_data[0]));\n        uint256 debtAmount = _data[1];\n\n        if (maxDebt >= debtAmount) {\n            boost(_data, _joinAddr, _exchangeAddress, _callData);\n            return;\n        }\n\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        uint256 loanAmount = sub(debtAmount, maxDebt);\n        uint maxLiq = getAvailableLiquidity(_joinAddr);\n\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(_data, _joinAddr, _exchangeAddress, _callData, false);\n\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, DAI_ADDRESS, loanAmount, paramsData);\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 0);\n\n        logger.logFlashLoan(\"AutomaticBoost\", loanAmount, _data[0], msg.sender);\n    }\n\n    function automaticRepay(\n        uint256[6] memory _data,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable {\n        uint collAmount = _data[1];\n        uint256 maxColl = getMaxCollateral(_data[0], manager.ilks(_data[0]));\n\n        if (maxColl >= collAmount) {\n            repay(_data, _joinAddr, _exchangeAddress, _callData);\n            return;\n        }\n\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        uint256 loanAmount = sub(_data[1], maxColl);\n        uint maxLiq = getAvailableLiquidity(_joinAddr);\n\n        loanAmount = loanAmount > maxLiq ? maxLiq : loanAmount;\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(_data, _joinAddr, _exchangeAddress, _callData, true);\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, getAaveCollAddr(_joinAddr), loanAmount, paramsData);\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 0);\n\n        logger.logFlashLoan(\"AutomaticRepay\", loanAmount, _data[0], msg.sender);\n    }\n\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getMaxDebt(uint256 _cdpId, bytes32 _ilk) public override view returns (uint256) {\n        uint256 price = getPrice(_ilk);\n\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (uint256 collateral, uint256 debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        return sub(wdiv(wmul(collateral, price), mat), debt);\n    }\n\n    /// @notice Gets the maximum amount of collateral available to draw\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxCollateral(uint _cdpId, bytes32 _ilk) public view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        (, uint mat) = Spotter(SPOTTER_ADDRESS).ilks(_ilk);\n\n        return sub(sub(collateral, (div(mul(mat, debt), price))), 10);\n    }\n\n    function getAaveCollAddr(address _joinAddr) internal returns (address) {\n        if (_joinAddr == 0x2F0b23f53734252Bda2277357e97e1517d6B042A\n            || _joinAddr == 0x775787933e92b709f2a3C70aa87999696e74A9F8) {\n            return KYBER_ETH_ADDRESS;\n        } else {\n            return getCollateralAddr(_joinAddr);\n        }\n    }\n\n    function getAvailableLiquidity(address _joinAddr) internal returns (uint liquidity) {\n        address tokenAddr = getAaveCollAddr(_joinAddr);\n\n        if (tokenAddr == KYBER_ETH_ADDRESS) {\n            liquidity = AAVE_POOL_CORE.balance;\n        } else {\n            liquidity = ERC20(tokenAddr).balanceOf(AAVE_POOL_CORE);\n        }\n    }\n\n}\n"
    },
    "contracts/mcd/automaticV2/ISubscriptionsV2.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./StaticV2.sol\";\n\nabstract contract ISubscriptionsV2 is StaticV2 {\n\n    function getOwner(uint _cdpId) external view virtual returns(address);\n    function getSubscribedInfo(uint _cdpId) public view virtual returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt);\n    function getCdpHolder(uint _cdpId) public view virtual returns (bool subscribed, CdpHolder memory);\n}\n"
    },
    "contracts/mcd/automaticV2/StaticV2.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/// @title Implements enum Method\nabstract contract StaticV2 {\n\n    enum Method { Boost, Repay }\n\n    struct CdpHolder {\n        uint128 minRatio;\n        uint128 maxRatio;\n        uint128 optimalRatioBoost;\n        uint128 optimalRatioRepay;\n        address owner;\n        uint cdpId;\n        bool boostEnabled;\n        bool nextPriceEnabled;\n    }\n\n    struct SubPosition {\n        uint arrPos;\n        bool subscribed;\n    }\n}\n"
    },
    "contracts/mcd/automaticV2/MCDMonitorProxyV2.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/DSProxyInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Implements logic for calling MCDSaverProxy always from same contract\ncontract MCDMonitorProxyV2 is AdminAuth {\n\n    uint public CHANGE_PERIOD;\n    address public monitor;\n    address public newMonitor;\n    address public lastMonitor;\n    uint public changeRequestedTimestamp;\n\n    mapping(address => bool) public allowed;\n\n    event MonitorChangeInitiated(address oldMonitor, address newMonitor);\n    event MonitorChangeCanceled();\n    event MonitorChangeFinished(address monitor);\n    event MonitorChangeReverted(address monitor);\n\n    // if someone who is allowed become malicious, owner can't be changed\n    modifier onlyAllowed() {\n        require(allowed[msg.sender] || msg.sender == owner);\n        _;\n    }\n\n    modifier onlyMonitor() {\n        require (msg.sender == monitor);\n        _;\n    }\n\n    constructor(uint _changePeriod) public {\n        CHANGE_PERIOD = _changePeriod * 1 days;\n    }\n\n    /// @notice Only monitor contract is able to call execute on users proxy\n    /// @param _owner Address of cdp owner (users DSProxy address)\n    /// @param _saverProxy Address of MCDSaverProxy\n    /// @param _data Data to send to MCDSaverProxy\n    function callExecute(address _owner, address _saverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_saverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n    /// @notice Allowed users are able to set Monitor contract without any waiting period first time\n    /// @param _monitor Address of Monitor contract\n    function setMonitor(address _monitor) public onlyAllowed {\n        require(monitor == address(0));\n        monitor = _monitor;\n    }\n\n    /// @notice Allowed users are able to start procedure for changing monitor\n    /// @dev after CHANGE_PERIOD needs to call confirmNewMonitor to actually make a change\n    /// @param _newMonitor address of new monitor\n    function changeMonitor(address _newMonitor) public onlyAllowed {\n        require(changeRequestedTimestamp == 0);\n\n        changeRequestedTimestamp = now;\n        lastMonitor = monitor;\n        newMonitor = _newMonitor;\n\n        emit MonitorChangeInitiated(lastMonitor, newMonitor);\n    }\n\n    /// @notice At any point allowed users are able to cancel monitor change\n    function cancelMonitorChange() public onlyAllowed {\n        require(changeRequestedTimestamp > 0);\n\n        changeRequestedTimestamp = 0;\n        newMonitor = address(0);\n\n        emit MonitorChangeCanceled();\n    }\n\n    /// @notice Anyone is able to confirm new monitor after CHANGE_PERIOD if process is started\n    function confirmNewMonitor() public onlyAllowed {\n        require((changeRequestedTimestamp + CHANGE_PERIOD) < now);\n        require(changeRequestedTimestamp != 0);\n        require(newMonitor != address(0));\n\n        monitor = newMonitor;\n        newMonitor = address(0);\n        changeRequestedTimestamp = 0;\n\n        emit MonitorChangeFinished(monitor);\n    }\n\n    /// @notice Its possible to revert monitor to last used monitor\n    function revertMonitor() public onlyAllowed {\n        require(lastMonitor != address(0));\n\n        monitor = lastMonitor;\n\n        emit MonitorChangeReverted(monitor);\n    }\n\n\n    /// @notice Allowed users are able to add new allowed user\n    /// @param _user Address of user that will be allowed\n    function addAllowed(address _user) public onlyAllowed {\n        allowed[_user] = true;\n    }\n\n    /// @notice Allowed users are able to remove allowed user\n    /// @dev owner is always allowed even if someone tries to remove it from allowed mapping\n    /// @param _user Address of allowed user\n    function removeAllowed(address _user) public onlyAllowed {\n        allowed[_user] = false;\n    }\n\n    function setChangePeriod(uint _periodInDays) public onlyAllowed {\n        require(_periodInDays * 1 days > CHANGE_PERIOD);\n\n        CHANGE_PERIOD = _periodInDays * 1 days;\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    /// @param _token address of token to withdraw balance\n    function withdrawToken(address _token) public onlyOwner {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, balance);\n    }\n\n    /// @notice In case something is left in contract, owner is able to withdraw it\n    function withdrawEth() public onlyOwner {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n}\n"
    },
    "contracts/mcd/automaticV2/MCDMonitorV2.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ISubscriptionsV2.sol\";\nimport \"./StaticV2.sol\";\nimport \"./MCDMonitorProxyV2.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../interfaces/GasTokenInterface.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../maker/Manager.sol\";\nimport \"../maker/Vat.sol\";\nimport \"../maker/Spotter.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../../loggers/AutomaticLogger.sol\";\n\n\n/// @title Implements logic that allows bots to call Boost and Repay\ncontract MCDMonitorV2 is AdminAuth, ConstantAddresses, DSMath, StaticV2 {\n\n    uint public REPAY_GAS_TOKEN = 35;\n    uint public BOOST_GAS_TOKEN = 25;\n\n    uint constant public MAX_GAS_PRICE = 80000000000; // 80 gwei\n\n    uint public REPAY_GAS_COST = 2200000;\n    uint public BOOST_GAS_COST = 1500000;\n\n    MCDMonitorProxyV2 public monitorProxyContract;\n    ISubscriptionsV2 public subscriptionsContract;\n    GasTokenInterface gasToken = GasTokenInterface(GAS_TOKEN_INTERFACE_ADDRESS);\n    address public automaticSaverProxyAddress;\n\n    Manager public manager = Manager(MANAGER_ADDRESS);\n    Vat public vat = Vat(VAT_ADDRESS);\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\n    AutomaticLogger public logger = AutomaticLogger(AUTOMATIC_LOGGER_ADDRESS);\n\n    /// @dev Addresses that are able to call methods for repay and boost\n    mapping(address => bool) public approvedCallers;\n\n    modifier onlyApproved() {\n        require(approvedCallers[msg.sender]);\n        _;\n    }\n\n    constructor(address _monitorProxy, address _subscriptions, address _automaticSaverProxyAddress) public {\n        approvedCallers[msg.sender] = true;\n\n        monitorProxyContract = MCDMonitorProxyV2(_monitorProxy);\n        subscriptionsContract = ISubscriptionsV2(_subscriptions);\n        automaticSaverProxyAddress = _automaticSaverProxyAddress;\n    }\n\n    /// @notice Bots call this method to repay for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _data Array of uints representing [cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _nextPrice Next price in Maker protocol\n    /// @param _joinAddr Address of collateral join for specific CDP\n    /// @param _exchangeAddress Address to call 0x exchange\n    /// @param _callData Bytes representing call data for 0x exchange\n    function repayFor(\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        uint256 _nextPrice,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable onlyApproved {\n        if (gasToken.balanceOf(address(this)) >= REPAY_GAS_TOKEN) {\n            gasToken.free(REPAY_GAS_TOKEN);\n        }\n\n        uint ratioBefore;\n        bool isAllowed;\n        (isAllowed, ratioBefore) = canCall(Method.Repay, _data[0], _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(REPAY_GAS_COST);\n        _data[4] = gasCost;\n\n        monitorProxyContract.callExecute{value: msg.value}(subscriptionsContract.getOwner(_data[0]), automaticSaverProxyAddress, abi.encodeWithSignature(\"automaticRepay(uint256[6],address,address,bytes)\", _data, _joinAddr, _exchangeAddress, _callData));\n\n        uint ratioAfter;\n        bool isGoodRatio;\n        (isGoodRatio, ratioAfter) = ratioGoodAfter(Method.Repay, _data[0], _nextPrice);\n        // doesn't allow user to repay too much\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.logRepay(_data[0], msg.sender, _data[1], ratioBefore, ratioAfter);\n    }\n\n    /// @notice Bots call this method to boost for user when conditions are met\n    /// @dev If the contract ownes gas token it will try and use it for gas price reduction\n    /// @param _data Array of uints representing [cdpId, collateralAmount, minPrice, exchangeType, gasCost, 0xPrice]\n    /// @param _nextPrice Next price in Maker protocol\n    /// @param _joinAddr Address of collateral join for specific CDP\n    /// @param _exchangeAddress Address to call 0x exchange\n    /// @param _callData Bytes representing call data for 0x exchange\n    function boostFor(\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        uint256 _nextPrice,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable onlyApproved {\n        if (gasToken.balanceOf(address(this)) >= BOOST_GAS_TOKEN) {\n            gasToken.free(BOOST_GAS_TOKEN);\n        }\n\n        uint ratioBefore;\n        bool isAllowed;\n        (isAllowed, ratioBefore) = canCall(Method.Boost, _data[0], _nextPrice);\n        require(isAllowed);\n\n        uint gasCost = calcGasCost(BOOST_GAS_COST);\n        _data[4] = gasCost;\n\n        monitorProxyContract.callExecute{value: msg.value}(subscriptionsContract.getOwner(_data[0]), automaticSaverProxyAddress, abi.encodeWithSignature(\"automaticBoost(uint256[6],address,address,bytes)\", _data, _joinAddr, _exchangeAddress, _callData));\n\n        uint ratioAfter;\n        bool isGoodRatio;\n        (isGoodRatio, ratioAfter) = ratioGoodAfter(Method.Boost, _data[0], _nextPrice);\n        // doesn't allow user to boost too much\n        require(isGoodRatio);\n\n        returnEth();\n\n        logger.logBoost(_data[0], msg.sender, _data[1], ratioBefore, ratioAfter);\n    }\n\n/******************* INTERNAL METHODS ********************************/\n    function returnEth() internal {\n        // return if some eth left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n\n/******************* STATIC METHODS ********************************/\n\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }\n\n    /// @notice Gets CDP info (collateral, debt)\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getCdpInfo(uint _cdpId, bytes32 _ilk) public view returns (uint, uint) {\n        address urn = manager.urns(_cdpId);\n\n        (uint collateral, uint debt) = vat.urns(_ilk, urn);\n        (,uint rate,,,) = vat.ilks(_ilk);\n\n        return (collateral, rmul(debt, rate));\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint) {\n        (, uint mat) = spotter.ilks(_ilk);\n        (,,uint spot,,) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    /// @notice Gets CDP ratio\n    /// @param _cdpId Id of the CDP\n    /// @param _nextPrice Next price for user\n    function getRatio(uint _cdpId, uint _nextPrice) public view returns (uint) {\n        bytes32 ilk = manager.ilks(_cdpId);\n        uint price = (_nextPrice == 0) ? getPrice(ilk) : _nextPrice;\n\n        (uint collateral, uint debt) = getCdpInfo(_cdpId, ilk);\n\n        if (debt == 0) return 0;\n\n        return rdiv(wmul(collateral, price), debt) / (10 ** 18);\n    }\n\n    /// @notice Checks if Boost/Repay could be triggered for the CDP\n    /// @dev Called by MCDMonitor to enforce the min/max check\n    function canCall(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        bool subscribed;\n        CdpHolder memory holder;\n        (subscribed, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        // check if cdp is subscribed\n        if (!subscribed) return (false, 0);\n\n        // check if using next price is allowed\n        if (_nextPrice > 0 && !holder.nextPriceEnabled) return (false, 0);\n\n        // check if boost and boost allowed\n        if (_method == Method.Boost && !holder.boostEnabled) return (false, 0);\n\n        // check if owner is still owner\n        if (getOwner(_cdpId) != holder.owner) return (false, 0);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.minRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.maxRatio, currRatio);\n        }\n    }\n\n    /// @dev After the Boost/Repay check if the ratio doesn't trigger another call\n    function ratioGoodAfter(Method _method, uint _cdpId, uint _nextPrice) public view returns(bool, uint) {\n        CdpHolder memory holder;\n\n        (, holder) = subscriptionsContract.getCdpHolder(_cdpId);\n\n        uint currRatio = getRatio(_cdpId, _nextPrice);\n\n        if (_method == Method.Repay) {\n            return (currRatio < holder.maxRatio, currRatio);\n        } else if (_method == Method.Boost) {\n            return (currRatio > holder.minRatio, currRatio);\n        }\n    }\n\n    /// @notice Calculates gas cost (in Eth) of tx\n    /// @dev Gas price is limited to MAX_GAS_PRICE to prevent attack of draining user CDP\n    /// @param _gasAmount Amount of gas used for the tx\n    function calcGasCost(uint _gasAmount) public view returns (uint) {\n        uint gasPrice = tx.gasprice <= MAX_GAS_PRICE ? tx.gasprice : MAX_GAS_PRICE;\n\n        return mul(gasPrice, _gasAmount);\n    }\n\n/******************* OWNER ONLY OPERATIONS ********************************/\n\n    /// @notice Allows owner to change gas cost for boost operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for boost method\n    function changeBoostGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        BOOST_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change gas cost for repay operation, but only up to 3 millions\n    /// @param _gasCost New gas cost for repay method\n    function changeRepayGasCost(uint _gasCost) public onlyOwner {\n        require(_gasCost < 3000000);\n\n        REPAY_GAS_COST = _gasCost;\n    }\n\n    /// @notice Allows owner to change the amount of gas token burned per function call\n    /// @param _gasAmount Amount of gas token\n    /// @param _isRepay Flag to know for which function we are setting the gas token amount\n    function changeGasTokenAmount(uint _gasAmount, bool _isRepay) public onlyOwner {\n        if (_isRepay) {\n            REPAY_GAS_TOKEN = _gasAmount;\n        } else {\n            BOOST_GAS_TOKEN = _gasAmount;\n        }\n    }\n\n    /// @notice Adds a new bot address which will be able to call repay/boost\n    /// @param _caller Bot address\n    function addCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = true;\n    }\n\n    /// @notice Removes a bot address so it can't call repay/boost\n    /// @param _caller Bot address\n    function removeCaller(address _caller) public onlyOwner {\n        approvedCallers[_caller] = false;\n    }\n\n    /// @notice If any tokens gets stuck in the contract owner can withdraw it\n    /// @param _tokenAddress Address of the ERC20 token\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n        ERC20(_tokenAddress).transfer(_to, _amount);\n    }\n\n    /// @notice If any Eth gets stuck in the contract owner can withdraw it\n    /// @param _to Address of the receiver\n    /// @param _amount The amount to be sent\n    function transferEth(address payable _to, uint _amount) public onlyOwner {\n        _to.transfer(_amount);\n    }\n}\n"
    },
    "contracts/mcd/automaticV2/MCDPriceVerifier.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/OsmMom.sol\";\nimport \"../../interfaces/Osm.sol\";\nimport \"../../auth/AdminAuth.sol\";\nimport \"../maker/Manager.sol\";\n\ncontract MCDPriceVerifier is AdminAuth {\n\n    OsmMom public osmMom = OsmMom(0x76416A4d5190d071bfed309861527431304aA14f);\n    Manager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n\n    mapping(address => bool) public authorized;\n\n    function verifyVaultNextPrice(uint _nextPrice, uint _cdpId) public view returns(bool) {\n        require(authorized[msg.sender]);\n\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        return verifyNextPrice(_nextPrice, ilk);\n    }\n\n    function verifyNextPrice(uint _nextPrice, bytes32 _ilk) public view returns(bool) {\n        require(authorized[msg.sender]);\n\n        address osmAddress = osmMom.osms(_ilk);\n\n        uint whitelisted = Osm(osmAddress).bud(address(this));\n        // If contracts doesn't have access return true\n        if (whitelisted != 1) return true;\n\n        (bytes32 price, bool has) = Osm(osmAddress).peep();\n\n        return has ? uint(price) == _nextPrice : false;\n    }\n\n    function setAuthorized(address _address, bool _allowed) public onlyOwner {\n        authorized[_address] = _allowed;\n    }\n}\n"
    },
    "contracts/mcd/automaticV2/SubscriptionsMigration.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../automatic/MCDMonitorProxy.sol\";\nimport \"../automatic/ISubscriptions.sol\";\nimport \"../maker/Manager.sol\";\nimport \"../../auth/Auth.sol\";\nimport \"../../auth/ProxyPermission.sol\";\nimport \"../../DS/DSAuth.sol\";\nimport \"../../DS/DSGuard.sol\";\n\n\ncontract SubscriptionsMigration is Auth {\n\n\t// proxyPermission address\n\taddress public proxyPermission;\n\n\n\taddress public monitorProxyAddress = 0x93Efcf86b6a7a33aE961A7Ec6C741F49bce11DA7;\n\t// v1 monitor proxy\n\tMCDMonitorProxy public monitorProxyContract = MCDMonitorProxy(monitorProxyAddress);\n\t// v1 subscriptions contract\n\tISubscriptions public subscriptionsContract = ISubscriptions(0x83152CAA0d344a2Fd428769529e2d490A88f4393);\n\t// v2 subscriptions proxy with \"migrate\" method\n\taddress public subscriptionsProxyV2address = 0xd6f2125bF7FE2bc793dE7685EA7DEd8bff3917DD;\n\t// v2 subscriptions address (needs to be passed to migrate method)\n\taddress public subscriptionsV2address = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\n\t// v1 subscriptions address\n\taddress public subscriptionsV1address = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\n\t// v1 subscriptions proxy address\n\taddress public subscriptionsProxyV1address = 0xA5D33b02dBfFB3A9eF26ec21F15c43BdB53EB455;\n\t// manager to check if owner is valid\n\tManager public manager = Manager(0x5ef30b9986345249bc32d8928B7ee64DE9435E39);\n\n\tconstructor(address _proxyPermission) public {\n\t\tproxyPermission = _proxyPermission;\n\t}\n\n\tfunction migrate(uint[] memory _cdps) public onlyAuthorized {\n\n\t\tfor (uint i=0; i<_cdps.length; i++) {\n\t\t\tif (_cdps[i] == 0) continue;\n\n\t\t\tbool sub;\n\t\t\tuint minRatio;\n\t\t\tuint maxRatio;\n\t\t\tuint optimalRepay;\n\t\t\tuint optimalBoost;\n\t\t\taddress cdpOwner;\n\t\t\tuint collateral;\n\n\t\t\t// get data for specific cdp\n\t\t\t(sub, minRatio, maxRatio, optimalRepay, optimalBoost, cdpOwner, collateral,) = subscriptionsContract.getSubscribedInfo(_cdps[i]);\n\n\t\t\t// if user is not the owner anymore, we will have to unsub him manually\n\t\t\tif (cdpOwner != _getOwner(_cdps[i])) {\n\t\t\t\tcontinue;\n\t\t\t} \n\n\t\t\t// call migrate method on SubscriptionsProxyV2 through users DSProxy if cdp is subbed and have collateral\n\t\t\tif (sub && collateral > 0) {\n\t\t\t\tmonitorProxyContract.callExecute(cdpOwner, subscriptionsProxyV2address, abi.encodeWithSignature(\"migrate(uint256,uint128,uint128,uint128,uint128,bool,bool,address)\", _cdps[i], minRatio, maxRatio, optimalBoost, optimalRepay, true, true, subscriptionsV2address));\n\t\t\t} else {\n\t\t\t\t// if cdp is subbed but no collateral, just unsubscribe user\n\t\t\t\tif (sub) {\n\t\t\t\t\t_unsubscribe(_cdps[i], cdpOwner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// don't remove authority here because we wouldn't be able to unsub or migrate if user have more than one cdp\n\t\t}\n\t}\n\n\tfunction removeAuthority(address[] memory _users) public onlyAuthorized {\n\n\t\tfor (uint i=0; i<_users.length; i++) {\n\t\t\t_removeAuthority(_users[i]);\n\t\t}\n\t}\n\n\tfunction _unsubscribe(uint _cdpId, address _cdpOwner) internal onlyAuthorized {\n\t\taddress currAuthority = address(DSAuth(_cdpOwner).authority());\n\t\t// if no authority return\n\t\tif (currAuthority == address(0)) return;\n        DSGuard guard = DSGuard(currAuthority);\n\n        // if we don't have permission on specific authority, return\n        if (!guard.canCall(monitorProxyAddress, _cdpOwner, bytes4(keccak256(\"execute(address,bytes)\")))) return;\n\n        // call unsubscribe on v1 proxy through users DSProxy\n\t\tmonitorProxyContract.callExecute(_cdpOwner, subscriptionsProxyV1address, abi.encodeWithSignature(\"unsubscribe(uint256,address)\", _cdpId, subscriptionsV1address));\n\t}\n\n\tfunction _removeAuthority(address _cdpOwner) internal onlyAuthorized {\n\n\t\taddress currAuthority = address(DSAuth(_cdpOwner).authority());\n\t\t// if no authority return\n\t\tif (currAuthority == address(0)) return;\n        DSGuard guard = DSGuard(currAuthority);\n\n        // if we don't have permission, that means its already removed\n        if (!guard.canCall(monitorProxyAddress, _cdpOwner, bytes4(keccak256(\"execute(address,bytes)\")))) return;\n\n\t\tmonitorProxyContract.callExecute(_cdpOwner, proxyPermission, abi.encodeWithSignature(\"removePermission(address)\", monitorProxyAddress));\n\t}\n\n\t/// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function _getOwner(uint _cdpId) internal view returns(address) {\n        return manager.owns(_cdpId);\n    }\n}"
    },
    "contracts/mcd/automaticV2/SubscriptionsProxyV2.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../DS/DSGuard.sol\";\nimport \"../../DS/DSAuth.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\n\ncontract SubscriptionsInterfaceV2 {\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {}\n    function unsubscribe(uint _cdpId) external {}\n}\n\n/// @title SubscriptionsProxy handles authorization and interaction with the Subscriptions contract\ncontract SubscriptionsProxyV2 is ConstantAddresses {\n\n    address public constant MONITOR_PROXY_ADDRESS = 0x7456f4218874eAe1aF8B83a64848A1B89fEB7d7C;\n    address public constant OLD_SUBSCRIPTION = 0x83152CAA0d344a2Fd428769529e2d490A88f4393;\n\n    function migrate(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n        SubscriptionsInterfaceV2(OLD_SUBSCRIPTION).unsubscribe(_cdpId);\n\n        subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled, _subscriptions);\n    }\n\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n\n        address currAuthority = address(DSAuth(address(this)).authority());\n        DSGuard guard = DSGuard(currAuthority);\n\n        if (currAuthority == address(0)) {\n            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n        }\n\n        guard.permit(MONITOR_PROXY_ADDRESS, address(this), bytes4(keccak256(\"execute(address,bytes)\")));\n\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\n    }\n\n    function update(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalRatioBoost, uint128 _optimalRatioRepay, bool _boostEnabled, bool _nextPriceEnabled, address _subscriptions) public {\n        SubscriptionsInterfaceV2(_subscriptions).subscribe(_cdpId, _minRatio, _maxRatio, _optimalRatioBoost, _optimalRatioRepay, _boostEnabled, _nextPriceEnabled);\n    }\n\n    function unsubscribe(uint _cdpId, address _subscriptions) public {\n        SubscriptionsInterfaceV2(_subscriptions).unsubscribe(_cdpId);\n    }\n}\n"
    },
    "contracts/mcd/automaticV2/SubscriptionsV2.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../maker/Manager.sol\";\nimport \"./StaticV2.sol\";\nimport \"../saver_proxy/MCDSaverProxy.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../maker/Vat.sol\";\nimport \"../maker/Spotter.sol\";\nimport \"../../auth/AdminAuth.sol\";\n\n/// @title Handles subscriptions for automatic monitoring\ncontract SubscriptionsV2 is AdminAuth, StaticV2, ConstantAddresses {\n\n    bytes32 internal constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n    bytes32 internal constant BAT_ILK = 0x4241542d41000000000000000000000000000000000000000000000000000000;\n\n    CdpHolder[] public subscribers;\n    mapping (uint => SubPosition) public subscribersPos;\n\n    mapping (bytes32 => uint) public minLimits;\n\n    uint public changeIndex;\n\n    Manager public manager = Manager(MANAGER_ADDRESS);\n    Vat public vat = Vat(VAT_ADDRESS);\n    Spotter public spotter = Spotter(SPOTTER_ADDRESS);\n    MCDSaverProxy public saverProxy;\n\n    event Subscribed(address indexed owner, uint cdpId);\n    event Unsubscribed(address indexed owner, uint cdpId);\n    event Updated(address indexed owner, uint cdpId);\n    event ParamUpdates(address indexed owner, uint cdpId, uint128, uint128, uint128, uint128, bool boostEnabled);\n\n    /// @param _saverProxy Address of the MCDSaverProxy contract\n    constructor(address _saverProxy) public {\n        saverProxy = MCDSaverProxy(_saverProxy);\n\n        minLimits[ETH_ILK] = 1700000000000000000;\n        minLimits[BAT_ILK] = 1700000000000000000;\n    }\n\n    /// @dev Called by the DSProxy contract which owns the CDP\n    /// @notice Adds the users CDP in the list of subscriptions so it can be monitored\n    /// @param _cdpId Id of the CDP\n    /// @param _minRatio Minimum ratio below which repay is triggered\n    /// @param _maxRatio Maximum ratio after which boost is triggered\n    /// @param _optimalBoost Ratio amount which boost should target\n    /// @param _optimalRepay Ratio amount which repay should target\n    /// @param _boostEnabled Boolean determing if boost is enabled\n    /// @param _nextPriceEnabled Boolean determing if we can use nextPrice for this cdp\n    function subscribe(uint _cdpId, uint128 _minRatio, uint128 _maxRatio, uint128 _optimalBoost, uint128 _optimalRepay, bool _boostEnabled, bool _nextPriceEnabled) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        // if boost is not enabled, set max ratio to max uint\n        uint128 localMaxRatio = _boostEnabled ? _maxRatio : uint128(-1);\n        require(checkParams(manager.ilks(_cdpId), _minRatio, localMaxRatio), \"Must be correct params\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        CdpHolder memory subscription = CdpHolder({\n                minRatio: _minRatio,\n                maxRatio: localMaxRatio,\n                optimalRatioBoost: _optimalBoost,\n                optimalRatioRepay: _optimalRepay,\n                owner: msg.sender,\n                cdpId: _cdpId,\n                boostEnabled: _boostEnabled,\n                nextPriceEnabled: _nextPriceEnabled\n            });\n\n        changeIndex++;\n\n        if (subInfo.subscribed) {\n            subscribers[subInfo.arrPos] = subscription;\n\n            emit Updated(msg.sender, _cdpId);\n            emit ParamUpdates(msg.sender, _cdpId, _minRatio, localMaxRatio, _optimalBoost, _optimalRepay, _boostEnabled);\n        } else {\n            subscribers.push(subscription);\n\n            subInfo.arrPos = subscribers.length - 1;\n            subInfo.subscribed = true;\n\n            emit Subscribed(msg.sender, _cdpId);\n        }\n    }\n\n    /// @notice Called by the users DSProxy\n    /// @dev Owner who subscribed cancels his subscription\n    function unsubscribe(uint _cdpId) external {\n        require(isOwner(msg.sender, _cdpId), \"Must be called by Cdp owner\");\n\n        _unsubscribe(_cdpId);\n    }\n\n    /// @dev Checks if the _owner is the owner of the CDP\n    function isOwner(address _owner, uint _cdpId) internal view returns (bool) {\n        return getOwner(_cdpId) == _owner;\n    }\n\n    /// @dev Checks limit for minimum ratio and if minRatio is bigger than max\n    function checkParams(bytes32 _ilk, uint128 _minRatio, uint128 _maxRatio) internal view returns (bool) {\n        if (_minRatio < minLimits[_ilk]) {\n            return false;\n        }\n\n        if (_minRatio > _maxRatio) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @dev Internal method to remove a subscriber from the list\n    function _unsubscribe(uint _cdpId) internal {\n        require(subscribers.length > 0, \"Must have subscribers in the list\");\n\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        require(subInfo.subscribed, \"Must first be subscribed\");\n\n        uint lastCdpId = subscribers[subscribers.length - 1].cdpId;\n\n        SubPosition storage subInfo2 = subscribersPos[lastCdpId];\n        subInfo2.arrPos = subInfo.arrPos;\n\n        subscribers[subInfo.arrPos] = subscribers[subscribers.length - 1];\n        subscribers.pop();\n\n        changeIndex++;\n        subInfo.subscribed = false;\n        subInfo.arrPos = 0;\n\n        emit Unsubscribed(msg.sender, _cdpId);\n    }\n\n    /// @notice Returns an address that owns the CDP\n    /// @param _cdpId Id of the CDP\n    function getOwner(uint _cdpId) public view returns(address) {\n        return manager.owns(_cdpId);\n    }\n\n    /// @notice Helper method for the front to get all the info about the subscribed CDP\n    function getSubscribedInfo(uint _cdpId) public view returns(bool, uint128, uint128, uint128, uint128, address, uint coll, uint debt) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, 0, 0, 0, 0, address(0), 0, 0);\n\n        (coll, debt) = saverProxy.getCdpInfo(manager, _cdpId, manager.ilks(_cdpId));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (\n            true,\n            subscriber.minRatio,\n            subscriber.maxRatio,\n            subscriber.optimalRatioRepay,\n            subscriber.optimalRatioBoost,\n            subscriber.owner,\n            coll,\n            debt\n        );\n    }\n\n    function getCdpHolder(uint _cdpId) public view returns (bool subscribed, CdpHolder memory) {\n        SubPosition memory subInfo = subscribersPos[_cdpId];\n\n        if (!subInfo.subscribed) return (false, CdpHolder(0, 0, 0, 0, address(0), 0, false, false));\n\n        CdpHolder memory subscriber = subscribers[subInfo.arrPos];\n\n        return (true, subscriber);\n    }\n\n    /// @notice Helper method for the front to get the information about the ilk of a CDP\n    function getIlkInfo(bytes32 _ilk, uint _cdpId) public view returns(bytes32 ilk, uint art, uint rate, uint spot, uint line, uint dust, uint mat, uint par) {\n        // send either ilk or cdpId\n        if (_ilk == bytes32(0)) {\n            _ilk = manager.ilks(_cdpId);\n        }\n\n        ilk = _ilk;\n        (,mat) = spotter.ilks(_ilk);\n        par = spotter.par();\n        (art, rate, spot, line, dust) = vat.ilks(_ilk);\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    function getSubscribers() public view returns (CdpHolder[] memory) {\n        return subscribers;\n    }\n\n    /// @notice Helper method to return all the subscribed CDPs\n    function getSubscribersByPage(uint _page, uint _perPage) public view returns (CdpHolder[] memory) {\n        CdpHolder[] memory holders = new CdpHolder[](_perPage);\n\n        uint start = _page * _perPage;\n        uint end = start + _perPage;\n\n        uint count = 0;\n        for (uint i=start; i<end; i++) {\n            holders[count] = subscribers[i];\n            count++;\n        }\n\n        return holders;\n    }\n\n    ////////////// ADMIN METHODS ///////////////////\n\n    /// @notice Admin function to change a min. limit for an asset\n    function changeMinRatios(bytes32 _ilk, uint _newRatio) public onlyOwner {\n        minLimits[_ilk] = _newRatio;\n    }\n\n    /// @notice Admin function to unsubscribe a CDP\n    function unsubscribeByAdmin(uint _cdpId) public onlyOwner {\n        SubPosition storage subInfo = subscribersPos[_cdpId];\n\n        if (subInfo.subscribed) {\n            _unsubscribe(_cdpId);\n        }\n    }\n}\n"
    },
    "contracts/mcd/bids/BidProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../maker/Join.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../maker/Vat.sol\";\nimport \"../maker/Flipper.sol\";\nimport \"../maker/Gem.sol\";\nimport \"../saver_proxy/ExchangeHelper.sol\";\n\n\ncontract BidProxy is ExchangeHelper {\n\n    address public constant ETH_FLIPPER = 0xd8a04F5412223F513DC55F839574430f5EC15531;\n    address public constant BAT_FLIPPER = 0xaA745404d55f88C108A28c86abE7b5A1E7817c07;\n    address public constant DAI_JOIN = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\n    address public constant ETH_JOIN = 0x2F0b23f53734252Bda2277357e97e1517d6B042A;\n    address public constant BAT_JOIN = 0x3D0B1912B66114d4096F48A8CEe3A56C231772cA;\n\n    bytes32 public constant BAT_ILK = 0x4241542d41000000000000000000000000000000000000000000000000000000;\n    bytes32 public constant ETH_ILK = 0x4554482d41000000000000000000000000000000000000000000000000000000;\n\n    address public constant SAVER_EXCHANGE = 0x606e9758a39d2d7fA7e70BC68E6E7D9b02948962;\n\n    function daiBid(uint _bidId, bool _isEth, uint _amount) public {\n        uint tendAmount = _amount * (10 ** 27);\n        address flipper = _isEth ? ETH_FLIPPER : BAT_FLIPPER;\n\n        joinDai(_amount);\n\n        (, uint lot, , , , , , ) = Flipper(flipper).bids(_bidId);\n\n        Vat(VAT_ADDRESS).hope(flipper);\n\n        Flipper(flipper).tend(_bidId, lot, tendAmount);\n    }\n\n    function collateralBid(uint _bidId, bool _isEth, uint _amount) public {\n        address flipper = _isEth ? ETH_FLIPPER : BAT_FLIPPER;\n\n        uint bid;\n        (bid, , , , , , , ) = Flipper(flipper).bids(_bidId);\n\n        joinDai(bid / (10**27));\n\n        Vat(VAT_ADDRESS).hope(flipper);\n\n        Flipper(flipper).dent(_bidId, _amount, bid);\n    }\n\n    function closeBid(uint _bidId, bool _isEth) public {\n        address flipper = _isEth ? ETH_FLIPPER : BAT_FLIPPER;\n        address join = _isEth ? ETH_JOIN : BAT_JOIN;\n        bytes32 ilk = _isEth ? ETH_ILK : BAT_ILK;\n\n        Flipper(flipper).deal(_bidId);\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this)) / (10**27);\n\n        Vat(VAT_ADDRESS).hope(join);\n        Gem(join).exit(msg.sender, amount);\n    }\n\n    function closeBidAndExchange(\n        uint _bidId,\n        bool _isEth,\n        uint256[4] memory _data,\n        address _exchangeAddress,\n        bytes memory _callData\n    )\n    public {\n        address flipper = _isEth ? ETH_FLIPPER : BAT_FLIPPER;\n        address join = _isEth ? ETH_JOIN : BAT_JOIN;\n\n        (uint bidAmount, , , , , , , ) = Flipper(flipper).bids(_bidId);\n\n        Flipper(flipper).deal(_bidId);\n\n        Vat(VAT_ADDRESS).hope(join);\n        Gem(join).exit(address(this), (bidAmount / 10**27));\n\n        address srcToken = _isEth ? KYBER_ETH_ADDRESS : address(Gem(join).gem());\n\n        uint daiAmount = swap(\n            _data,\n            srcToken,\n            DAI_ADDRESS,\n            _exchangeAddress,\n            _callData\n        );\n\n        ERC20(DAI_ADDRESS).transfer(msg.sender, daiAmount);\n    }\n\n    function exitCollateral(bool _isEth) public {\n        address join = _isEth ? ETH_JOIN : BAT_JOIN;\n        bytes32 ilk = _isEth ? ETH_ILK : BAT_ILK;\n\n        uint amount = Vat(VAT_ADDRESS).gem(ilk, address(this));\n\n        Vat(VAT_ADDRESS).hope(join);\n        Gem(join).exit(msg.sender, amount);\n    }\n\n    function exitDai() public {\n        uint amount = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\n\n        Vat(VAT_ADDRESS).hope(DAI_JOIN);\n        Gem(DAI_JOIN).exit(msg.sender, amount);\n    }\n\n    function withdrawToken(address _token) public {\n        uint balance = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, balance);\n    }\n\n    function withdrawEth() public {\n        uint balance = address(this).balance;\n        msg.sender.transfer(balance);\n    }\n\n    function joinDai(uint _amount) internal {\n        uint amountInVat = Vat(VAT_ADDRESS).dai(address(this)) / (10**27);\n\n        if (_amount > amountInVat) {\n            uint amountDiff = (_amount - amountInVat) + 1;\n\n            ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), amountDiff);\n            ERC20(DAI_ADDRESS).approve(DAI_JOIN, amountDiff);\n            Join(DAI_JOIN).join(address(this), amountDiff);\n        }\n    }\n}\n"
    },
    "contracts/mcd/maker/Flipper.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Flipper {\n    function bids(uint _bidId) public virtual returns (uint256, uint256, address, uint48, uint48, address, address, uint256);\n    function tend(uint id, uint lot, uint bid) virtual external;\n    function dent(uint id, uint lot, uint bid) virtual external;\n    function deal(uint id) virtual external;\n}\n"
    },
    "contracts/mcd/flashloan/MCDCloseFlashLoan.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../mcd/saver_proxy/MCDSaverProxy.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\n\ncontract MCDCloseFlashLoan is MCDSaverProxy, FlashLoanReceiverBase {\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address payable public owner;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n        }\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (\n            uint256[6] memory data,\n            uint256[4] memory debtData,\n            address joinAddr,\n            address exchangeAddress,\n            bytes memory callData\n        )\n         = abi.decode(_params, (uint256[6],uint256[4],address,address,bytes));\n\n        closeCDP(data, debtData, joinAddr, exchangeAddress, callData, _fee);\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n\n    function closeCDP(\n        uint256[6] memory _data,\n        uint[4] memory debtData,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData,\n        uint _fee\n    ) internal {\n        address payable user = address(uint160(getOwner(manager, _data[0])));\n        address collateralAddr = getCollateralAddr(_joinAddr);\n\n        uint loanAmount = debtData[0];\n\n        paybackDebt(_data[0], manager.ilks(_data[0]), debtData[0], user); // payback whole debt\n        drawMaxCollateral(_data[0], _joinAddr, debtData[2]);\n\n        uint256 collAmount = getCollAmount(_data, loanAmount, collateralAddr);\n\n        // collDrawn, minPrice, exchangeType, 0xPrice\n        uint256[4] memory swapData = [collAmount, _data[2], _data[3], _data[5]];\n        uint256 daiSwaped = swap(\n            swapData,\n            collateralAddr,\n            DAI_ADDRESS,\n            _exchangeAddress,\n            _callData\n        );\n\n        daiSwaped = daiSwaped - getFee(daiSwaped, 0, user);\n\n        require(daiSwaped >= (loanAmount + _fee), \"We must exchange enough Dai tokens to repay loan\");\n\n        // If we swapped to much and have extra Dai\n        if (daiSwaped > (loanAmount + _fee)) {\n            swap(\n                [sub(daiSwaped, (loanAmount + _fee)), 0, 3, 1],\n                DAI_ADDRESS,\n                collateralAddr,\n                address(0),\n                _callData\n            );\n        }\n\n        // Give user the leftover collateral\n        if (collateralAddr == WETH_ADDRESS) {\n            require(address(this).balance >= debtData[3], \"Below min. number of eth specified\");\n            user.transfer(address(this).balance);\n        } else {\n            uint256 tokenBalance = ERC20(collateralAddr).balanceOf(address(this));\n\n            require(tokenBalance >= debtData[3], \"Below min. number of collateral specified\");\n            ERC20(collateralAddr).transfer(user, tokenBalance);\n        }\n    }\n\n    function getCollAmount(uint256[6] memory _data, uint256 _loanAmount, address _collateralAddr)\n        internal\n        view\n        returns (uint256 collAmount)\n    {\n        (, uint256 collPrice) = SaverExchangeInterface(SAVER_EXCHANGE_ADDRESS).getBestPrice(\n            _data[1],\n            _collateralAddr,\n            DAI_ADDRESS,\n            _data[2]\n        );\n        collPrice = sub(collPrice, collPrice / 50); // offset the price by 2%\n\n        collAmount = wdiv(_loanAmount, collPrice);\n    }\n\n    function drawMaxCollateral(uint _cdpId, address _joinAddr, uint _amount) internal returns (uint) {\n        manager.frob(_cdpId, -toPositiveInt(_amount), 0);\n        manager.flux(_cdpId, address(this), _amount);\n\n        uint joinAmount = _amount;\n\n        if (Join(_joinAddr).dec() != 18) {\n            joinAmount = _amount / (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        Join(_joinAddr).exit(address(this), joinAmount);\n\n        if (_joinAddr == ETH_JOIN_ADDRESS) {\n            Join(_joinAddr).gem().withdraw(joinAmount); // Weth -> Eth\n        }\n\n        return joinAmount;\n    }\n\n    receive() external override payable {}\n\n    // ADMIN ONLY FAIL SAFE FUNCTION IF FUNDS GET STUCK\n    function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            owner.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).transfer(owner, _amount);\n        }\n    }\n}\n"
    },
    "contracts/mcd/flashloan/MCDFlashLoanTaker.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../mcd/saver_proxy/MCDSaverProxy.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../loggers/FlashLoanLogger.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\n\nabstract contract IMCDSubscriptions {\n    function unsubscribe(uint256 _cdpId) external virtual ;\n\n    function subscribersPos(uint256 _cdpId) external virtual returns (uint256, bool);\n}\n\n\ncontract MCDFlashLoanTaker is ConstantAddresses, SaverProxyHelper {\n\n    address payable public constant MCD_SAVER_FLASH_LOAN = 0xCcFb21Ced87762a1d8425F867a7F8Ec2dFfaBE92;\n    address payable public constant MCD_CLOSE_FLASH_LOAN = 0xfCF3e72445D105c38C0fDC1a0687BDEeb8947a93;\n    address payable public constant MCD_OPEN_FLASH_LOAN = 0x86E132932566fb7030eeF19B997C8797De13CFBD;\n\n    address public constant SUBSCRIPTION_ADDRESS_NEW = 0xC45d4f6B6bf41b6EdAA58B01c4298B8d9078269a;\n\n    bytes32 public constant USDC_ILK = 0x555344432d410000000000000000000000000000000000000000000000000000;\n\n    address public constant AAVE_DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n    // address public constant MCD_CLOSE_FLASH_PROXY = 0xF6195D8d254bEF755fA8232D55Bb54B3b3eCf0Ce;\n    // address payable public constant MCD_OPEN_FLASH_PROXY = 0x22e37Df56cAFc7f33e9438751dff42DbD5CB8Ed6;\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    // solhint-disable-next-line const-name-snakecase\n    Manager public constant manager = Manager(MANAGER_ADDRESS);\n    // solhint-disable-next-line const-name-snakecase\n    FlashLoanLogger public constant logger = FlashLoanLogger(\n        0xb9303686B0EE92F92f63973EF85f3105329D345c\n    );\n\n    // solhint-disable-next-line const-name-snakecase\n    Vat public constant vat = Vat(VAT_ADDRESS);\n    // solhint-disable-next-line const-name-snakecase\n    Spotter public constant spotter = Spotter(SPOTTER_ADDRESS);\n\n    function boostWithLoan(\n        uint[6] memory _data, // cdpId, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable {\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        uint256 maxDebt = getMaxDebt(_data[0], manager.ilks(_data[0]));\n        uint256 debtAmount = _data[1];\n\n        require(debtAmount >= maxDebt, \"Amount to small for flash loan use CDP balance instead\");\n\n        uint256 loanAmount = sub(debtAmount, maxDebt);\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(_data, _joinAddr, _exchangeAddress, _callData, false);\n\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, AAVE_DAI_ADDRESS, loanAmount, paramsData);\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 0);\n\n        logger.logFlashLoan(\"Boost\", loanAmount, _data[0], msg.sender);\n    }\n\n    function repayWithLoan(\n        uint256[6] memory _data,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData\n    ) public payable {\n        MCD_SAVER_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        uint256 maxColl = getMaxCollateral(_data[0], manager.ilks(_data[0]), _joinAddr);\n\n        uint256 loanAmount = sub(_data[1], maxColl);\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 1);\n\n        bytes memory paramsData = abi.encode(_data, _joinAddr, _exchangeAddress, _callData, true);\n        lendingPool.flashLoan(MCD_SAVER_FLASH_LOAN, getAaveCollAddr(_joinAddr), loanAmount, paramsData);\n\n        manager.cdpAllow(_data[0], MCD_SAVER_FLASH_LOAN, 0);\n\n        logger.logFlashLoan(\"Repay\", loanAmount, _data[0], msg.sender);\n    }\n\n    function closeWithLoan(\n        uint256[6] memory _data,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData,\n        uint256 _minCollateral\n    ) public payable {\n        MCD_CLOSE_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n        bytes32 ilk = manager.ilks(_data[0]);\n\n        uint256 maxDebt = getMaxDebt(_data[0], ilk);\n\n        (uint256 collateral, ) = getCdpInfo(manager, _data[0], ilk);\n\n        uint256 wholeDebt = getAllDebt(\n            VAT_ADDRESS,\n            manager.urns(_data[0]),\n            manager.urns(_data[0]),\n            ilk\n        );\n\n        require(wholeDebt > maxDebt, \"No need for a flash loan\");\n\n        manager.cdpAllow(_data[0], MCD_CLOSE_FLASH_LOAN, 1);\n\n        uint[4] memory debtData = [wholeDebt, maxDebt, collateral, _minCollateral];\n        bytes memory paramsData = abi.encode(_data, debtData, _joinAddr, _exchangeAddress, _callData);\n\n        lendingPool.flashLoan(MCD_CLOSE_FLASH_LOAN, AAVE_DAI_ADDRESS, wholeDebt, paramsData);\n\n        manager.cdpAllow(_data[0], MCD_CLOSE_FLASH_LOAN, 0);\n\n        // If sub. to automatic protection unsubscribe\n        unsubscribe(SUBSCRIPTION_ADDRESS, _data[0]);\n        unsubscribe(SUBSCRIPTION_ADDRESS_NEW, _data[0]);\n\n        logger.logFlashLoan(\"Close\", wholeDebt, _data[0], msg.sender);\n    }\n\n    function openWithLoan(\n        uint256[6] memory _data, // collAmount, daiAmount, minPrice, exchangeType, gasCost, 0xPrice\n        bytes32 _ilk,\n        address _collJoin,\n        address _exchangeAddress,\n        bytes memory _callData,\n        address _proxy,\n        bool _isEth\n    ) public payable {\n        if (_isEth) {\n            MCD_OPEN_FLASH_LOAN.transfer(msg.value);\n        } else {\n            MCD_OPEN_FLASH_LOAN.transfer(msg.value); // 0x fee\n\n            ERC20(getCollateralAddr(_collJoin)).transferFrom(msg.sender, address(this), _data[0]);\n            ERC20(getCollateralAddr(_collJoin)).transfer(MCD_OPEN_FLASH_LOAN, _data[0]);\n        }\n\n        address[3] memory addrData = [_collJoin, _exchangeAddress, _proxy];\n\n        bytes memory paramsData = abi.encode(_data, _ilk, addrData, _callData, _isEth);\n\n        lendingPool.flashLoan(MCD_OPEN_FLASH_LOAN, AAVE_DAI_ADDRESS, _data[1], paramsData);\n\n        logger.logFlashLoan(\"Open\", manager.last(_proxy), _data[1], msg.sender);\n    }\n\n\n    /// @notice Gets the maximum amount of debt available to generate\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    function getMaxDebt(uint256 _cdpId, bytes32 _ilk) public view returns (uint256) {\n        uint256 price = getPrice(_ilk);\n\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (uint256 collateral, uint256 debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        return sub(wdiv(wmul(collateral, price), mat), debt);\n    }\n\n    /// @notice Gets the maximum amount of collateral available to draw\n    /// @param _cdpId Id of the CDP\n    /// @param _ilk Ilk of the CDP\n    /// @param _joinAddr Join Addr of collateral\n    /// @dev Substracts 10 wei to aviod rounding error later on\n    function getMaxCollateral(uint _cdpId, bytes32 _ilk, address _joinAddr) public view returns (uint) {\n        uint price = getPrice(_ilk);\n\n        (uint collateral, uint debt) = getCdpInfo(manager, _cdpId, _ilk);\n\n        (, uint mat) = Spotter(SPOTTER_ADDRESS).ilks(_ilk);\n\n        uint maxCollateral = sub(sub(collateral, (div(mul(mat, debt), price))), 10);\n\n        uint normalizeMaxCollateral = maxCollateral;\n\n        if (Join(_joinAddr).dec() != 18) {\n            normalizeMaxCollateral = maxCollateral / (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        return normalizeMaxCollateral;\n    }\n\n    /// @notice Gets a price of the asset\n    /// @param _ilk Ilk of the CDP\n    function getPrice(bytes32 _ilk) public view returns (uint256) {\n        (, uint256 mat) = spotter.ilks(_ilk);\n        (, , uint256 spot, , ) = vat.ilks(_ilk);\n\n        return rmul(rmul(spot, spotter.par()), mat);\n    }\n\n    function getAaveCollAddr(address _joinAddr) internal returns (address) {\n        if (_joinAddr == 0x2F0b23f53734252Bda2277357e97e1517d6B042A\n            || _joinAddr == 0x775787933e92b709f2a3C70aa87999696e74A9F8) {\n            return KYBER_ETH_ADDRESS;\n        } else {\n            return getCollateralAddr(_joinAddr);\n        }\n    }\n\n    function unsubscribe(address _subContract, uint _cdpId) internal {\n        (, bool isSubscribed) = IMCDSubscriptions(_subContract).subscribersPos(_cdpId);\n\n        if (isSubscribed) {\n            IMCDSubscriptions(_subContract).unsubscribe(_cdpId);\n        }\n    }\n\n}\n"
    },
    "contracts/mcd/flashloan/MCDOpenFlashLoan.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../mcd/saver_proxy/MCDSaverProxy.sol\";\nimport \"./MCDOpenProxyActions.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\n\n\ncontract MCDOpenFlashLoan is MCDSaverProxy, FlashLoanReceiverBase {\n    address public constant OPEN_PROXY_ACTIONS = 0x6d0984E80a86f26c0dd564ca0CF74a8E9Da03305;\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address payable public owner;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n        }\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (\n            uint[6] memory data,\n            bytes32 ilk,\n            address[3] memory addrData,\n            bytes memory callData,\n            bool isEth\n        )\n         = abi.decode(_params, (uint256[6],bytes32,address[3],bytes,bool));\n\n        openAndLeverage(data, ilk, addrData, callData, isEth, _fee);\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function openAndLeverage(\n        uint256[6] memory _data,\n        bytes32 _ilk,\n        address[3] memory addrData, // [_collJoin, _exchangeAddress, _proxy]\n        bytes memory _callData,\n        bool _isEth,\n        uint _fee\n    ) public {\n\n        // Exchange the Dai loaned to Eth\n        // solhint-disable-next-line no-unused-vars\n        uint256 collSwaped = swap(\n            [(_data[1] - getFee(_data[1], 0, tx.origin)), _data[2], _data[3], _data[4]],\n            DAI_ADDRESS,\n            getCollateralAddr(addrData[0]),\n            addrData[1],\n            _callData\n        );\n\n        if (_isEth) {\n            MCDOpenProxyActions(OPEN_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\n                address(manager),\n                JUG_ADDRESS,\n                ETH_JOIN_ADDRESS,\n                DAI_JOIN_ADDRESS,\n                _ilk,\n                (_data[1] + _fee),\n                addrData[2]\n            );\n        } else {\n            ERC20(getCollateralAddr(addrData[0])).approve(OPEN_PROXY_ACTIONS, uint256(-1));\n\n            MCDOpenProxyActions(OPEN_PROXY_ACTIONS).openLockGemAndDraw(\n                address(manager),\n                JUG_ADDRESS,\n                addrData[0],\n                DAI_JOIN_ADDRESS,\n                _ilk,\n                (_data[0] + collSwaped),\n                (_data[1] + _fee),\n                true,\n                addrData[2]\n            );\n        }\n    }\n\n    receive() external override payable {}\n\n    // ADMIN ONLY FAIL SAFE FUNCTION IF FUNDS GET STUCK\n    function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            owner.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).transfer(owner, _amount);\n        }\n    }\n}\n"
    },
    "contracts/mcd/flashloan/MCDOpenProxyActions.sol": {
      "content": "pragma solidity ^0.6.0;\n\n\nabstract contract GemLike {\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual;\n\n    function transferFrom(address, address, uint256) public virtual;\n\n    function deposit() public virtual payable;\n\n    function withdraw(uint256) public virtual;\n}\n\n\nabstract contract ManagerLike {\n    function cdpCan(address, uint256, address) public virtual view returns (uint256);\n\n    function ilks(uint256) public virtual view returns (bytes32);\n\n    function owns(uint256) public virtual view returns (address);\n\n    function urns(uint256) public virtual view returns (address);\n\n    function vat() public virtual view returns (address);\n\n    function open(bytes32, address) public virtual returns (uint256);\n\n    function give(uint256, address) public virtual;\n\n    function cdpAllow(uint256, address, uint256) public virtual;\n\n    function urnAllow(address, uint256) public virtual;\n\n    function frob(uint256, int256, int256) public virtual;\n\n    function flux(uint256, address, uint256) public virtual;\n\n    function move(uint256, address, uint256) public virtual;\n\n    function exit(address, uint256, address, uint256) public virtual;\n\n    function quit(uint256, address) public virtual;\n\n    function enter(address, uint256) public virtual;\n\n    function shift(uint256, uint256) public virtual;\n}\n\n\nabstract contract VatLike {\n    function can(address, address) public virtual view returns (uint256);\n\n    function ilks(bytes32) public virtual view returns (uint256, uint256, uint256, uint256, uint256);\n\n    function dai(address) public virtual view returns (uint256);\n\n    function urns(bytes32, address) public virtual view returns (uint256, uint256);\n\n    function frob(bytes32, address, address, address, int256, int256) public virtual;\n\n    function hope(address) public virtual;\n\n    function move(address, address, uint256) public virtual;\n}\n\n\nabstract contract GemJoinLike {\n    function dec() public virtual returns (uint256);\n\n    function gem() public virtual returns (GemLike);\n\n    function join(address, uint256) public virtual payable;\n\n    function exit(address, uint256) public virtual;\n}\n\n\nabstract contract GNTJoinLike {\n    function bags(address) public virtual view returns (address);\n\n    function make(address) public virtual returns (address);\n}\n\n\nabstract contract DaiJoinLike {\n    function vat() public virtual returns (VatLike);\n\n    function dai() public virtual returns (GemLike);\n\n    function join(address, uint256) public virtual payable;\n\n    function exit(address, uint256) public virtual;\n}\n\n\nabstract contract HopeLike {\n    function hope(address) public virtual;\n\n    function nope(address) public virtual;\n}\n\n\nabstract contract ProxyRegistryInterface {\n    function build(address) public virtual returns (address);\n}\n\n\nabstract contract EndLike {\n    function fix(bytes32) public virtual view returns (uint256);\n\n    function cash(bytes32, uint256) public virtual;\n\n    function free(bytes32) public virtual;\n\n    function pack(uint256) public virtual;\n\n    function skim(bytes32, address) public virtual;\n}\n\n\nabstract contract JugLike {\n    function drip(bytes32) public virtual returns (uint256);\n}\n\n\nabstract contract PotLike {\n    function pie(address) public virtual view returns (uint256);\n\n    function drip() public virtual returns (uint256);\n\n    function join(uint256) public virtual;\n\n    function exit(uint256) public virtual;\n}\n\n\nabstract contract ProxyRegistryLike {\n    function proxies(address) public virtual view returns (address);\n\n    function build(address) public virtual returns (address);\n}\n\n\nabstract contract ProxyLike {\n    function owner() public virtual view returns (address);\n}\n\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ncontract Common {\n    uint256 constant RAY = 10**27;\n\n    // Internal functions\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    // Public functions\n    // solhint-disable-next-line func-name-mixedcase\n    function daiJoin_join(address apt, address urn, uint256 wad) public {\n        // Gets DAI from the user's wallet\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the DAI amount\n        DaiJoinLike(apt).dai().approve(apt, wad);\n        // Joins DAI into the vat\n        DaiJoinLike(apt).join(urn, wad);\n    }\n}\n\n\ncontract MCDOpenProxyActions is Common {\n    // Internal functions\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    function toInt(uint256 x) internal pure returns (int256 y) {\n        y = int256(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    function toRad(uint256 wad) internal pure returns (uint256 rad) {\n        rad = mul(wad, 10**27);\n    }\n\n    function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\n        // Adapters will automatically handle the difference of precision\n        wad = mul(amt, 10**(18 - GemJoinLike(gemJoin).dec()));\n    }\n\n    function _getDrawDart(address vat, address jug, address urn, bytes32 ilk, uint256 wad)\n        internal\n        returns (int256 dart)\n    {\n        // Updates stability fee rate\n        uint256 rate = JugLike(jug).drip(ilk);\n\n        // Gets DAI balance of the urn in the vat\n        uint256 dai = VatLike(vat).dai(urn);\n\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\n        if (dai < mul(wad, RAY)) {\n            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\n            dart = toInt(sub(mul(wad, RAY), dai) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\n            dart = mul(uint256(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\n        }\n    }\n\n    function _getWipeDart(address vat, uint256 dai, address urn, bytes32 ilk)\n        internal\n        view\n        returns (int256 dart)\n    {\n        // Gets actual rate from the vat\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\n        // Gets actual art value of the urn\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\n\n        // Uses the whole dai balance in the vat to reduce the debt\n        dart = toInt(dai / rate);\n        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\n        dart = uint256(dart) <= art ? -dart : -toInt(art);\n    }\n\n    function _getWipeAllWad(address vat, address usr, address urn, bytes32 ilk)\n        internal\n        view\n        returns (uint256 wad)\n    {\n        // Gets actual rate from the vat\n        (, uint256 rate, , , ) = VatLike(vat).ilks(ilk);\n        // Gets actual art value of the urn\n        (, uint256 art) = VatLike(vat).urns(ilk, urn);\n        // Gets actual dai amount in the urn\n        uint256 dai = VatLike(vat).dai(usr);\n\n        uint256 rad = sub(mul(art, rate), dai);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n    // Public functions\n\n    function transfer(address gem, address dst, uint256 wad) public {\n        GemLike(gem).transfer(dst, wad);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function ethJoin_join(address apt, address urn) public payable {\n        // Wraps ETH in WETH\n        GemJoinLike(apt).gem().deposit{value: msg.value}();\n        // Approves adapter to take the WETH amount\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\n        // Joins WETH collateral into the vat\n        GemJoinLike(apt).join(urn, msg.value);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function gemJoin_join(address apt, address urn, uint256 wad, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), wad);\n            // Approves adapter to take the token amount\n            GemJoinLike(apt).gem().approve(apt, wad);\n        }\n        // Joins token collateral into the vat\n        GemJoinLike(apt).join(urn, wad);\n    }\n\n    function hope(address obj, address usr) public {\n        HopeLike(obj).hope(usr);\n    }\n\n    function nope(address obj, address usr) public {\n        HopeLike(obj).nope(usr);\n    }\n\n    function open(address manager, bytes32 ilk, address usr) public returns (uint256 cdp) {\n        cdp = ManagerLike(manager).open(ilk, usr);\n    }\n\n    function give(address manager, uint256 cdp, address usr) public {\n        ManagerLike(manager).give(cdp, usr);\n    }\n\n    function move(address manager, uint256 cdp, address dst, uint256 rad) public {\n        ManagerLike(manager).move(cdp, dst, rad);\n    }\n\n    function frob(address manager, uint256 cdp, int256 dink, int256 dart) public {\n        ManagerLike(manager).frob(cdp, dink, dart);\n    }\n\n    function lockETH(address manager, address ethJoin, uint256 cdp) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n    }\n\n    function lockGem(address manager, address gemJoin, uint256 cdp, uint256 wad, bool transferFrom)\n        public\n    {\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, address(this), wad, transferFrom);\n        // Locks token amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(gemJoin, wad)),\n            0\n        );\n    }\n\n    function draw(address manager, address jug, address daiJoin, uint256 cdp, uint256 wad) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Generates debt in the CDP\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wad);\n    }\n\n    function lockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        uint256 cdp,\n        uint256 wadD\n    ) public payable {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, urn);\n        // Locks WETH amount into the CDP and generates debt\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint256 wadD,\n        address owner\n    ) public payable returns (uint256 cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n        give(manager, cdp, owner);\n    }\n\n    function lockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        uint256 cdp,\n        uint256 wadC,\n        uint256 wadD,\n        bool transferFrom\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, urn, wadC, transferFrom);\n        // Locks token amount into the CDP and generates debt\n        frob(\n            manager,\n            cdp,\n            toInt(convertTo18(gemJoin, wadC)),\n            _getDrawDart(vat, jug, urn, ilk, wadD)\n        );\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint256 wadC,\n        uint256 wadD,\n        bool transferFrom,\n        address owner\n    ) public returns (uint256 cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, wadC, wadD, transferFrom);\n        give(manager, cdp, owner);\n    }\n}\n"
    },
    "contracts/mcd/flashloan/MCDSaverFlashLoan.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../mcd/saver_proxy/MCDSaverProxy.sol\";\nimport \"../../utils/FlashLoanReceiverBase.sol\";\n\ncontract MCDSaverFlashLoan is MCDSaverProxy, FlashLoanReceiverBase {\n    Manager public constant MANAGER = Manager(MANAGER_ADDRESS);\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n\n    address payable public owner;\n\n    constructor()\n        FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER)\n        public {\n            owner = msg.sender;\n    }\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n\n        //check the contract has the specified balance\n        require(_amount <= getBalanceInternal(address(this), _reserve),\n            \"Invalid balance for the contract\");\n\n        (\n            uint[6] memory data,\n            address joinAddr,\n            address exchangeAddress,\n            bytes memory callData,\n            bool isRepay\n        )\n         = abi.decode(_params, (uint256[6],address,address,bytes,bool));\n\n        if (isRepay) {\n            repayWithLoan(data, _amount, joinAddr, exchangeAddress, callData, _fee);\n        } else {\n            boostWithLoan(data, _amount, joinAddr, exchangeAddress, callData, _fee);\n        }\n\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function boostWithLoan(\n        uint256[6] memory _data,\n        uint256 _loanAmount,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData,\n        uint _fee\n    ) internal boostCheck(_data[0]) {\n\n        // maxDebt,    daiDrawn,   dfsFee,     amountToSwap, swapedAmount\n        // amounts[0], amounts[1], amounts[2], amounts[3],   amounts[4]\n        uint[] memory amounts = new uint[](5);\n        address owner = getOwner(MANAGER, _data[0]);\n\n        // Draw users Dai\n        amounts[0] = getMaxDebt(_data[0], manager.ilks(_data[0]));\n        amounts[1] = drawDai(_data[0], MANAGER.ilks(_data[0]), amounts[0]);\n\n        // Calc. fees\n        amounts[2] = getFee((amounts[1] + _loanAmount), _data[4], owner);\n        amounts[3] = (amounts[1] + _loanAmount) - amounts[2];\n\n        // Swap Dai to collateral\n        amounts[4] = swap(\n            [amounts[3], _data[2], _data[3], _data[5]],\n            DAI_ADDRESS,\n            getCollateralAddr(_joinAddr),\n            _exchangeAddress,\n            _callData\n        );\n\n        // Return collateral\n        addCollateral(_data[0], _joinAddr, amounts[4]);\n\n        // Draw Dai to repay the flash loan\n        drawDai(_data[0],  manager.ilks(_data[0]), (_loanAmount + _fee));\n\n        SaverLogger(LOGGER_ADDRESS).LogBoost(_data[0], owner, (amounts[1] + _loanAmount), amounts[4]);\n    }\n\n    function repayWithLoan(\n        uint256[6] memory _data,\n        uint256 _loanAmount,\n        address _joinAddr,\n        address _exchangeAddress,\n        bytes memory _callData,\n        uint _fee\n    ) internal repayCheck(_data[0]) {\n\n        // maxColl,    collDrawn,  swapedAmount, dfsFee\n        // amounts[0], amounts[1], amounts[2],   amounts[3]\n        uint[] memory amounts = new uint[](4);\n        address owner = getOwner(MANAGER, _data[0]);\n\n        // Draw collateral\n        amounts[0] = getMaxCollateral(_data[0], manager.ilks(_data[0]), _joinAddr);\n        amounts[1] = drawCollateral(_data[0], manager.ilks(_data[0]), _joinAddr, amounts[0]);\n\n        // Swap for Dai\n        amounts[2] = swap(\n            [(amounts[1] + _loanAmount), _data[2], _data[3], _data[5]],\n            getCollateralAddr(_joinAddr),\n            DAI_ADDRESS,\n            _exchangeAddress,\n            _callData\n        );\n\n        // Get our fee\n        amounts[3] = getFee(amounts[2], _data[4], owner);\n\n        uint paybackAmount = (amounts[2] - amounts[3]);\n        paybackAmount = limitLoanAmount(_data[0], manager.ilks(_data[0]), paybackAmount, owner);\n\n        // Payback the debt\n        paybackDebt(_data[0], MANAGER.ilks(_data[0]), paybackAmount, owner);\n\n        // Draw collateral to repay the flash loan\n        drawCollateral(_data[0], manager.ilks(_data[0]), _joinAddr, (_loanAmount + _fee));\n\n        SaverLogger(LOGGER_ADDRESS).LogRepay(_data[0], owner, (amounts[1] + _loanAmount), amounts[2]);\n    }\n\n    receive() external override payable {}\n\n    /// @notice Handles that the amount is not bigger than cdp debt and not dust\n    function limitLoanAmount(uint _cdpId, bytes32 _ilk, uint _paybackAmount, address _owner) internal returns (uint256) {\n        uint debt = getAllDebt(address(vat), manager.urns(_cdpId), manager.urns(_cdpId), _ilk);\n\n        if (_paybackAmount > debt) {\n            ERC20(DAI_ADDRESS).transfer(_owner, (_paybackAmount - debt));\n            return debt;\n        }\n\n        uint debtLeft = debt - _paybackAmount;\n\n        // Less than dust value\n        if (debtLeft < 20 ether) {\n            uint amountOverDust = ((20 ether) - debtLeft);\n\n            ERC20(DAI_ADDRESS).transfer(_owner, amountOverDust);\n\n            return (_paybackAmount - amountOverDust);\n        }\n\n        return _paybackAmount;\n    }\n\n    // ADMIN ONLY FAIL SAFE FUNCTION IF FUNDS GET STUCK\n    function withdrawStuckFunds(address _tokenAddr, uint _amount) public {\n        require(msg.sender == owner, \"Only owner\");\n\n        if (_tokenAddr == KYBER_ETH_ADDRESS) {\n            owner.transfer(_amount);\n        } else {\n            ERC20(_tokenAddr).transfer(owner, _amount);\n        }\n    }\n}\n"
    },
    "contracts/mcd/general/SaverProxyActions.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract GemLike {\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract ManagerLike {\n    function cdpCan(address, uint, address) virtual public view returns (uint);\n    function ilks(uint) virtual public view returns (bytes32);\n    function owns(uint) virtual public view returns (address);\n    function urns(uint) virtual public view returns (address);\n    function vat() virtual public view returns (address);\n    function open(bytes32, address) virtual public returns (uint);\n    function give(uint, address) virtual public;\n    function cdpAllow(uint, address, uint) virtual public;\n    function urnAllow(address, uint) virtual public;\n    function frob(uint, int, int) virtual public;\n    function flux(uint, address, uint) virtual public;\n    function move(uint, address, uint) virtual public;\n    function exit(address, uint, address, uint) virtual public;\n    function quit(uint, address) virtual public;\n    function enter(address, uint) virtual public;\n    function shift(uint, uint) virtual public;\n}\n\nabstract contract VatLike {\n    function can(address, address) virtual public view returns (uint);\n    function ilks(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\n    function dai(address) virtual public view returns (uint);\n    function urns(bytes32, address) virtual public view returns (uint, uint);\n    function frob(bytes32, address, address, address, int, int) virtual public;\n    function hope(address) virtual public;\n    function move(address, address, uint) virtual public;\n}\n\nabstract contract GemJoinLike {\n    function dec() virtual public returns (uint);\n    function gem() virtual public returns (GemLike);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\nabstract contract GNTJoinLike {\n    function bags(address) virtual public view returns (address);\n    function make(address) virtual public returns (address);\n}\n\nabstract contract DaiJoinLike {\n    function vat() virtual public returns (VatLike);\n    function dai() virtual public returns (GemLike);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\nabstract contract HopeLike {\n    function hope(address) virtual public;\n    function nope(address) virtual public;\n}\n\nabstract contract ProxyRegistryInterface {\n    function proxies(address _owner) virtual public view returns (address);\n    function build(address) virtual public returns (address);\n}\n\nabstract contract EndLike {\n    function fix(bytes32) virtual public view returns (uint);\n    function cash(bytes32, uint) virtual public;\n    function free(bytes32) virtual public;\n    function pack(uint) virtual public;\n    function skim(bytes32, address) virtual public;\n}\n\nabstract contract JugLike {\n    function drip(bytes32) virtual public returns (uint);\n}\n\nabstract contract PotLike {\n    function pie(address) virtual public view returns (uint);\n    function drip() virtual public returns (uint);\n    function join(uint) virtual public;\n    function exit(uint) virtual public;\n}\n\nabstract contract ProxyRegistryLike {\n    function proxies(address) virtual public view returns (address);\n    function build(address) virtual public returns (address);\n}\n\nabstract contract ProxyLike {\n    function owner() virtual public view returns (address);\n}\n\nabstract contract DSProxy {\n    function execute(address _target, bytes memory _data) virtual public payable returns (bytes32);\n    function setOwner(address owner_) virtual public;\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ncontract Common {\n    uint256 constant RAY = 10 ** 27;\n\n    // Internal functions\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n    }\n\n    // Public functions\n\n    function daiJoin_join(address apt, address urn, uint wad) public {\n        // Gets DAI from the user's wallet\n        DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        // Approves adapter to take the DAI amount\n        DaiJoinLike(apt).dai().approve(apt, wad);\n        // Joins DAI into the vat\n        DaiJoinLike(apt).join(urn, wad);\n    }\n}\n\ncontract SaverProxyActions is Common {\n\n\n    event CDPAction(string indexed, uint indexed, uint, uint);\n\n    // Internal functions\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, \"sub-overflow\");\n    }\n\n    function toInt(uint x) internal pure returns (int y) {\n        y = int(x);\n        require(y >= 0, \"int-overflow\");\n    }\n\n    function toRad(uint wad) internal pure returns (uint rad) {\n        rad = mul(wad, 10 ** 27);\n    }\n\n    function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\n        // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\n        // Adapters will automatically handle the difference of precision\n        wad = mul(\n            amt,\n            10 ** (18 - GemJoinLike(gemJoin).dec())\n        );\n    }\n\n    function _getDrawDart(\n        address vat,\n        address jug,\n        address urn,\n        bytes32 ilk,\n        uint wad\n    ) internal returns (int dart) {\n        // Updates stability fee rate\n        uint rate = JugLike(jug).drip(ilk);\n\n        // Gets DAI balance of the urn in the vat\n        uint dai = VatLike(vat).dai(urn);\n\n        // If there was already enough DAI in the vat balance, just exits it without adding more debt\n        if (dai < mul(wad, RAY)) {\n            // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\n            dart = toInt(sub(mul(wad, RAY), dai) / rate);\n            // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\n            dart = mul(uint(dart), rate) < mul(wad, RAY) ? dart + 1 : dart;\n        }\n    }\n\n    function _getWipeDart(\n        address vat,\n        uint dai,\n        address urn,\n        bytes32 ilk\n    ) internal view returns (int dart) {\n        // Gets actual rate from the vat\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\n        // Gets actual art value of the urn\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        // Uses the whole dai balance in the vat to reduce the debt\n        dart = toInt(dai / rate);\n        // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\n        dart = uint(dart) <= art ? - dart : - toInt(art);\n    }\n\n    function _getWipeAllWad(\n        address vat,\n        address usr,\n        address urn,\n        bytes32 ilk\n    ) internal view returns (uint wad) {\n        // Gets actual rate from the vat\n        (, uint rate,,,) = VatLike(vat).ilks(ilk);\n        // Gets actual art value of the urn\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n        // Gets actual dai amount in the urn\n        uint dai = VatLike(vat).dai(usr);\n\n        uint rad = sub(mul(art, rate), dai);\n        wad = rad / RAY;\n\n        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n        wad = mul(wad, RAY) < rad ? wad + 1 : wad;\n    }\n\n    // Public functions\n\n    function transfer(address gem, address dst, uint wad) public {\n        GemLike(gem).transfer(dst, wad);\n    }\n\n    function ethJoin_join(address apt, address urn) public payable {\n        // Wraps ETH in WETH\n        GemJoinLike(apt).gem().deposit{value: msg.value}();\n        // Approves adapter to take the WETH amount\n        GemJoinLike(apt).gem().approve(address(apt), msg.value);\n        // Joins WETH collateral into the vat\n        GemJoinLike(apt).join(urn, msg.value);\n    }\n\n    function gemJoin_join(address apt, address urn, uint wad, bool transferFrom) public {\n        // Only executes for tokens that have approval/transferFrom implementation\n        if (transferFrom) {\n            // Gets token from the user's wallet\n            GemJoinLike(apt).gem().transferFrom(msg.sender, address(this), wad);\n            // Approves adapter to take the token amount\n            GemJoinLike(apt).gem().approve(apt, wad);\n        }\n        // Joins token collateral into the vat\n        GemJoinLike(apt).join(urn, wad);\n    }\n\n    function hope(\n        address obj,\n        address usr\n    ) public {\n        HopeLike(obj).hope(usr);\n    }\n\n    function nope(\n        address obj,\n        address usr\n    ) public {\n        HopeLike(obj).nope(usr);\n    }\n\n    function open(\n        address manager,\n        bytes32 ilk,\n        address usr\n    ) public returns (uint cdp) {\n        cdp = ManagerLike(manager).open(ilk, usr);\n    }\n\n    function give(\n        address manager,\n        uint cdp,\n        address usr\n    ) public {\n        ManagerLike(manager).give(cdp, usr);\n\n        emit CDPAction('give', cdp, 0, 0);\n    }\n\n    function giveToProxy(\n        address proxyRegistry,\n        address manager,\n        uint cdp,\n        address dst\n    ) public {\n        // Gets actual proxy address\n        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n        // Checks if the proxy address already existed and dst address is still the owner\n        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n            uint csize;\n            assembly {\n                csize := extcodesize(dst)\n            }\n            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the CDP\n            require(csize == 0, \"Dst-is-a-contract\");\n            // Creates the proxy for the dst address\n            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n        }\n        // Transfers CDP to the dst proxy\n        give(manager, cdp, proxy);\n    }\n\n    function cdpAllow(\n        address manager,\n        uint cdp,\n        address usr,\n        uint ok\n    ) public {\n        ManagerLike(manager).cdpAllow(cdp, usr, ok);\n    }\n\n    function urnAllow(\n        address manager,\n        address usr,\n        uint ok\n    ) public {\n        ManagerLike(manager).urnAllow(usr, ok);\n    }\n\n    function flux(\n        address manager,\n        uint cdp,\n        address dst,\n        uint wad\n    ) public {\n        ManagerLike(manager).flux(cdp, dst, wad);\n    }\n\n    function move(\n        address manager,\n        uint cdp,\n        address dst,\n        uint rad\n    ) public {\n        ManagerLike(manager).move(cdp, dst, rad);\n    }\n\n    function frob(\n        address manager,\n        uint cdp,\n        int dink,\n        int dart\n    ) public {\n        ManagerLike(manager).frob(cdp, dink, dart);\n    }\n\n    function quit(\n        address manager,\n        uint cdp,\n        address dst\n    ) public {\n        ManagerLike(manager).quit(cdp, dst);\n    }\n\n    function enter(\n        address manager,\n        address src,\n        uint cdp\n    ) public {\n        ManagerLike(manager).enter(src, cdp);\n    }\n\n    function shift(\n        address manager,\n        uint cdpSrc,\n        uint cdpOrg\n    ) public {\n        ManagerLike(manager).shift(cdpSrc, cdpOrg);\n    }\n\n    function makeGemBag(\n        address gemJoin\n    ) public returns (address bag) {\n        bag = GNTJoinLike(gemJoin).make(address(this));\n    }\n\n    function lockETH(\n        address manager,\n        address ethJoin,\n        uint cdp\n    ) public payable {\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, address(this));\n        // Locks WETH amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(msg.value),\n            0\n        );\n\n        emit CDPAction('lockETH', cdp, msg.value, 0);\n    }\n\n    function lockGem(\n        address manager,\n        address gemJoin,\n        uint cdp,\n        uint wad,\n        bool transferFrom\n    ) public {\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, address(this), wad, transferFrom);\n        // Locks token amount into the CDP\n        VatLike(ManagerLike(manager).vat()).frob(\n            ManagerLike(manager).ilks(cdp),\n            ManagerLike(manager).urns(cdp),\n            address(this),\n            address(this),\n            toInt(convertTo18(gemJoin, wad)),\n            0\n        );\n\n        emit CDPAction('lockGem', cdp, wad, 0);\n    }\n\n    function freeETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Unlocks WETH amount from the CDP\n        frob(manager, cdp, -toInt(wad), 0);\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n\n        emit CDPAction('freeETH', cdp, wad, 0);\n    }\n\n    function freeGem(\n        address manager,\n        address gemJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        uint wad18 = convertTo18(gemJoin, wad);\n        // Unlocks token amount from the CDP\n        frob(manager, cdp, -toInt(wad18), 0);\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad18);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wad);\n\n        emit CDPAction('freeGem', cdp, wad, 0);\n    }\n\n    function exitETH(\n        address manager,\n        address ethJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad);\n\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wad);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wad);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wad);\n    }\n\n    function exitGem(\n        address manager,\n        address gemJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), convertTo18(gemJoin, wad));\n\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wad);\n    }\n\n    function draw(\n        address manager,\n        address jug,\n        address daiJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Generates debt in the CDP\n        frob(manager, cdp, 0, _getDrawDart(vat, jug, urn, ilk, wad));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wad));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wad);\n\n        emit CDPAction('draw', cdp, 0, wad);\n    }\n\n    function wipe(\n        address manager,\n        address daiJoin,\n        uint cdp,\n        uint wad\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n\n        address own = ManagerLike(manager).owns(cdp);\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, urn, wad);\n            // Paybacks debt to the CDP\n            frob(manager, cdp, 0, _getWipeDart(vat, VatLike(vat).dai(urn), urn, ilk));\n        } else {\n             // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, address(this), wad);\n            // Paybacks debt to the CDP\n            VatLike(vat).frob(\n                ilk,\n                urn,\n                address(this),\n                address(this),\n                0,\n                _getWipeDart(vat, wad * RAY, urn, ilk)\n            );\n        }\n\n        emit CDPAction('wipe', cdp, 0, wad);\n    }\n\n    function wipeAll(\n        address manager,\n        address daiJoin,\n        uint cdp\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        address own = ManagerLike(manager).owns(cdp);\n        if (own == address(this) || ManagerLike(manager).cdpCan(own, cdp, address(this)) == 1) {\n            // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n            // Paybacks debt to the CDP\n            frob(manager, cdp, 0, -int(art));\n        } else {\n            // Joins DAI amount into the vat\n            daiJoin_join(daiJoin, address(this), _getWipeAllWad(vat, address(this), urn, ilk));\n            // Paybacks debt to the CDP\n            VatLike(vat).frob(\n                ilk,\n                urn,\n                address(this),\n                address(this),\n                0,\n                -int(art)\n            );\n        }\n\n        emit CDPAction('wipeAll', cdp, 0, art);\n    }\n\n    function lockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadD\n    ) public payable {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Receives ETH amount, converts it to WETH and joins it into the vat\n        ethJoin_join(ethJoin, urn);\n        // Locks WETH amount into the CDP and generates debt\n        frob(manager, cdp, toInt(msg.value), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n    }\n\n    function openLockETHAndDraw(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadD\n    ) public payable returns (uint cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockETHAndDraw(manager, jug, ethJoin, daiJoin, cdp, wadD);\n\n        emit CDPAction('openLockETHAndDraw', cdp, msg.value, wadD);\n    }\n\n    function lockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC,\n        uint wadD,\n        bool transferFrom\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        address vat = ManagerLike(manager).vat();\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        // Takes token amount from user's wallet and joins into the vat\n        gemJoin_join(gemJoin, urn, wadC, transferFrom);\n        // Locks token amount into the CDP and generates debt\n        frob(manager, cdp, toInt(convertTo18(gemJoin, wadC)), _getDrawDart(vat, jug, urn, ilk, wadD));\n        // Moves the DAI amount (balance in the vat in rad) to proxy's address\n        move(manager, cdp, address(this), toRad(wadD));\n        // Allows adapter to access to proxy's DAI balance in the vat\n        if (VatLike(vat).can(address(this), address(daiJoin)) == 0) {\n            VatLike(vat).hope(daiJoin);\n        }\n        // Exits DAI to the user's wallet as a token\n        DaiJoinLike(daiJoin).exit(msg.sender, wadD);\n\n    }\n\n    function openLockGemAndDraw(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadC,\n        uint wadD,\n        bool transferFrom\n    ) public returns (uint cdp) {\n        cdp = open(manager, ilk, address(this));\n        lockGemAndDraw(manager, jug, gemJoin, daiJoin, cdp, wadC, wadD, transferFrom);\n\n        emit CDPAction('openLockGemAndDraw', cdp, wadC, wadD);\n\n    }\n\n    function wipeAllAndFreeETH(\n        address manager,\n        address ethJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n        // Paybacks debt to the CDP and unlocks WETH amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wadC),\n            -int(art)\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wadC);\n        // Exits WETH amount to proxy address as a token\n        GemJoinLike(ethJoin).exit(address(this), wadC);\n        // Converts WETH to ETH\n        GemJoinLike(ethJoin).gem().withdraw(wadC);\n        // Sends ETH back to the user's wallet\n        msg.sender.transfer(wadC);\n\n        emit CDPAction('wipeAllAndFreeETH', cdp, wadC, art);\n    }\n\n    function wipeAndFreeGem(\n        address manager,\n        address gemJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC,\n        uint wadD\n    ) public {\n        address urn = ManagerLike(manager).urns(cdp);\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, wadD);\n        uint wad18 = convertTo18(gemJoin, wadC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wad18),\n            _getWipeDart(ManagerLike(manager).vat(), VatLike(ManagerLike(manager).vat()).dai(urn), urn, ManagerLike(manager).ilks(cdp))\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad18);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wadC);\n    }\n\n    function wipeAllAndFreeGem(\n        address manager,\n        address gemJoin,\n        address daiJoin,\n        uint cdp,\n        uint wadC\n    ) public {\n        address vat = ManagerLike(manager).vat();\n        address urn = ManagerLike(manager).urns(cdp);\n        bytes32 ilk = ManagerLike(manager).ilks(cdp);\n        (, uint art) = VatLike(vat).urns(ilk, urn);\n\n        // Joins DAI amount into the vat\n        daiJoin_join(daiJoin, urn, _getWipeAllWad(vat, urn, urn, ilk));\n        uint wad18 = convertTo18(gemJoin, wadC);\n        // Paybacks debt to the CDP and unlocks token amount from it\n        frob(\n            manager,\n            cdp,\n            -toInt(wad18),\n            -int(art)\n        );\n        // Moves the amount from the CDP urn to proxy's address\n        flux(manager, cdp, address(this), wad18);\n        // Exits token amount to the user's wallet as a token\n        GemJoinLike(gemJoin).exit(msg.sender, wadC);\n\n        emit CDPAction('wipeAllAndFreeGem', cdp, wadC, art);\n    }\n\n    function createProxyAndCDP(\n        address manager,\n        address jug,\n        address ethJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadD,\n        address registry\n        ) public payable returns(uint) {\n\n            address proxy = ProxyRegistryInterface(registry).build(msg.sender);\n\n            uint cdp = openLockETHAndDraw(manager,\n                jug,\n                ethJoin,\n                daiJoin,\n                ilk,\n                wadD\n                );\n\n            give(manager, cdp, address(proxy));\n\n            return cdp;\n\n    }\n\n    function createProxyAndGemCDP(\n        address manager,\n        address jug,\n        address gemJoin,\n        address daiJoin,\n        bytes32 ilk,\n        uint wadC,\n        uint wadD,\n        bool transferFrom,\n        address registry\n        ) public returns(uint) {\n\n\n            address proxy = ProxyRegistryInterface(registry).build(msg.sender);\n\n            uint cdp = openLockGemAndDraw(manager,\n                jug,\n                gemJoin,\n                daiJoin,\n                ilk,\n                wadC,\n                wadD,\n                transferFrom);\n\n            give(manager, cdp, address(proxy));\n\n            return cdp;\n    }\n}\n"
    },
    "contracts/mcd/maker/Cat.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Cat {\n    struct Ilk {\n        address flip;  // Liquidator\n        uint256 chop;  // Liquidation Penalty   [ray]\n        uint256 lump;  // Liquidation Quantity  [wad]\n    }\n\n    mapping (bytes32 => Ilk) public ilks;\n}\n"
    },
    "contracts/mcd/maker/DSSProxyActions.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract GemLike {\n    function approve(address, uint) public virtual;\n    function transfer(address, uint) public virtual;\n    function transferFrom(address, address, uint) public virtual;\n    function deposit() public virtual payable;\n    function withdraw(uint) public virtual;\n}\n\nabstract contract ManagerLike {\n    function cdpCan(address, uint, address) public virtual view returns (uint);\n    function ilks(uint) public virtual view returns (bytes32);\n    function owns(uint) public virtual view returns (address);\n    function urns(uint) public virtual view returns (address);\n    function vat() public virtual view returns (address);\n    function open(bytes32) public virtual returns (uint);\n    function give(uint, address) public virtual;\n    function cdpAllow(uint, address, uint) public virtual;\n    function urnAllow(address, uint) public virtual;\n    function frob(uint, int, int) public virtual;\n    function frob(uint, address, int, int) public virtual;\n    function flux(uint, address, uint) public virtual;\n    function move(uint, address, uint) public virtual;\n    function exit(address, uint, address, uint) public virtual;\n    function quit(uint, address) public virtual;\n    function enter(address, uint) public virtual;\n    function shift(uint, uint) public virtual;\n}\n\nabstract contract VatLike {\n    function can(address, address) public virtual view returns (uint);\n    function ilks(bytes32) public virtual view returns (uint, uint, uint, uint, uint);\n    function dai(address) public virtual view returns (uint);\n    function urns(bytes32, address) public virtual view returns (uint, uint);\n    function frob(bytes32, address, address, address, int, int) public virtual;\n    function hope(address) public virtual;\n    function move(address, address, uint) public virtual;\n}\n\nabstract contract GemJoinLike {\n    function dec() public virtual returns (uint);\n    function gem() public virtual returns (GemLike);\n    function join(address, uint) public virtual payable;\n    function exit(address, uint) public virtual;\n}\n\nabstract contract GNTJoinLike {\n    function bags(address) public virtual view returns (address);\n    function make(address) public virtual returns (address);\n}\n\nabstract contract DaiJoinLike {\n    function vat() public virtual returns (VatLike);\n    function dai() public virtual returns (GemLike);\n    function join(address, uint) public virtual payable;\n    function exit(address, uint) public virtual;\n}\n\nabstract contract HopeLike {\n    function hope(address) public virtual;\n    function nope(address) public virtual;\n}\n\nabstract contract EndLike {\n    function fix(bytes32) public virtual view returns (uint);\n    function cash(bytes32, uint) public virtual;\n    function free(bytes32) public virtual;\n    function pack(uint) public virtual;\n    function skim(bytes32, address) public virtual;\n}\n\nabstract contract JugLike {\n    function drip(bytes32) public virtual;\n}\n\nabstract contract PotLike {\n    function chi() public virtual view returns (uint);\n    function pie(address) public virtual view returns (uint);\n    function drip() public virtual;\n    function join(uint) public virtual;\n    function exit(uint) public virtual;\n}\n\nabstract contract ProxyRegistryLike {\n    function proxies(address) public virtual view returns (address);\n    function build(address) public virtual returns (address);\n}\n\nabstract contract ProxyLike {\n    function owner() public virtual view returns (address);\n}\n\nabstract contract DssProxyActions {\n    function daiJoin_join(address apt, address urn, uint wad) public virtual;\n    function transfer(address gem, address dst, uint wad) public virtual;\n    function ethJoin_join(address apt, address urn) public virtual payable;\n    function gemJoin_join(address apt, address urn, uint wad, bool transferFrom) public virtual payable;\n\n    function hope(address obj, address usr) public virtual;\n    function nope(address obj, address usr) public virtual;\n\n    function open(address manager, bytes32 ilk, address usr) public virtual returns (uint cdp);\n    function give(address manager, uint cdp, address usr) public virtual;\n    function giveToProxy(address proxyRegistry, address manager, uint cdp, address dst) public virtual;\n\n    function cdpAllow(address manager, uint cdp, address usr, uint ok) public virtual;\n    function urnAllow(address manager, address usr, uint ok) public virtual;\n    function flux(address manager, uint cdp, address dst, uint wad) public virtual;\n    function move(address manager, uint cdp, address dst, uint rad) public virtual;\n    function frob(address manager, uint cdp, int dink, int dart) public virtual;\n    function frob(address manager, uint cdp, address dst, int dink, int dart) public virtual;\n    function quit(address manager, uint cdp, address dst) public virtual;\n    function enter(address manager, address src, uint cdp) public virtual;\n    function shift(address manager, uint cdpSrc, uint cdpOrg) public virtual;\n    function makeGemBag(address gemJoin) public virtual returns (address bag);\n\n    function lockETH(address manager, address ethJoin, uint cdp) public virtual payable;\n    function safeLockETH(address manager, address ethJoin, uint cdp, address owner) public virtual payable;\n    function lockGem(address manager, address gemJoin, uint cdp, uint wad, bool transferFrom) public virtual;\n    function safeLockGem(address manager, address gemJoin, uint cdp, uint wad, bool transferFrom, address owner) public virtual;\n    function freeETH(address manager, address ethJoin, uint cdp, uint wad) public virtual;\n    function freeGem(address manager, address gemJoin, uint cdp, uint wad) public virtual;\n    function draw(address manager, address jug, address daiJoin, uint cdp, uint wad) public virtual;\n\n    function wipe(address manager, address daiJoin, uint cdp, uint wad) public virtual;\n    function safeWipe(address manager, address daiJoin, uint cdp, uint wad, address owner) public virtual;\n    function wipeAll(address manager, address daiJoin, uint cdp) public virtual;\n    function safeWipeAll(address manager, address daiJoin, uint cdp, address owner) public virtual;\n    function lockETHAndDraw(address manager, address jug, address ethJoin, address daiJoin, uint cdp, uint wadD) public virtual payable;\n    function openLockETHAndDraw(address manager, address jug, address ethJoin, address daiJoin, bytes32 ilk, uint wadD) public virtual payable returns (uint cdp);\n    function lockGemAndDraw(address manager, address jug, address gemJoin, address daiJoin, uint cdp, uint wadC, uint wadD, bool transferFrom) public virtual;\n    function openLockGemAndDraw(address manager, address jug, address gemJoin, address daiJoin, bytes32 ilk, uint wadC, uint wadD, bool transferFrom) public virtual returns (uint cdp);\n\n    function openLockGNTAndDraw(address manager, address jug, address gntJoin, address daiJoin, bytes32 ilk, uint wadC, uint wadD) public virtual returns (address bag, uint cdp);\n    function wipeAndFreeETH(address manager, address ethJoin, address daiJoin, uint cdp, uint wadC, uint wadD) public virtual;\n    function wipeAllAndFreeETH(address manager, address ethJoin, address daiJoin, uint cdp, uint wadC) public virtual;\n    function wipeAndFreeGem(address manager, address gemJoin, address daiJoin, uint cdp, uint wadC, uint wadD) public virtual;\n    function wipeAllAndFreeGem(address manager, address gemJoin, address daiJoin, uint cdp, uint wadC) public virtual;\n}\n\n"
    },
    "contracts/mcd/maker/DssProxyActionsDsr.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract DssProxyActionsDsr {\n    function join(address daiJoin, address pot, uint wad) virtual public;\n    function exit(address daiJoin, address pot, uint wad) virtual public;\n    function exitAll(address daiJoin, address pot) virtual public;\n}\n"
    },
    "contracts/mcd/maker/Faucet.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract Faucet {\n    function gulp(address) public virtual;\n}\n"
    },
    "contracts/mcd/maker/GetCdps.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract GetCdps {\n    function getCdpsAsc(address manager, address guy) external view virtual returns (uint[] memory ids, address[] memory urns, bytes32[] memory ilks);\n    function getCdpsDesc(address manager, address guy) external view virtual returns (uint[] memory ids, address[] memory urns, bytes32[] memory ilks);\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
    },
    "contracts/savings/aave/AaveSavingsProtocol.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"../../interfaces/IAToken.sol\";\nimport \"../../interfaces/ILendingPool.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../DS/DSAuth.sol\";\n\n\ncontract AaveSavingsProtocol is ProtocolInterface, DSAuth {\n\n    address public constant ADAI_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d;\n    address public constant AAVE_LENDING_POOL = 0x398eC7346DcD622eDc5ae82352F02bE94C62d119;\n    address public constant AAVE_LENDING_POOL_CORE = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        ERC20(DAI_ADDRESS).approve(AAVE_LENDING_POOL_CORE, uint(-1));\n        ILendingPool(AAVE_LENDING_POOL).deposit(DAI_ADDRESS, _amount, 0);\n\n        ERC20(ADAI_ADDRESS).transfer(_user, ERC20(ADAI_ADDRESS).balanceOf(address(this)));\n    }\n\n    function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n        require(ERC20(ADAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        IAToken(ADAI_ADDRESS).redeem(_amount);\n\n        // return dai we have to user\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\n    }\n}\n"
    },
    "contracts/savings/ProtocolInterface.sol": {
      "content": "pragma solidity ^0.6.0;\n\nabstract contract ProtocolInterface {\n    function deposit(address _user, uint256 _amount) public virtual;\n\n    function withdraw(address _user, uint256 _amount) public virtual;\n}\n"
    },
    "contracts/savings/automatic/ProtocolManager.sol": {
      "content": "pragma solidity ^0.6.0;\n// pragma experimental ABIEncoderV2;\n\n// import \"../ProtocolInterface.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n// import \"../../constants/ConstantAddresses.sol\";\n// import \"../dydx/ISoloMargin.sol\";\n// import \"../SavingsLogger.sol\";\n// import \"../dydx/lib/Types.sol\";\n\n// contract FulcrumInterface {\n//     function assetBalanceOf(address _owner) public view returns(uint256);\n// }\n\n// contract CompoundInterface {\n//     function balanceOfUnderlying(address account) public view returns (uint);\n// }\n\n// contract DyDxInterface {\n//     function getWeiBalance(address _user, uint _index) public view returns(Types.Wei memory);\n// }\n\n\n// contract ProtocolManager is ConstantAddresses {\n\n//     address constant public SAVINGS_COMPOUND_ADDRESS = 0xba7676a6c3E2FFff9f8d16e9C7b1e7848CC0f7DE;\n//     address constant public SAVINGS_DYDX_ADDRESS = 0x97a13567879471E1d6a3C37AB1017321980cd0ca;\n//     address constant public SAVINGS_FULCRUM_ADDRESS = 0x0F0277EE54403a46f12D68Eeb49e444FE0bd4682;\n\n//     enum SavingsProtocol { Compound, Dydx, Fulcrum }\n\n//     function _deposit(SavingsProtocol _protocol, uint _amount) internal {\n//         approveDeposit(_protocol, _amount);\n\n//         ProtocolInterface(getAddress(_protocol)).deposit(address(this), _amount);\n\n//         endAction(_protocol);\n\n//         SavingsLogger(SAVINGS_LOGGER_ADDRESS).logDeposit(msg.sender, uint8(_protocol), _amount);\n\n//     }\n\n//     function _withdraw(SavingsProtocol _protocol, uint _amount) internal {\n//         approveWithdraw(_protocol, _amount);\n\n//         ProtocolInterface(getAddress(_protocol)).withdraw(address(this), _amount);\n\n//         endAction(_protocol);\n\n//         withdrawDai();\n\n//         SavingsLogger(SAVINGS_LOGGER_ADDRESS).logWithdraw(msg.sender, uint8(_protocol), _amount);\n//     }\n\n//     function _swap(SavingsProtocol _from, SavingsProtocol _to, uint _amount) internal {\n//         _withdraw(_from, _amount);\n//         _deposit(_to, _amount);\n\n//         SavingsLogger(SAVINGS_LOGGER_ADDRESS).logSwap(msg.sender, uint8(_from), uint8(_to), _amount);\n//     }\n\n//     function withdrawDai() internal {\n\n//         ERC20(MAKER_DAI_ADDRESS).transfer(msg.sender, ERC20(MAKER_DAI_ADDRESS).balanceOf(address(this)));\n//     }\n\n//     function getAddress(SavingsProtocol _protocol) internal pure returns(address) {\n//         if (_protocol == SavingsProtocol.Compound) {\n//             return SAVINGS_COMPOUND_ADDRESS;\n//         }\n\n//         if (_protocol == SavingsProtocol.Dydx) {\n//             return SAVINGS_DYDX_ADDRESS;\n//         }\n\n//         if (_protocol == SavingsProtocol.Fulcrum) {\n//             return SAVINGS_FULCRUM_ADDRESS;\n//         }\n//     }\n\n//     function endAction(SavingsProtocol _protocol)  internal {\n//         if (_protocol == SavingsProtocol.Dydx) {\n//             setDydxOperator(false);\n//         }\n//     }\n\n//     function approveDeposit(SavingsProtocol _protocol, uint _amount) internal {\n//         ERC20(MAKER_DAI_ADDRESS).transferFrom(msg.sender, address(this), _amount);\n\n//         if (_protocol == SavingsProtocol.Compound || _protocol == SavingsProtocol.Fulcrum) {\n//             ERC20(MAKER_DAI_ADDRESS).approve(getAddress(_protocol), _amount);\n//         }\n\n//         if (_protocol == SavingsProtocol.Dydx) {\n//             ERC20(MAKER_DAI_ADDRESS).approve(SOLO_MARGIN_ADDRESS, _amount);\n//             setDydxOperator(true);\n//         }\n//     }\n\n//     function approveWithdraw(SavingsProtocol _protocol, uint _amount) internal {\n//         if (_protocol == SavingsProtocol.Compound) {\n//             ERC20(CDAI_ADDRESS).approve(getAddress(_protocol), _amount);\n//         }\n\n//         if (_protocol == SavingsProtocol.Dydx) {\n//             setDydxOperator(true);\n//         }\n\n//         if (_protocol == SavingsProtocol.Fulcrum) {\n//             ERC20(IDAI_ADDRESS).approve(getAddress(_protocol), _amount);\n//         }\n//     }\n\n//     function setDydxOperator(bool _trusted) internal {\n//         ISoloMargin.OperatorArg[] memory operatorArgs = new ISoloMargin.OperatorArg[](1);\n//         operatorArgs[0] = ISoloMargin.OperatorArg({\n//             operator: getAddress(SavingsProtocol.Dydx),\n//             trusted: _trusted\n//         });\n\n//         ISoloMargin(SOLO_MARGIN_ADDRESS).setOperators(operatorArgs);\n//     }\n\n//     function getDyDxBalance(address _account) internal returns (uint) {\n//         return DyDxInterface(SAVINGS_DYDX_ADDRESS).getWeiBalance(_account, 0).value;\n//     }\n\n//     function getCompoundBalance(address _account) internal returns (uint) {\n//         return CompoundInterface(CDAI_ADDRESS).balanceOfUnderlying(_account);\n//     }\n\n//     function getFulcrumBalance(address _account) internal returns (uint) {\n//         return FulcrumInterface(IDAI_ADDRESS).assetBalanceOf(_account);\n//     }\n// }\n"
    },
    "contracts/savings/automatic/SavingsManager.sol": {
      "content": "pragma solidity ^0.6.0;\n// pragma experimental ABIEncoderV2;\n\n// import { SafeMath } from \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n// import \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\n// import \"./ProtocolManager.sol\";\n\n// /// @title Controls where Dai gets lend and manages the money\n// contract SavingsManager is ProtocolManager, Ownable {\n//     using SafeMath for uint256;\n\n//     struct Vault {\n//         uint depositedAmount;\n//         uint daiBalance;\n//         uint rate;\n//     }\n\n//     Vault public vault;\n//     address public sDaiAddress;\n//     mapping (address => bool) public approvedBots;\n\n//     ERC20 public daiToken;\n\n//     modifier onlySDai {\n//         require(msg.sender == sDaiAddress);\n//         _;\n//     }\n\n//     modifier onlyBots {\n//         require(approvedBots[msg.sender]);\n//         _;\n//     }\n\n//     constructor() public {\n//         vault = Vault({\n//             depositedAmount: 0,\n//             daiBalance: 0,\n//             rate: 1\n//         });\n\n//         daiToken = ERC20(MAKER_DAI_ADDRESS);\n//     }\n\n//     /********************************* Only sDai functions **********************************/\n\n//     function deposit(uint[3] memory _amounts, uint _sumAmount) public onlySDai {\n//         recalculateRate();\n\n//         if (_amounts[0] > 0) {\n//             _deposit(SavingsProtocol.Compound, _amounts[0]);\n//         }\n\n//         if (_amounts[1] > 0) {\n//             _deposit(SavingsProtocol.Dydx, _amounts[1]);\n//         }\n\n//         if (_amounts[2] > 0) {\n//             _deposit(SavingsProtocol.Fulcrum, _amounts[2]);\n//         }\n\n//         vault.depositedAmount = vault.depositedAmount.add(_sumAmount);\n//     }\n\n//     function withdraw(uint[3] memory _amounts, uint _sumAmount, address _receiver) public onlySDai {\n//         recalculateRate();\n\n//         if (_amounts[0] > 0) {\n//             _withdraw(SavingsProtocol.Compound, _amounts[0]);\n//         }\n\n//         if (_amounts[1] > 0) {\n//             _withdraw(SavingsProtocol.Dydx, _amounts[1]);\n//         }\n\n//         if (_amounts[2] > 0) {\n//             _withdraw(SavingsProtocol.Fulcrum, _amounts[2]);\n//         }\n\n//         vault.depositedAmount = vault.depositedAmount.sub(_sumAmount);\n\n//         daiToken.transfer(_receiver, _sumAmount);\n//     }\n\n//     /********************************* Only owner functions **********************************/\n\n//     function setsDaiContract(address _sDaiAddress) public onlyOwner {\n//         require(sDaiAddress == address(0));\n\n//         sDaiAddress = _sDaiAddress;\n//     }\n\n//     function addBotAddress(address _botAddress) public onlyOwner {\n//         approvedBots[_botAddress] = true;\n//     }\n\n//     function removeBotAddress(address _botAddress) public onlyOwner {\n//         approvedBots[_botAddress] = false;\n//     }\n\n//     /********************************* Only bot functions **********************************/\n\n//     function swap(SavingsProtocol _from, SavingsProtocol _to, uint _amount) external onlyBots {\n//         _swap(_from, _to, _amount);\n//     }\n\n//     function getCurrentRate() public view returns (uint) {\n//         return vault.rate;\n//     }\n\n//     function getWholeDaiBalance() public returns (uint) {\n//         uint balanceSum = getDyDxBalance(address(this))\n//             .add(getCompoundBalance(address(this)))\n//             .add(getFulcrumBalance(address(this)));\n\n//         return balanceSum;\n//     }\n\n//     function recalculateRate() internal {\n//         uint currDaiBalance = getWholeDaiBalance();\n//         uint sDaiBalance = ERC20(sDaiAddress).totalSupply();\n\n//         if (currDaiBalance == 0 || sDaiBalance == 0) {\n//             vault.rate = 1;\n//         }\n\n//         // daiBlance / sDai supply = new rate\n//         vault.rate = currDaiBalance.div(sDaiBalance);\n//     }\n\n// }\n"
    },
    "contracts/savings/automatic/sDai.sol": {
      "content": "pragma solidity ^0.6.0;\n\n// import \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n// import \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\n\n// import \"./SavingsManager.sol\";\n\n// /// @title Savings Dai is a token which is an abstraction ledning token for the most popular lending platforms\n// /// @notice sDai starts of as 1 sDai = 1 Dai, but at interest accurs sDai will be worth more Dai\n// contract sDai is ERC20, ERC20Detailed {\n\n//     using SafeMath for uint256;\n\n//     // Kovan\n//     address public constant DAI_ADDRESS = 0xC4375B7De8af5a38a93548eb8453a498222C4fF2;\n\n//     SavingsManager public savingsManager;\n//     ERC20 public daiToken;\n\n//     constructor(address _managerAddr) ERC20Detailed(\"Saver Dai\", \"sDAI\", 18) public {\n//         savingsManager = SavingsManager(_managerAddr);\n//         daiToken = ERC20(DAI_ADDRESS);\n//     }\n\n//     /// @notice User sends Dai, which enter lending protcols an we mint him sDai\n//     /// @dev User specifies in which protocols how many tokens will be entered\n//     /// @dev Need to approve Dai first to call this\n//     function mint(uint[3] calldata _daiAmounts) external {\n//         uint totalDaiAmount = _daiAmounts[0].add(_daiAmounts[1]).add(_daiAmounts[2]);\n\n//         require(daiToken.transferFrom(msg.sender, address(savingsManager), totalDaiAmount));\n\n//         savingsManager.deposit(_daiAmounts, totalDaiAmount);\n\n//         uint amount = totalDaiAmount.div(savingsManager.getCurrentRate());\n\n//         _mint(msg.sender, amount);\n//     }\n\n//     /// @notice We burn the users sDai, and give him Dai based on the current rate\n//     /// @dev User specifies from which protocols dai will be drawn\n//     function withdraw(uint[3] calldata _daiAmounts) external {\n//         uint totalDaiAmount = _daiAmounts[0].add(_daiAmounts[1]).add(_daiAmounts[2]);\n\n//         savingsManager.withdraw(_daiAmounts, totalDaiAmount, msg.sender);\n\n//         uint sDaiAmount = totalDaiAmount.div(savingsManager.getCurrentRate());\n\n//         _burn(msg.sender, sDaiAmount);\n//     }\n// }\n"
    },
    "contracts/savings/compound/CompoundSavingsProtocol.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"../../interfaces/CTokenInterface.sol\";\nimport \"../../compound/helpers/Exponential.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\n\ncontract CompoundSavingsProtocol is ConstantAddresses {\n\n    CTokenInterface public constant cDaiContract = CTokenInterface(NEW_CDAI_ADDRESS);\n\n    function compDeposit(address _user, uint _amount) internal {\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        // mainnet only\n        ERC20(DAI_ADDRESS).approve(NEW_CDAI_ADDRESS, uint(-1));\n\n        // mint cDai\n        require(cDaiContract.mint(_amount) == 0, \"Failed Mint\");\n    }\n\n    function compWithdraw(address _user, uint _amount) internal {\n        // transfer all users balance to this contract\n        require(cDaiContract.transferFrom(_user, address(this), ERC20(NEW_CDAI_ADDRESS).balanceOf(_user)));\n\n        // approve cDai to compound contract\n        cDaiContract.approve(NEW_CDAI_ADDRESS, uint(-1));\n        // get dai from cDai contract\n        require(cDaiContract.redeemUnderlying(_amount) == 0, \"Reedem Failed\");\n\n        // return to user balance we didn't spend\n        uint cDaiBalance = cDaiContract.balanceOf(address(this));\n        if (cDaiBalance > 0) {\n            cDaiContract.transfer(_user, cDaiBalance);\n        }\n        // return dai we have to user\n        ERC20(DAI_ADDRESS).transfer(_user, _amount);\n    }\n}\n"
    },
    "contracts/savings/dsr/DSRSavingsProtocol.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../mcd/maker/Join.sol\";\nimport \"../../DS/DSMath.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\n\nabstract contract VatLike {\n    function can(address, address) virtual public view returns (uint);\n    function ilks(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\n    function dai(address) virtual public view returns (uint);\n    function urns(bytes32, address) virtual public view returns (uint, uint);\n    function frob(bytes32, address, address, address, int, int) virtual public;\n    function hope(address) virtual public;\n    function move(address, address, uint) virtual public;\n}\n\nabstract contract PotLike {\n    function pie(address) virtual public view returns (uint);\n    function drip() virtual public returns (uint);\n    function join(uint) virtual public;\n    function exit(uint) virtual public;\n}\n\nabstract contract GemLike {\n    function approve(address, uint) virtual public;\n    function transfer(address, uint) virtual public;\n    function transferFrom(address, address, uint) virtual public;\n    function deposit() virtual public payable;\n    function withdraw(uint) virtual public;\n}\n\nabstract contract DaiJoinLike {\n    function vat() virtual public returns (VatLike);\n    function dai() virtual public returns (GemLike);\n    function join(address, uint) virtual public payable;\n    function exit(address, uint) virtual public;\n}\n\ncontract DSRSavingsProtocol is DSMath, ConstantAddresses {\n\n    // Kovan\n    // address public constant DAI_JOIN_ADDRESS = 0x5AA71a3ae1C0bd6ac27A1f28e1415fFFB6F15B8c;\n    // address public constant POT_ADDRESS = 0xEA190DBDC7adF265260ec4dA6e9675Fd4f5A78bb;\n\n    // Mainnet\n    address public constant POT_ADDRESS = 0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7;\n\n    function dsrDeposit(uint _amount, bool _fromUser) internal {\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\n\n        uint chi = PotLike(POT_ADDRESS).drip();\n\n        daiJoin_join(DAI_JOIN_ADDRESS, address(this), _amount, _fromUser);\n\n        if (vat.can(address(this), address(POT_ADDRESS)) == 0) {\n            vat.hope(POT_ADDRESS);\n        }\n\n        PotLike(POT_ADDRESS).join(mul(_amount, RAY) / chi);\n    }\n\n    function dsrWithdraw(uint _amount, bool _toUser) internal {\n        VatLike vat = DaiJoinLike(DAI_JOIN_ADDRESS).vat();\n\n        uint chi = PotLike(POT_ADDRESS).drip();\n        uint pie = mul(_amount, RAY) / chi;\n\n        PotLike(POT_ADDRESS).exit(pie);\n        uint balance = DaiJoinLike(DAI_JOIN_ADDRESS).vat().dai(address(this));\n\n        if (vat.can(address(this), address(DAI_JOIN_ADDRESS)) == 0) {\n            vat.hope(DAI_JOIN_ADDRESS);\n        }\n\n        address to;\n        if (_toUser) {\n            to = msg.sender;\n        } else {\n            to = address(this);\n        }\n\n        if (_amount == uint(-1)) {\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(to, mul(chi, pie) / RAY);\n        } else {\n            DaiJoinLike(DAI_JOIN_ADDRESS).exit(\n                to,\n                balance >= mul(_amount, RAY) ? _amount : balance / RAY\n            );\n        }\n    }\n\n    function daiJoin_join(address apt, address urn, uint wad, bool _fromUser) internal {\n        if (_fromUser) {\n            DaiJoinLike(apt).dai().transferFrom(msg.sender, address(this), wad);\n        }\n\n        DaiJoinLike(apt).dai().approve(apt, wad);\n\n        DaiJoinLike(apt).join(urn, wad);\n    }\n}\n"
    },
    "contracts/savings/dydx/DydxSavingsProtocol.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"./ISoloMargin.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../DS/DSAuth.sol\";\n\ncontract DydxSavingsProtocol is ProtocolInterface, ConstantAddresses, DSAuth {\n\n\n    ISoloMargin public soloMargin;\n    address public savingsProxy;\n\n    uint daiMarketId = 3;\n\n    constructor() public {\n        soloMargin = ISoloMargin(SOLO_MARGIN_ADDRESS);\n    }\n\n    function addSavingsProxy(address _savingsProxy) public auth {\n        savingsProxy = _savingsProxy;\n    }\n\n    function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = getAccount(_user, 0);\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        Types.AssetAmount memory amount = Types.AssetAmount({\n            sign: true,\n            denomination: Types.AssetDenomination.Wei,\n            ref: Types.AssetReference.Delta,\n            value: _amount\n        });\n\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Deposit,\n            accountId: 0,\n            amount: amount,\n            primaryMarketId: daiMarketId,\n            otherAddress: _user,\n            secondaryMarketId: 0, //not used\n            otherAccountId: 0, //not used\n            data: \"\" //not used\n        });\n\n        soloMargin.operate(accounts, actions);\n    }\n\n    function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        Account.Info[] memory accounts = new Account.Info[](1);\n        accounts[0] = getAccount(_user, 0);\n\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\n        Types.AssetAmount memory amount = Types.AssetAmount({\n            sign: false,\n            denomination: Types.AssetDenomination.Wei,\n            ref: Types.AssetReference.Delta,\n            value: _amount\n        });\n\n        actions[0] = Actions.ActionArgs({\n            actionType: Actions.ActionType.Withdraw,\n            accountId: 0,\n            amount: amount,\n            primaryMarketId: daiMarketId,\n            otherAddress: _user,\n            secondaryMarketId: 0, //not used\n            otherAccountId: 0, //not used\n            data: \"\" //not used\n        });\n\n        soloMargin.operate(accounts, actions);\n    }\n\n    function getWeiBalance(address _user, uint _index) public view returns(Types.Wei memory) {\n\n        Types.Wei[] memory weiBalances;\n        (,,weiBalances) = soloMargin.getAccountBalances(getAccount(_user, _index));\n\n        return weiBalances[daiMarketId];\n    }\n\n    function getParBalance(address _user, uint _index) public view returns(Types.Par memory) {\n        Types.Par[] memory parBalances;\n        (,parBalances,) = soloMargin.getAccountBalances(getAccount(_user, _index));\n\n        return parBalances[daiMarketId];\n    }\n\n    function getAccount(address _user, uint _index) public pure returns(Account.Info memory) {\n        Account.Info memory account = Account.Info({\n            owner: _user,\n            number: _index\n        });\n\n        return account;\n    }\n}\n"
    },
    "contracts/savings/fulcrum/FulcrumSavingsProtocol.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolInterface.sol\";\nimport \"../../interfaces/ERC20.sol\";\nimport \"../../interfaces/ITokenInterface.sol\";\nimport \"../../constants/ConstantAddresses.sol\";\nimport \"../../DS/DSAuth.sol\";\n\ncontract FulcrumSavingsProtocol is ProtocolInterface, ConstantAddresses, DSAuth {\n\n    address public savingsProxy;\n    uint public decimals = 10 ** 18;\n\n    function addSavingsProxy(address _savingsProxy) public auth {\n        savingsProxy = _savingsProxy;\n    }\n\n    function deposit(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        // get dai from user\n        require(ERC20(DAI_ADDRESS).transferFrom(_user, address(this), _amount));\n\n        // approve dai to Fulcrum\n        ERC20(DAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\n\n        // mint iDai\n        ITokenInterface(NEW_IDAI_ADDRESS).mint(_user, _amount);\n    }\n\n    function withdraw(address _user, uint _amount) public override {\n        require(msg.sender == _user);\n\n        // transfer all users tokens to our contract\n        require(ERC20(NEW_IDAI_ADDRESS).transferFrom(_user, address(this), ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(_user)));\n\n        // approve iDai to that contract\n        ERC20(NEW_IDAI_ADDRESS).approve(NEW_IDAI_ADDRESS, uint(-1));\n        uint tokenPrice = ITokenInterface(NEW_IDAI_ADDRESS).tokenPrice();\n\n        // get dai from iDai contract\n        ITokenInterface(NEW_IDAI_ADDRESS).burn(_user, _amount * decimals / tokenPrice);\n\n        // return all remaining tokens back to user\n        require(ERC20(NEW_IDAI_ADDRESS).transfer(_user, ITokenInterface(NEW_IDAI_ADDRESS).balanceOf(address(this))));\n    }\n}\n"
    },
    "contracts/savings/SavingsLogger.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract SavingsLogger {\n    event Deposit(address indexed sender, uint8 protocol, uint256 amount);\n    event Withdraw(address indexed sender, uint8 protocol, uint256 amount);\n    event Swap(address indexed sender, uint8 fromProtocol, uint8 toProtocol, uint256 amount);\n\n    function logDeposit(address _sender, uint8 _protocol, uint256 _amount) external {\n        emit Deposit(_sender, _protocol, _amount);\n    }\n\n    function logWithdraw(address _sender, uint8 _protocol, uint256 _amount) external {\n        emit Withdraw(_sender, _protocol, _amount);\n    }\n\n    function logSwap(address _sender, uint8 _protocolFrom, uint8 _protocolTo, uint256 _amount)\n        external\n    {\n        emit Swap(_sender, _protocolFrom, _protocolTo, _amount);\n    }\n}\n"
    },
    "contracts/savings/SavingsProxy.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"./ProtocolInterface.sol\";\nimport \"../interfaces/ERC20.sol\";\nimport \"../interfaces/ITokenInterface.sol\";\nimport \"../interfaces/ComptrollerInterface.sol\";\nimport \"./dydx/ISoloMargin.sol\";\nimport \"./SavingsLogger.sol\";\nimport \"./dsr/DSRSavingsProtocol.sol\";\nimport \"./compound/CompoundSavingsProtocol.sol\";\n\n\ncontract SavingsProxy is DSRSavingsProtocol, CompoundSavingsProtocol {\n    address public constant ADAI_ADDRESS = 0xfC1E690f61EFd961294b3e1Ce3313fBD8aa4f85d;\n\n    address public constant SAVINGS_DYDX_ADDRESS = 0x03b1565e070df392e48e7a8e01798C4B00E534A5;\n    address public constant SAVINGS_AAVE_ADDRESS = 0x535B9035E9bA8D7efe0FeAEac885fb65b303E37C;\n\n    address public constant COMP_ADDRESS = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    enum SavingsProtocol {Compound, Dydx, Fulcrum, Dsr, Aave}\n\n    function deposit(SavingsProtocol _protocol, uint256 _amount) public {\n        if (_protocol == SavingsProtocol.Dsr) {\n            dsrDeposit(_amount, true);\n        } else if (_protocol == SavingsProtocol.Compound) {\n            compDeposit(msg.sender, _amount);\n        } else {\n            _deposit(_protocol, _amount, true);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logDeposit(msg.sender, uint8(_protocol), _amount);\n    }\n\n    function withdraw(SavingsProtocol _protocol, uint256 _amount) public {\n        if (_protocol == SavingsProtocol.Dsr) {\n            dsrWithdraw(_amount, true);\n        } else if (_protocol == SavingsProtocol.Compound) {\n            compWithdraw(msg.sender, _amount);\n        } else {\n            _withdraw(_protocol, _amount, true);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logWithdraw(msg.sender, uint8(_protocol), _amount);\n    }\n\n    function swap(SavingsProtocol _from, SavingsProtocol _to, uint256 _amount) public {\n        if (_from == SavingsProtocol.Dsr) {\n            dsrWithdraw(_amount, false);\n        } else if (_from == SavingsProtocol.Compound) {\n            compWithdraw(msg.sender, _amount);\n        } else {\n            _withdraw(_from, _amount, false);\n        }\n\n        // possible to withdraw 1-2 wei less than actual amount due to division precision\n        // so we deposit all amount on DSProxy\n        uint256 amountToDeposit = ERC20(DAI_ADDRESS).balanceOf(address(this));\n\n        if (_to == SavingsProtocol.Dsr) {\n            dsrDeposit(amountToDeposit, false);\n        } else if (_from == SavingsProtocol.Compound) {\n            compDeposit(msg.sender, _amount);\n        } else {\n            _deposit(_to, amountToDeposit, false);\n        }\n\n        SavingsLogger(SAVINGS_LOGGER_ADDRESS).logSwap(\n            msg.sender,\n            uint8(_from),\n            uint8(_to),\n            _amount\n        );\n    }\n\n    function withdrawDai() public {\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\n    }\n\n    function claimComp() public {\n        ComptrollerInterface(COMP_ADDRESS).claimComp(address(this));\n    }\n\n    function getAddress(SavingsProtocol _protocol) public pure returns (address) {\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            return SAVINGS_DYDX_ADDRESS;\n        }\n\n        if (_protocol == SavingsProtocol.Aave) {\n            return SAVINGS_AAVE_ADDRESS;\n        }\n    }\n\n    function _deposit(SavingsProtocol _protocol, uint256 _amount, bool _fromUser) internal {\n        if (_fromUser) {\n            ERC20(DAI_ADDRESS).transferFrom(msg.sender, address(this), _amount);\n        }\n\n        approveDeposit(_protocol);\n\n        ProtocolInterface(getAddress(_protocol)).deposit(address(this), _amount);\n\n        endAction(_protocol);\n    }\n\n    function _withdraw(SavingsProtocol _protocol, uint256 _amount, bool _toUser) public {\n        approveWithdraw(_protocol);\n\n        ProtocolInterface(getAddress(_protocol)).withdraw(address(this), _amount);\n\n        endAction(_protocol);\n\n        if (_toUser) {\n            withdrawDai();\n        }\n    }\n\n    function endAction(SavingsProtocol _protocol) internal {\n        if (_protocol == SavingsProtocol.Dydx) {\n            setDydxOperator(false);\n        }\n    }\n\n    function approveDeposit(SavingsProtocol _protocol) internal {\n        if (_protocol == SavingsProtocol.Compound || _protocol == SavingsProtocol.Fulcrum || _protocol == SavingsProtocol.Aave) {\n            ERC20(DAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            ERC20(DAI_ADDRESS).approve(SOLO_MARGIN_ADDRESS, uint256(-1));\n            setDydxOperator(true);\n        }\n    }\n\n    function approveWithdraw(SavingsProtocol _protocol) internal {\n        if (_protocol == SavingsProtocol.Compound) {\n            ERC20(NEW_CDAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n\n        if (_protocol == SavingsProtocol.Dydx) {\n            setDydxOperator(true);\n        }\n\n        if (_protocol == SavingsProtocol.Fulcrum) {\n            ERC20(NEW_IDAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n\n        if (_protocol == SavingsProtocol.Aave) {\n            ERC20(ADAI_ADDRESS).approve(getAddress(_protocol), uint256(-1));\n        }\n    }\n\n    function setDydxOperator(bool _trusted) internal {\n        ISoloMargin.OperatorArg[] memory operatorArgs = new ISoloMargin.OperatorArg[](1);\n        operatorArgs[0] = ISoloMargin.OperatorArg({\n            operator: getAddress(SavingsProtocol.Dydx),\n            trusted: _trusted\n        });\n\n        ISoloMargin(SOLO_MARGIN_ADDRESS).setOperators(operatorArgs);\n    }\n}\n"
    },
    "contracts/shifter/LoanShifterReceiver.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../auth/AdminAuth.sol\";\nimport \"../utils/FlashLoanReceiverBase.sol\";\nimport \"../interfaces/DSProxyInterface.sol\";\nimport \"../exchange/SaverExchangeCore.sol\";\nimport \"./ShifterRegistry.sol\";\n\n/// @title LoanShifterReceiver Recevies the Aave flash loan and calls actions through users DSProxy\ncontract LoanShifterReceiver is SaverExchangeCore, FlashLoanReceiverBase, AdminAuth {\n\n    ILendingPoolAddressesProvider public LENDING_POOL_ADDRESS_PROVIDER = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0xaD888d0Ade988EbEe74B8D4F39BF29a8d0fe8A8D);\n\n    struct ParamData {\n        bytes proxyData1;\n        bytes proxyData2;\n        address proxy;\n        address debtAddr;\n        uint8 protocol1;\n        uint8 protocol2;\n        uint8 swapType;\n    }\n\n    constructor() FlashLoanReceiverBase(LENDING_POOL_ADDRESS_PROVIDER) public {}\n\n    function executeOperation(\n        address _reserve,\n        uint256 _amount,\n        uint256 _fee,\n        bytes calldata _params)\n    external override {\n        // Format the call data for DSProxy\n        (ParamData memory paramData, ExchangeData memory exchangeData)\n                                 = packFunctionCall(_amount, _fee, _params);\n\n        address protocolAddr1 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol1));\n        address protocolAddr2 = shifterRegistry.getAddr(getNameByProtocol(paramData.protocol2));\n\n        // Send Flash loan amount to DSProxy\n        sendToProxy(payable(paramData.proxy), _reserve, _amount);\n\n        // Execute the Close/Change debt operation\n        DSProxyInterface(paramData.proxy).execute(protocolAddr1, paramData.proxyData1);\n\n        if (paramData.swapType == 1) { // COLL_SWAP\n            exchangeData.srcAmount = getBalance(exchangeData.srcAddr);\n            (, uint amount) = _sell(exchangeData);\n\n            sendToProxy(payable(paramData.proxy), exchangeData.destAddr, amount);\n        } else if (paramData.swapType == 2) { // DEBT_SWAP\n            exchangeData.destAmount = (_amount + _fee);\n            _buy(exchangeData);\n        } else { // NO_SWAP just send tokens to proxy\n            sendToProxy(payable(paramData.proxy), exchangeData.srcAddr, getBalance(exchangeData.srcAddr));\n        }\n\n        // Execute the Open operation (Skip if it's debt swap)\n        if (paramData.swapType != 2) {\n            DSProxyInterface(paramData.proxy).execute(protocolAddr2, paramData.proxyData2);\n        }\n\n        // Repay FL\n        transferFundsBackToPoolInternal(_reserve, _amount.add(_fee));\n\n        // if there is some eth left (0x fee), return it to user\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function packFunctionCall(uint _amount, uint _fee, bytes memory _params)\n        internal pure returns (ParamData memory paramData, ExchangeData memory exchangeData) {\n\n        (\n            uint[8] memory numData, // collAmount, debtAmount, id1, id2, srcAmount, destAmount, minPrice, price0x\n            address[8] memory addrData, // addrLoan1, addrLoan2, debtAddr1, debtAddr2, srcAddr, destAddr, exchangeAddr, wrapper\n            uint8[3] memory enumData, // fromProtocol, toProtocol, swapType\n            bytes memory callData,\n            address proxy\n        )\n        = abi.decode(_params, (uint256[8],address[8],uint8[3],bytes,address));\n\n        bytes memory proxyData1;\n        bytes memory proxyData2;\n        uint openDebtAmount = (_amount + _fee);\n\n        if (enumData[0] == 0) { // MAKER FROM\n            proxyData1 = abi.encodeWithSignature(\"close(uint256,address,uint256,uint256)\", numData[2], addrData[0], _amount, numData[0]);\n\n        } else if(enumData[0] == 1) { // COMPOUND FROM\n            proxyData1 = abi.encodeWithSignature(\n            \"close(address,address,uint256,uint256)\", addrData[0], addrData[2], numData[0], numData[1]);\n        }\n\n        if (enumData[1] == 0) { // MAKER TO\n            proxyData2 = abi.encodeWithSignature(\"open(uint256,address,uint256)\", numData[3], addrData[1], openDebtAmount);\n        } else if(enumData[1] == 1) { // COMPOUND TO\n            proxyData2 = abi.encodeWithSignature(\"open(address,address,uint256)\", addrData[1], addrData[3], openDebtAmount);\n        }\n\n        // Call specific function if it's a debt swap\n        if (enumData[2] == 2) { // DEBT_SWAP\n            proxyData1 = abi.encodeWithSignature(\"changeDebt(address,address,uint256,uint256)\", addrData[2], addrData[3], (_amount + _fee), numData[4]);\n        }\n\n        paramData = ParamData({\n            proxyData1: proxyData1,\n            proxyData2: proxyData2,\n            proxy: proxy,\n            debtAddr: addrData[2],\n            protocol1: enumData[0],\n            protocol2: enumData[1],\n            swapType: enumData[2]\n        });\n\n        exchangeData = SaverExchangeCore.ExchangeData({\n            srcAddr: addrData[4],\n            destAddr: addrData[5],\n            srcAmount: numData[4],\n            destAmount: numData[5],\n            minPrice: numData[6],\n            wrapper: addrData[7],\n            exchangeAddr: addrData[6],\n            callData: callData,\n            price0x: numData[7]\n        });\n\n    }\n\n    function sendToProxy(address payable _proxy, address _reserve, uint _amount) internal {\n        if (_reserve != ETH_ADDRESS) {\n            ERC20(_reserve).safeTransfer(_proxy, _amount);\n        }\n\n        _proxy.transfer(address(this).balance);\n    }\n\n    function getNameByProtocol(uint8 _proto) internal pure returns (string memory) {\n        if (_proto == 0) {\n            return \"MCD_SHIFTER\";\n        } else if (_proto == 1) {\n            return \"COMP_SHIFTER\";\n        }\n    }\n\n    receive() external override(FlashLoanReceiverBase, SaverExchangeCore) payable {}\n}\n"
    },
    "contracts/shifter/LoanShifterTaker.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/ILendingPool.sol\";\nimport \"../interfaces/CTokenInterface.sol\";\nimport \"../interfaces/ILoanShifter.sol\";\nimport \"../interfaces/DSProxyInterface.sol\";\nimport \"../mcd/maker/Vat.sol\";\nimport \"../mcd/maker/Manager.sol\";\nimport \"../auth/AdminAuth.sol\";\nimport \"../auth/ProxyPermission.sol\";\nimport \"../exchange/SaverExchangeCore.sol\";\nimport \"./ShifterRegistry.sol\";\n\n/// @title LoanShifterTaker Entry point for using the shifting operation\ncontract LoanShifterTaker is AdminAuth, ProxyPermission {\n\n    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n    address public constant MANAGER_ADDRESS = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39;\n\n    Manager public constant manager = Manager(MANAGER_ADDRESS);\n    ShifterRegistry public constant shifterRegistry = ShifterRegistry(0xaD888d0Ade988EbEe74B8D4F39BF29a8d0fe8A8D);\n\n    enum Protocols { MCD, COMPOUND }\n    enum SwapType { NO_SWAP, COLL_SWAP, DEBT_SWAP }\n\n    struct LoanShiftData {\n        Protocols fromProtocol;\n        Protocols toProtocol;\n        SwapType swapType;\n        bool wholeDebt;\n        uint collAmount;\n        uint debtAmount;\n        address debtAddr1;\n        address debtAddr2;\n        address addrLoan1;\n        address addrLoan2;\n        uint id1;\n        uint id2;\n    }\n\n    /// @notice Main entry point, it will move or transform a loan\n    /// @dev If the operation doesn't require exchange send empty data\n    function moveLoan(\n        LoanShiftData memory _loanShift,\n        SaverExchangeCore.ExchangeData memory _exchangeData\n    ) public {\n        if (_isSameTypeVaults(_loanShift)) {\n            _forkVault(_loanShift);\n            return;\n        }\n\n        _callCloseAndOpen(_loanShift, _exchangeData);\n    }\n\n    //////////////////////// INTERNAL FUNCTIONS //////////////////////////\n\n    function _callCloseAndOpen(\n        LoanShiftData memory _loanShift,\n        SaverExchangeCore.ExchangeData memory _exchangeData\n    ) internal {\n        address protoAddr = shifterRegistry.getAddr(getNameByProtocol(uint8(_loanShift.fromProtocol)));\n\n        uint loanAmount = _loanShift.debtAmount;\n\n        if (_loanShift.wholeDebt) {\n            loanAmount = ILoanShifter(protoAddr).getLoanAmount(_loanShift.id1, _loanShift.addrLoan1);\n        }\n\n        (\n            uint[8] memory numData,\n            address[8] memory addrData,\n            uint8[3] memory enumData,\n            bytes memory callData\n        )\n        = _packData(_loanShift, _exchangeData);\n\n        // encode data\n        bytes memory paramsData = abi.encode(numData, addrData, enumData, callData, address(this));\n\n        address payable loanShifterReceiverAddr = payable(shifterRegistry.getAddr(\"LOAN_SHIFTER_RECEIVER\"));\n\n        // call FL\n        givePermission(loanShifterReceiverAddr);\n\n        lendingPool.flashLoan(loanShifterReceiverAddr,\n           getLoanAddr(_loanShift.debtAddr1, _loanShift.fromProtocol), loanAmount, paramsData);\n\n        removePermission(loanShifterReceiverAddr);\n    }\n\n    function _forkVault(LoanShiftData memory _loanShift) internal {\n        // Create new Vault to move to\n        if (_loanShift.id2 == 0) {\n            _loanShift.id2 = manager.open(manager.ilks(_loanShift.id1), address(this));\n        }\n\n        if (_loanShift.wholeDebt) {\n            manager.shift(_loanShift.id1, _loanShift.id2);\n        }\n    }\n\n    function _isSameTypeVaults(LoanShiftData memory _loanShift) internal pure returns (bool) {\n        return _loanShift.fromProtocol == Protocols.MCD && _loanShift.toProtocol == Protocols.MCD\n                && _loanShift.addrLoan1 == _loanShift.addrLoan2;\n    }\n\n    function getNameByProtocol(uint8 _proto) internal pure returns (string memory) {\n        if (_proto == 0) {\n            return \"MCD_SHIFTER\";\n        } else if (_proto == 1) {\n            return \"COMP_SHIFTER\";\n        }\n    }\n\n    function getLoanAddr(address _address, Protocols _fromProtocol) internal returns (address) {\n        if (_fromProtocol == Protocols.COMPOUND) {\n            return CTokenInterface(_address).underlying();\n        } else if (_fromProtocol == Protocols.MCD) {\n            return DAI_ADDRESS;\n        } else {\n            return address(0);\n        }\n    }\n\n    function _packData(\n        LoanShiftData memory _loanShift,\n        SaverExchangeCore.ExchangeData memory exchangeData\n    ) internal pure returns (uint[8] memory numData, address[8] memory addrData, uint8[3] memory enumData, bytes memory callData) {\n\n        numData = [\n            _loanShift.collAmount,\n            _loanShift.debtAmount,\n            _loanShift.id1,\n            _loanShift.id2,\n            exchangeData.srcAmount,\n            exchangeData.destAmount,\n            exchangeData.minPrice,\n            exchangeData.price0x\n        ];\n\n        addrData = [\n            _loanShift.addrLoan1,\n            _loanShift.addrLoan2,\n            _loanShift.debtAddr1,\n            _loanShift.debtAddr2,\n            exchangeData.srcAddr,\n            exchangeData.destAddr,\n            exchangeData.exchangeAddr,\n            exchangeData.wrapper\n        ];\n\n        enumData = [\n            uint8(_loanShift.fromProtocol),\n            uint8(_loanShift.toProtocol),\n            uint8(_loanShift.swapType)\n        ];\n\n        callData = exchangeData.callData;\n    }\n\n}\n"
    },
    "contracts/shifter/protocols/CompShifter.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../compound/helpers/CompoundSaverHelper.sol\";\nimport \"../../utils/DebugInfo.sol\";\n\ncontract CompShifter is CompoundSaverHelper {\n\n    address public constant COMPTROLLER_ADDR = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n\n    function getWholeDebt(uint _cdpId, address _joinAddr) public virtual returns(uint loanAmount) {\n        return CTokenInterface(_joinAddr).borrowBalanceCurrent(msg.sender);\n    }\n\n    function close(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _collAmount,\n        uint _debtAmount\n    ) public {\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n\n        // payback debt\n        paybackDebt(_debtAmount, _cBorrowAddr, getUnderlyingAddr(_cBorrowAddr), tx.origin);\n\n        // draw coll\n        if (CTokenInterface(_cBorrowAddr).borrowBalanceCurrent(address(this)) == 0) {\n            uint cTokenBalance = CTokenInterface(_cCollAddr).balanceOf(address(this));\n            require(CTokenInterface(_cCollAddr).redeem(cTokenBalance) == 0);\n        } else {\n            require(CTokenInterface(_cCollAddr).redeemUnderlying(_collAmount) == 0);\n        }\n\n        // Send back money to repay FL\n        if (collAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(collAddr).transfer(msg.sender, ERC20(collAddr).balanceOf(address(this)));\n        }\n    }\n\n    function changeDebt(\n        address _cBorrowAddrOld,\n        address _cBorrowAddrNew,\n        uint _debtAmountOld,\n        uint _debtAmountNew\n    ) public {\n\n        address borrowAddrNew = getUnderlyingAddr(_cBorrowAddrNew);\n\n        // payback debt in one token\n        paybackDebt(_debtAmountOld, _cBorrowAddrOld, getUnderlyingAddr(_cBorrowAddrOld), tx.origin);\n\n        // draw debt in another one\n        borrowCompound(_cBorrowAddrNew, _debtAmountNew);\n\n        // Send back money to repay FL\n        if (borrowAddrNew == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddrNew).transfer(msg.sender, ERC20(borrowAddrNew).balanceOf(address(this)));\n        }\n    }\n\n    function open(\n        address _cCollAddr,\n        address _cBorrowAddr,\n        uint _debtAmount\n    ) public {\n\n        address collAddr = getUnderlyingAddr(_cCollAddr);\n        address borrowAddr = getUnderlyingAddr(_cBorrowAddr);\n\n        uint collAmount = 0;\n\n        if (collAddr == ETH_ADDRESS) {\n            collAmount = address(this).balance;\n        } else {\n            collAmount = ERC20(collAddr).balanceOf(address(this));\n        }\n\n        depositCompound(collAddr, _cCollAddr, collAmount);\n\n        // draw debt\n        borrowCompound(_cBorrowAddr, _debtAmount);\n\n        // Send back money to repay FL\n        if (borrowAddr == ETH_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20(borrowAddr).transfer(msg.sender, ERC20(borrowAddr).balanceOf(address(this)));\n        }\n\n    }\n\n    function depositCompound(address _tokenAddr, address _cTokenAddr, uint _amount) internal {\n        approveCToken(_tokenAddr, _cTokenAddr);\n\n        enterMarket(_cTokenAddr);\n\n        if (_tokenAddr != ETH_ADDRESS) {\n            require(CTokenInterface(_cTokenAddr).mint(_amount) == 0, \"mint error\");\n        } else {\n            CEtherInterface(_cTokenAddr).mint{value: _amount}();\n        }\n    }\n\n    function borrowCompound(address _cTokenAddr, uint _amount) internal {\n        enterMarket(_cTokenAddr);\n\n        require(CTokenInterface(_cTokenAddr).borrow(_amount) == 0);\n    }\n\n    function enterMarket(address _cTokenAddr) public {\n        address[] memory markets = new address[](1);\n        markets[0] = _cTokenAddr;\n\n        ComptrollerInterface(COMPTROLLER_ADDR).enterMarkets(markets);\n    }\n\n}\n"
    },
    "contracts/utils/DebugInfo.sol": {
      "content": "pragma solidity ^0.6.0;\n\ncontract DebugInfo {\n\n    mapping (string => uint) public uintValues;\n    mapping (string => address) public addrValues;\n    mapping (string => string) public stringValues;\n    mapping (string => bytes32) public bytes32Values;\n\n    function logUint(string memory _id, uint _value) public {\n        uintValues[_id] = _value;\n    }\n\n    function logAddr(string memory _id, address _value) public {\n        addrValues[_id] = _value;\n    }\n\n    function logString(string memory _id, string memory _value) public {\n        stringValues[_id] = _value;\n    }\n\n    function logBytes32(string memory _id, bytes32 _value) public {\n        bytes32Values[_id] = _value;\n    }\n}\n"
    },
    "contracts/shifter/protocols/McdShifter.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../interfaces/ILoanShifter.sol\";\nimport \"../../mcd/saver_proxy/MCDSaverProxy.sol\";\nimport \"../../mcd/flashloan/MCDOpenProxyActions.sol\";\n\ncontract McdShifter is MCDSaverProxy {\n\n    address public constant OPEN_PROXY_ACTIONS = 0x6d0984E80a86f26c0dd564ca0CF74a8E9Da03305;\n\n    function getLoanAmount(uint _cdpId, address _joinAddr) public view virtual returns(uint loanAmount) {\n        bytes32 ilk = manager.ilks(_cdpId);\n\n        (, uint rate,,,) = vat.ilks(ilk);\n        (, uint art) = vat.urns(ilk, manager.urns(_cdpId));\n        uint dai = vat.dai(manager.urns(_cdpId));\n\n        uint rad = sub(mul(art, rate), dai);\n        loanAmount = rad / RAY;\n\n        loanAmount = mul(loanAmount, RAY) < rad ? loanAmount + 1 : loanAmount;\n    }\n\n    function close(\n        uint _cdpId,\n        address _joinAddr,\n        uint _loanAmount,\n        uint _collateral\n    ) public {\n        address owner = getOwner(manager, _cdpId);\n        bytes32 ilk = manager.ilks(_cdpId);\n        (uint maxColl, ) = getCdpInfo(manager, _cdpId, ilk);\n\n        // repay dai debt cdp\n        paybackDebt(_cdpId, ilk, _loanAmount, owner);\n\n        maxColl = _collateral > maxColl ? maxColl : _collateral;\n\n        // withdraw collateral from cdp\n        drawMaxCollateral(_cdpId, _joinAddr, maxColl);\n\n        // send back to msg.sender\n        if (_joinAddr == ETH_JOIN_ADDRESS) {\n            msg.sender.transfer(address(this).balance);\n        } else {\n            ERC20 collToken = ERC20(getCollateralAddr(_joinAddr));\n            collToken.transfer(msg.sender, collToken.balanceOf(address(this)));\n        }\n    }\n\n    function open(\n        uint _cdpId,\n        address _joinAddr,\n        uint _debtAmount\n    ) public {\n\n        uint collAmount = 0;\n\n        if (_joinAddr == ETH_JOIN_ADDRESS) {\n            collAmount = address(this).balance;\n        } else {\n            collAmount = ERC20(address(Join(_joinAddr).gem())).balanceOf(address(this));\n        }\n\n        if (_cdpId == 0) {\n            openAndWithdraw(collAmount, _debtAmount, address(this), _joinAddr);\n        } else {\n            // add collateral\n            addCollateral(_cdpId, _joinAddr, collAmount);\n            // draw debt\n            drawDai(_cdpId, manager.ilks(_cdpId), _debtAmount);\n        }\n\n        // transfer to repay FL\n        ERC20(DAI_ADDRESS).transfer(msg.sender, ERC20(DAI_ADDRESS).balanceOf(address(this)));\n\n        if (address(this).balance > 0) {\n            tx.origin.transfer(address(this).balance);\n        }\n    }\n\n    function openAndWithdraw(uint _collAmount, uint _debtAmount, address _proxy, address _joinAddrTo) internal {\n        bytes32 ilk = Join(_joinAddrTo).ilk();\n\n        if (_joinAddrTo == ETH_JOIN_ADDRESS) {\n            MCDOpenProxyActions(OPEN_PROXY_ACTIONS).openLockETHAndDraw{value: address(this).balance}(\n                address(manager),\n                JUG_ADDRESS,\n                ETH_JOIN_ADDRESS,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                _debtAmount,\n                _proxy\n            );\n        } else {\n            ERC20(getCollateralAddr(_joinAddrTo)).approve(OPEN_PROXY_ACTIONS, uint256(-1));\n\n            MCDOpenProxyActions(OPEN_PROXY_ACTIONS).openLockGemAndDraw(\n                address(manager),\n                JUG_ADDRESS,\n                _joinAddrTo,\n                DAI_JOIN_ADDRESS,\n                ilk,\n                _collAmount,\n                _debtAmount,\n                true,\n                _proxy\n            );\n        }\n    }\n\n\n    function drawMaxCollateral(uint _cdpId, address _joinAddr, uint _amount) internal returns (uint) {\n        manager.frob(_cdpId, -toPositiveInt(_amount), 0);\n        manager.flux(_cdpId, address(this), _amount);\n\n        uint joinAmount = _amount;\n\n        if (Join(_joinAddr).dec() != 18) {\n            joinAmount = _amount / (10 ** (18 - Join(_joinAddr).dec()));\n        }\n\n        Join(_joinAddr).exit(address(this), joinAmount);\n\n        if (_joinAddr == ETH_JOIN_ADDRESS) {\n            Join(_joinAddr).gem().withdraw(joinAmount); // Weth -> Eth\n        }\n\n        return joinAmount;\n    }\n\n}\n"
    },
    "contracts/utils/DFSProxy.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../auth/Auth.sol\";\nimport \"../interfaces/DSProxyInterface.sol\";\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\ncontract DFSProxy is Auth {\n    string public constant NAME = \"DFSProxy\";\n    string public constant VERSION = \"v0.1\";\n\n    mapping(address => mapping(uint => bool)) public nonces;\n\n    // --- EIP712 niceties ---\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"callProxy(address _user,address _proxy,address _contract,bytes _txData,uint256 _nonce)\");\n\n    constructor(uint256 chainId_) public {\n        DOMAIN_SEPARATOR = keccak256(abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(NAME)),\n            keccak256(bytes(VERSION)),\n            chainId_,\n            address(this)\n        ));\n    }\n\n    function callProxy(address _user, address _proxy, address _contract, bytes calldata _txData, uint256 _nonce,\n                    uint8 _v, bytes32 _r, bytes32 _s) external payable onlyAuthorized\n    {\n        bytes32 digest =\n            keccak256(abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH,\n                                     _user,\n                                     _proxy,\n                                     _contract,\n                                     _txData,\n                                     _nonce))\n        ));\n\n        // user must be proxy owner\n        require(DSProxyInterface(_proxy).owner() == _user);\n        require(_user == ecrecover(digest, _v, _r, _s), \"DFSProxy/user-not-valid\");\n        require(!nonces[_user][_nonce], \"DFSProxy/invalid-nonce\");\n        \n        nonces[_user][_nonce] = true;\n\n        DSProxyInterface(_proxy).execute{value: msg.value}(_contract, _txData);\n    }\n}"
    },
    "contracts/utils/ExchangeDataParser.sol": {
      "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../exchange/SaverExchangeCore.sol\";\n\ncontract ExchangeDataParser {\n     function decodeExchangeData(\n        SaverExchangeCore.ExchangeData memory exchangeData\n    ) internal pure returns (address[4] memory, uint[4] memory, bytes memory) {\n        return (\n         [exchangeData.srcAddr, exchangeData.destAddr, exchangeData.exchangeAddr, exchangeData.wrapper],\n         [exchangeData.srcAmount, exchangeData.destAmount, exchangeData.minPrice, exchangeData.price0x],\n         exchangeData.callData\n        );\n    }\n\n    function encodeExchangeData(\n        address[4] memory exAddr, uint[4] memory exNum, bytes memory callData\n    ) internal pure returns (SaverExchangeCore.ExchangeData memory) {\n        return SaverExchangeCore.ExchangeData({\n            srcAddr: exAddr[0],\n            destAddr: exAddr[1],\n            srcAmount: exNum[0],\n            destAmount: exNum[1],\n            minPrice: exNum[2],\n            wrapper: exAddr[3],\n            exchangeAddr: exAddr[2],\n            callData: callData,\n            price0x: exNum[3]\n        });\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}