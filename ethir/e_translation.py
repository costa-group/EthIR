from rbr_rule import RBRRule
import os
from timeit import default_timer as dtimer
from utils import delete_dup
import  traceback

'''
This module translate the RBR generated by EthIR to SACO RBR.
It receives a list with rbr_rule instances.
'''
costabs_path = "/tmp/costabs/"
tmp_path = "/tmp/"

def init_global_vars():
    global pattern
    pattern = ["PUSH1",
                   "DUP2",
                   "PUSH1",
                   "AND",
                   "ISZERO",
                   "PUSH2",
                   "MUL",
                   "SUB",
                   "AND",
                   "PUSH1",
                   "SWAP1",
                   "DIV"]

    global svcomp
    svcomp = {}

    global verifier
    verifier = ""

    global init_loop
    init_loop = 0

    global init_globals
    init_globals = False

    global blocks2init
    blocks2init = []

    global signextend_function
    signextend_function = False

    global stack_vars_global
    stack_vars_global = []

    global goto
    goto= False

    global potential_uncalled
    potential_uncalled = []

def rbr2c(rbr,execution,cname,scc,svc_labels,gotos,fbm,init_fields):
    global svcomp
    global verifier
    global init_globals
    global blocks2init
    global goto
    global potential_uncalled

    init_global_vars()
    potential_uncalled = []
    
    svcomp = svc_labels
    verifier = svc_labels.get("verify","")
    
    begin = dtimer()

    if fbm != []:
        init_globals = True
        blocks2init = fbm

    try:
        if gotos:
            goto = True
            heads, new_rules = rbr2c_gotos(rbr,scc)
        else:
            heads, new_rules = rbr2c_recur(rbr)
        
        if svcomp!={}:
            head_c , rule = initialize_globals(rbr,init_fields)
            heads = "\n"+head_c+heads
            new_rules.append(rule)

        if signextend_function:
            head, f = def_signextend_function()
            heads = heads+head
            new_rules.append(f)
            
        #Escritura del fichero .c 
        write_init(rbr,execution,cname)
        write(heads,new_rules,execution,cname)
        write_main(execution,cname)

        end = dtimer()
        print("C RBR: "+str(end-begin)+"s")
    except:
        traceback.print_exc()
        raise Exception("Error in C_trnalsation",6)

def rbr2c_gotos(rbr,scc):
    heads = "\n"
    new_rules = []

    scc_unit = scc["unary"]
    scc_multiple = scc["multiple"]
    l = scc_multiple.values()
    scc_ids_multiple = [x for y in l for x in y]
    scc_ids = scc_unit+scc_ids_multiple#get_scc_labels(scc_multiple.values())

    out_in = {}

    #It computes first the scc_multiple to identify if any unary scc is nested.
    heads_m, scc_multiple_rules = compute_sccs_multiple(rbr,scc_multiple,scc_unit,out_in)
    heads_u, scc_unary_rules = compute_sccs_unary(rbr,scc_unit,out_in)

    
    for rules in rbr: #it contains list of two elemtns (jumps) or unitary lists (standard rule)
        getId = rules[0].get_Id()
        type_rule = rules[0].get_type()

        if getId in scc_ids :
            if (heads_u.get(getId,-1)!=-1) and (type_rule == "block") :
                heads = heads+heads_u[getId]
                new_rules.append(scc_unary_rules[getId])

            elif (heads_m.get(getId,-1)!=-1) and (type_rule == "block"):
                heads = heads+heads_m[getId]
                new_rules.append(scc_multiple_rules[getId])
        else:
            if len(rules) == 2:
                head,new_rule = process_jumps(rules)
            else:
                head,new_rule = process_rule_c(rules[0])
                
            heads = heads+head
            new_rules.append(new_rule)

    # ll = filter(lambda x: heads.find("void "+x)==-1,potential_uncalled)
    # heads = heads+build_headers(ll,rbr)
    return heads, new_rules

def build_headers(l,rbr):
    rbr_aux = [item for sublist in rbr for item in sublist]
    heads = ""
    for e in l:
        idx = e.find("(")
        b_id = e[5:idx]

        r = RBRRule(b_id,"block")
        i = rbr_aux.index(r)
        rule = rbr_aux[i]
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "ethint256 "+x,stack_variables)
        s_head = ", ".join(stack) 
        head_c ="void " + rule.get_rule_name()+"();\n"
        heads = heads+head_c
    return heads

def rbr2c_recur(rbr):
    heads = "\n"
    new_rules = []
    
    for rules in rbr: #it contains list of two elemtns (jumps) or unitary lists (standard rule)

        if len(rules) == 2:
            head,new_rule = process_jumps(rules)
        else:
            head,new_rule = process_rule_c(rules[0])
                
        heads = heads+head
        new_rules.append(new_rule)

    return heads,new_rules


#If an id its in out_in means that this scc is nested and the continue
#block has been translated in the outer scc.
def compute_sccs_unary(rbr,scc_unit,out_in):
    global init_loop
    
    rules = {}
    heads = {}
    
    l = len(rbr)
    i = 0
    while i < l:
        nested = False
        r = rbr[i]
        if len(r) == 2:
            rid = r[0].get_Id()
            if rid in scc_unit:

                if out_in.get(rid,-1)!=-1:
                    nested = True
            
                part_jump = translate_jump_scc(r,scc_unit,init_loop,nested)
                i =i+1
                rule_main = rbr[i][0]
                head, part_main = translate_block_scc(rule_main,init_loop)
                init_loop+=1
                rule = part_main+"\n"+part_jump+"}"
                rules[rid] = rule
                heads[rid] = head
        else:
            rid = r[0].get_Id()
            if rid in scc_unit:

                if out_in.get(rid,-1)!=-1:
                    nested = True
                
                head, part_main = translate_block_scc(r[0],init_loop)
                i+=1
                rule_jump = rbr[i]
                part_jump = translate_jump_scc(rule_jump,scc_unit,init_loop,nested)
                init_loop+=1
                rule = part_main+"\n"+part_jump+"}"
                rules[rid] = rule
                heads[rid] = head

        i=i+1

    return heads, rules


#If scc is nested, the exit block is translated in the outer scc.
def translate_jump_scc(r,scc,id_loop,nested = False):
    
    jump1 = r[0]
    jump2 = r[1]

    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    if_id = get_called_block(call_if)

    if if_id in scc:
        guard = jump1.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_else

    else:
        guard = jump2.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_if
        
    label = "goto init_loop_"+str(id_loop)

    body = "\tif("+cond+"){\n"
    body = body+"\t\t"+label+"; }\n"
    if not nested:
        body = body+"\t"+call_instr+";\n"

    return body


def translate_block_scc(rule,id_loop,multiple=False):
    
    stack_variables = get_input_variables(rule.get_index_invars())
    stack = map(lambda x: "int "+x,stack_variables)
    s_head = ", ".join(stack)

    
    # head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
    # head = "void " + rule.get_rule_name()+"("+s_head+"){\n"

    head_c = "void " + rule.get_rule_name()+"();\n"
    head = "void " + rule.get_rule_name()+"(){\n"

    cont = rule.get_fresh_index()+1
    instructions = rule.get_instructions()
    has_string_pattern = rule.get_string_getter()
    new_instructions,variables = process_body_c(instructions,cont,has_string_pattern)

    if multiple:
        variables_d = get_variables_to_be_declared(stack_variables,variables,True)
    else:
        variables_d = get_variables_to_be_declared(stack_variables,variables)
        var_declarations = "\n"+variables_d+"\n"
    
    #To delete skip instructions
    new_instructions = filter(lambda x: not(x.strip().startswith("nop(")) and x!=";",new_instructions)

    new_instructions = new_instructions[:-1] #To delete the call instructions. It is always the last one.
    new_instructions = map(lambda x: "\t"+x,new_instructions)
    body = "\n".join(new_instructions)

    init_loop_label = "  init_loop_"+str(id_loop)+":\n"
    if rule.has_invalid() and svcomp!={}:
        source = rule.get_invalid_source()
        label = get_error_svcomp_label()+"; //"+source+"\n"
    else:
        label = ""

    update_stack_vars_global(stack_variables)
    update_stack_vars_global(variables)
        
    if not multiple:
        #rule_c = head+var_declarations+init_loop_label+body+label
        rule_c = head+init_loop_label+body+label
        return head_c,rule_c
    else:
        return head_c,[head,init_loop_label+body+label],variables_d


    
def translate_scc_blocks(next_rule,entry_rule,rbr_scc,scc,all_scc_ids,inner,rbr,out_in,outer_id):
    if outer_id !=-1:
        part_block,vars_declaration =  process_goto(next_rule,entry_rule,rbr_scc,scc,all_scc_ids,inner,rbr,out_in,scc[outer_id])
    else:
        part_block,vars_declaration =  process_goto(next_rule,entry_rule,rbr_scc,scc,all_scc_ids,inner,rbr,out_in)

    return part_block,vars_declaration


def compone_blocks_common_scc(code_blocks,next_idx,rbr_scc):
    code_if = code_blocks[0]
    code_else = code_blocks[1]

    jump1 = rbr_scc[next_idx]

    guard = jump1.get_guard()
    cond = translate_conditions(guard)

    code_if_aux = code_if.split("\n")
    code_if_aux = map(lambda x: "\t"+x,code_if_aux)
    code_if = "\n".join(code_if_aux)

    code_else_aux = code_else.split("\n")
    code_else_aux = map(lambda x: "\t"+x,code_else_aux)
    code_else = "\n".join(code_else_aux)
    
    body = "\tif("+cond+"){\n"
    body = body+code_if+"\n\t}else{\n"
    body = body+code_else+"\n\t}\n"

    return body


def compute_sccs_multiple(rbr,scc,scc_unit_keys,out_in):
    global init_loop
    
    rules = {}
    heads = {}
    inner_scc = []
    body = ""
    exit_label = ""
    part_block = ""
     
    to_translate = scc.keys()

    scc_ids = to_translate+scc_unit_keys
    
    s = get_next_scc(scc,to_translate)
    while(s!=-1):
        rbr_scc = filter_scc_multiple(rbr,scc[s])
        entry = get_rule_from_scc(s,rbr_scc)

        head, entry_part,vars_declaration = translate_block_scc(entry,init_loop,True)
        outer_id = out_in.get(s,-1)

        #if entry is unconditional, it gets the next block and call to
        #translate.  if entry is conditional it checks if both jumps
        #are inside the scc. If they are, it translates each block
        #separately and compone the results.  If not, it computes
        #which is the next block (the one that is inside the scc) and
        #continue the process with it.
        if entry.is_conditional():
            id1, id2 = get_next_from_rule(s,rbr_scc)
            next_idx = get_rule_from_scc(s,rbr_scc,True,True)
            
            if id1 in scc[s] and id2 in scc[s]:
                next_rule = get_rule_from_scc(id1,rbr_scc)
                part_block1,vars_declaration1 = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)

                next_rule = get_rule_from_scc(id2,rbr_scc)
                part_block2,vars_declaration2 = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)

                entry_jump = ""
                part_block = compone_blocks_common_scc((part_block1,part_block2),next_idx,rbr_scc)
                
                vars_declaration = vars_declaration1+vars_declaration2
            else:

                if s in inner_scc:
                    entry_jump,exit_block,next_block = translate_entry_jump(next_idx,rbr_scc,scc[outer_id])
                    
                else:
                    entry_jump,exit_block,next_block = translate_entry_jump(next_idx,rbr_scc)
               
                next_rule = get_rule_from_scc(next_block,rbr_scc)
                part_block,vars_declaration = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)

        else:
            entry_jump=""
            next_block = entry.get_call_to()
            next_rule = get_rule_from_scc(next_block,rbr_scc)
            part_block,vars_declaration = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)
            

        init_label = "\tgoto init_loop_"+str(init_loop)+";\n"
        end_label = "  end_loop_"+str(init_loop)+": \n"

        vars_declaration = delete_dup(vars_declaration)
        varsd_string = "\t".join(vars_declaration)
        
        body = entry_part[0]+entry_part[1]+"\n"
        body = body+entry_jump+part_block
        body = body+init_label+"\n"
        body = body+end_label
            
        if s in inner_scc:
            exit_block = ""

        body = body+"\t ;\n}"

        rules[s] = body
        heads[s] = head
        init_loop+=1
        exit_label = ""
        part_block = ""
        
        s = get_next_scc(scc,to_translate)
    return heads,rules


def get_next_scc(scc,to_translate):
    if to_translate == []:
        return -1
    else:
        for s in scc:
            if s in to_translate:
                r = check_candidate(s,scc,to_translate)
                if r:
                    i = to_translate.index(s)
                    to_translate.pop(i)
                    return s

def check_candidate(s,scc,to_translate):
    candidate = True
    scc_aux = filter(lambda x: x in to_translate,scc.keys())
    for e in scc_aux:
        if s != e:
            l = scc[e]
            candidate = candidate and (s not in l)
    return candidate
        
                
def process_goto(next_rule,entry,rbr_scc, scc, all_scc_ids,inner_scc,rbr,out_in,outer_scc=[]):
    if (next_rule == entry):
        return "",[]
    
    else:#(next_rule!=entry):
        if next_rule.get_Id() in all_scc_ids:
            out_in[next_rule.get_Id()] = entry.get_Id()
            inner_scc.append(next_rule.get_Id())
            part = "\tblock"+str(next_rule.get_Id())+"();\n"
            vars_d = []
            if_id,else_id = get_next_from_rule(next_rule.get_Id(),rbr_scc)
            
            #the next rule has to be in the outer scc and not in the
            #inner one. If get_Id is in all_scc_ids but it is not in
            #scc means that it is a unitary scc and the value of
            #scc_list is [Id]
            scc_list = scc.get(next_rule.get_Id(),[next_rule.get_Id()])
            if if_id in scc_list:
                candidate = if_id
                next_id = else_id
            else:
                next_id = if_id
                candidate = else_id
            next_id = check_next_id((next_id,candidate),scc[entry.get_Id()],scc_list,rbr_scc)
            #print next_id
            next_rule = get_rule_from_scc(next_id,rbr_scc)
            part_block_aux, vars_declaration = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)

            part_block = part+part_block_aux
            vars_declaration = vars_declaration+vars_d
        
        else:
            vars_d, part, next_id ,both= translate_scc_multiple(next_rule,rbr_scc,scc[entry.get_Id()],outer_scc)
            if both:
                if_id = next_id[0]
                next_rule = get_rule_from_scc(if_id,rbr_scc)
                part_block_aux, vars_declaration = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)

                part_block1 = tab_block(part_block_aux)
                vars_declaration = vars_declaration+vars_d
                
                else_id = next_id[1]
                next_rule = get_rule_from_scc(else_id,rbr_scc)
                part_block_aux, vars_d = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)

                part_block2 = tab_block(part_block_aux)
                vars_declaration = vars_declaration+vars_d
                
                part_block = part+part_block1+"}\n\telse {\n"+part_block2+"\t}\n"
                
            else:
                
                next_rule = get_rule_from_scc(next_id,rbr_scc)
                part_block_aux,vars_declaration = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)
                part_block = part+part_block_aux
                vars_declaration = vars_declaration+vars_d
                
        return part_block,vars_declaration

#For inner scc it checks if the id returned is a valid one (is in the
#scc). If not it means that the inner and outer scc share some nodes.
def check_next_id(ids, outer_scc,inner_scc, rbr_scc):
    next_id,candidate_id = ids
    scc = filter(lambda x: x not in inner_scc,outer_scc)
    if next_id in scc:
        return next_id
    else:
        # it has to find the next_id. Candidate is in inner_scc
        if_id, else_id = get_next_from_rule(candidate_id,rbr_scc)
        if if_id in scc:
            return if_id
        elif else_id in scc:
            return else_id
        else:
            if if_id in inner_scc:
                return check_next_id((else_id,if_id),outer_scc,inner_scc,rbr_scc)
            else:
                return check_next_id((if_id,else_id),outer_scc,inner_scc,rbr_scc)

            
def tab_block(chain):
    lines = chain.split("\n")
    new_lines = map(lambda x: "\t"+x,lines)
    result = "\n".join(new_lines)
    return result
    
def get_next_from_rule(ruleId,scc):
    try:
        next_idx = get_rule_from_scc(ruleId,scc,True,True)
        jump1 = scc[next_idx]
        jump2 = scc[next_idx+1]

        instructions1 = jump1.get_instructions()
        instructions2 = jump2.get_instructions()

        call_if = filter_call(instructions1[0])
        call_else = filter_call(instructions2[0])

        if_id = get_called_block(call_if)
        else_id = get_called_block(call_else)

        return if_id,else_id

    except: #it is not an conditional jump
        rule = get_rule_from_scc(ruleId,scc)
        next_id = rule.get_call_to()
        return next_id, next_id

#If outer_scc != [] is a inner_scc
def translate_entry_jump(next_idx,scc,outer_scc = []):
    jump1 = scc[next_idx]
    jump2 = scc[next_idx+1]
    
    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    if_id = get_called_block(call_if)
    else_id = get_called_block(call_else)

    r_aux = RBRRule(if_id,"block")
    
    if r_aux in scc:
        guard = jump2.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_else
        exit_block = else_id
        next_block = if_id

    else:
        guard = jump1.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_if
        exit_block = if_id
        next_block = else_id

    if outer_scc != []:
        if exit_block in outer_scc:
            body_call = ""
            label = "goto end_loop_"+str(init_loop)
        else:
            body_call = "\t\tblock"+str(exit_block)+"();"
            label = "goto end_loop_"+str(init_loop)
    else:
        body_call = "\t\t"+call_instr+";"
        label = "goto end_loop_"+str(init_loop)

    body = "\tif("+cond+"){\n"
    body = body+body_call+"\n"
    body = body+"\t\t"+label+"; }\n"

    return body,call_instr,next_block


def translate_scc_multiple(rule,rbr_scc,scc,outer_scc):
    
    stack_variables = get_input_variables(rule.get_index_invars())

    cont = rule.get_fresh_index()+1
    instructions = rule.get_instructions()
    has_string_pattern = rule.get_string_getter()
    new_instructions,variables = process_body_c(instructions,cont,has_string_pattern)
    
    variables_d = get_variables_to_be_declared(stack_variables,variables,True)
    #var_declarations = "\n"+variables_d+"\n"
    
    #To delete skip instructions
    new_instructions = filter(lambda x: not(x.strip().startswith("nop(")) and x!=";",new_instructions)

    called_instructions = new_instructions[-1]
    called_is_jump = called_instructions.startswith("j")

    if called_is_jump:
        jump_idx = get_rule_from_scc(rule.get_Id(),rbr_scc,True,True)
        part, next_block, both = translate_jump_scc_multiple(jump_idx,rbr_scc,scc,outer_scc)
       
    else:
        part = ""
        both = False
        next_block = get_called_block(called_instructions)

    new_instructions = new_instructions[:-1] #To delete the call instructions. It is always the last one.
    new_instructions = map(lambda x: "\t"+x,new_instructions)
    body = "\n".join(new_instructions)
    body = body+"\n"+part
    
    update_stack_vars_global(stack_variables)
    update_stack_vars_global(variables)
    
    return variables_d, body, next_block, both

def translate_jump_scc_multiple(idx,rule_scc,scc,outer_scc):
    global potential_uncalled

    both = False
    
    jump1 = rule_scc[idx]
    jump2 = rule_scc[idx+1]

    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    if_id = get_called_block(call_if)
    else_id = get_called_block(call_else)

    #if_b = get_rule_from_scc(if_id,rule_scc)
    

    if if_id in scc and else_id in scc:
        both = True
        
        guard = jump1.get_guard()
        cond = translate_conditions(guard)
        body = "\tif("+cond+"){\n"
        next_block = (if_id,else_id)

    else:    
        if if_id in scc:
            guard = jump2.get_guard()
            cond = translate_conditions(guard)
            call_instr = call_else
            exit_block = else_id
            next_block = if_id

        else:
            guard = jump1.get_guard()
            cond = translate_conditions(guard)
            call_instr = call_if
            exit_block = if_id
            next_block = else_id


        body = "\tif("+cond+"){\n"
            
        if outer_scc != []:
            if exit_block in outer_scc and exit_block not in scc:
                label = "goto end_loop_"+str(init_loop)
            else:
                body = body+"\t\t"+call_instr+";\n"
                label = "goto end_loop_"+str(init_loop)
        else:
            label = "goto end_loop_"+str(init_loop)
            body = body+"\t\t"+call_instr+";\n"

        body = body+"\t\t"+label+"; }\n"
        
        if call_instr not in potential_uncalled:
            potential_uncalled.append(call_instr)
        
    return body,next_block,both


def get_rule_from_scc(blockId,rbr_scc,jump=False,idx_r=False):
    if jump:
        r_aux = RBRRule(blockId,"jump")
    else:
        r_aux = RBRRule(blockId,"block")

    idx = rbr_scc.index(r_aux)
    if idx_r:
        return idx
    else:
        return rbr_scc[idx]

    
def get_scc_labels(scc):
    l = []
    for i in range(len(scc)):
        #l = l+scc[i]
        l.append(scc[i])
    return l


def filter_scc_multiple(rbr,scc):
    rules = []
    
    l = get_scc_labels(scc)

    for r in rbr:
        rule = r[0]
        rid = rule.get_Id()
        if rid in l:
            rules = rules+r

    return rules


def unbox_variable(var):
    open_pos = var.find("(")
    close_pos = var.find(")")
    if open_pos !=-1 and close_pos !=-1:
        new_var = var[:open_pos]+var[open_pos+1:close_pos]
    else:
        new_var = var
    return new_var


def check_declare_variable(var,variables):
    if var not in variables:
        variables.append(var)

        
def get_stack_variables(variables,l=False):
    stack_variables = filter(lambda x: x.startswith("s"),variables)
    idx_list = map(lambda x: int(x.strip()[1:]),stack_variables)
    sorted_idx = sorted(idx_list)
    rebuild_stack_variables = map(lambda x: "ethint256 s"+str(x)+";\n",sorted_idx)
    s_vars = "\t".join(rebuild_stack_variables)
    if l:
        return rebuild_stack_variables
    else:
        return s_vars

    
def get_rest_variables(variables,l=False):
    r_variables = filter(lambda x: not(x.startswith("s")),variables)
    sorted_variables = sorted(r_variables)
    rebuild_rvariables = map(lambda x: "ethint256 "+x+";\n",sorted_variables)
    r_vars = "\t".join(rebuild_rvariables)

    if l:
        return rebuild_rvariables
    else:
        return r_vars

    
def get_variables_to_be_declared(stack_variables,variables,l=False):
    vd = []
    for v in variables:
        if v not in stack_variables:
            vd.append(v)

    s_vars = get_stack_variables(vd,l)
    r_vars = get_rest_variables(vd,l)
    if l:
        return s_vars+r_vars
    else:
        return "\t"+s_vars+"\t"+r_vars

    
def get_input_variables(idx):
    in_vars = []
    for i in xrange(idx-1,-1,-1):
        var = "s"+str(i)
        in_vars.append(var)
    return in_vars


#if arg is a int, it transform the variable into a eth256 var
#Otherwise, it returns the same val
def return_correct_val(var):
    arg = var.strip()
    if arg.isdigit():
        hex_value = hex(int(arg))
        lis = fun_aux_split(hex_value)
        sep = ','
        lis_final = "ASSIGN(" + sep.join(lis) + ")"
        new = lis_final
        return new
    else:
        return arg

#se llama a las versiones que devuelven un int para que el if funcione (GEQ,GT...)
def translate_conditions(instr):

    if instr.startswith("gt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "GT(" + var1_def + "," + var2_def + ")"
        
    elif instr.startswith("sgt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "SGT(" + var1_def + "," + var2_def + ")"
        
    elif instr.startswith("geq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[4:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "GEQ(" + var1_def + "," + var2_def + ")"
        
    elif instr.startswith("lt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "LT(" + var1_def + "," + var2_def + ")"
        
    elif instr.startswith("slt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "SLT(" + var1_def + "," + var2_def + ")"
        
    elif instr.startswith("leq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[4:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "LEQ(" + var1_def + "," + var2_def + ")"
        
    elif instr.startswith("eq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        if str(var2) == '0':
           instr = "ISZERO(" + var1 + ")"
        else:
            var1_def = return_correct_val(var1)
            var2_def = return_correct_val(var2)
            instr = "EQ(" + var1_def + "," + var2_def + ")"
            
    elif instr.startswith("neq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[4:])
        var2 = unbox_variable(arg2[:-1])
        var1_def = return_correct_val(var1)
        var2_def = return_correct_val(var2)
        instr = "NEQ(" + var1_def + "," + var2_def + ")"
    else:
        instr = "Error in guard translation"

    return instr


def filter_call(call_instruction):
    block = call_instruction.strip()[5:-1].strip()
    pos_open = block.find("(")
    arguments = block[pos_open+1:-1]
    variables = arguments.split(",")
    s_vars = filter(lambda x: x.strip().startswith("s("),variables)
    s_vars = map(lambda x: unbox_variable(x.strip()),s_vars)
    
    s_string = ", ".join(s_vars)
    if goto:
        call = block[:pos_open]+"()"
    else:
        call = block[:pos_open]+"("+s_string+")"
    return call


def get_called_block(call_instruction):
    block = call_instruction.strip()[5:-1].strip()
    pos_open = block.find("(")
    block_id = block[:pos_open].strip()

    try:
        return int(block_id)

    except:
        return block_id

def process_jumps(rules):
    jump1 = rules[0]
    jump2 = rules[1]

    stack_variables = get_input_variables(jump1.get_index_invars())
    stack = map(lambda x: "unsigned int "+x,stack_variables)
    s_head = ", ".join(stack)

    if goto:
        head_c ="void " + jump1.get_rule_name()+"();\n"
        head = "void " + jump1.get_rule_name()+"(){\n"
    else:
        head_c ="void " + jump1.get_rule_name()+"("+s_head+");\n"
        head = "void " + jump1.get_rule_name()+"("+s_head+"){\n"

    guard = jump1.get_guard()
    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()
    
    cond = translate_conditions(guard)

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    body = "\tif("+cond+"){\n"
    body = body+"\t\t"+call_if+"; }\n"
    body = body+"\telse {\n"
    body = body+"\t\t"+call_else+"; }\n"
    end = "}\n"

    rule_c = head+body+end
    return head_c,rule_c

    
#Es llamado para cada instruccion
def process_rule_c(rule):
    stack_variables = get_input_variables(rule.get_index_invars())
    stack = map(lambda x: "ethint256 "+x,stack_variables)
    s_head = ", ".join(stack)

    if goto:
        head_c = "void " + rule.get_rule_name()+"();\n"
        head = "void " + rule.get_rule_name()+"(){\n"
    else:
        head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
        head = "void " + rule.get_rule_name()+"("+s_head+"){\n"
    
    cont = rule.get_fresh_index()+1
    instructions = rule.get_instructions()
    has_string_pattern = rule.get_string_getter()
    new_instructions,variables = process_body_c(instructions,cont,has_string_pattern)
    
    variables_d = get_variables_to_be_declared(stack_variables,variables)
    var_declarations = "\n"+variables_d+"\n"
    
    #To delete skip instructions
    new_instructions = filter(lambda x: not(x.strip().startswith("nop(")) and x!=";",new_instructions)
    
    new_instructions = map(lambda x: "\t"+x,new_instructions)
    body = "\n".join(new_instructions)

    if rule.has_invalid() and svcomp!={}:
        source = rule.get_invalid_source()
        label = get_error_svcomp_label()+"; //"+source+"\n"
    else:
        label = ""
        
    end ="\n}\n"

    if goto:
        update_stack_vars_global(stack_variables)
        update_stack_vars_global(variables)
        rule_c = head
    else:
        rule_c = head+var_declarations

        
    if (rule.get_Id() in blocks2init) and (svcomp!={}):
        init = "\tinit_globals();\n"
        rule_c = rule_c+init+body+label+end
    else:
        rule_c = rule_c+body+label+end
    
    return head_c,rule_c


def is_number(var):
    try:
        r = int(var)
        b = True
    except:
        r = -1
        b = False
        
    return b,r



def compute_string_pattern(new_instructions):
    nop_inst = map(lambda x: "nop("+x+")",pattern)
    new_instructions = new_instructions+nop_inst
    return new_instructions


def process_body_c(instructions,cont,has_string_pattern):
    new_instructions = []
    variables = []
    #    instructions = filter(lambda x: x!= "", instructions)
    idx_loop = 0
    len_ins = len(instructions)
    
    #for instr in instructions:
    while(idx_loop<len_ins):
        instr = instructions[idx_loop]

        if idx_loop == 8 and has_string_pattern:
            new_instructions = compute_string_pattern(new_instructions)
            idx_loop = idx_loop+26
        else:
            cont = process_instruction(instr,new_instructions,variables,cont)
            idx_loop = idx_loop+1

    new_instructions = filter(lambda x: x!= "", new_instructions)
    return new_instructions,variables



def process_instr(instr,op,bool,vars_to_declare):
    elems = instr.split(op) #Por el operador de la instruccion

    if bool == False:                ###### ARITMETICAS
        arg01 = elems[0].split("=")
        arg0 = arg01[0].strip()
        var0 = unbox_variable(arg0)
        lista = [var0]

        arg1 = arg01[1].strip() #primer parametro 
        var1 = unbox_variable(arg1)
        lista.append(var1)

        arg2 = elems[1].strip() #segundo parametro 
        var2 = unbox_variable(arg2)
        lista.append(var2)

    else:                             ##### LOGICAS
        arg0 = elems[0].strip() 
        var0 = unbox_variable(arg0)
        lista = [var0]

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip() #primer parametro 
        var1 = unbox_variable(arg1)
        lista.append(var1)

        arg2 = arg12[1].strip() #segundo parametro 
        var2 = unbox_variable(arg2)
        lista.append(var2)
        check_declare_variable(var0,vars_to_declare)

    return lista

def process_instr_nop(instr,new_instructions,op):
    args = pre_instr.split("=") #siempre por el igual
    arg0 = args[0].strip()
    lista = [arg0]
    args12 = args[1].split(op)  #operador de la instruccion
    arg1 = args12[0].strip()
    lista.append(arg1)
    arg2 = args12[1].strip()
    lista.append(arg2)

    return lista

#-------------------------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------METODO QUE PROCESA CADA LINEA DE LA RBR Y ESCRIBE EN EL C---------------------

def process_instruction(instr,new_instructions,vars_to_declare,cont):

    if instr.find("nop(SGT")!=-1:
        pre_instr = new_instructions.pop() 

        if pre_instr.find("=")!=-1 and pre_instr.find(">")!=-1:
            args = pre_instr.split("=")
            arg0 = args[0].strip()
            args12 = args[1].split(">")
            arg1 = args12[0].strip()
            arg2 = args12[1].strip()

            new_pre = arg0 + " =sgt( " + arg1 + "," + arg2 +")"
            new_instructions.append(new_pre)
            new = instr
        else:
            new_instructions.append(pre_instr)
            new = instr

    elif instr.find("nop(SLT")!=-1:
        pre_instr = new_instructions.pop()
        if pre_instr.find("=")!=-1 and pre_instr.find("<")!=-1:

            lista = process_instr_nop(instr,new_instructions,"<")
            new_pre = lista[0] + " = SLT(" + lista[1] + "," + lista[2] + ")"
            new_instructions.append(new_pre)
            new = instr
        else:
            new_instructions.append(pre_instr)
            new = instr

    elif instr.find("nop(SDIV")!=-1:
        if verifier != "verymax":
            pre_instr = new_instructions.pop()
            lista = process_instr_nop(instr,new_instructions,"/")
            new_pre = lista[0] + " = SDIV(" + lista[1] + "," + lista[2] + ")"
            new_instructions.append(new_pre)

        new = instr
        
    elif instr.find("nop(SMOD")!=-1:
        if verifier != "verymax":
            pre_instr = new_instructions.pop()
            lista = process_instr_nop(instr,new_instructions,"%")
            new_pre = lista[0] + " = SMOD(" + lista[1] + "," + lista[2] + ")"
            new_instructions.append(new_pre)

        new = instr

    elif instr.find("nop(SIGNEXTEND")!=-1:
        pre_instr = new_instructions.pop()
        args = pre_instr.split("=")
        arg0 = args[0].strip()
        arg1 = args[1].strip()[:-1] #pos = COPY(s4),
        pos = arg1[6:-1] # hay que quedarse con el numero solo
        pos_f = "s"+str(pos) #hay que pasarle a la funcion s4
        pre_pos = int(pos)+1
        arg_bits = "s"+str(pre_pos) #hya que pasarle s5

        new_pre = arg0+" =SIGNEXTEND(" + pos_f + ", " + arg_bits + ");"
        new_instructions.append(new_pre)
        new = instr
        
    elif instr.find("nop(")!=-1:
        new = instr
        

    # son las instrucciones de block y jump
    elif instr.find("call(",0)!=-1:
        call_block = instr[5:-1].strip()
        pos_open = call_block.find("(")
        block = call_block[:pos_open]
        
        args = call_block[pos_open+1:-1]
        vars_aux = args.split(",")
        stack_variables = filter(lambda x: x.startswith("s("),vars_aux)
        variables = map(lambda x : unbox_variable(x.strip()),stack_variables)
        new_variables = ", ".join(variables)
        if goto:
            new = block+"()"
        else:
            new = block+"("+new_variables+")"

    #variables de storage y memoria
    elif instr.find("gs(",0)!=-1:
        pos = instr.find("=")
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg1 = instr[pos+1:].strip()
        var1 = unbox_variable(arg1)
        
        new = var0 +" = COPY(" + var1 + ")"
        check_declare_variable(var0,vars_to_declare)

    elif instr.find("l(l")!=-1:
        pos_local = instr.find("l(l")
        pos_eq = instr.find("=")
        if pos_eq < pos_local: #it is in the right
            arg0 = instr[:pos_eq].strip()
            var0 = unbox_variable(arg0)
            
            arg1 = instr[pos_eq+1:].strip()
            var1_aux = unbox_variable(arg1)
            var1 = var1_aux[1:]
            new = var0 + " = COPY(" + var1 + ")"
        else:
            arg0 = instr[:pos_eq].strip()
            var0_aux = unbox_variable(arg0)
            var0 = var0_aux[1:]

            if instr[pos_eq+1:].strip().startswith("fresh("):
                if svcomp!={}:
                    new = var0+" = "+get_nondet_svcomp_label()
                else:
                    new = var0 + " =s" + str(cont)
                    check_declare_variable("s"+str(cont),vars_to_declare)
                    cont+=1
            else:
                arg1 = instr[pos_eq+1:].strip()
                var1 = unbox_variable(arg1)
                new = var0+" = COPY(" + var1 + ")"
    
    elif instr.find("ls(",0)!=-1:
        pos = instr.find("=")
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg1 = instr[pos+1:].strip()
        var1 = unbox_variable(arg1)
        
        new = var0 +" = COPY(" + var1 + ")"
        check_declare_variable(var0,vars_to_declare)     

    elif instr.find("fresh",0)!=-1:
        pos = instr.find("=")
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if svcomp!={}:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1
        
    elif instr.find("g(",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg1 = instr[pos+1:].strip()
        var1 = unbox_variable(arg1)

        new = var0+" = COPY(" + var1 + ")"
        if var0.startswith("g"):
            check_declare_variable(var1,vars_to_declare)
        else:
            check_declare_variable(var0,vars_to_declare)
    
    elif instr.find("sha",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if svcomp!={}:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1
        
    elif instr.find("skip")!=-1:
        new = ""

    
    #////////////////////////////////////////////////////////////////////////////////////////////////////
  
    elif instr.find("and(",0)!=-1:
        lista=process_instr(instr,"= and",True,vars_to_declare)
        if (svcomp == {} or svcomp["verify"] == "cpa"):
            new = lista[0] + " = AND(" + lista[1] + "," + lista[2] + ")"
        else:
            new = lista[0] +" = "+get_nondet_svcomp_label()  

    elif instr.find("xor(",0)!=-1:
        lista=process_instr(instr,"= xor",True,vars_to_declare)

        if (svcomp == {} or svcomp["verify"] == "cpa"): 
            new = lista[0] + " = XOR(" + lista[1] + "," + lista[2] + ")"
        else:
            new = lista[0] +" = "+get_nondet_svcomp_label()
      
    elif instr.find("or(",0)!=-1:
        lista=process_instr(instr,"= or",True,vars_to_declare)

        if (svcomp == {} or svcomp["verify"] == "cpa"):
            new = lista[0] + " = OR(" + lista[1] + "," + lista[2] + ")"
        else:
            new = lista[0] +" = "+get_nondet_svcomp_label()
        
    elif instr.find("not(",0)!=-1:
        elems = instr.split("= not")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = elems[1].strip()[1:-1]
        var1 = unbox_variable(arg1)
        new = var0 + " = NOT(" + var1 + ")"
        
    #se llama a las versiones que devuelven un struct (geq, gt...)
    elif instr.find("= eq(",0)!=-1:
        lista=process_instr(instr,"= eq",True,vars_to_declare)
        new = lista[0] + " = equals(" + lista[1] + "," + lista[2] + ")"
        
    elif instr.find("= lt(",0)!=-1:
        lista=process_instr(instr,"= lt",True,vars_to_declare)
        new = lista[0] + " = lt(" + lista[1] + "," + lista[2] + ")"

    elif instr.find("= leq(",0)!=-1:
        lista=process_instr(instr,"= leq",True,vars_to_declare)
        new = lista[0] + " = leq(" + lista[1] + "," + lista[2] + ")"
    
    elif instr.find("= slt(",0)!=-1:
        lista=process_instr(instr,"= slt",True,vars_to_declare)
        new = lista[0] + " = slt(" + lista[1] + "," + lista[2] + ")"
        
    elif instr.find("= gt(",0)!=-1:
        lista=process_instr(instr,"= gt",True,vars_to_declare)
        new = lista[0] + " = gt(" + lista[1] + "," + lista[2] + ")"

    elif instr.find("= geq(",0)!=-1:
        lista=process_instr(instr,"= geq",True,vars_to_declare)
        new = lista[0] + " = geq(" + lista[1] + "," + lista[2] + ")"

    elif instr.find("= sgt(",0)!=-1:
        lista=process_instr(instr,"= sgt",True,vars_to_declare)
        new = lista[0] + " = sgt(" + lista[1] + "," + lista[2] + ")"

        
    elif instr.find("^",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg12 = instr[pos+1:].strip().split("^")
        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)
        
        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)
        new = var0 + "=EXP(" + var1 + "," + var2 + ")"
              

    elif instr.find("+")!=-1:
        if instr.find("%")!=-1:#mulmod
            elems = instr.split("%")
            arg012 = elems[0].split("=")
            arg0 = arg012[0].strip()
            var0 = unbox_variable(arg0)

            arg12_aux = arg012[1].strip().lstrip("(")
            arg12 = arg12_aux[:-1].split("+")
            arg1 = arg12[0].strip()
            var1 = unbox_variable(arg1)

            arg2 = arg12[1].strip()
            var2 = unbox_variable(arg2)

            arg3 = elems[1].strip()
            var3 = unbox_variable(arg3)

            # var1 y var2 son para sumar y var3 el modulo
            new = var0+" = MODS(" + var1 + "," + var2 + "," + var3 + ")"
 
        else:
            lista=process_instr(instr,"+",False,vars_to_declare)
            new = lista[0] + " = ADD(" + lista[1] + "," + lista[2] + ")"
        
    elif instr.find("-")!=-1:
        lista=process_instr(instr,"-",False,vars_to_declare)
        new = lista[0] + " = SUB(" + lista[1] + "," + lista[2] + ")"


    elif instr.find("*")!=-1:
        if instr.find("%")!=-1:#mulmod
            elems = instr.split("%")
            arg012 = elems[0].split("=")
            arg0 = arg012[0].strip()
            var0 = unbox_variable(arg0)

            arg12_aux = arg012[1].strip().lstrip("(")
            arg12 = arg12_aux[:-1].split("*")
            arg1 = arg12[0].strip()
            var1 = unbox_variable(arg1)

            arg2 = arg12[1].strip()
            var2 = unbox_variable(arg2)

            arg3 = elems[1].strip()
            var3 = unbox_variable(arg3)

            # var1 y var2 son para multiplicar y var3 el modulo
            new = var0+" = MODX(" + var1 + "," + var2 + "," + var3 + ")"
        

        else:
            elems = instr.split("*")
            arg01 = elems[0].split("=")
            arg0 = arg01[0].strip()
            var0 = unbox_variable(arg0)

            arg1 = arg01[1].strip()
            var1 = unbox_variable(arg1)

            arg2 = elems[1].strip()
            var2 = unbox_variable(arg2)

            new = var0+" = MUL(" + var1 + "," + var2 +  ")"
          

    elif instr.find("/")!=-1:
        elems = instr.split("/")
        arg01 = elems[0].split("=")
        arg0 = arg01[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = arg01[1].strip()
        var1 = unbox_variable(arg1)

        arg2 = elems[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = DIV(" + var1 + "," + var2 +  ")"
      

    elif instr.find("%")!=-1:
        elems = instr.split("%")
        arg01 = elems[0].split("=")
        arg0 = arg01[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = arg01[1].strip()
        var1 = unbox_variable(arg1)

        arg2 = elems[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = MOD(" + var1 + "," + var2 +  ")"

                
    elif len(instr.split("=")) > 1:
        slices = instr.split("=")
        
        arg1 = slices[0].strip() 
        arg2 = slices[1].strip()

        var1 = unbox_variable(arg1)
        if arg2.find("nondet")==-1:
            var2 = unbox_variable(arg2)
        else:
            var2 = arg2

        if var2[0] == 's' :  #ej: s4 = s10
            new = var1 + " = COPY(" + var2 + ")"

        elif var2.isdigit() == True: #ej: s4 = 157
            hex_value = hex(int(var2))
            lis = fun_aux_split(hex_value)
            sep = ','
            lis_final = "ASSIGN(" + sep.join(lis) + ")"
            new = var1 + " = " + lis_final

        else: #ej: s4 = __VERIFIER_nondet_256
            new = var1 + " = COPY(" + var2  + ")"
            
        check_declare_variable(var1,vars_to_declare)        
    else:
        new = instr
            
    new_instructions.append(new+";")
    return cont

#Recibe el numero en hex y lo divide en bloques de 8
def fun_aux_split(hex_value):
    value_string = str(hex_value)[2:].strip("L") #hay que quitar el 0x
    aux = '0x'
    tam = len(value_string)
    palabras = tam / 8 
    mod = tam % 8
    if mod >0 :
        palabras +=1
    listaFinal = ['0x0','0x0','0x0','0x0','0x0','0x0','0x0','0x0'] 
    punt = vuelta = 0

    while palabras > 0 and palabras <= 8:   #recorre las 8 palabras de la lista final
        while vuelta < 8 and punt < tam :   #recorre cada palabra de la lista (8elems/palabra)
            aux += value_string[punt]
            vuelta += 1
            punt += 1
            
        listaFinal[palabras-1] = aux
        palabras -= 1
        aux = '0x' 
        vuelta = 0

    listaFinal.reverse()
    return listaFinal

 
def get_current_initloop():
    if init_loop == 0:
        return init_loop
    else:
        return init_loop-1

#-------------------------------------------------------------------------------------------------------------------
#----------------------------------------------------------LLAMADA VERIFIER NONDET-----------------------------------
def get_nondet_svcomp_label():
    return "__VERIFIER_nondet_256()"
#-------------------------------------------------------------------------------------------------------------------

def get_error_svcomp_label():
    return "ERROR: __VERIFIER_error()"

def add_svcomp_labels():
    labels = "";
    labels = labels+"extern unsigned int __VERIFIER_nondet_uint();\n"
    labels = labels + "extern void __VERIFIER_error();\n"

    return labels

def initialize_globals(rules,init_fields):
    head_c = "void init_globals();"
    head = "void init_globals(){\n"
    
    vars_init = initialize_global_variables(rules,init_fields)
    method = head+vars_init+"}\n"

    return head_c, method
    
def initialize_global_variables(rules,init_fields):

    s = ""

    initialized_vars = init_fields.keys()
    
    if(len(rules)>1):
        r = rules[1][0]
    else:
        r = rules[0][0]
            
    name_fields, numeric_fields = r.get_global_arg()
    fields_id = name_fields[::-1]+numeric_fields[::-1]
    bc_data = r.get_bc()
    locals_vars = sorted(r.get_args_local())[::-1]

    nondet_fields = filter(lambda x: x not in initialized_vars,fields_id) 
    fields = map(lambda x: "\tg"+str(x)+" = __VERIFIER_nondet_256()",nondet_fields)

    for v in initialized_vars:
        val = init_fields[v]
        hex_value = hex(int(val))
        lis = fun_aux_split(hex_value)
        sep = ','
        lis_final = "ASSIGN(" + sep.join(lis) + ")"
        fields.append("\tg"+str(v)+" = "+lis_final)

    
    l_vars = map(lambda x: "\tl"+str(x)+" = __VERIFIER_nondet_256()",locals_vars)
    bc = map(lambda x: "\t"+x+" = __VERIFIER_nondet_256()",bc_data)

    if fields != []:
        s = s+";\n".join(fields)+";\n"

    if l_vars != []:
        s = s+";\n".join(l_vars)+";\n"

    if bc != []:
        s = s+";\n".join(bc)+";\n"

    if goto:
        for e in stack_vars_global:
            s = s+"\t"+e+" = __VERIFIER_nondet_256();\n"
    
    return s

def write_init(rules,execution,cname):
    s = "\n"

    if svcomp!={}:
        s = add_svcomp_labels()
        s = s+"\n"
        
    if execution == None:
        name = costabs_path+"rbr.c"
    elif cname == None:
        name = costabs_path+"rbr"+str(execution)+".c"
    else:
        name = costabs_path+cname+".c"
    with open(name,"w") as f:
        if(len(rules)>1):
            r = rules[1][0]
        else:
            r = rules[0][0]
            
        name_fields, numeric_fields = r.get_global_arg()
        fields_id = name_fields[::-1]+numeric_fields[::-1]
        bc_data = r.get_bc()
        locals_vars = sorted(r.get_args_local())[::-1]
                                
        fields = map(lambda x: "ethint256 g"+str(x),fields_id)
        l_vars = map(lambda x: "ethint256 l"+str(x),locals_vars)
        bc = map(lambda x: "ethint256 "+x,bc_data)
        
        
        if fields != []:
            s = s+";\n".join(fields)+";\n"
        if l_vars != []:
            s = s+";\n".join(l_vars)+";\n"

        if bc != []:
            s = s+";\n".join(bc)+";\n"

        if svcomp == {}:
            f.write("#include <stdio.h>\n\n")

        if goto:
            s_vars = get_stack_variables(stack_vars_global,True)
            r_vars = get_rest_variables(stack_vars_global,True)    
            s = s+"".join(s_vars)+"".join(r_vars)
            with open ('ethereum-256.c',"r") as fich :
                f.write(fich.read())
            fich.close()

        f.write(s)
        
    f.close()


def update_stack_vars_global(vs):
    global stack_vars_global

    for v in vs:
        if v.strip() not in stack_vars_global:
            stack_vars_global.append(v.strip())
            

#Metodo que escribe la parte del main en el fichero .c
def write_main(execution,cname):
    if execution == None:
        name = costabs_path+"rbr.c"
    elif cname == None:
        name = costabs_path+"rbr"+str(execution)+".c"
    else:
        name = costabs_path+cname+".c"

    with open(name,"a") as f:
        init = "\tinit_globals();"
        
        s = "\nint main(){\n"
        if svcomp!={} :
            s = s+"\n"+init+"\n"
        s = s+"\tblock0();\n"
        s = s+"\treturn 0;\n}"
        f.write(s)
    f.close()

#Metodo que escribe todas las instrucciones en el fichero .c
def write(head,rules,execution,cname):
    
    # if "costabs" not in os.listdir("/tmp/"):
    #     os.mkdir("/tmp/costabs/")

    if execution == None:
        name = costabs_path+"rbr.c"
    elif cname == None:
        name = costabs_path+"rbr"+str(execution)+".c"
    else:
        name = costabs_path+cname+".c"
    with open(name,"a") as f:
        f.write(head+"\n")
        
        for rule in rules:
            f.write(rule+"\n")

    f.close()
