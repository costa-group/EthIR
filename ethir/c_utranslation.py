from rbr_rule import RBRRule
import os
from timeit import default_timer as dtimer
from utils import delete_dup
import global_params
import  traceback

'''
This module translate the RBR generated by EthIR to SACO RBR.
It receives a list with rbr_rule instances.
'''

def init_global_vars():
    global pattern
    pattern = ["PUSH1",
                   "DUP2",
                   "PUSH1",
                   "AND",
                   "ISZERO",
                   "PUSH2",
                   "MUL",
                   "SUB",
                   "AND",
                   "PUSH1",
                   "SWAP1",
                   "DIV"]

    global svcomp
    svcomp = {}

    global verifier
    verifier = ""

    global init_loop
    init_loop = 0

    global init_globals
    init_globals = False

    global blocks2init
    blocks2init = []

    global exp_function
    exp_function = False

    global signextend_function
    signextend_function = False

    global stack_vars_global
    stack_vars_global = []

    global goto
    goto= False

    global potential_uncalled
    potential_uncalled = []

    global max_stack_idx
    max_stack_idx = 0

    global block0_header
    block0_header = ""

    
    global mem_id
    mem_id = 0

    global mem_init_blocks
    mem_init_blocks = []

    global mem40_status
    mem40_status = False

    global init_mem40
    init_mem40 = "128"

    # Keys: id of the different specialized mload and mstore
    #Values: ids of the mem variables (intervals) involved in the
    # corresponding memory instructions
    
    global memory_id_spec
    memory_id_spec = {}

    global meminstr_id
    meminstr_id = 0

    # Keys: block id
    #Values: mem_var ids (p1,p2,...) declared in this block
    global mem_vars_per_block
    mem_vars_per_block = {}

    global non_interval_memvars
    non_interval_memvars = []
    
    global components
    components = {}

    global mem_abs
    mem_abs = False
    
def rbr2c(rbr,execution,cname,component_of,scc,svc_labels,gotos,fbm,init_fields,mem_blocks,mem_intervals,sto_abs,storage_arrays):
    global svcomp
    global verifier
    global init_globals
    global blocks2init
    global goto
    global potential_uncalled
    global mem_init_blocks
    global components
    global mem_abs

    
    init_global_vars()
    potential_uncalled = []
    
    svcomp = svc_labels
    verifier = svc_labels.get("verify","")

    components = component_of

    if mem_intervals == "arrays":
        mem_abs = True

    if mem_intervals == "arrays" and verifier == "cpa":
        create_mem_variables(mem_blocks)

    #print mem_blocks
    mem_init_blocks = map(lambda x: x[0], mem_blocks)
    
    begin = dtimer()

    if fbm != []:
        init_globals = True
        blocks2init = fbm

    try:
        if gotos["gotos"]== "iterative":
            goto = gotos["args"] if gotos["args"]!= None else "global"
            heads, new_rules = rbr2c_gotos(rbr,scc)
        else:
            goto = gotos["args"] if gotos["args"]!= None else "global"
            heads, new_rules = rbr2c_recur(rbr)
        
        if not svcomp["exec"] and goto != "local":
            head_c , rule = initialize_globals(rbr,init_fields)
            heads = "\n"+head_c+heads
            new_rules.append(rule)

        if verifier == "cpa" and len(mem_blocks)>0:
            head_mload, mload_f = mload_functions()
            head_mstore, mstore_f = mstore_functions()

            heads = heads+head_mload+head_mstore
            new_rules.append(mload_f)
            new_rules.append(mstore_f)
            
        if exp_function:
            head, f = def_exp_function()
            heads = heads+head
            new_rules.append(f)
            
        if signextend_function:
            head, f = def_signextend_function()
            heads = heads+head
            new_rules.append(f)

        ap = map(lambda x: x[1],mem_blocks)
        num = sum(ap)
            
        write_init(rbr,execution,cname,num)
        write(heads,new_rules,execution,cname)

        s_init = build_init_main(rbr)
        
        write_main(execution,cname,s_init)
        end = dtimer()
        print("C RBR: "+str(end-begin)+"s")
    except:
        traceback.print_exc()
        raise Exception("Error in C_trnalsation",6)

def rbr2c_gotos(rbr,scc):
    global max_stack_idx
    global block0_header
    
    heads = "\n"
    new_rules = []

    scc_unit = scc["unary"]
    scc_multiple = scc["multiple"]
    l = scc_multiple.values()
    scc_ids_multiple = [x for y in l for x in y]
    scc_ids = scc_unit+scc_ids_multiple#get_scc_labels(scc_multiple.values())

    out_in = {}

    #It computes first the scc_multiple to identify if any unary scc is nested.
    heads_m, scc_multiple_rules = compute_sccs_multiple(rbr,scc_multiple,scc_unit,out_in)
    heads_u, scc_unary_rules = compute_sccs_unary(rbr,scc_unit,out_in)

    
    for rules in rbr: #it contains list of two elemtns (jumps) or unitary lists (standard rule)
        getId = rules[0].get_Id()
        type_rule = rules[0].get_type()

        max_stack_idx = max(max_stack_idx,rules[0].get_fresh_index())
        
        if getId in scc_ids :
            if (heads_u.get(getId,-1)!=-1) and (type_rule == "block") :
                heads = heads+heads_u[getId]
                new_rules.append(scc_unary_rules[getId])

            elif (heads_m.get(getId,-1)!=-1) and (type_rule == "block"):
                heads = heads+heads_m[getId]
                new_rules.append(scc_multiple_rules[getId])
        else:
            if len(rules) == 2:
                head,new_rule = process_jumps(rules)
            else:
                head,new_rule = process_rule_c(rules[0])
                
            heads = heads+head
            new_rules.append(new_rule)

        if getId == 0 and len(rules) == 1:
            block0_header =  head[4:]
    # ll = filter(lambda x: heads.find("void "+x)==-1,potential_uncalled)
    # heads = heads+build_headers(ll,rbr)
    return heads, new_rules

def build_headers(l,rbr):
    rbr_aux = [item for sublist in rbr for item in sublist]
    heads = ""
    for e in l:
        idx = e.find("(")
        b_id = e[5:idx]

        r = RBRRule(b_id,"block")
        i = rbr_aux.index(r)
        rule = rbr_aux[i]
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int "+x,stack_variables)
        s_head = ", ".join(stack) 
        head_c ="void " + rule.get_rule_name()+"();\n"
        heads = heads+head_c
    return heads

def rbr2c_recur(rbr):
    global max_stack_idx
    global block0_header
    
    heads = "\n"
    new_rules = []
    
    for rules in rbr: #it contains list of two elemtns (jumps) or unitary lists (standard rule)

        max_stack_idx = max(max_stack_idx,rules[0].get_fresh_index())
        
        if len(rules) == 2:
            head,new_rule = process_jumps(rules)
        else:
            head,new_rule = process_rule_c(rules[0])

            if rules[0].get_Id() == 0:
                block0_header =  head[4:]
                
        heads = heads+head
        new_rules.append(new_rule)

    return heads,new_rules


#If an id its in out_in means that this scc is nested and the continue
#block has been translated in the outer scc.
def compute_sccs_unary(rbr,scc_unit,out_in):
    global init_loop
    
    rules = {}
    heads = {}
    
    l = len(rbr)
    i = 0
    while i < l:
        nested = False
        r = rbr[i]
        if len(r) == 2:
            rid = r[0].get_Id()
            if rid in scc_unit:

                if out_in.get(rid,-1)!=-1:
                    nested = True
            
                part_jump = translate_jump_scc(r,scc_unit,init_loop,nested)
                i =i+1
                rule_main = rbr[i][0]
                head, part_main = translate_block_scc(rule_main,init_loop)
                init_loop+=1
                rule = part_main+"\n"+part_jump+"}"
                rules[rid] = rule
                heads[rid] = head
        else:
            rid = r[0].get_Id()
            if rid in scc_unit:

                if out_in.get(rid,-1)!=-1:
                    nested = True
                
                head, part_main = translate_block_scc(r[0],init_loop)
                i+=1
                rule_jump = rbr[i]
                part_jump = translate_jump_scc(rule_jump,scc_unit,init_loop,nested)
                init_loop+=1
                rule = part_main+"\n"+part_jump+"}"
                rules[rid] = rule
                heads[rid] = head

        i=i+1

    return heads, rules


#If scc is nested, the exit block is translated in the outer scc.
def translate_jump_scc(r,scc,id_loop,nested = False):
    
    jump1 = r[0]
    jump2 = r[1]

    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    if_id = get_called_block(call_if)

    if if_id in scc:
        guard = jump1.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_else

    else:
        guard = jump2.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_if
        
    label = "goto init_loop_"+str(id_loop)

    body = "\tif("+cond+"){\n"
    body = body+"\t\t"+label+"; }\n"
    if not nested:
        body = body+"\t"+call_instr+";\n"

    return body


def translate_block_scc(rule,id_loop,multiple=False):
    
    if goto == "local":
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int i_"+x,stack_variables)

        fields_variables = get_field_variables(rule)
        fields = map(lambda x: "unsigned int i_"+x,fields_variables)[::-1]
        #build memory
        if not mem_abs:
            local_variables = get_local_variables(rule)
            local = map(lambda x: "unsigned int i_"+x, local_variables)
        else:
            local_variables = []
            local = []
            
        #build blockchain
        bc_variables = get_blockchain_variables(rule)
        bc = map(lambda x: "unsigned int i_"+x, bc_variables)

        r_vars = stack+fields+local+bc
        s_head = ",".join(r_vars)
        head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
        head = "void " + rule.get_rule_name()+"("+s_head+"){\n"

    elif goto == "global":
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int "+x,stack_variables)
        s_head = ", ".join(stack)

        head_c = "void " + rule.get_rule_name()+"();\n"
        head = "void " + rule.get_rule_name()+"(){\n"
        
    elif goto == "mix":
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int i_"+x,stack_variables)
        s_head = ", ".join(stack)

        head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
        head = "void " + rule.get_rule_name()+"("+s_head+"){\n"

    else:
        head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
        head = "void " + rule.get_rule_name()+"("+s_head+"){\n"

        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int "+x,stack_variables)
        
        
    cont = rule.get_fresh_index()+1
    instructions = rule.get_instructions()
    has_string_pattern = rule.get_string_getter()
    new_instructions,variables = process_body_c(rule.get_Id(),instructions,cont,has_string_pattern)

    if multiple:
        variables_d = get_variables_to_be_declared(stack_variables,variables,True)
    else:
        variables_d = get_variables_to_be_declared(stack_variables,variables)
        var_declarations = "\n"+variables_d+"\n"
    
    #To delete skip instructions
    new_instructions = filter(lambda x: not(x.strip().startswith("nop(")) and x!=";",new_instructions)

    new_instructions = new_instructions[:-1] #To delete the call instructions. It is always the last one.
    new_instructions = map(lambda x: "\t"+x,new_instructions)
    body = "\n".join(new_instructions)

    init_loop_label = "  init_loop_"+str(id_loop)+":\n"
    if rule.has_invalid() and not svcomp["exec"]:
        source = rule.get_invalid_source()
        label = get_error_svcomp_label()+"; //"+source+"\n"
    else:
        label = ""

    update_stack_vars_global(stack_variables)
    update_stack_vars_global(variables)

    if goto == "mix":
        init_vars_aux = map(lambda x: "\t"+x+" = i_"+x+";",stack_variables)
        init_vars = "\n".join(init_vars_aux)+"\n\n"

        initializations_aux = generate_initializations(stack_variables[::-1]+variables)
        initializations = "\n".join(initializations_aux)+"\n\n"
        
    elif goto == "local":
        init_vars_aux = map(lambda x: "\t"+x+" = i_"+x+";",stack_variables)
        initializations_aux = generate_initializations(stack_variables[::-1]+variables)

        initializations_fields = map(lambda x: "\tunsigned int "+x+";",fields_variables)

        init_fvars_aux = map(lambda x: "\t"+x+" = i_"+x+";",fields_variables)
        
        #build memory
        if not mem_abs:
            initializations_local = map(lambda x: "\tunsigned int "+x+";", local_variables)

            init_lvars_aux = map(lambda x: "\t"+x+" = i_"+x+";",local_variables)

        else:
            initializations_local = []
            init_lvars_aux = []
            
        #build blockchain
        initializations_bc = map(lambda x: "\tunsigned int "+x+";", bc_variables)

        init_bvars_aux = map(lambda x: "\t"+x+" = i_"+x+";",bc_variables)

        initializations = "\n".join(initializations_aux+initializations_fields+initializations_local+initializations_bc)+"\n\n"
        init_vars = "\n".join(init_vars_aux+init_fvars_aux+init_lvars_aux+init_bvars_aux)+"\n\n"
        
    if not multiple:
        #rule_c = head+var_declarations+init_loop_label+body+label
        if goto == "local" or goto == "mix":
            rule_c = head+initializations+init_vars+init_loop_label+body+label
        else:
            rule_c = head+init_loop_label+body+label
        return head_c,rule_c
    else:
        if goto == "local" or goto == "mix":
            init_loop_label = initializations+init_vars+init_loop_label
        return head_c,[head,init_loop_label+body+label],variables_d



    
def translate_scc_blocks(next_rule,entry_rule,rbr_scc,scc,all_scc_ids,inner,rbr,out_in,outer_id):
    if outer_id !=-1:
        part_block,vars_declaration =  process_goto(next_rule,entry_rule,rbr_scc,scc,all_scc_ids,inner,rbr,out_in,scc[outer_id])
    else:
        part_block,vars_declaration =  process_goto(next_rule,entry_rule,rbr_scc,scc,all_scc_ids,inner,rbr,out_in)

    return part_block,vars_declaration


def compone_blocks_common_scc(code_blocks,next_idx,rbr_scc):
    code_if = code_blocks[0]
    code_else = code_blocks[1]

    jump1 = rbr_scc[next_idx]

    guard = jump1.get_guard()
    cond = translate_conditions(guard)

    code_if_aux = code_if.split("\n")
    code_if_aux = map(lambda x: "\t"+x,code_if_aux)
    code_if = "\n".join(code_if_aux)

    code_else_aux = code_else.split("\n")
    code_else_aux = map(lambda x: "\t"+x,code_else_aux)
    code_else = "\n".join(code_else_aux)
    
    body = "\tif("+cond+"){\n"
    body = body+code_if+"\n\t}else{\n"
    body = body+code_else+"\n\t}\n"

    return body


def compute_sccs_multiple(rbr,scc,scc_unit_keys,out_in):
    global init_loop
    
    rules = {}
    heads = {}
    inner_scc = []
    body = ""
    exit_label = ""
    part_block = ""
     
    to_translate = scc.keys()

    scc_ids = to_translate+scc_unit_keys
    
    s = get_next_scc(scc,to_translate)
    while(s!=-1):
        rbr_scc = filter_scc_multiple(rbr,scc[s])
        entry = get_rule_from_scc(s,rbr_scc)

        head, entry_part,vars_declaration = translate_block_scc(entry,init_loop,True)
        outer_id = out_in.get(s,-1)

        #if entry is unconditional, it gets the next block and call to
        #translate.  if entry is conditional it checks if both jumps
        #are inside the scc. If they are, it translates each block
        #separately and compone the results.  If not, it computes
        #which is the next block (the one that is inside the scc) and
        #continue the process with it.
        if entry.is_conditional():
            id1, id2 = get_next_from_rule(s,rbr_scc)
            next_idx = get_rule_from_scc(s,rbr_scc,True,True)
            
            if id1 in scc[s] and id2 in scc[s]:
                next_rule = get_rule_from_scc(id1,rbr_scc)
                part_block1,vars_declaration1 = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)

                next_rule = get_rule_from_scc(id2,rbr_scc)
                part_block2,vars_declaration2 = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)

                entry_jump = ""
                part_block = compone_blocks_common_scc((part_block1,part_block2),next_idx,rbr_scc)
                
                vars_declaration = vars_declaration1+vars_declaration2
            else:

                if s in inner_scc:
                    entry_jump,exit_block,next_block = translate_entry_jump(next_idx,rbr_scc,scc[outer_id])
                    
                else:
                    entry_jump,exit_block,next_block = translate_entry_jump(next_idx,rbr_scc)
               
                next_rule = get_rule_from_scc(next_block,rbr_scc)
                part_block,vars_declaration = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)

        else:
            entry_jump=""
            next_block = entry.get_call_to()
            next_rule = get_rule_from_scc(next_block,rbr_scc)
            part_block,vars_declaration = translate_scc_blocks(next_rule,entry,rbr_scc,scc,scc_ids,inner_scc,rbr,out_in,outer_id)
            

        init_label = "\tgoto init_loop_"+str(init_loop)+";\n"
        end_label = "  end_loop_"+str(init_loop)+": \n"

        vars_declaration = delete_dup(vars_declaration)
        varsd_string = "\t".join(vars_declaration)
        
        body = entry_part[0]+entry_part[1]+"\n"
        body = body+entry_jump+part_block
        body = body+init_label+"\n"
        body = body+end_label
            
        if s in inner_scc:
            exit_block = ""

        body = body+"\t ;\n}"

        rules[s] = body
        heads[s] = head
        init_loop+=1
        exit_label = ""
        part_block = ""
        
        s = get_next_scc(scc,to_translate)
    return heads,rules


def get_next_scc(scc,to_translate):
    if to_translate == []:
        return -1
    else:
        for s in scc:
            if s in to_translate:
                r = check_candidate(s,scc,to_translate)
                if r:
                    i = to_translate.index(s)
                    to_translate.pop(i)
                    return s

def check_candidate(s,scc,to_translate):
    candidate = True
    scc_aux = filter(lambda x: x in to_translate,scc.keys())
    for e in scc_aux:
        if s != e:
            l = scc[e]
            candidate = candidate and (s not in l)
    return candidate
        
                
def process_goto(next_rule,entry,rbr_scc, scc, all_scc_ids,inner_scc,rbr,out_in,outer_scc=[]):
    if (next_rule == entry):
        return "",[]
    
    else:#(next_rule!=entry):
        if next_rule.get_Id() in all_scc_ids:
            out_in[next_rule.get_Id()] = entry.get_Id()
            inner_scc.append(next_rule.get_Id())
            part = "\tblock"+str(next_rule.get_Id())+"();\n"
            vars_d = []
            if_id,else_id = get_next_from_rule(next_rule.get_Id(),rbr_scc)
            
            #the next rule has to be in the outer scc and not in the
            #inner one. If get_Id is in all_scc_ids but it is not in
            #scc means that it is a unitary scc and the value of
            #scc_list is [Id]
            scc_list = scc.get(next_rule.get_Id(),[next_rule.get_Id()])
            if if_id in scc_list:
                candidate = if_id
                next_id = else_id
            else:
                next_id = if_id
                candidate = else_id
            next_id = check_next_id((next_id,candidate),scc[entry.get_Id()],scc_list,rbr_scc)
            #print next_id
            next_rule = get_rule_from_scc(next_id,rbr_scc)
            part_block_aux, vars_declaration = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)

            part_block = part+part_block_aux
            vars_declaration = vars_declaration+vars_d
        
        else:
            vars_d, part, next_id ,both= translate_scc_multiple(next_rule,rbr_scc,scc[entry.get_Id()],outer_scc)
            if both:
                if_id = next_id[0]
                next_rule = get_rule_from_scc(if_id,rbr_scc)
                part_block_aux, vars_declaration = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)

                part_block1 = tab_block(part_block_aux)
                vars_declaration = vars_declaration+vars_d
                
                else_id = next_id[1]
                next_rule = get_rule_from_scc(else_id,rbr_scc)
                part_block_aux, vars_d = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)

                part_block2 = tab_block(part_block_aux)
                vars_declaration = vars_declaration+vars_d
                
                part_block = part+part_block1+"}\n\telse {\n"+part_block2+"\t}\n"
                
            else:
                
                next_rule = get_rule_from_scc(next_id,rbr_scc)
                part_block_aux,vars_declaration = process_goto(next_rule,entry,rbr_scc,scc,all_scc_ids,inner_scc,rbr,out_in,outer_scc)
                part_block = part+part_block_aux
                vars_declaration = vars_declaration+vars_d
                
        return part_block,vars_declaration

#For inner scc it checks if the id returned is a valid one (is in the
#scc). If not it means that the inner and outer scc share some nodes.
def check_next_id(ids, outer_scc,inner_scc, rbr_scc):
    next_id,candidate_id = ids
    scc = filter(lambda x: x not in inner_scc,outer_scc)
    if next_id in scc:
        return next_id
    else:
        # it has to find the next_id. Candidate is in inner_scc
        if_id, else_id = get_next_from_rule(candidate_id,rbr_scc)
        if if_id in scc:
            return if_id
        elif else_id in scc:
            return else_id
        else:
            if if_id in inner_scc:
                return check_next_id((else_id,if_id),outer_scc,inner_scc,rbr_scc)
            else:
                return check_next_id((if_id,else_id),outer_scc,inner_scc,rbr_scc)

            
def tab_block(chain):
    lines = chain.split("\n")
    new_lines = map(lambda x: "\t"+x,lines)
    result = "\n".join(new_lines)
    return result
    
def get_next_from_rule(ruleId,scc):
    try:
        next_idx = get_rule_from_scc(ruleId,scc,True,True)
        jump1 = scc[next_idx]
        jump2 = scc[next_idx+1]

        instructions1 = jump1.get_instructions()
        instructions2 = jump2.get_instructions()

        call_if = filter_call(instructions1[0])
        call_else = filter_call(instructions2[0])

        if_id = get_called_block(call_if)
        else_id = get_called_block(call_else)

        return if_id,else_id

    except: #it is not an conditional jump
        rule = get_rule_from_scc(ruleId,scc)
        next_id = rule.get_call_to()
        return next_id, next_id

#If outer_scc != [] is a inner_scc
def translate_entry_jump(next_idx,scc,outer_scc = []):
    jump1 = scc[next_idx]
    jump2 = scc[next_idx+1]
    
    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    if_id = get_called_block(call_if)
    else_id = get_called_block(call_else)

    r_aux = RBRRule(if_id,"block")
    
    if r_aux in scc:
        guard = jump2.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_else
        exit_block = else_id
        next_block = if_id

    else:
        guard = jump1.get_guard()
        cond = translate_conditions(guard)
        call_instr = call_if
        exit_block = if_id
        next_block = else_id

    if outer_scc != []:
        if exit_block in outer_scc:
            body_call = ""
            label = "goto end_loop_"+str(init_loop)
        else:
            body_call = "\t\tblock"+str(exit_block)+"();"
            label = "goto end_loop_"+str(init_loop)
    else:
        body_call = "\t\t"+call_instr+";"
        label = "goto end_loop_"+str(init_loop)

    body = "\tif("+cond+"){\n"
    body = body+body_call+"\n"
    body = body+"\t\t"+label+"; }\n"

    return body,call_instr,next_block


def translate_scc_multiple(rule,rbr_scc,scc,outer_scc):
    
    stack_variables = get_input_variables(rule.get_index_invars())

    cont = rule.get_fresh_index()+1
    instructions = rule.get_instructions()
    has_string_pattern = rule.get_string_getter()
    new_instructions,variables = process_body_c(rule.get_Id(),instructions,cont,has_string_pattern)
    
    variables_d = get_variables_to_be_declared(stack_variables,variables,True)
    #var_declarations = "\n"+variables_d+"\n"
    
    #To delete skip instructions
    new_instructions = filter(lambda x: not(x.strip().startswith("nop(")) and x!=";",new_instructions)

    called_instructions = new_instructions[-1]
    called_is_jump = called_instructions.startswith("j")

    if called_is_jump:
        jump_idx = get_rule_from_scc(rule.get_Id(),rbr_scc,True,True)
        part, next_block, both = translate_jump_scc_multiple(jump_idx,rbr_scc,scc,outer_scc)
       
    else:
        part = ""
        both = False
        next_block = get_called_block(called_instructions)

    new_instructions = new_instructions[:-1] #To delete the call instructions. It is always the last one.
    new_instructions = map(lambda x: "\t"+x,new_instructions)
    body = "\n".join(new_instructions)
    body = body+"\n"+part
    
    update_stack_vars_global(stack_variables)
    update_stack_vars_global(variables)
    
    return variables_d, body, next_block, both

def translate_jump_scc_multiple(idx,rule_scc,scc,outer_scc):
    global potential_uncalled

    both = False
    
    jump1 = rule_scc[idx]
    jump2 = rule_scc[idx+1]

    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    if_id = get_called_block(call_if)
    else_id = get_called_block(call_else)

    #if_b = get_rule_from_scc(if_id,rule_scc)
    

    if if_id in scc and else_id in scc:
        both = True
        
        guard = jump1.get_guard()
        cond = translate_conditions(guard)
        body = "\tif("+cond+"){\n"
        next_block = (if_id,else_id)

    else:    
        if if_id in scc:
            guard = jump2.get_guard()
            cond = translate_conditions(guard)
            call_instr = call_else
            exit_block = else_id
            next_block = if_id

        else:
            guard = jump1.get_guard()
            cond = translate_conditions(guard)
            call_instr = call_if
            exit_block = if_id
            next_block = else_id


        body = "\tif("+cond+"){\n"
            
        if outer_scc != []:
            if exit_block in outer_scc and exit_block not in scc:
                label = "goto end_loop_"+str(init_loop)
            else:
                body = body+"\t\t"+call_instr+";\n"
                label = "goto end_loop_"+str(init_loop)
        else:
            label = "goto end_loop_"+str(init_loop)
            body = body+"\t\t"+call_instr+";\n"

        body = body+"\t\t"+label+"; }\n"
        
        if call_instr not in potential_uncalled:
            potential_uncalled.append(call_instr)
        
    return body,next_block,both


def get_rule_from_scc(blockId,rbr_scc,jump=False,idx_r=False):
    if jump:
        r_aux = RBRRule(blockId,"jump")
    else:
        r_aux = RBRRule(blockId,"block")

    idx = rbr_scc.index(r_aux)
    if idx_r:
        return idx
    else:
        return rbr_scc[idx]

    
def get_scc_labels(scc):
    l = []
    for i in range(len(scc)):
        #l = l+scc[i]
        l.append(scc[i])
    return l


def filter_scc_multiple(rbr,scc):
    rules = []
    
    l = get_scc_labels(scc)

    for r in rbr:
        rule = r[0]
        rid = rule.get_Id()
        if rid in l:
            rules = rules+r

    return rules


def unbox_variable(var):
    open_pos = var.find("(")
    close_pos = var.find(")")
    if open_pos !=-1 and close_pos !=-1:
        new_var = var[:open_pos]+var[open_pos+1:close_pos]
    else:
        new_var = var
    return new_var


def check_declare_variable(var,variables):
    if var not in variables:
        variables.append(var)

        
def get_stack_variables(variables,l=False):
    stack_variables = filter(lambda x: x.startswith("s"),variables)
    idx_list = map(lambda x: int(x.strip()[1:]),stack_variables)
    sorted_idx = sorted(idx_list)
    rebuild_stack_variables = map(lambda x: "unsigned int s"+str(x)+";\n",sorted_idx)
    s_vars = "\t".join(rebuild_stack_variables)

    if l:
        return rebuild_stack_variables
    else:
        return s_vars

    
def get_rest_variables(variables,l=False):
    r_variables = filter(lambda x: not(x.startswith("s")),variables)
    sorted_variables = sorted(r_variables)
    rebuild_rvariables = map(lambda x: "unsigned int "+x+";\n",sorted_variables)
    r_vars = "\t".join(rebuild_rvariables)

    if l:
        return rebuild_rvariables
    else:
        return r_vars

    
def get_variables_to_be_declared(stack_variables,variables,l=False):
    vd = []
    for v in variables:
        if v not in stack_variables:
            vd.append(v)

    s_vars = get_stack_variables(vd,l)
    r_vars = get_rest_variables(vd,l)
    if l:
        return s_vars+r_vars
    else:
        return "\t"+s_vars+"\t"+r_vars

    
def get_input_variables(idx):
    in_vars = []
    for i in xrange(idx-1,-1,-1):
        var = "s"+str(i)
        in_vars.append(var)
    return in_vars

def get_field_variables(rule):
    
    name_fields, numeric_fields = rule.get_global_arg()
    fields_id = name_fields[::-1]+numeric_fields[::-1]

    new = map(lambda x: "g"+x, fields_id)
    
    return new

#No memory intervals abstraction
def get_local_variables(rule):
    locals_vars = sorted(rule.get_args_local())[::-1]
    l_vars = map(lambda x: "l"+str(x),locals_vars)

    return l_vars
    
def get_blockchain_variables(rule):
    bc_data = rule.get_bc()

    return bc_data


def translate_conditions(instr):

    if instr.startswith("gt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        instr = var1+" > "+var2
    elif instr.startswith("sgt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        instr = "(int)"+var1+" > "+"(int)"+var2
    elif instr.startswith("geq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[4:])
        var2 = unbox_variable(arg2[:-1])
        instr = var1+" >= "+var2
    elif instr.startswith("lt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        instr = var1+" < "+var2
    elif instr.startswith("slt"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        instr = "(int)"+var1+" < "+"(int)"+var2
    elif instr.startswith("leq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[4:])
        var2 = unbox_variable(arg2[:-1])
        instr = var1+" <= "+var2
    elif instr.startswith("eq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[3:])
        var2 = unbox_variable(arg2[:-1])
        instr = var1+" == "+var2
    elif instr.startswith("neq"):
        arg1 = instr.split(",")[0].strip()
        arg2 = instr.split(",")[1].strip()
        var1 = unbox_variable(arg1[4:])
        var2 = unbox_variable(arg2[:-1])
        instr = var1+" != "+var2
    else:
        instr = "Error in guard translation"

    return instr


def filter_call(call_instruction):
    block = call_instruction.strip()[5:-1].strip()
    pos_open = block.find("(")
    arguments = block[pos_open+1:-1]
    variables = arguments.split(",")
    stack_variables = filter(lambda x: x.strip().startswith("s("),variables)
    s_vars = map(lambda x: unbox_variable(x.strip()),stack_variables)
    
    s_string = ", ".join(s_vars)
    if goto == "global":
        call = block[:pos_open]+"()"
    elif goto == "mix":
        call = block[:pos_open]+"("+s_string+")"
    elif goto == "local":
        field_variables = filter(lambda x: x.strip().startswith("g("),variables)
        f_vars = map(lambda x: unbox_variable(x.strip()),field_variables)

        local_variables_mem = filter(lambda x: x.strip().startswith("l("),variables)
        
        if not mem_abs:
            local_variables = filter(lambda x: x.strip().startswith("l("),variables)
            l_vars = map(lambda x: x.strip()[2:-1],local_variables)
        else:
            local_variables = []
            l_vars = []
            
        other = stack_variables+field_variables+local_variables+local_variables_mem
        bc_vars = filter(lambda x: x not in other,variables)
        
        v_vars = s_vars+f_vars+l_vars+bc_vars
        s_string = ", ".join(v_vars)
        call = block[:pos_open]+"("+s_string+")"
    else:
        call = block[:pos_open]+"("+s_string+")"
    return call



def get_called_block(call_instruction):
    block = call_instruction.strip()[5:-1].strip()
    pos_open = block.find("(")
    block_id = block[:pos_open].strip()

    try:
        return int(block_id)

    except:
        return block_id

def process_jumps(rules):
    jump1 = rules[0]
    jump2 = rules[1]

    stack_variables = get_input_variables(jump1.get_index_invars())
    stack = map(lambda x: "unsigned int "+x,stack_variables)
    s_head = ", ".join(stack)

    if goto == "global":
        head_c ="void " + jump1.get_rule_name()+"();\n"
        head = "void " + jump1.get_rule_name()+"(){\n"
    elif goto == "mix":
        head_c ="void " + jump1.get_rule_name()+"("+s_head+");\n"
        head = "void " + jump1.get_rule_name()+"("+s_head+"){\n"
    elif goto == "local":
        fields_variables = get_field_variables(jump1)[::-1]
        fields = map(lambda x: "unsigned int "+x,fields_variables)
        #build memory
        if not mem_abs:
            local_variables = get_local_variables(jump1)
            local = map(lambda x: "unsigned int "+x, local_variables)
        else:
            local = []
            
        #build blockchain
        bc_variables = get_blockchain_variables(jump1)
        bc = map(lambda x: "unsigned int "+x, bc_variables)

        r_vars = stack+fields+local+bc
        r_head = ",".join(r_vars)

        head_c ="void " + jump1.get_rule_name()+"("+r_head+");\n"
        head = "void " + jump1.get_rule_name()+"("+r_head+"){\n"
        
    else:
        head_c ="void " + jump1.get_rule_name()+"("+s_head+");\n"
        head = "void " + jump1.get_rule_name()+"("+s_head+"){\n"

    guard = jump1.get_guard()
    instructions1 = jump1.get_instructions()
    instructions2 = jump2.get_instructions()
    
    cond = translate_conditions(guard)

    call_if = filter_call(instructions1[0])
    call_else = filter_call(instructions2[0])

    body = "\tif("+cond+"){\n"
    body = body+"\t\t"+call_if+"; }\n"
    body = body+"\telse {\n"
    body = body+"\t\t"+call_else+"; }\n"
    end = "}\n"

    rule_c = head+body+end
    return head_c,rule_c

    
def process_rule_c(rule):
    if goto == "global":
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int "+x,stack_variables)
        s_head = ", ".join(stack)
    else:
        stack_variables = get_input_variables(rule.get_index_invars())
        stack = map(lambda x: "unsigned int i_"+x,stack_variables)
        s_head = ", ".join(stack)
        
    if goto == "global":
        head_c = "void " + rule.get_rule_name()+"();\n"
        head = "void " + rule.get_rule_name()+"(){\n"
    elif goto == "mix":
        head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
        head = "void " + rule.get_rule_name()+"("+s_head+"){\n"
    elif goto == "local": #local

        #build fields
        fields_variables = get_field_variables(rule)
        fields = map(lambda x: "unsigned int i_"+x,fields_variables)[::-1]
        #build memory
        if not mem_abs:
            local_variables = get_local_variables(rule)
            local = map(lambda x: "unsigned int i_"+x, local_variables)
        else:
            local = []
            
        #build blockchain
        bc_variables = get_blockchain_variables(rule)
        bc = map(lambda x: "unsigned int i_"+x, bc_variables)

        r_vars = stack+fields+local+bc
        r_head = ",".join(r_vars)
        
        head_c = "void " + rule.get_rule_name()+"("+r_head+");\n"
        head = "void " + rule.get_rule_name()+"("+r_head+"){\n"

    else: #no gotos
        head_c = "void " + rule.get_rule_name()+"("+s_head+");\n"
        head = "void " + rule.get_rule_name()+"("+s_head+"){\n"

        
    cont = rule.get_fresh_index()+1
    instructions = rule.get_instructions()
    has_string_pattern = rule.get_string_getter()
    new_instructions,variables = process_body_c(rule.get_Id(),instructions,cont,has_string_pattern)
    
    variables_d = get_variables_to_be_declared(stack_variables,variables)
    var_declarations = "\n"+variables_d+"\n"
    
    #To delete skip instructions
    new_instructions = filter(lambda x: not(x.strip().startswith("nop(")) and x!=";",new_instructions)
    
    new_instructions = map(lambda x: "\t"+x,new_instructions)
    body = "\n".join(new_instructions)

    if rule.has_invalid() and not svcomp["exec"]:
        source = rule.get_invalid_source()
        label = get_error_svcomp_label()+"; //"+source+"\n"
    else:
        label = ""
        
    end ="\n}\n"

    if goto == "global":
        update_stack_vars_global(stack_variables)
        update_stack_vars_global(variables)
        rule_c = head
        
    elif goto == "mix":
        initializations_aux = generate_initializations(stack_variables[::-1]+variables)
        initializations = "\n".join(initializations_aux)+"\n\n"

        init_vars_aux = map(lambda x: "\t"+x+" = i_"+x+";",stack_variables)
        init_vars = "\n".join(init_vars_aux)+"\n" if init_vars_aux != [] else ""


        rule_c = head+initializations+init_vars

    elif goto == "local":
        #stack variables
        initializations_stack = generate_initializations(stack_variables[::-1]+variables)
        init_svars = map(lambda x: "\t"+x+" = i_"+x+";",stack_variables)
        
        initializations_fields = map(lambda x: "\tunsigned int "+x+";",fields_variables)
        init_fvars = map(lambda x: "\t"+x+" = i_"+x+";",fields_variables)
        
        #build memory
        if not mem_abs:
            initializations_local = map(lambda x: "\tunsigned int "+x+";", local_variables)
            init_lvars = map(lambda x: "\t"+x+" = i_"+x+";",local_variables)
        else:
            initializations_local = []
            init_lvars = []
            
        #build blockchain
        initializations_bc = map(lambda x: "\tunsigned int "+x+";", bc_variables)
        init_bvars = map(lambda x: "\t"+x+" = i_"+x+";",bc_variables)

        initializations = "\n".join(initializations_stack+initializations_fields+initializations_local+initializations_bc)+"\n\n"
        init_vars = "\n".join(init_svars+init_fvars+init_lvars+init_bvars)+"\n\n"
        rule_c = head+initializations+init_vars
        #aniadir declaracion de variables y asignaciones nuevas
    
    else:
        rule_c = head+var_declarations
    
    if (rule.get_Id() in blocks2init) and not svcomp["exec"]:
        if goto == "local":
            init = ""
        else:
            init = "\tinit_globals();\n"
        rule_c = rule_c+init+body+label+end
    else:
        rule_c = rule_c+body+label+end
    
    return head_c,rule_c


def is_number(var):
    try:
        r = int(var)
        b = True
    except:
        r = -1
        b = False
        
    return b,r


def abstract_integer(var):
    b,r = is_number(var)
    new_var = ""

    if b:
        hexadec = hex(r)
        if len(hexadec)<=10:
            new_var = str(r)
        else:
            if not svcomp["exec"]:
                new_var = get_nondet_svcomp_label()
            else:
                new_var = "4294967295"
            # if hexadec[-1]=="L":
            #     left_h = hexadec[2:-9]
            #     right_h = hexadec[-9:-1]
            # else:
            #     left_h = hexadec[2:-8]
            #     right_h = hexadec[-8:]

            # fs = filter(lambda x: x!="f",left_h)
            
            # if len(fs)!= 0 and svcomp!={}:
            #     new_var = get_nondet_svcomp_label()
            # elif len(fs)!= 0 and svcomp=={}:
            #     new_var = "4294967295"
            # else:
            #     aux = "0x"+right_h
            #     new_var = str(int(aux,16))
            
    # if b and r>=4294967296:
    #     new_var = "4294967295"

    # elif b and r<4294967296:
    #     new_var = str(r)
    else:
        new_var = var
        
    return new_var


def compute_string_pattern(new_instructions):
    nop_inst = map(lambda x: "nop("+x+")",pattern)
    new_instructions = new_instructions+nop_inst
    return new_instructions


def process_body_c(rule_id,instructions,cont,has_string_pattern):
    global mem40_status
    global mem_id

    new_instructions = []
    variables = []
    #    instructions = filter(lambda x: x!= "", instructions)
    idx_loop = 0
    len_ins = len(instructions)

    mem40_status = False
    mem_id = 0
    mem_already_defined = []
    
    #for instr in instructions:
    while(idx_loop<len_ins):
        instr = instructions[idx_loop]

        if idx_loop == 8 and has_string_pattern:
            new_instructions = compute_string_pattern(new_instructions)
            idx_loop = idx_loop+26
        else:
            cont = process_instruction(rule_id,instr,new_instructions,variables,cont,mem_already_defined)
            idx_loop = idx_loop+1

    new_instructions = filter(lambda x: x!= "", new_instructions)
    return new_instructions,variables


def process_instruction(rule_id,instr,new_instructions,vars_to_declare,cont,mem_defined):
    global signextend_function
    global exp_function
    global mem_id
    global mem40_status
    global init_mem40
    global mem_vars_per_block
    global non_interval_memvars
    
    if instr.find("nop(SGT")!=-1:
        pre_instr = new_instructions.pop()
        if pre_instr.find("=")!=-1 and pre_instr.find(">")!=-1:
            args = pre_instr.split("=")
            arg0 = args[0].strip()
            args12 = args[1].split(">")
            arg1 = args12[0].strip()
            arg2 = args12[1].strip()

            new_pre = arg0+" = "+"(int)"+arg1+" > "+" (int)"+arg2
            new_instructions.append(new_pre)
            new = instr
        else:
            new_instructions.append(pre_instr)
            new = instr

    elif instr.find("nop(SLT")!=-1:
        pre_instr = new_instructions.pop()
        if pre_instr.find("=")!=-1 and pre_instr.find("<")!=-1:
            args = pre_instr.split("=")
            arg0 = args[0].strip()
            args12 = args[1].split("<")
            arg1 = args12[0].strip()
            arg2 = args12[1].strip()

            new_pre = arg0+" = "+"(int)"+arg1+" < "+" (int)"+arg2
            new_instructions.append(new_pre)
            new = instr
        else:
            new_instructions.append(pre_instr)
            new = instr

    elif instr.find("nop(SDIV")!=-1:

        if verifier != "verymax":
            pre_instr = new_instructions.pop()
            args = pre_instr.split("=")
            arg0 = args[0].strip()
            args12 = args[1].split("/")
            arg1 = args12[0].strip()
            arg2 = args12[1].strip()

            new_pre = arg0+" = "+"(int)"+arg1+" / "+"(int)"+arg2
            new_instructions.append(new_pre)

        new = instr
        
    elif instr.find("nop(SMOD")!=-1:

        if verifier != "verymax":
            pre_instr = new_instructions.pop()
            args = pre_instr.split("=")
            arg0 = args[0].strip()
            arg12 = args[1].split("%")
            arg1 = args12[0].strip()
            arg2 = args12[1].strip()

            new_pre = arg0+" = "+"(int)"+arg1+" % "+"(int)"+arg2
            new_instructions.append(new_pre)

        new = instr

    elif instr.find("nop(SIGNEXTEND")!=-1:
        pre_instr = new_instructions.pop()
        args = pre_instr.split("=")
        arg0 = args[0].strip()
        arg1 = args[1].strip()[:-1]
        pos = arg1[1:]
        pre_pos = int(pos)+1
        arg_bits = "s"+str(pre_pos)

        new_pre = arg0+" = signextend_eth("+arg1+", "+arg_bits+");"
        new_instructions.append(new_pre)
        signextend_function = True
        new = instr

    elif instr.find("nop(MLOAD)")!=-1 and mem_abs:
        pre_instr_bad = new_instructions.pop()
        pre_instr = new_instructions.pop()

        if (pre_instr.find("ll")!=-1):
            var = pre_instr.split("=")[1].strip()[:-1]

            if rule_id in mem_init_blocks:
                already_def = get_already_def_memvars(rule_id)
                vars_declared = mem_vars_per_block[rule_id]
                memvars_otherblock = filter(lambda x: x not in vars_declared,already_def)
                already_def_mem = memvars_otherblock+ mem_defined
            else:
                already_def_mem = get_already_def_memvars(rule_id)

            # print "mload"
            # print already_def_mem
            # print "*/*/*/*/*/*/*/*/"
            mload_id = get_mem_instruction_identifier(already_def_mem)

            new1 = var+" = mload"+str(mload_id)+"("+var+");"
            new_instructions.append(new1)
            
        else:
            new_instructions.append(pre_instr)
            new_instructions.append(pre_instr_bad)
            
        new = instr

    elif instr.find("nop(MSTORE")!=-1 and mem_abs:
        pre_instr1 = new_instructions.pop()
        pre_instr2 = new_instructions.pop()

        if pre_instr1.find("ls")!=-1:
            var1 = pre_instr1.split("=")[1].strip()[:-1]
            var2 = pre_instr2.split("=")[1].strip()[:-1]
            if rule_id in mem_init_blocks:
                already_def = get_already_def_memvars(rule_id)
                vars_declared = mem_vars_per_block[rule_id]
                memvars_otherblock = filter(lambda x: x not in vars_declared,already_def)
                already_def_mem = memvars_otherblock+ mem_defined
            else:
                already_def_mem = get_already_def_memvars(rule_id)
                
            mstore_id = get_mem_instruction_identifier(already_def_mem)
            new1 = "mstore"+str(mstore_id)+"("+var1+" , "+var2+");"
            new_instructions.append(new1)
            
        else:
            new_instructions.append(pre_instr2)
            new_instructions.append(pre_instr1)
            
        new = instr
        
    elif instr.find("nop(")!=-1:
        new = instr
        
    elif instr.find("call(",0)!=-1:
        call_block = instr[5:-1].strip()
        pos_open = call_block.find("(")
        block = call_block[:pos_open]
        
        args = call_block[pos_open+1:-1]
        vars_aux = args.split(",")
        stack_variables = filter(lambda x: x.startswith("s("),vars_aux)
        variables = map(lambda x : unbox_variable(x.strip()),stack_variables)
        new_variables = ", ".join(variables)
        if goto == "global":
            new = block+"()"
        elif goto == "mix":
            new = block+"("+new_variables+")"
        elif goto == "local":
            s_variables = map(lambda x : unbox_variable(x.strip()),stack_variables)
            
            field_variables = filter(lambda x: x.strip().startswith("g("),vars_aux)
            f_variables = map(lambda x: unbox_variable(x.strip()),field_variables)

            local_variables_mem = filter(lambda x: x.strip().startswith("l("),vars_aux)
            if not mem_abs:
                local_variables = filter(lambda x: x.strip().startswith("l("),vars_aux)
                l_variables = map(lambda x: x.strip()[2:-1],local_variables)

            else:
                local_variables = []
                l_variables = []
                
            other = stack_variables+field_variables+local_variables+local_variables_mem
            bc_variables = filter(lambda x: x not in other,vars_aux)

            variables = s_variables+f_variables+l_variables+bc_variables
            
            new_variables = ", ".join(variables)
            new = block+"("+new_variables+")"
        else:
            new = block+"("+new_variables+")"

    elif instr.find("and(",0)!=-1:
        elems = instr.split("= and")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        #if (svcomp == {}):# or (svcomp["verify"] == "cpa"):
        if verifier == "cpa" or svcomp == {}:
            new = var0+" = "+ var1 +" & "+var2
        else:
        #if svcomp!={}:
            new = var0+" = "+get_nondet_svcomp_label()
        # else:
        #     new = var0+" = "+ var1 +" & "+var2

        check_declare_variable(var0,vars_to_declare)

    elif instr.find("xor(",0)!=-1:
        elems = instr.split("= xor")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)


        #if (svcomp == {}): #or (svcomp["verify"] == "cpa"):
        if verifier == "cpa" or svcomp == {}:
            new = var0+" = "+ var1 +" ^ "+var2
        else:
        #if svcomp!={}:
            new = var0+" = "+get_nondet_svcomp_label()
        # #if svcomp!={}:
        #     new = var0+" = "+ get_nondet_svcomp_label()

        # else:
        #     new = var0+" = "+ var1 +" ^ "+var2

        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("or(",0)!=-1:
        
        elems = instr.split("= or")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        #if (svcomp == {}):# or (svcomp["verify"] == "cpa"):
        if verifier == "cpa" or svcomp == {}:
            new = var0+" = "+ var1 +" | "+var2
        else:
            new = var0+" = "+get_nondet_svcomp_label()
        # if svcomp!={}:
        #     new = var0+" = "+get_nondet_svcomp_label()
        # else:
        #     new = var0+" = "+ var1 +" | "+var2
            
        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("not(",0)!=-1:
        elems = instr.split("= not")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = elems[1].strip()[1:-1]
        var1 = unbox_variable(arg1)

        #if (svcomp == {}):# or (svcomp["verify"] == "cpa"):
        if verifier == "cpa" or svcomp == {}:
            new = var0+" = ~"+ var1
        else:
            new = var0+" = "+get_nondet_svcomp_label()

        # if svcomp!={}:
        #     new = var0+" = "+get_nondet_svcomp_label()
        # else:
        #     new = var0+" = ~"+ var1

        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("gs(",0)!=-1:
        pos = instr.find("=")
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg1 = instr[pos+1:].strip()
        var1 = unbox_variable(arg1)
        
        new = var0 +" = "+ var1
        check_declare_variable(var0,vars_to_declare)
        
    # elif instr.find("gl =",0)!=-1:
    #     pos = instr.find("=")
    #     arg0 = instr[:pos].strip()
    #     var0 = unbox_variable(arg0)

    #     arg1 = instr[pos+1:].strip()
    #     var1 = unbox_variable(arg1)
        
    #     new = var0 +" = " var1

    elif instr.find("l(l")!=-1:
        pos_local = instr.find("l(l")
        pos_eq = instr.find("=")
        if pos_eq < pos_local: #it is in the right
            arg0 = instr[:pos_eq].strip()
            var0 = unbox_variable(arg0)
            
            arg1 = instr[pos_eq+1:].strip()
            var1_aux = unbox_variable(arg1)
            var1 = var1_aux[1:]
            new = var0+" = "+var1
        else:
            arg0 = instr[:pos_eq].strip()
            var0_aux = unbox_variable(arg0)
            var0 = var0_aux[1:]

            if instr[pos_eq+1:].strip().startswith("fresh("):
                if not svcomp["exec"]:
                    new = var0+" = "+get_nondet_svcomp_label()
                else:
                    new = var0+" = s"+str(cont)
                    check_declare_variable("s"+str(cont),vars_to_declare)
                    cont+=1
            else:
                arg1 = instr[pos_eq+1:].strip()
                var1 = unbox_variable(arg1)
                new = var0+" = "+var1


    elif instr.find("l(mem")!=-1 and mem_abs:
        pos_local = instr.find("l(mem")
        pos_eq = instr.find("=")
        if pos_eq < pos_local: #it is in the right MLOAD

            arg0 = instr[:pos_eq].strip()
            var0 = unbox_variable(arg0)
            
            arg1 = instr[pos_eq+1:].strip()
            var1_aux = unbox_variable(arg1)
            var1 = var1_aux[1:]
            
            if verifier == "cpa" and mem_init_blocks !=[]:
                if var1 == "mem64":
                    if rule_id in mem_init_blocks:
                        new1 = var0+" = "+var1+";"
                        new_instructions.append(new1)
                        id_var = mem_vars_per_block[rule_id] 
                        new = "p"+str(id_var[mem_id])+" = mem64"
                        mem40_status = True
                        mem_defined.append(id_var[mem_id])
                        
                    else:
                        new = var0+" = "+var1
                else:
                    if rule_id in mem_init_blocks:
                        already_def = get_already_def_memvars(rule_id)
                        vars_declared = mem_vars_per_block[rule_id]
                        memvars_otherblock = filter(lambda x: x not in vars_declared,already_def)
                        already_def_mem = memvars_otherblock+ mem_defined
                    else:
                        al = []
                        if var1.startswith("mem"):
                            if var1 not in non_interval_memvars:
                                non_interval_memvars.append(var1)
                                    
                            al = mem_vars_per_block.get(rule_id,[])
                            if var1 not in al:
                                al.append(var1);
                            mem_vars_per_block[rule_id] = al

                        already_def_mem = get_already_def_memvars(rule_id)
                        for x in al:
                            if x not in already_def_mem:
                                already_def_mem.append(x)


                    # print "mload"
                    # print already_def_mem
                    # print "*/*/*/*/*/*/*/*/"

                    mload_id = get_mem_instruction_identifier(already_def_mem)

                    new = var0+" = mload"+str(mload_id)+"("+var0+")"

            else:    
                new = var0+" = "+var1
        else: #MSTORE
            arg0 = instr[:pos_eq].strip()
            var0_aux = unbox_variable(arg0)
            var0 = var0_aux[1:]

            if instr[pos_eq+1:].strip().startswith("fresh("):
                if not svcomp["exec"]:
                    new = var0+" = "+get_nondet_svcomp_label()
                else:
                    new = var0+" = s"+str(cont)
                    check_declare_variable("s"+str(cont),vars_to_declare)
                    cont+=1
            else:
                arg1 = instr[pos_eq+1:].strip()
                var1 = unbox_variable(arg1)

                if verifier == "cpa" and mem_init_blocks !=[]:

                    if (var0 == "mem64"):

                        if mem40_status and rule_id in mem_init_blocks:

                            id_var = mem_vars_per_block[rule_id]
                            
                            new1 = var0+" = "+var1+";"
                            new2 = "p"+str(id_var[mem_id])+"p = mem64;"
                            new3 = "if (p"+str(id_var[mem_id])+"p < p"+str(id_var[mem_id])+") exit(0);"
                            new4 = "unsigned int m"+str(id_var[mem_id])+"static[p"+str(id_var[mem_id])+"p-p"+str(id_var[mem_id])+"];"

                            new_instructions.append(new1)
                            new_instructions.append(new2)
                            new_instructions.append(new3)
                            new_instructions.append(new4)
                                                   
                            new = "m"+str(id_var[mem_id])+" = m"+str(id_var[mem_id])+"static"

                            
                            mem40_status = False
                            mem_id = mem_id+1

                        else:
                            new = var0+" = "+var1
                            if rule_id == 0:
                                ins = new_instructions[-4] # We have nops
                                val = ins.split("=")[-1].strip()[:-1]
                                init_mem40 = val
                                
                    else:

                        if rule_id in mem_init_blocks:
                            already_def = get_already_def_memvars(rule_id)
                            vars_declared = mem_vars_per_block[rule_id]
                            memvars_otherblock = filter(lambda x: x not in vars_declared,already_def)
                            already_def_mem = memvars_otherblock+ mem_defined
                        else:
                            # print "*-*-*--*-*--*-"
                            # print "NO"
                            # print rule_id
                            # print var0
                            if var0.startswith("mem"):
                                if var0 not in non_interval_memvars:
                                    non_interval_memvars.append(var0)
                                    
                                al = mem_vars_per_block.get(rule_id,[])
                                if var0 not in al:
                                    al.append(var0);
                                    mem_vars_per_block[rule_id] = al
                                
                            already_def_mem = get_already_def_memvars(rule_id)
                            for x in al:
                                if x not in already_def_mem:
                                    already_def_mem.append(x)
                            
                        mstore_id = get_mem_instruction_identifier(already_def_mem)
                        
                        var1p = int(var1[1:])+1
                        # print "mstore"
                        # print already_def_mem
                        # print "*/*/*/*/*/*/*/*/"

                        new = "mstore"+str(mstore_id)+"(s"+str(var1p)+" , "+var1+")"
                    
                else:
                    new = var0+" = "+var1


                
    elif instr.find("ls(",0)!=-1:
        pos = instr.find("=")
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg1 = instr[pos+1:].strip()
        var1 = unbox_variable(arg1)
        
        new = var0 +" = "+ var1
        check_declare_variable(var0,vars_to_declare)
        
    # elif instr.find("ll =",0)!=-1:
    #     pos = instr.find("=")
    #     new = "l("+instr[:pos].strip()+") "+instr[pos:]        

    elif instr.find("fresh",0)!=-1:
        pos = instr.find("=")
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1
        
    elif instr.find("= eq(",0)!=-1:
        elems = instr.split("= eq")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = "+ var1 +" == "+var2
        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("= lt(",0)!=-1:
        elems = instr.split("= lt")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")
        
        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = "+ var1 +" < "+var2
        check_declare_variable(var0,vars_to_declare)

    elif instr.find("= slt(",0)!=-1:
        elems = instr.split("= slt")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")
        
        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = "+ var1 +" < "+var2
        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("= gt(",0)!=-1:
        elems = instr.split("= gt")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = "+ var1 +" > "+var2
        check_declare_variable(var0,vars_to_declare)

    elif instr.find("= sgt(",0)!=-1:
        elems = instr.split("= sgt")
        arg0 = elems[0].strip()
        var0 = unbox_variable(arg0)

        arg12_aux = elems[1].strip()[1:-1]
        arg12 = arg12_aux.split(",")

        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)

        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = "+ var1 +" > "+var2
        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("g(",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg1 = instr[pos+1:].strip()
        var1 = unbox_variable(arg1)

        new = var0+" = "+var1
        if var0.startswith("g"):
            check_declare_variable(var1,vars_to_declare)
        else:
            check_declare_variable(var0,vars_to_declare)
            
    elif instr.find("^",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        arg12 = instr[pos+1:].strip().split("^")
        arg1 = arg12[0].strip()
        var1 = unbox_variable(arg1)
        
        arg2 = arg12[1].strip()
        var2 = unbox_variable(arg2)

        # new = var0+" = exp_eth("+var1+", "+var2+")"
        # exp_function = True
        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1

        
    elif instr.find("byte",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1

        check_declare_variable(var0,vars_to_declare)
        
    elif instr.find("sha",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1


    elif instr.find("shl",0)!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1

        
        # new = instr[:pos+1]+var
        # cont+=1

    elif instr.find("shr")!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1


    elif instr.find("sar")!=-1:
        pos = instr.find("=",0)
        arg0 = instr[:pos].strip()
        var0 = unbox_variable(arg0)

        if not svcomp["exec"]:
            new = var0+" = "+get_nondet_svcomp_label()
        else:
            new = var0+" = s"+str(cont)
            check_declare_variable("s"+str(cont),vars_to_declare)
            cont+=1


            
    elif instr.find("+")!=-1:
        if instr.find("%")!=-1:#mulmod
            elems = instr.split("%")
            arg012 = elems[0].split("=")
            arg0 = arg012[0].strip()
            var0 = unbox_variable(arg0)

            arg12_aux = arg012[1].strip().lstrip("(")
            arg12 = arg12_aux[:-1].split("+")
            arg1 = arg12[0].strip()
            var1 = unbox_variable(arg1)

            arg2 = arg12[1].strip()
            var2 = unbox_variable(arg2)

            arg3 = elems[1].strip()
            var3 = unbox_variable(arg3)

            new = var0+" = ("+var1+" + "+var2+") % "+var3

        else:
            elems = instr.split("+")
            arg01 = elems[0].split("=")
            arg0 = arg01[0].strip()
            var0 = unbox_variable(arg0)

            arg1 = arg01[1].strip()
            var1 = unbox_variable(arg1)

            arg2 = elems[1].strip()
            var2 = unbox_variable(arg2)

            new = var0+" = "+var1+" + "+var2
        
    elif instr.find("-")!=-1:
        elems = instr.split("-")
        arg01 = elems[0].split("=")
        arg0 = arg01[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = arg01[1].strip()
        var1 = unbox_variable(arg1)

        arg2 = elems[1].strip()
        var2 = unbox_variable(arg2)

        new = var0+" = "+var1+" - "+var2

    elif instr.find("*")!=-1:
        if instr.find("%")!=-1:#mulmod
            elems = instr.split("%")
            arg012 = elems[0].split("=")
            arg0 = arg012[0].strip()
            var0 = unbox_variable(arg0)

            arg12_aux = arg012[1].strip().lstrip("(")
            arg12 = arg12_aux[:-1].split("*")
            arg1 = arg12[0].strip()
            var1 = unbox_variable(arg1)

            arg2 = arg12[1].strip()
            var2 = unbox_variable(arg2)

            arg3 = elems[1].strip()
            var3 = unbox_variable(arg3)

            if verifier == "verymax":
                new = var0+" = "+ get_nondet_svcomp_label()
            else:
                new = var0+" = ("+var1+" * "+var2+") % "+var3

        else:
            elems = instr.split("*")
            arg01 = elems[0].split("=")
            arg0 = arg01[0].strip()
            var0 = unbox_variable(arg0)

            arg1 = arg01[1].strip()
            var1 = unbox_variable(arg1)

            arg2 = elems[1].strip()
            var2 = unbox_variable(arg2)

            if verifier == "verymax":
                new = var0+" = "+ get_nondet_svcomp_label()
            else:
                new = var0+" = "+var1+" * "+var2

    elif instr.find("/")!=-1:
        elems = instr.split("/")
        arg01 = elems[0].split("=")
        arg0 = arg01[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = arg01[1].strip()
        var1 = unbox_variable(arg1)

        arg2 = elems[1].strip()
        var2 = unbox_variable(arg2)

        if verifier == "verymax":
            new = var0+" = "+ get_nondet_svcomp_label()
        else:
            new = var0+" = "+var1+" / "+var2

    elif instr.find("%")!=-1:
        elems = instr.split("%")
        arg01 = elems[0].split("=")
        arg0 = arg01[0].strip()
        var0 = unbox_variable(arg0)

        arg1 = arg01[1].strip()
        var1 = unbox_variable(arg1)

        arg2 = elems[1].strip()
        var2 = unbox_variable(arg2)

        if verifier == "verymax":
            new = var0+" = "+ get_nondet_svcomp_label()
        else:
            new = var0+" = "+var1+" % "+var2
                
    elif len(instr.split("=")) > 1:
        slices = instr.split("=")
        
        arg1 = slices[0].strip()
        arg2 = slices[1].strip()

        arg2 = abstract_integer(arg2)

        var1 = unbox_variable(arg1)
        if arg2.find("nondet")==-1:
            var2 = unbox_variable(arg2)
        else:
            var2 = arg2

        new = var1+" = "+var2
        check_declare_variable(var1,vars_to_declare)
        
    elif instr.find("skip")!=-1:
        new = ""
        
    else:
        new = instr
            
    new_instructions.append(new+";")
    return cont


def get_current_initloop():
    if init_loop == 0:
        return init_loop
    else:
        return init_loop-1

def get_nondet_svcomp_label():
    return "__VERIFIER_nondet_uint()"

def get_error_svcomp_label():
    # return "ERROR: __VERIFIER_error()"
    return "ERROR: {reach_error();abort();}"

def add_svcomp_labels():
    labels = "";
    labels = labels+"extern unsigned int __VERIFIER_nondet_uint();\n"
    # labels = labels + "extern void __VERIFIER_error();\n"
    labels = labels +"extern void abort(void);\n"
    labels = labels+"extern void __assert_fail(const char *, const char *, unsigned int, const char *) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));\n"
    labels = labels+'void reach_error() { __assert_fail("0", "c", 0, "reach_error"); }\n'

    return labels

def initialize_globals(rules,init_fields):
    head_c = "void init_globals();"
    head = "void init_globals(){\n"
    
    vars_init = initialize_global_variables(rules,init_fields)
    method = head+vars_init+"}\n"

    return head_c, method
    
def initialize_global_variables(rules,init_fields):

    s = ""

    initialized_vars = init_fields.keys()
    
    if(len(rules)>1):
        r = rules[1][0]
    else:
        r = rules[0][0]
            
    name_fields, numeric_fields = r.get_global_arg()
    fields_id = name_fields[::-1]+numeric_fields[::-1]
    bc_data = r.get_bc()
    locals_vars = sorted(r.get_args_local())[::-1]

    
    nondet_fields = filter(lambda x: x not in initialized_vars,fields_id) 
    fields = map(lambda x: "\tg"+str(x)+" = __VERIFIER_nondet_uint()",nondet_fields)

    for v in initialized_vars:
        val = init_fields[v]
        fields.append("\tg"+str(v)+" = "+str(val))


    if mem_abs and verifier == "cpa":
        l_vars = ["\tmem64 = "+init_mem40]
    elif mem_abs:
        l_vars = map(lambda x: "\tmem"+str(x)+" = __VERIFIER_nondet_uint()",locals_vars)
    else:
        l_vars = map(lambda x: "\tl"+str(x)+" = __VERIFIER_nondet_uint()",locals_vars)
        
    bc = map(lambda x: "\t"+x+" = __VERIFIER_nondet_uint()",bc_data)

    if fields != []:
        s = s+";\n".join(fields)+";\n"

    if l_vars != []:
        s = s+";\n".join(l_vars)+";\n"

    if bc != []:
        s = s+";\n".join(bc)+";\n"

    if goto == "global":
        for e in stack_vars_global:
            s = s+"\t"+e+" = __VERIFIER_nondet_uint();\n"
    
    return s

def write_init(rules,execution,cname,num_mem_vars):
    s = "\n"

    if not svcomp["exec"]:
        s = add_svcomp_labels()
        s = s+"\n"
        
    if execution == None:
        name = global_params.costabs_path+"rbr.c"
    elif cname == None:
        name = global_params.costabs_path+"rbr"+str(execution)+".c"
    else:
        name = global_params.costabs_path+cname+".c"
    with open(name,"w") as f:
        if(len(rules)>1):
            r = rules[1][0]
        else:
            r = rules[0][0]
            
        name_fields, numeric_fields = r.get_global_arg()
        fields_id = name_fields[::-1]+numeric_fields[::-1]
        bc_data = r.get_bc()
        locals_vars = sorted(r.get_args_local())[::-1]
                                
        fields = map(lambda x: "unsigned int g"+str(x),fields_id)

        if mem_abs and verifier == "cpa":
            l_vars = ["unsigned int mem64"]
        elif mem_abs:
            l_vars = map(lambda x: "unsigned int mem"+str(x),locals_vars)
        else:
            l_vars = map(lambda x: "unsigned int l"+str(x),locals_vars)
        
        bc = map(lambda x: "unsigned int "+x,bc_data)
        
        build_vars_to_initialize(fields,l_vars,bc)
        
        if svcomp["exec"]:
            f.write("#include <stdio.h>\n\n")

        if goto == "global":
            s_vars = get_stack_variables(stack_vars_global,True)
            r_vars = get_rest_variables(stack_vars_global,True)    
            s = s+"".join(s_vars)+"".join(r_vars)

        if verifier == "cpa":
            s = s+"\n"+build_mem_vars(num_mem_vars)
            
        f.write(s)

        
        
    f.close()

def build_vars_to_initialize(fields,local,blockchain):
    s = ""

    if goto == "global" or goto == "mix":
        if fields != []:
            s = s+";\n".join(fields)+";\n"

        if local != []:
            s = s+";\n".join(local)+";\n"

        if blockchain != []:
            s = s+";\n".join(blockchain)+";\n"

    else: #all variables local except interval memory
        if mem_abs:
            s = s+";\n".join(local)+";\n"
        
    return s

    
def def_signextend_function():
    head = "unsigned int signextend_eth(unsigned int v0, unsigned int v1);\n"

    f = "unsigned int signextend_eth(unsigned int v0, unsigned int v1){\n"
    if svcomp.get("verify",-1) != -1:
        f = f+"\t\treturn __VERIFIER_nondet_uint();\n"
    else:
        f = f+"\tif (v1 == 0 && v0 <= 0x7F){\n"+"\t\treturn v0;\n"+ "\t}"
        f = f+"else if (v1 == 0 && v0 >  0x7F){\n"+"\t\treturn v0 | 0xFFFFFF00;\n"+"\t}"
        f = f+"else if (v1 == 1 && v0 <= 0x7FFF){\n"+"\t\treturn v0;\n"+"\t}"
        f = f+"else if (v1 == 1 && v0 >  0x7FFF)  {\n"+"\t\treturn v0 | 0xFFFF0000;\n"+"\t}"
        f = f+"else if (v1 == 2 && v0 <= 0x7FFFFF) {\n"+"\t\treturn v0;\n"+"\t}"
        f = f+"else if (v1 == 2 && v0 >  0x7FFFFF) {\n"+"\t\treturn v0 | 0xFF000000;\n"+"\t}"
        f = f+"else if (v1 == 3) {\n"+"\t\treturn v0;\n"+"\t}"
        f = f+"else {\n"+"\t\treturn __VERIFIER_nondet_uint();\n"+"\t}\n"
        #f = f+"else {\n"+"\t\tunsigned int v0;\n \t\treturn v0;\n"+"\t}\n"
        
    f = f+"}\n"

    return head,f

def def_exp_function():
    if goto:
        head = "unsigned int exp_eth (unsigned int w0, unsigned int w1);\n"

        f = "unsigned int exp_eth (unsigned int w0, unsigned int w1) {\n"
        f = f+"\tunsigned int v0 = w0;\n"
        f = f+"\tunsigned int v1 = w1;\n"
    else:
        head = "unsigned int exp_eth (unsigned int v0, unsigned int v1);\n"
        f = "unsigned int exp_eth (unsigned int v0, unsigned int v1) {\n"
        
    f = f+"\tif (v1 == 0) return 1;\n"
    f = f+"\tif (v1 == 1) return v0;\n"
    f = f+"\tif (v1 == 2) return v0*v0;\n"
    f = f+"\tif (v1 == 3) return v0*v0*v0;\n"
    f = f+"\tif (v1 == 4) return v0*v0*v0*v0;\n"
    f = f+"\tif (v1 == 5) return v0*v0*v0*v0*v0;\n"
    f = f+"\tif (v1 == 6) return v0*v0*v0*v0*v0*v0;\n"
    f = f+"\tif (v1 == 7) return v0*v0*v0*v0*v0*v0*v0;\n"
    f = f+"\tif (v1 == 8) return v0*v0*v0*v0*v0*v0*v0*v0;\n"

    f = f+"\n\tunsigned int res;\n"
    
    if svcomp.get("verify",-1) != -1:
        f = f+"\tres = "+get_nondet_svcomp_label()+";\n"
    elif not goto:
        f = f+"\tunsigned int v2;\n\tres = v2;\n"
        f = f+"\tres = 1\n;"
        f = f+"\tfor (unsigned int i = 0; i < v1; i ++) {\n"
        f = f+"\t\tres = res * v0;\n"
        f = f+"\t}\n"
    f = f+"\treturn res;\n"
    f = f+"}"

    return head,f


def mload_functions():
    head = ""
    f = ""
    
    for a in memory_id_spec.keys():
        head = head+"unsigned int mload"+str(a)+"(unsigned int pos);\n"


        f = f+"unsigned int mload"+str(a)+"(unsigned int pos){\n"
        f = f+"\tunsigned int val;\n\n"

        values = memory_id_spec[a]
        non_interval = filter(lambda x: str(x).startswith("mem"),values)
        is_first = False
        for mvars in non_interval:
            int_val = mvars[3:].strip()
            if not is_first:
                f = f+"\tif ( pos == "+int_val+" ){\n"
                f = f+"\t\tval = p"+mvars+";\n"
                is_first = True
            else:
                f = f+"\t}else if ( pos == "+int_val+" ){\n"
                f = f+"\t\tval = p"+mvars+";\n"

        interval_vars = filter(lambda x: not str(x).startswith("mem"),values)
        for x in interval_vars:
            start_idx = "p"+str(x)
            end_idx = "p"+str(x)+"p"
            first_val = "fv"+str(x)
            arr = "m"+str(x)

            if not is_first:
                f = f + "\t}if ("+start_idx+" == pos) {\n"
                f = f + "\t\tval = "+first_val+";\n"
                is_first = True
            else:
                f = f + "\t}else if ("+start_idx+" == pos) {\n"
                f = f + "\t\tval = "+first_val+";\n"

            f = f + "\t}else if ("+start_idx+" < pos && pos < "+end_idx+") {\n"
            f = f + "\t\tval = "+arr+"[pos-"+start_idx+"];\n"
        f = f+"\t}\n\treturn val;\n"+"}\n"

    return head, f
            
# def mload_function(l):

#     memory_id_spec.keys
    
#     ap = map(lambda x: x[1],l)
#     num_arr = sum(ap)
    
#     head = "int mload(int pos);\n"
#     f = ""
#     f = "int mload(int pos){\n"
    
#     f = f+"\tint val;\n\n"
#     f = f+"\tif ( p0 == pos ){\n"
#     f = f+"\t\tval = fv0;\n"
#     f = f+"\t}else if (p0 < pos && pos < p0p){\n"
#     f = f+"\t\tval = m0[pos-p0];\n"
#     #We construct the first element

#     num =num_arr-1

#     for idx in range(1,num+1):
#         start_idx = "p"+str(idx)
#         end_idx = "p"+str(idx)+"p"
#         first_val = "fv"+str(idx)
#         arr = "m"+str(idx)
        
#         f = f + "\t}else if ("+start_idx+" == pos) {\n"
#         f = f + "\t\tval = "+first_val+";\n"
#         f = f + "\t}else if ("+start_idx+" < pos && pos < "+end_idx+") {\n"
#         f = f + "\t\tval = "+arr+"[pos-"+start_idx+"];\n"
#     f = f+"\t}\n\treturn val;\n"+"}\n"
#     return head, f


def mstore_functions():
    head = ""
    f = ""
    
    for a in memory_id_spec.keys():
        head = head+"void mstore"+str(a)+"(unsigned int pos, unsigned int val);\n"

        f = f +"void mstore"+str(a)+"(unsigned int pos, unsigned int val){\n"

        values = memory_id_spec[a]
        non_interval = filter(lambda x: str(x).startswith("mem"),values)
        is_first = False
        for mvars in non_interval:
            int_val = mvars[3:].strip()
            if not is_first:
                f = f+"\tif ( pos == "+int_val+" ){\n"
                f = f+"\t\tp"+mvars+" = val;\n"
                is_first = True
            else:
                f = f+"\t}else if ( pos == "+int_val+" ){\n"
                f = f+"\t\tp"+mvars+" = val;\n"

        interval_vars = filter(lambda x: not str(x).startswith("mem"),values)
        for x in interval_vars:
            start_idx = "p"+str(x)
            end_idx = "p"+str(x)+"p"
            first_val = "fv"+str(x)
            arr = "m"+str(x)

            if not is_first:
                f = f + "\t}if ("+start_idx+" == pos) {\n"
                f = f + "\t\t"+first_val+" = val;\n"
                is_first = True
            else:
                f = f + "\t}else if ("+start_idx+" == pos) {\n"
                f = f + "\t\t"+first_val+" = val;\n"

            f = f + "\t}else if ("+start_idx+" < pos && pos < "+end_idx+") {\n"
            f = f + "\t\t"+arr+"[pos-"+start_idx+"] = val;\n"
        f = f + "\t}\n}\n"

    return head, f


# def mstore_function(l):

#     ap = map(lambda x: x[1],l)
#     num_arr = sum(ap)
    
#     head = "void mstore(int pos, int val);\n"

#     f = "void mstore(int pos, int val){\n"

#     f = f+"\tif ( p0 == pos ){\n"
#     f = f+"\t\tfv0 = val;\n"
#     f = f+"\t}else if (p0 < pos && pos < p0p){\n"
#     f = f+"\t\tm0[pos-p0]= val;\n"
#     #We construct the first element

#     num =num_arr-1

#     for idx in range(1,num+1):
#         start_idx = "p"+str(idx)
#         end_idx = "p"+str(idx)+"p"
#         first_val = "fv"+str(idx)
#         arr = "m"+str(idx)
        
#         f = f + "\t}else if ("+start_idx+" == pos) {\n"
#         f = f + "\t\t"+first_val+" = val;\n"
#         f = f + "\t}else if ("+start_idx+" < pos && pos < "+end_idx+") {\n"
#         f = f + "\t\t"+arr+"[pos-"+start_idx+"] = val;\n"
#     f = f + "\t}\n}\n"
#     return head, f

def build_mem_vars(num):    
    f = ""

    non_interval_memvars.sort()
    for i in non_interval_memvars:
        f = f + "unsigned int "+i+";\n"

    f+="\n"

    for i in range(num):
        f = f + "unsigned int *m"+str(i)+";\n"
        f = f + "unsigned int fv"+str(i)+";\n"
        f = f + "unsigned int p"+str(i)+";\n"
        f = f + "unsigned int p"+str(i)+"p;\n\n"

    return f


def update_stack_vars_global(vs):
    global stack_vars_global

    for v in vs:
        if v.strip() not in stack_vars_global:
            stack_vars_global.append(v.strip())
            

def write_main(execution,cname,init_vars):
    if execution == None:
        name = global_params.costabs_path+"rbr.c"
    elif cname == None:
        name = global_params.costabs_path+"rbr"+str(execution)+".c"
    else:
        name = global_params.costabs_path+cname+".c"

    if not svcomp["exec"]:
        with open(name,"a") as f:
            init = "\tinit_globals();"
        
            s = "\nint main(){\n"

            if goto != "local":
                s = s+"\n"+init+"\n"
            if goto != "global":
                s = s+"\n"+init_vars+"\n"

            if goto == "global":
                s = s+"\tblock0();\n"
            else:
                s = s+"\t"+block0_header.replace("unsigned int","")+"\n"

            s = s+"\treturn 0;\n}"
            f.write(s)
        f.close()

def write(head,rules,execution,cname):
    
    # if "costabs" not in os.listdir("/tmp/"):
    #     os.mkdir("/tmp/costabs/")

    if execution == None:
        name = global_params.costabs_path+"rbr.c"
    elif cname == None:
        name = global_params.costabs_path+"rbr"+str(execution)+".c"
    else:
        name = global_params.costabs_path+cname+".c"
    with open(name,"a") as f:
        f.write(head+"\n")
        
        for rule in rules:
            f.write(rule+"\n")

    f.close()

def create_mem_variables(mem_blocks):
    global mem_id
    global mem_vars_per_block
    
    for block, number in mem_blocks:
        vars_id = range(mem_id,mem_id+number)
        mem_vars_per_block[block] = vars_id
        mem_id+=number
        # print block
        # print vars_id

    # print mem_vars_per_block
    
def get_already_def_memvars(block_id):
    c_component = components[block_id]
    blocks_dec = mem_vars_per_block.keys()

    blocks_with_mem = filter(lambda x: x in blocks_dec,c_component)
    already_def = []
    for b in blocks_with_mem:
        m_block = mem_vars_per_block[b]
        new_mem_vars = filter(lambda x: x not in already_def,m_block)
        already_def+=new_mem_vars

    # own = mem_vars_per_block.get(block_id,[])
    # already_def+=own
    return already_def

def get_mem_instruction_identifier(already_def):
    global memory_id_spec
    global meminstr_id

    found = False
    elems = memory_id_spec.items()

    already_def.sort()
    
    if elems == []:
        memory_id_spec[meminstr_id] = already_def
        result = meminstr_id
        meminstr_id+=1
    else:
        for mem_id,vars_def in elems:
            if vars_def == already_def:
                result = mem_id
                found = True

        if not found:
            memory_id_spec[meminstr_id] = already_def
            result = meminstr_id
            meminstr_id+=1

    return result

def generate_initializations(stack_vars):
    vars_def = []
    for s in stack_vars:
        if s.strip() not in vars_def:
            vars_def.append(s)

    l_vars = map(lambda x: "\tunsigned int "+x+";",vars_def)
    return l_vars

def generate_storage_address(storage_arrays):
    ids_dict = {}
    
    ids = storage_arrays["ids"]
    vals = storage_arrays["vals"]
    
    for bl in ids:
        ids_list = ids[bl]
        vals_list = vals[bl]
    
        ids_dict[bl] = zip(ids_list,vals_list)



def build_init_main(rules):
    if(len(rules)>1):
        r = rules[1][0]
    else:
        r = rules[0][0]

    name_fields, numeric_fields = r.get_global_arg()
    fields_id = name_fields[::-1]+numeric_fields[::-1]
    bc_data = r.get_bc()
    locals_vars = sorted(r.get_args_local())[::-1]
                                
    fields = map(lambda x: "unsigned int g"+str(x),fields_id)

    if mem_abs and verifier == "cpa":
        l_vars = ["unsigned int mem64"]
    elif mem_abs:
        l_vars = map(lambda x: "unsigned int mem"+str(x),locals_vars)
    else:
        l_vars = map(lambda x: "unsigned int l"+str(x),locals_vars)
        
    bc = map(lambda x: "unsigned int "+x,bc_data)
    
    s_vars = vars_in_main(fields,l_vars,bc)
    return s_vars
    
def vars_in_main(fields,local,blockchain):
    s = ""
    
    #It has to be initialize in local and mix
    stack_vars = []
    for x in xrange(0,max_stack_idx+1):
        stack_vars.append("\tunsigned int i_s"+str(x)+" = "+get_nondet_svcomp_label())
        
    if goto == "local":
        
        all_vars = map(lambda x: "\t"+x.split()[0]+" "+x.split()[1]+" i_"+x.split()[-1]+" = "+get_nondet_svcomp_label(),fields+local+blockchain)

        s = s+";\n".join(stack_vars+all_vars)+";\n"
        
        if mem_abs:
            local_aux = map(lambda x: "\t"+x,local)
            s = s+";\n".join(local_aux)+";\n"

    else:
        s = s+";\n".join(stack_vars)+";\n"

    return s
